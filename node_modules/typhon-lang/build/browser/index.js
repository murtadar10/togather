(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.typhonLang = {}));
})(this, (function (exports) { 'use strict';

    /**
     * We're looking for something that is truthy, not just true.
     */
    function assert(condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    }
    function fail(message) {
        assert(false, message);
    }

    /**
     * Null function used for default values of callbacks, etc.
     */
    /**
     * Returns true if the specified value is not undefined.
     * WARNING: Do not use this to test if an object has a property. Use the in
     * operator instead.  Additionally, this function assumes that the global
     * undefined variable has not been redefined.
     * @param {*} val Variable to test.
     * @return {boolean} Whether variable is defined.
     */
    function isDef(val) {
        return val !== undefined;
    }
    /**
     * Returns true if the specified value is a string.
     * @param {*} val Variable to test.
     * @return {boolean} Whether variable is a string.
     */
    function isString(val) {
        return typeof val === 'string';
    }
    /**
     * Returns true if the specified value is a number.
     * @param {*} val Variable to test.
     * @return {boolean} Whether variable is a number.
     */
    function isNumber(val) {
        return typeof val === 'number';
    }

    /**
     * Returns the number of children in the specified node.
     * Returns n.children.length
     */
    function NCH(n) {
        assert(n !== undefined);
        if (Array.isArray(n.children)) {
            return n.children.length;
        }
        else {
            return 0;
        }
    }
    function CHILD(n, i) {
        assert(i !== undefined && i >= 0);
        return CHILDREN(n)[i];
    }
    function FIND(n, type) {
        assert(type !== undefined);
        const children = CHILDREN(n);
        const N = children.length;
        for (let i = 0; i < N; i++) {
            const child = children[i];
            if (child.type === type) {
                return i;
            }
        }
        return -1;
    }
    function CHILDREN(n) {
        assert(n !== undefined);
        if (n.children) {
            return n.children;
        }
        else {
            throw new Error("node does not have any children");
        }
    }
    /**
     * Convenience function to return the index of the last element in an array.
     * @param xs The array.
     * @returns The length of the array minus 1.
     */
    function IDXLAST(xs) {
        return xs.length - 1;
    }

    /**
     * Symbolic constants for various Python Language tokens.
     */
    exports.Tokens = void 0;
    (function (Tokens) {
        Tokens[Tokens["T_ENDMARKER"] = 0] = "T_ENDMARKER";
        Tokens[Tokens["T_NAME"] = 1] = "T_NAME";
        Tokens[Tokens["T_NUMBER"] = 2] = "T_NUMBER";
        Tokens[Tokens["T_STRING"] = 3] = "T_STRING";
        Tokens[Tokens["T_NEWLINE"] = 4] = "T_NEWLINE";
        Tokens[Tokens["T_INDENT"] = 5] = "T_INDENT";
        Tokens[Tokens["T_DEDENT"] = 6] = "T_DEDENT";
        Tokens[Tokens["T_LPAR"] = 7] = "T_LPAR";
        Tokens[Tokens["T_RPAR"] = 8] = "T_RPAR";
        Tokens[Tokens["T_LSQB"] = 9] = "T_LSQB";
        Tokens[Tokens["T_RSQB"] = 10] = "T_RSQB";
        Tokens[Tokens["T_COLON"] = 11] = "T_COLON";
        Tokens[Tokens["T_COMMA"] = 12] = "T_COMMA";
        Tokens[Tokens["T_SEMI"] = 13] = "T_SEMI";
        Tokens[Tokens["T_PLUS"] = 14] = "T_PLUS";
        Tokens[Tokens["T_MINUS"] = 15] = "T_MINUS";
        Tokens[Tokens["T_STAR"] = 16] = "T_STAR";
        Tokens[Tokens["T_SLASH"] = 17] = "T_SLASH";
        Tokens[Tokens["T_VBAR"] = 18] = "T_VBAR";
        Tokens[Tokens["T_AMPER"] = 19] = "T_AMPER";
        Tokens[Tokens["T_LESS"] = 20] = "T_LESS";
        Tokens[Tokens["T_GREATER"] = 21] = "T_GREATER";
        Tokens[Tokens["T_EQUAL"] = 22] = "T_EQUAL";
        Tokens[Tokens["T_DOT"] = 23] = "T_DOT";
        Tokens[Tokens["T_PERCENT"] = 24] = "T_PERCENT";
        Tokens[Tokens["T_BACKQUOTE"] = 25] = "T_BACKQUOTE";
        Tokens[Tokens["T_LBRACE"] = 26] = "T_LBRACE";
        Tokens[Tokens["T_RBRACE"] = 27] = "T_RBRACE";
        Tokens[Tokens["T_EQEQUAL"] = 28] = "T_EQEQUAL";
        Tokens[Tokens["T_NOTEQUAL"] = 29] = "T_NOTEQUAL";
        Tokens[Tokens["T_LESSEQUAL"] = 30] = "T_LESSEQUAL";
        Tokens[Tokens["T_GREATEREQUAL"] = 31] = "T_GREATEREQUAL";
        Tokens[Tokens["T_TILDE"] = 32] = "T_TILDE";
        /**
         * '^'
         */
        Tokens[Tokens["T_CIRCUMFLEX"] = 33] = "T_CIRCUMFLEX";
        Tokens[Tokens["T_LEFTSHIFT"] = 34] = "T_LEFTSHIFT";
        Tokens[Tokens["T_RIGHTSHIFT"] = 35] = "T_RIGHTSHIFT";
        Tokens[Tokens["T_DOUBLESTAR"] = 36] = "T_DOUBLESTAR";
        Tokens[Tokens["T_PLUSEQUAL"] = 37] = "T_PLUSEQUAL";
        Tokens[Tokens["T_MINEQUAL"] = 38] = "T_MINEQUAL";
        Tokens[Tokens["T_STAREQUAL"] = 39] = "T_STAREQUAL";
        Tokens[Tokens["T_SLASHEQUAL"] = 40] = "T_SLASHEQUAL";
        Tokens[Tokens["T_PERCENTEQUAL"] = 41] = "T_PERCENTEQUAL";
        Tokens[Tokens["T_AMPEREQUAL"] = 42] = "T_AMPEREQUAL";
        Tokens[Tokens["T_VBAREQUAL"] = 43] = "T_VBAREQUAL";
        Tokens[Tokens["T_CIRCUMFLEXEQUAL"] = 44] = "T_CIRCUMFLEXEQUAL";
        Tokens[Tokens["T_LEFTSHIFTEQUAL"] = 45] = "T_LEFTSHIFTEQUAL";
        Tokens[Tokens["T_RIGHTSHIFTEQUAL"] = 46] = "T_RIGHTSHIFTEQUAL";
        Tokens[Tokens["T_DOUBLESTAREQUAL"] = 47] = "T_DOUBLESTAREQUAL";
        Tokens[Tokens["T_DOUBLESLASH"] = 48] = "T_DOUBLESLASH";
        Tokens[Tokens["T_DOUBLESLASHEQUAL"] = 49] = "T_DOUBLESLASHEQUAL";
        Tokens[Tokens["T_AT"] = 50] = "T_AT";
        Tokens[Tokens["T_ATEQUAL"] = 51] = "T_ATEQUAL";
        Tokens[Tokens["T_OP"] = 52] = "T_OP";
        Tokens[Tokens["T_COMMENT"] = 53] = "T_COMMENT";
        Tokens[Tokens["T_NL"] = 54] = "T_NL";
        Tokens[Tokens["T_RARROW"] = 55] = "T_RARROW";
        Tokens[Tokens["T_AWAIT"] = 56] = "T_AWAIT";
        Tokens[Tokens["T_ASYNC"] = 57] = "T_ASYNC";
        Tokens[Tokens["T_ERRORTOKEN"] = 58] = "T_ERRORTOKEN";
        Tokens[Tokens["T_N_TOKENS"] = 59] = "T_N_TOKENS";
        Tokens[Tokens["T_NT_OFFSET"] = 256] = "T_NT_OFFSET";
    })(exports.Tokens || (exports.Tokens = {}));

    // DO NOT MODIFY. File automatically generated by pgen/parser/main.py
    /**
     * Mapping from operator textual symbols to token symbolic constants.
     */
    const OpMap = {
        "(": exports.Tokens.T_LPAR,
        ")": exports.Tokens.T_RPAR,
        "[": exports.Tokens.T_LSQB,
        "]": exports.Tokens.T_RSQB,
        ":": exports.Tokens.T_COLON,
        ",": exports.Tokens.T_COMMA,
        ";": exports.Tokens.T_SEMI,
        "+": exports.Tokens.T_PLUS,
        "-": exports.Tokens.T_MINUS,
        "*": exports.Tokens.T_STAR,
        "/": exports.Tokens.T_SLASH,
        "|": exports.Tokens.T_VBAR,
        "&": exports.Tokens.T_AMPER,
        "<": exports.Tokens.T_LESS,
        ">": exports.Tokens.T_GREATER,
        "=": exports.Tokens.T_EQUAL,
        ".": exports.Tokens.T_DOT,
        "%": exports.Tokens.T_PERCENT,
        "`": exports.Tokens.T_BACKQUOTE,
        "{": exports.Tokens.T_LBRACE,
        "}": exports.Tokens.T_RBRACE,
        "@": exports.Tokens.T_AT,
        "==": exports.Tokens.T_EQEQUAL,
        "!=": exports.Tokens.T_NOTEQUAL,
        "<>": exports.Tokens.T_NOTEQUAL,
        "<=": exports.Tokens.T_LESSEQUAL,
        ">=": exports.Tokens.T_GREATEREQUAL,
        "~": exports.Tokens.T_TILDE,
        "^": exports.Tokens.T_CIRCUMFLEX,
        "<<": exports.Tokens.T_LEFTSHIFT,
        ">>": exports.Tokens.T_RIGHTSHIFT,
        "**": exports.Tokens.T_DOUBLESTAR,
        "+=": exports.Tokens.T_PLUSEQUAL,
        "-=": exports.Tokens.T_MINEQUAL,
        "*=": exports.Tokens.T_STAREQUAL,
        "/=": exports.Tokens.T_SLASHEQUAL,
        "%=": exports.Tokens.T_PERCENTEQUAL,
        "&=": exports.Tokens.T_AMPEREQUAL,
        "|=": exports.Tokens.T_VBAREQUAL,
        "^=": exports.Tokens.T_CIRCUMFLEXEQUAL,
        "<<=": exports.Tokens.T_LEFTSHIFTEQUAL,
        ">>=": exports.Tokens.T_RIGHTSHIFTEQUAL,
        "**=": exports.Tokens.T_DOUBLESTAREQUAL,
        "//": exports.Tokens.T_DOUBLESLASH,
        "//=": exports.Tokens.T_DOUBLESLASHEQUAL,
        "->": exports.Tokens.T_RARROW
    };
    /**
     * An Arc is a pair, represented in an array, consisting a label and a to-state.
     */
    const ARC_SYMBOL_LABEL = 0;
    const ARC_TO_STATE = 1;
    /**
     *
     */
    const IDX_DFABT_DFA = 0;
    const IDX_DFABT_BEGIN_TOKENS = 1;
    /**
     *
     */
    const ParseTables = {
        sym: { AndExpr: 257,
            ArithmeticExpr: 258,
            AtomExpr: 259,
            BitwiseAndExpr: 260,
            BitwiseOrExpr: 261,
            BitwiseXorExpr: 262,
            ComparisonExpr: 263,
            ExprList: 264,
            ExprStmt: 265,
            GeometricExpr: 266,
            GlobalStmt: 267,
            IfExpr: 268,
            ImportList: 269,
            ImportSpecifier: 270,
            LambdaExpr: 271,
            ModuleSpecifier: 272,
            NonLocalStmt: 273,
            NotExpr: 274,
            OrExpr: 275,
            PowerExpr: 276,
            ShiftExpr: 277,
            UnaryExpr: 278,
            YieldExpr: 279,
            annasign: 280,
            arglist: 281,
            argument: 282,
            assert_stmt: 283,
            augassign: 284,
            break_stmt: 285,
            classdef: 286,
            comp_op: 287,
            compound_stmt: 288,
            continue_stmt: 289,
            decorated: 290,
            decorator: 291,
            decorators: 292,
            del_stmt: 293,
            dictmaker: 294,
            dotted_as_name: 295,
            dotted_as_names: 296,
            dotted_name: 297,
            encoding_decl: 298,
            eval_input: 299,
            except_clause: 300,
            exec_stmt: 301,
            file_input: 302,
            flow_stmt: 303,
            for_stmt: 304,
            fpdef: 305,
            fplist: 306,
            funcdef: 307,
            gen_for: 308,
            gen_if: 309,
            gen_iter: 310,
            if_stmt: 311,
            import_from: 312,
            import_name: 313,
            import_stmt: 314,
            list_for: 315,
            list_if: 316,
            list_iter: 317,
            listmaker: 318,
            old_LambdaExpr: 319,
            old_test: 320,
            parameters: 321,
            pass_stmt: 322,
            print_stmt: 323,
            raise_stmt: 324,
            return_stmt: 325,
            simple_stmt: 326,
            single_input: 256,
            sliceop: 327,
            small_stmt: 328,
            stmt: 329,
            subscript: 330,
            subscriptlist: 331,
            suite: 332,
            testlist: 333,
            testlist1: 334,
            testlist_gexp: 335,
            testlist_safe: 336,
            trailer: 337,
            try_stmt: 338,
            varargslist: 339,
            while_stmt: 340,
            with_stmt: 341,
            with_var: 342,
            yield_stmt: 343 },
        number2symbol: { 256: 'single_input',
            257: 'AndExpr',
            258: 'ArithmeticExpr',
            259: 'AtomExpr',
            260: 'BitwiseAndExpr',
            261: 'BitwiseOrExpr',
            262: 'BitwiseXorExpr',
            263: 'ComparisonExpr',
            264: 'ExprList',
            265: 'ExprStmt',
            266: 'GeometricExpr',
            267: 'GlobalStmt',
            268: 'IfExpr',
            269: 'ImportList',
            270: 'ImportSpecifier',
            271: 'LambdaExpr',
            272: 'ModuleSpecifier',
            273: 'NonLocalStmt',
            274: 'NotExpr',
            275: 'OrExpr',
            276: 'PowerExpr',
            277: 'ShiftExpr',
            278: 'UnaryExpr',
            279: 'YieldExpr',
            280: 'annasign',
            281: 'arglist',
            282: 'argument',
            283: 'assert_stmt',
            284: 'augassign',
            285: 'break_stmt',
            286: 'classdef',
            287: 'comp_op',
            288: 'compound_stmt',
            289: 'continue_stmt',
            290: 'decorated',
            291: 'decorator',
            292: 'decorators',
            293: 'del_stmt',
            294: 'dictmaker',
            295: 'dotted_as_name',
            296: 'dotted_as_names',
            297: 'dotted_name',
            298: 'encoding_decl',
            299: 'eval_input',
            300: 'except_clause',
            301: 'exec_stmt',
            302: 'file_input',
            303: 'flow_stmt',
            304: 'for_stmt',
            305: 'fpdef',
            306: 'fplist',
            307: 'funcdef',
            308: 'gen_for',
            309: 'gen_if',
            310: 'gen_iter',
            311: 'if_stmt',
            312: 'import_from',
            313: 'import_name',
            314: 'import_stmt',
            315: 'list_for',
            316: 'list_if',
            317: 'list_iter',
            318: 'listmaker',
            319: 'old_LambdaExpr',
            320: 'old_test',
            321: 'parameters',
            322: 'pass_stmt',
            323: 'print_stmt',
            324: 'raise_stmt',
            325: 'return_stmt',
            326: 'simple_stmt',
            327: 'sliceop',
            328: 'small_stmt',
            329: 'stmt',
            330: 'subscript',
            331: 'subscriptlist',
            332: 'suite',
            333: 'testlist',
            334: 'testlist1',
            335: 'testlist_gexp',
            336: 'testlist_safe',
            337: 'trailer',
            338: 'try_stmt',
            339: 'varargslist',
            340: 'while_stmt',
            341: 'with_stmt',
            342: 'with_var',
            343: 'yield_stmt' },
        dfas: { 256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[1, 1]]],
                { 1: 1,
                    4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    19: 1,
                    20: 1,
                    21: 1,
                    22: 1,
                    23: 1,
                    24: 1,
                    25: 1,
                    26: 1,
                    27: 1,
                    28: 1,
                    29: 1,
                    30: 1,
                    31: 1,
                    32: 1,
                    33: 1,
                    34: 1,
                    35: 1,
                    36: 1,
                    37: 1 }],
            257: [[[[38, 1]], [[39, 0], [0, 1]]],
                { 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            258: [[[[40, 1]], [[5, 0], [6, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            259: [[[[8, 1], [9, 2], [10, 3], [11, 4], [12, 5], [13, 5], [14, 6]],
                    [[41, 7], [42, 7], [43, 5]],
                    [[44, 8], [45, 5]],
                    [[46, 9], [47, 5]],
                    [[48, 10]],
                    [[0, 5]],
                    [[14, 6], [0, 6]],
                    [[43, 5]],
                    [[45, 5]],
                    [[47, 5]],
                    [[11, 5]]],
                { 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            260: [[[[49, 1]], [[50, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            261: [[[[51, 1]], [[52, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            262: [[[[53, 1]], [[54, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            263: [[[[55, 1]], [[56, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            264: [[[[55, 1]], [[57, 2], [0, 1]], [[55, 1], [0, 2]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            265: [[[[58, 1]],
                    [[59, 2], [60, 3], [61, 4], [0, 1]],
                    [[0, 2]],
                    [[41, 2], [58, 2]],
                    [[41, 5], [58, 5]],
                    [[61, 4], [0, 5]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            266: [[[[62, 1]], [[63, 0], [64, 0], [65, 0], [66, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            267: [[[[26, 1]], [[12, 2]], [[57, 1], [0, 2]]], { 26: 1 }],
            268: [[[[67, 1], [68, 2]],
                    [[30, 3], [0, 1]],
                    [[0, 2]],
                    [[67, 4]],
                    [[69, 5]],
                    [[70, 2]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            269: [[[[71, 1]], [[57, 2], [0, 1]], [[71, 1], [0, 2]]], { 12: 1 }],
            270: [[[[12, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]], { 12: 1 }],
            271: [[[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[70, 4]], [[0, 4]]],
                { 15: 1 }],
            272: [[[[14, 1]], [[0, 1]]], { 14: 1 }],
            273: [[[[27, 1]], [[12, 2]], [[57, 1], [0, 2]]], { 27: 1 }],
            274: [[[[4, 1], [75, 2]], [[38, 2]], [[0, 2]]],
                { 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            275: [[[[76, 1]], [[77, 0], [0, 1]]],
                { 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            276: [[[[78, 1]], [[79, 1], [80, 2], [0, 1]], [[49, 3]], [[0, 3]]],
                { 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            277: [[[[81, 1]], [[82, 0], [83, 0], [0, 1]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            278: [[[[5, 1], [6, 1], [7, 1], [84, 2]], [[49, 2]], [[0, 2]]],
                { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
            279: [[[[23, 1]], [[58, 2], [0, 1]], [[0, 2]]], { 23: 1 }],
            280: [[[[74, 1]], [[70, 2]], [[61, 3], [0, 2]], [[70, 4]], [[0, 4]]], { 74: 1 }],
            281: [[[[85, 1], [63, 2], [80, 3]],
                    [[57, 4], [0, 1]],
                    [[70, 5]],
                    [[70, 6]],
                    [[85, 1], [63, 2], [80, 3], [0, 4]],
                    [[57, 7], [0, 5]],
                    [[0, 6]],
                    [[85, 5], [80, 3]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    63: 1,
                    80: 1 }],
            282: [[[[70, 1]], [[86, 2], [61, 3], [0, 1]], [[0, 2]], [[70, 2]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            283: [[[[29, 1]], [[70, 2]], [[57, 3], [0, 2]], [[70, 4]], [[0, 4]]], { 29: 1 }],
            284: [[[[87, 1],
                        [88, 1],
                        [89, 1],
                        [90, 1],
                        [91, 1],
                        [92, 1],
                        [93, 1],
                        [94, 1],
                        [95, 1],
                        [96, 1],
                        [97, 1],
                        [98, 1]],
                    [[0, 1]]],
                { 87: 1,
                    88: 1,
                    89: 1,
                    90: 1,
                    91: 1,
                    92: 1,
                    93: 1,
                    94: 1,
                    95: 1,
                    96: 1,
                    97: 1,
                    98: 1 }],
            285: [[[[19, 1]], [[0, 1]]], { 19: 1 }],
            286: [[[[36, 1]],
                    [[12, 2]],
                    [[8, 3], [74, 4]],
                    [[58, 5], [43, 6]],
                    [[99, 7]],
                    [[43, 6]],
                    [[74, 4]],
                    [[0, 7]]],
                { 36: 1 }],
            287: [[[[100, 1],
                        [101, 1],
                        [102, 1],
                        [103, 1],
                        [104, 1],
                        [105, 1],
                        [105, 1],
                        [106, 1],
                        [4, 2],
                        [107, 3]],
                    [[0, 1]],
                    [[106, 1]],
                    [[4, 1], [0, 3]]],
                { 4: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1, 105: 1, 106: 1, 107: 1 }],
            288: [[[[108, 1],
                        [109, 1],
                        [110, 1],
                        [111, 1],
                        [112, 1],
                        [113, 1],
                        [114, 1],
                        [115, 1]],
                    [[0, 1]]],
                { 30: 1, 31: 1, 32: 1, 33: 1, 34: 1, 35: 1, 36: 1, 37: 1 }],
            289: [[[[20, 1]], [[0, 1]]], { 20: 1 }],
            290: [[[[116, 1]], [[114, 2], [113, 2]], [[0, 2]]], { 37: 1 }],
            291: [[[[37, 1]],
                    [[117, 2]],
                    [[8, 3], [1, 4]],
                    [[118, 5], [43, 6]],
                    [[0, 4]],
                    [[43, 6]],
                    [[1, 4]]],
                { 37: 1 }],
            292: [[[[119, 1]], [[119, 1], [0, 1]]], { 37: 1 }],
            293: [[[[17, 1]], [[120, 2]], [[0, 2]]], { 17: 1 }],
            294: [[[[70, 1]], [[74, 2]], [[70, 3]], [[57, 4], [0, 3]], [[70, 1], [0, 4]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            295: [[[[117, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]], { 12: 1 }],
            296: [[[[121, 1]], [[57, 0], [0, 1]]], { 12: 1 }],
            297: [[[[12, 1]], [[122, 0], [0, 1]]], { 12: 1 }],
            298: [[[[12, 1]], [[0, 1]]], { 12: 1 }],
            299: [[[[58, 1]], [[1, 1], [123, 2]], [[0, 2]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            300: [[[[124, 1]],
                    [[70, 2], [0, 1]],
                    [[72, 3], [57, 3], [0, 2]],
                    [[70, 4]],
                    [[0, 4]]],
                { 124: 1 }],
            301: [[[[28, 1]],
                    [[55, 2]],
                    [[106, 3], [0, 2]],
                    [[70, 4]],
                    [[57, 5], [0, 4]],
                    [[70, 6]],
                    [[0, 6]]],
                { 28: 1 }],
            302: [[[[1, 0], [125, 0], [123, 1]], [[0, 1]]],
                { 1: 1,
                    4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    19: 1,
                    20: 1,
                    21: 1,
                    22: 1,
                    23: 1,
                    24: 1,
                    25: 1,
                    26: 1,
                    27: 1,
                    28: 1,
                    29: 1,
                    30: 1,
                    31: 1,
                    32: 1,
                    33: 1,
                    34: 1,
                    35: 1,
                    36: 1,
                    37: 1,
                    123: 1 }],
            303: [[[[126, 1], [127, 1], [128, 1], [129, 1], [130, 1]], [[0, 1]]],
                { 19: 1, 20: 1, 21: 1, 22: 1, 23: 1 }],
            304: [[[[32, 1]],
                    [[120, 2]],
                    [[106, 3]],
                    [[58, 4]],
                    [[74, 5]],
                    [[99, 6]],
                    [[69, 7], [0, 6]],
                    [[74, 8]],
                    [[99, 9]],
                    [[0, 9]]],
                { 32: 1 }],
            305: [[[[12, 1], [8, 2]],
                    [[74, 3], [0, 1]],
                    [[131, 4]],
                    [[70, 5]],
                    [[43, 5]],
                    [[0, 5]]],
                { 8: 1, 12: 1 }],
            306: [[[[132, 1]], [[57, 2], [0, 1]], [[132, 1], [0, 2]]], { 8: 1, 12: 1 }],
            307: [[[[35, 1]],
                    [[12, 2]],
                    [[133, 3]],
                    [[134, 4], [74, 5]],
                    [[70, 6]],
                    [[99, 7]],
                    [[74, 5]],
                    [[0, 7]]],
                { 35: 1 }],
            308: [[[[32, 1]],
                    [[120, 2]],
                    [[106, 3]],
                    [[67, 4]],
                    [[135, 5], [0, 4]],
                    [[0, 5]]],
                { 32: 1 }],
            309: [[[[30, 1]], [[136, 2]], [[135, 3], [0, 2]], [[0, 3]]], { 30: 1 }],
            310: [[[[86, 1], [137, 1]], [[0, 1]]], { 30: 1, 32: 1 }],
            311: [[[[30, 1]],
                    [[70, 2]],
                    [[74, 3]],
                    [[99, 4]],
                    [[138, 1], [69, 5], [0, 4]],
                    [[74, 6]],
                    [[99, 7]],
                    [[0, 7]]],
                { 30: 1 }],
            312: [[[[25, 1]],
                    [[139, 2]],
                    [[24, 3]],
                    [[63, 4], [8, 5], [140, 4]],
                    [[0, 4]],
                    [[140, 6]],
                    [[43, 4]]],
                { 25: 1 }],
            313: [[[[24, 1]], [[141, 2]], [[0, 2]]], { 24: 1 }],
            314: [[[[142, 1], [143, 1]], [[0, 1]]], { 24: 1, 25: 1 }],
            315: [[[[32, 1]],
                    [[120, 2]],
                    [[106, 3]],
                    [[144, 4]],
                    [[145, 5], [0, 4]],
                    [[0, 5]]],
                { 32: 1 }],
            316: [[[[30, 1]], [[136, 2]], [[145, 3], [0, 2]], [[0, 3]]], { 30: 1 }],
            317: [[[[146, 1], [147, 1]], [[0, 1]]], { 30: 1, 32: 1 }],
            318: [[[[70, 1]],
                    [[146, 2], [57, 3], [0, 1]],
                    [[0, 2]],
                    [[70, 4], [0, 3]],
                    [[57, 3], [0, 4]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            319: [[[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[136, 4]], [[0, 4]]],
                { 15: 1 }],
            320: [[[[67, 1], [148, 1]], [[0, 1]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            321: [[[[8, 1]], [[73, 2], [43, 3]], [[43, 3]], [[0, 3]]], { 8: 1 }],
            322: [[[[18, 1]], [[0, 1]]], { 18: 1 }],
            323: [[[[16, 1]],
                    [[70, 2], [83, 3], [0, 1]],
                    [[57, 4], [0, 2]],
                    [[70, 5]],
                    [[70, 2], [0, 4]],
                    [[57, 6], [0, 5]],
                    [[70, 7]],
                    [[57, 8], [0, 7]],
                    [[70, 7], [0, 8]]],
                { 16: 1 }],
            324: [[[[22, 1]],
                    [[70, 2], [0, 1]],
                    [[57, 3], [0, 2]],
                    [[70, 4]],
                    [[57, 5], [0, 4]],
                    [[70, 6]],
                    [[0, 6]]],
                { 22: 1 }],
            325: [[[[21, 1]], [[58, 2], [0, 1]], [[0, 2]]], { 21: 1 }],
            326: [[[[149, 1]], [[150, 2], [1, 3]], [[149, 1], [1, 3]], [[0, 3]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    19: 1,
                    20: 1,
                    21: 1,
                    22: 1,
                    23: 1,
                    24: 1,
                    25: 1,
                    26: 1,
                    27: 1,
                    28: 1,
                    29: 1 }],
            327: [[[[74, 1]], [[70, 2], [0, 1]], [[0, 2]]], { 74: 1 }],
            328: [[[[151, 1],
                        [152, 1],
                        [153, 1],
                        [154, 1],
                        [155, 1],
                        [156, 1],
                        [157, 1],
                        [158, 1],
                        [159, 1],
                        [160, 1]],
                    [[0, 1]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    19: 1,
                    20: 1,
                    21: 1,
                    22: 1,
                    23: 1,
                    24: 1,
                    25: 1,
                    26: 1,
                    27: 1,
                    28: 1,
                    29: 1 }],
            329: [[[[2, 1], [3, 1]], [[0, 1]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    19: 1,
                    20: 1,
                    21: 1,
                    22: 1,
                    23: 1,
                    24: 1,
                    25: 1,
                    26: 1,
                    27: 1,
                    28: 1,
                    29: 1,
                    30: 1,
                    31: 1,
                    32: 1,
                    33: 1,
                    34: 1,
                    35: 1,
                    36: 1,
                    37: 1 }],
            330: [[[[122, 1], [70, 2], [74, 3]],
                    [[122, 4]],
                    [[74, 3], [0, 2]],
                    [[70, 5], [161, 6], [0, 3]],
                    [[122, 6]],
                    [[161, 6], [0, 5]],
                    [[0, 6]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    74: 1,
                    122: 1 }],
            331: [[[[162, 1]], [[57, 2], [0, 1]], [[162, 1], [0, 2]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    74: 1,
                    122: 1 }],
            332: [[[[2, 1], [1, 2]],
                    [[0, 1]],
                    [[163, 3]],
                    [[125, 4]],
                    [[125, 4], [164, 1]]],
                { 1: 1,
                    4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    19: 1,
                    20: 1,
                    21: 1,
                    22: 1,
                    23: 1,
                    24: 1,
                    25: 1,
                    26: 1,
                    27: 1,
                    28: 1,
                    29: 1 }],
            333: [[[[70, 1]], [[57, 2], [0, 1]], [[70, 1], [0, 2]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            334: [[[[70, 1]], [[57, 0], [0, 1]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            335: [[[[70, 1]],
                    [[86, 2], [57, 3], [0, 1]],
                    [[0, 2]],
                    [[70, 4], [0, 3]],
                    [[57, 3], [0, 4]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            336: [[[[136, 1]],
                    [[57, 2], [0, 1]],
                    [[136, 3]],
                    [[57, 4], [0, 3]],
                    [[136, 3], [0, 4]]],
                { 4: 1,
                    5: 1,
                    6: 1,
                    7: 1,
                    8: 1,
                    9: 1,
                    10: 1,
                    11: 1,
                    12: 1,
                    13: 1,
                    14: 1,
                    15: 1 }],
            337: [[[[8, 1], [9, 2], [122, 3]],
                    [[118, 4], [43, 5]],
                    [[165, 6]],
                    [[12, 5]],
                    [[43, 5]],
                    [[0, 5]],
                    [[45, 5]]],
                { 8: 1, 9: 1, 122: 1 }],
            338: [[[[33, 1]],
                    [[74, 2]],
                    [[99, 3]],
                    [[166, 4], [167, 5]],
                    [[74, 6]],
                    [[74, 7]],
                    [[99, 8]],
                    [[99, 9]],
                    [[166, 4], [69, 10], [167, 5], [0, 8]],
                    [[0, 9]],
                    [[74, 11]],
                    [[99, 12]],
                    [[167, 5], [0, 12]]],
                { 33: 1 }],
            339: [[[[132, 1], [63, 2], [80, 3]],
                    [[61, 4], [57, 5], [0, 1]],
                    [[12, 6]],
                    [[12, 7]],
                    [[70, 8]],
                    [[132, 1], [63, 2], [80, 3], [0, 5]],
                    [[57, 9], [0, 6]],
                    [[0, 7]],
                    [[57, 5], [0, 8]],
                    [[80, 3]]],
                { 8: 1, 12: 1, 63: 1, 80: 1 }],
            340: [[[[31, 1]],
                    [[70, 2]],
                    [[74, 3]],
                    [[99, 4]],
                    [[69, 5], [0, 4]],
                    [[74, 6]],
                    [[99, 7]],
                    [[0, 7]]],
                { 31: 1 }],
            341: [[[[34, 1]],
                    [[70, 2]],
                    [[168, 3], [74, 4]],
                    [[74, 4]],
                    [[99, 5]],
                    [[0, 5]]],
                { 34: 1 }],
            342: [[[[72, 1]], [[55, 2]], [[0, 2]]], { 72: 1 }],
            343: [[[[41, 1]], [[0, 1]]], { 23: 1 }] },
        states: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[1, 1]]],
            [[[38, 1]], [[39, 0], [0, 1]]],
            [[[40, 1]], [[5, 0], [6, 0], [0, 1]]],
            [[[8, 1], [9, 2], [10, 3], [11, 4], [12, 5], [13, 5], [14, 6]],
                [[41, 7], [42, 7], [43, 5]],
                [[44, 8], [45, 5]],
                [[46, 9], [47, 5]],
                [[48, 10]],
                [[0, 5]],
                [[14, 6], [0, 6]],
                [[43, 5]],
                [[45, 5]],
                [[47, 5]],
                [[11, 5]]],
            [[[49, 1]], [[50, 0], [0, 1]]],
            [[[51, 1]], [[52, 0], [0, 1]]],
            [[[53, 1]], [[54, 0], [0, 1]]],
            [[[55, 1]], [[56, 0], [0, 1]]],
            [[[55, 1]], [[57, 2], [0, 1]], [[55, 1], [0, 2]]],
            [[[58, 1]],
                [[59, 2], [60, 3], [61, 4], [0, 1]],
                [[0, 2]],
                [[41, 2], [58, 2]],
                [[41, 5], [58, 5]],
                [[61, 4], [0, 5]]],
            [[[62, 1]], [[63, 0], [64, 0], [65, 0], [66, 0], [0, 1]]],
            [[[26, 1]], [[12, 2]], [[57, 1], [0, 2]]],
            [[[67, 1], [68, 2]],
                [[30, 3], [0, 1]],
                [[0, 2]],
                [[67, 4]],
                [[69, 5]],
                [[70, 2]]],
            [[[71, 1]], [[57, 2], [0, 1]], [[71, 1], [0, 2]]],
            [[[12, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]],
            [[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[70, 4]], [[0, 4]]],
            [[[14, 1]], [[0, 1]]],
            [[[27, 1]], [[12, 2]], [[57, 1], [0, 2]]],
            [[[4, 1], [75, 2]], [[38, 2]], [[0, 2]]],
            [[[76, 1]], [[77, 0], [0, 1]]],
            [[[78, 1]], [[79, 1], [80, 2], [0, 1]], [[49, 3]], [[0, 3]]],
            [[[81, 1]], [[82, 0], [83, 0], [0, 1]]],
            [[[5, 1], [6, 1], [7, 1], [84, 2]], [[49, 2]], [[0, 2]]],
            [[[23, 1]], [[58, 2], [0, 1]], [[0, 2]]],
            [[[74, 1]], [[70, 2]], [[61, 3], [0, 2]], [[70, 4]], [[0, 4]]],
            [[[85, 1], [63, 2], [80, 3]],
                [[57, 4], [0, 1]],
                [[70, 5]],
                [[70, 6]],
                [[85, 1], [63, 2], [80, 3], [0, 4]],
                [[57, 7], [0, 5]],
                [[0, 6]],
                [[85, 5], [80, 3]]],
            [[[70, 1]], [[86, 2], [61, 3], [0, 1]], [[0, 2]], [[70, 2]]],
            [[[29, 1]], [[70, 2]], [[57, 3], [0, 2]], [[70, 4]], [[0, 4]]],
            [[[87, 1],
                    [88, 1],
                    [89, 1],
                    [90, 1],
                    [91, 1],
                    [92, 1],
                    [93, 1],
                    [94, 1],
                    [95, 1],
                    [96, 1],
                    [97, 1],
                    [98, 1]],
                [[0, 1]]],
            [[[19, 1]], [[0, 1]]],
            [[[36, 1]],
                [[12, 2]],
                [[8, 3], [74, 4]],
                [[58, 5], [43, 6]],
                [[99, 7]],
                [[43, 6]],
                [[74, 4]],
                [[0, 7]]],
            [[[100, 1],
                    [101, 1],
                    [102, 1],
                    [103, 1],
                    [104, 1],
                    [105, 1],
                    [105, 1],
                    [106, 1],
                    [4, 2],
                    [107, 3]],
                [[0, 1]],
                [[106, 1]],
                [[4, 1], [0, 3]]],
            [[[108, 1],
                    [109, 1],
                    [110, 1],
                    [111, 1],
                    [112, 1],
                    [113, 1],
                    [114, 1],
                    [115, 1]],
                [[0, 1]]],
            [[[20, 1]], [[0, 1]]],
            [[[116, 1]], [[114, 2], [113, 2]], [[0, 2]]],
            [[[37, 1]],
                [[117, 2]],
                [[8, 3], [1, 4]],
                [[118, 5], [43, 6]],
                [[0, 4]],
                [[43, 6]],
                [[1, 4]]],
            [[[119, 1]], [[119, 1], [0, 1]]],
            [[[17, 1]], [[120, 2]], [[0, 2]]],
            [[[70, 1]], [[74, 2]], [[70, 3]], [[57, 4], [0, 3]], [[70, 1], [0, 4]]],
            [[[117, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]],
            [[[121, 1]], [[57, 0], [0, 1]]],
            [[[12, 1]], [[122, 0], [0, 1]]],
            [[[12, 1]], [[0, 1]]],
            [[[58, 1]], [[1, 1], [123, 2]], [[0, 2]]],
            [[[124, 1]],
                [[70, 2], [0, 1]],
                [[72, 3], [57, 3], [0, 2]],
                [[70, 4]],
                [[0, 4]]],
            [[[28, 1]],
                [[55, 2]],
                [[106, 3], [0, 2]],
                [[70, 4]],
                [[57, 5], [0, 4]],
                [[70, 6]],
                [[0, 6]]],
            [[[1, 0], [125, 0], [123, 1]], [[0, 1]]],
            [[[126, 1], [127, 1], [128, 1], [129, 1], [130, 1]], [[0, 1]]],
            [[[32, 1]],
                [[120, 2]],
                [[106, 3]],
                [[58, 4]],
                [[74, 5]],
                [[99, 6]],
                [[69, 7], [0, 6]],
                [[74, 8]],
                [[99, 9]],
                [[0, 9]]],
            [[[12, 1], [8, 2]],
                [[74, 3], [0, 1]],
                [[131, 4]],
                [[70, 5]],
                [[43, 5]],
                [[0, 5]]],
            [[[132, 1]], [[57, 2], [0, 1]], [[132, 1], [0, 2]]],
            [[[35, 1]],
                [[12, 2]],
                [[133, 3]],
                [[134, 4], [74, 5]],
                [[70, 6]],
                [[99, 7]],
                [[74, 5]],
                [[0, 7]]],
            [[[32, 1]], [[120, 2]], [[106, 3]], [[67, 4]], [[135, 5], [0, 4]], [[0, 5]]],
            [[[30, 1]], [[136, 2]], [[135, 3], [0, 2]], [[0, 3]]],
            [[[86, 1], [137, 1]], [[0, 1]]],
            [[[30, 1]],
                [[70, 2]],
                [[74, 3]],
                [[99, 4]],
                [[138, 1], [69, 5], [0, 4]],
                [[74, 6]],
                [[99, 7]],
                [[0, 7]]],
            [[[25, 1]],
                [[139, 2]],
                [[24, 3]],
                [[63, 4], [8, 5], [140, 4]],
                [[0, 4]],
                [[140, 6]],
                [[43, 4]]],
            [[[24, 1]], [[141, 2]], [[0, 2]]],
            [[[142, 1], [143, 1]], [[0, 1]]],
            [[[32, 1]], [[120, 2]], [[106, 3]], [[144, 4]], [[145, 5], [0, 4]], [[0, 5]]],
            [[[30, 1]], [[136, 2]], [[145, 3], [0, 2]], [[0, 3]]],
            [[[146, 1], [147, 1]], [[0, 1]]],
            [[[70, 1]],
                [[146, 2], [57, 3], [0, 1]],
                [[0, 2]],
                [[70, 4], [0, 3]],
                [[57, 3], [0, 4]]],
            [[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[136, 4]], [[0, 4]]],
            [[[67, 1], [148, 1]], [[0, 1]]],
            [[[8, 1]], [[73, 2], [43, 3]], [[43, 3]], [[0, 3]]],
            [[[18, 1]], [[0, 1]]],
            [[[16, 1]],
                [[70, 2], [83, 3], [0, 1]],
                [[57, 4], [0, 2]],
                [[70, 5]],
                [[70, 2], [0, 4]],
                [[57, 6], [0, 5]],
                [[70, 7]],
                [[57, 8], [0, 7]],
                [[70, 7], [0, 8]]],
            [[[22, 1]],
                [[70, 2], [0, 1]],
                [[57, 3], [0, 2]],
                [[70, 4]],
                [[57, 5], [0, 4]],
                [[70, 6]],
                [[0, 6]]],
            [[[21, 1]], [[58, 2], [0, 1]], [[0, 2]]],
            [[[149, 1]], [[150, 2], [1, 3]], [[149, 1], [1, 3]], [[0, 3]]],
            [[[74, 1]], [[70, 2], [0, 1]], [[0, 2]]],
            [[[151, 1],
                    [152, 1],
                    [153, 1],
                    [154, 1],
                    [155, 1],
                    [156, 1],
                    [157, 1],
                    [158, 1],
                    [159, 1],
                    [160, 1]],
                [[0, 1]]],
            [[[2, 1], [3, 1]], [[0, 1]]],
            [[[122, 1], [70, 2], [74, 3]],
                [[122, 4]],
                [[74, 3], [0, 2]],
                [[70, 5], [161, 6], [0, 3]],
                [[122, 6]],
                [[161, 6], [0, 5]],
                [[0, 6]]],
            [[[162, 1]], [[57, 2], [0, 1]], [[162, 1], [0, 2]]],
            [[[2, 1], [1, 2]], [[0, 1]], [[163, 3]], [[125, 4]], [[125, 4], [164, 1]]],
            [[[70, 1]], [[57, 2], [0, 1]], [[70, 1], [0, 2]]],
            [[[70, 1]], [[57, 0], [0, 1]]],
            [[[70, 1]],
                [[86, 2], [57, 3], [0, 1]],
                [[0, 2]],
                [[70, 4], [0, 3]],
                [[57, 3], [0, 4]]],
            [[[136, 1]],
                [[57, 2], [0, 1]],
                [[136, 3]],
                [[57, 4], [0, 3]],
                [[136, 3], [0, 4]]],
            [[[8, 1], [9, 2], [122, 3]],
                [[118, 4], [43, 5]],
                [[165, 6]],
                [[12, 5]],
                [[43, 5]],
                [[0, 5]],
                [[45, 5]]],
            [[[33, 1]],
                [[74, 2]],
                [[99, 3]],
                [[166, 4], [167, 5]],
                [[74, 6]],
                [[74, 7]],
                [[99, 8]],
                [[99, 9]],
                [[166, 4], [69, 10], [167, 5], [0, 8]],
                [[0, 9]],
                [[74, 11]],
                [[99, 12]],
                [[167, 5], [0, 12]]],
            [[[132, 1], [63, 2], [80, 3]],
                [[61, 4], [57, 5], [0, 1]],
                [[12, 6]],
                [[12, 7]],
                [[70, 8]],
                [[132, 1], [63, 2], [80, 3], [0, 5]],
                [[57, 9], [0, 6]],
                [[0, 7]],
                [[57, 5], [0, 8]],
                [[80, 3]]],
            [[[31, 1]],
                [[70, 2]],
                [[74, 3]],
                [[99, 4]],
                [[69, 5], [0, 4]],
                [[74, 6]],
                [[99, 7]],
                [[0, 7]]],
            [[[34, 1]], [[70, 2]], [[168, 3], [74, 4]], [[74, 4]], [[99, 5]], [[0, 5]]],
            [[[72, 1]], [[55, 2]], [[0, 2]]],
            [[[41, 1]], [[0, 1]]]],
        labels: [[0, 'EMPTY'],
            [4, null],
            [326, null],
            [288, null],
            [1, 'not'],
            [14, null],
            [15, null],
            [32, null],
            [7, null],
            [9, null],
            [26, null],
            [25, null],
            [1, null],
            [2, null],
            [3, null],
            [1, 'lambda'],
            [1, 'print'],
            [1, 'del'],
            [1, 'pass'],
            [1, 'break'],
            [1, 'continue'],
            [1, 'return'],
            [1, 'raise'],
            [1, 'yield'],
            [1, 'import'],
            [1, 'from'],
            [1, 'global'],
            [1, 'nonlocal'],
            [1, 'exec'],
            [1, 'assert'],
            [1, 'if'],
            [1, 'while'],
            [1, 'for'],
            [1, 'try'],
            [1, 'with'],
            [1, 'def'],
            [1, 'class'],
            [50, null],
            [274, null],
            [1, 'and'],
            [266, null],
            [279, null],
            [335, null],
            [8, null],
            [318, null],
            [10, null],
            [294, null],
            [27, null],
            [334, null],
            [278, null],
            [19, null],
            [262, null],
            [18, null],
            [260, null],
            [33, null],
            [258, null],
            [287, null],
            [12, null],
            [333, null],
            [280, null],
            [284, null],
            [22, null],
            [277, null],
            [16, null],
            [17, null],
            [24, null],
            [48, null],
            [275, null],
            [271, null],
            [1, 'else'],
            [268, null],
            [270, null],
            [1, 'as'],
            [339, null],
            [11, null],
            [263, null],
            [257, null],
            [1, 'or'],
            [259, null],
            [337, null],
            [36, null],
            [261, null],
            [34, null],
            [35, null],
            [276, null],
            [282, null],
            [308, null],
            [37, null],
            [38, null],
            [39, null],
            [40, null],
            [41, null],
            [42, null],
            [43, null],
            [44, null],
            [45, null],
            [46, null],
            [47, null],
            [49, null],
            [332, null],
            [20, null],
            [21, null],
            [28, null],
            [31, null],
            [30, null],
            [29, null],
            [1, 'in'],
            [1, 'is'],
            [311, null],
            [340, null],
            [304, null],
            [338, null],
            [341, null],
            [307, null],
            [286, null],
            [290, null],
            [292, null],
            [297, null],
            [281, null],
            [291, null],
            [264, null],
            [295, null],
            [23, null],
            [0, null],
            [1, 'except'],
            [329, null],
            [285, null],
            [289, null],
            [325, null],
            [324, null],
            [343, null],
            [306, null],
            [305, null],
            [321, null],
            [55, null],
            [310, null],
            [320, null],
            [309, null],
            [1, 'elif'],
            [272, null],
            [269, null],
            [296, null],
            [313, null],
            [312, null],
            [336, null],
            [317, null],
            [315, null],
            [316, null],
            [319, null],
            [328, null],
            [13, null],
            [265, null],
            [323, null],
            [293, null],
            [322, null],
            [303, null],
            [314, null],
            [267, null],
            [273, null],
            [301, null],
            [283, null],
            [327, null],
            [330, null],
            [5, null],
            [6, null],
            [331, null],
            [300, null],
            [1, 'finally'],
            [342, null]],
        keywords: { 'and': 39,
            'as': 72,
            'assert': 29,
            'break': 19,
            'class': 36,
            'continue': 20,
            'def': 35,
            'del': 17,
            'elif': 138,
            'else': 69,
            'except': 124,
            'exec': 28,
            'finally': 167,
            'for': 32,
            'from': 25,
            'global': 26,
            'if': 30,
            'import': 24,
            'in': 106,
            'is': 107,
            'lambda': 15,
            'nonlocal': 27,
            'not': 4,
            'or': 77,
            'pass': 18,
            'print': 16,
            'raise': 22,
            'return': 21,
            'try': 33,
            'while': 31,
            'with': 34,
            'yield': 23 },
        tokens: { 0: 123,
            1: 12,
            2: 13,
            3: 14,
            4: 1,
            5: 163,
            6: 164,
            7: 8,
            8: 43,
            9: 9,
            10: 45,
            11: 74,
            12: 57,
            13: 150,
            14: 5,
            15: 6,
            16: 63,
            17: 64,
            18: 52,
            19: 50,
            20: 100,
            21: 101,
            22: 61,
            23: 122,
            24: 65,
            25: 11,
            26: 10,
            27: 47,
            28: 102,
            29: 105,
            30: 104,
            31: 103,
            32: 7,
            33: 54,
            34: 82,
            35: 83,
            36: 80,
            37: 87,
            38: 88,
            39: 89,
            40: 90,
            41: 91,
            42: 92,
            43: 93,
            44: 94,
            45: 95,
            46: 96,
            47: 97,
            48: 66,
            49: 98,
            50: 37,
            55: 134 },
        start: 256
    };
    // Nothing more to see here.

    /**
     * Decodes of the tokens.
     * A mapping from the token number (symbol) to its human-readable name.
     */
    const tokenNames = {};
    tokenNames[exports.Tokens.T_AMPER] = 'T_AMPER';
    tokenNames[exports.Tokens.T_AMPEREQUAL] = 'T_AMPEREQUAL';
    tokenNames[exports.Tokens.T_AT] = 'T_AT';
    tokenNames[exports.Tokens.T_BACKQUOTE] = 'T_BACKQUOTE';
    tokenNames[exports.Tokens.T_CIRCUMFLEX] = 'T_CIRCUMFLEX';
    tokenNames[exports.Tokens.T_CIRCUMFLEXEQUAL] = 'T_CIRCUMFLEXEQUAL';
    tokenNames[exports.Tokens.T_COLON] = 'T_COLON';
    tokenNames[exports.Tokens.T_COMMA] = 'T_COMMA';
    tokenNames[exports.Tokens.T_COMMENT] = 'T_COMMENT';
    tokenNames[exports.Tokens.T_DEDENT] = 'T_DEDENT';
    tokenNames[exports.Tokens.T_DOT] = 'T_DOT';
    tokenNames[exports.Tokens.T_DOUBLESLASH] = 'T_DOUBLESLASH';
    tokenNames[exports.Tokens.T_DOUBLESLASHEQUAL] = 'T_DOUBLESLASHEQUAL';
    tokenNames[exports.Tokens.T_DOUBLESTAR] = 'T_DOUBLESTAR';
    tokenNames[exports.Tokens.T_DOUBLESTAREQUAL] = 'T_DOUBLESTAREQUAL';
    tokenNames[exports.Tokens.T_ENDMARKER] = 'T_ENDMARKER';
    tokenNames[exports.Tokens.T_EQEQUAL] = 'T_EQEQUAL';
    tokenNames[exports.Tokens.T_EQUAL] = 'T_EQUAL';
    tokenNames[exports.Tokens.T_ERRORTOKEN] = 'T_ERRORTOKEN';
    tokenNames[exports.Tokens.T_GREATER] = 'T_GREATER';
    tokenNames[exports.Tokens.T_GREATEREQUAL] = 'T_GREATEREQUAL';
    tokenNames[exports.Tokens.T_INDENT] = 'T_INDENT';
    tokenNames[exports.Tokens.T_LBRACE] = 'T_LBRACE';
    tokenNames[exports.Tokens.T_LEFTSHIFT] = 'T_LEFTSHIFT';
    tokenNames[exports.Tokens.T_LEFTSHIFTEQUAL] = 'T_LEFTSHIFTEQUAL';
    tokenNames[exports.Tokens.T_LESS] = 'T_LESS';
    tokenNames[exports.Tokens.T_LESSEQUAL] = 'T_LESSEQUAL';
    tokenNames[exports.Tokens.T_LPAR] = 'T_LPAR';
    tokenNames[exports.Tokens.T_LSQB] = 'T_LSQB';
    tokenNames[exports.Tokens.T_MINEQUAL] = 'T_MINEQUAL';
    tokenNames[exports.Tokens.T_MINUS] = 'T_MINUS';
    tokenNames[exports.Tokens.T_N_TOKENS] = 'T_N_TOKENS';
    tokenNames[exports.Tokens.T_NAME] = 'T_NAME';
    tokenNames[exports.Tokens.T_NEWLINE] = 'T_NEWLINE';
    tokenNames[exports.Tokens.T_NL] = 'T_NL';
    tokenNames[exports.Tokens.T_NOTEQUAL] = 'T_NOTEQUAL';
    tokenNames[exports.Tokens.T_NT_OFFSET] = 'T_NT_OFFSET';
    tokenNames[exports.Tokens.T_NUMBER] = 'T_NUMBER';
    tokenNames[exports.Tokens.T_OP] = 'T_OP';
    tokenNames[exports.Tokens.T_PERCENT] = 'T_PERCENT';
    tokenNames[exports.Tokens.T_PERCENTEQUAL] = 'T_PERCENTEQUAL';
    tokenNames[exports.Tokens.T_PLUS] = 'T_PLUS';
    tokenNames[exports.Tokens.T_PLUSEQUAL] = 'T_PLUSEQUAL';
    tokenNames[exports.Tokens.T_RARROW] = 'T_RARROW';
    tokenNames[exports.Tokens.T_RBRACE] = 'T_RBRACE';
    tokenNames[exports.Tokens.T_RIGHTSHIFT] = 'T_RIGHTSHIFT';
    tokenNames[exports.Tokens.T_RPAR] = 'T_RPAR';
    tokenNames[exports.Tokens.T_RSQB] = 'T_RSQB';
    tokenNames[exports.Tokens.T_SEMI] = 'T_SEMI';
    tokenNames[exports.Tokens.T_SLASH] = 'T_SLASH';
    tokenNames[exports.Tokens.T_SLASHEQUAL] = 'T_SLASHEQUAL';
    tokenNames[exports.Tokens.T_STAR] = 'T_STAR';
    tokenNames[exports.Tokens.T_STAREQUAL] = 'T_STAREQUAL';
    tokenNames[exports.Tokens.T_STRING] = 'T_STRING';
    tokenNames[exports.Tokens.T_TILDE] = 'T_TILDE';
    tokenNames[exports.Tokens.T_VBAR] = 'T_VBAR';
    tokenNames[exports.Tokens.T_VBAREQUAL] = 'T_VBAREQUAL';

    function grammarName(type) {
        const tokenName = tokenNames[type];
        if (tokenName) {
            return tokenName;
        }
        else {
            return ParseTables.number2symbol[type];
        }
    }

    /**
     * A token error is exclusively used to indicate EOF situations.
     */
    class TokenError extends Error {
        /**
         * @param message
         * @param lineNumber
         * @param columnNumber
         */
        constructor(message, lineNumber, columnNumber) {
            super(message);
            this.lineNumber = lineNumber;
            this.columnNumber = columnNumber;
            assert(isNumber(lineNumber), "lineNumber must be a number");
            assert(isNumber(columnNumber), "columnNumber must be a number");
        }
    }

    // Cache a few tokens for performance.
    const T_COMMENT$1 = exports.Tokens.T_COMMENT;
    const T_DEDENT = exports.Tokens.T_DEDENT;
    const T_ENDMARKER$1 = exports.Tokens.T_ENDMARKER;
    const T_ERRORTOKEN = exports.Tokens.T_ERRORTOKEN;
    const T_INDENT = exports.Tokens.T_INDENT;
    const T_NAME$1 = exports.Tokens.T_NAME;
    const T_NEWLINE = exports.Tokens.T_NEWLINE;
    const T_NL$1 = exports.Tokens.T_NL;
    const T_NUMBER = exports.Tokens.T_NUMBER;
    const T_OP$1 = exports.Tokens.T_OP;
    const T_STRING = exports.Tokens.T_STRING;
    /* we have to use string and ctor to be able to build patterns up. + on /.../
        * does something strange. */
    // const Whitespace = "[ \\f\\t]*";
    const Comment_ = "#[^\\r\\n]*";
    const MultiComment_ = "'{3}[^]*'{3}";
    const Ident = "[a-zA-Z_]\\w*";
    const Binnumber = '0[bB][01]*';
    const Hexnumber = '0[xX][\\da-fA-F]*[lL]?';
    const Octnumber = '0[oO]?[0-7]*[lL]?';
    const Decnumber = '[1-9]\\d*[lL]?';
    const Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);
    const Exponent = "[eE][-+]?\\d+";
    const Pointfloat = group("\\d+\\.\\d*", "\\.\\d+") + maybe(Exponent);
    const Expfloat = '\\d+' + Exponent;
    const Floatnumber = group(Pointfloat, Expfloat);
    const Imagnumber = group("\\d+[jJ]", Floatnumber + "[jJ]");
    const Number_ = group(Imagnumber, Floatnumber, Intnumber);
    // tail end of ' string
    const Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'";
    // tail end of " string
    const Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
    // tail end of ''' string
    const Single3 = "[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
    // tail end of """ string
    const Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
    const Triple = group("[ubUB]?[rR]?'''", '[ubUB]?[rR]?"""');
    // const String_ = group("[uU]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
    // Because of leftmost-then-longest match semantics, be sure to put the
    // longest operators first (e.g., if = came before ==, == would get
    // recognized as two instances of =).
    const Operator = group("\\*\\*=?", ">>=?", "<<=?", "<>", "!=", "//=?", "->", "[+\\-*/%&|^=<>]=?", "~");
    const Bracket = '[\\][(){}]';
    const Special = group('\\r?\\n', '[:;.,`@]');
    const Funny = group(Operator, Bracket, Special);
    const ContStr = group("[uUbB]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" +
        group("'", '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' +
        group('"', '\\\\\\r?\\n'));
    const PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple, MultiComment_);
    // Need to prefix with "^" as we only want to match what's next
    const PseudoToken = "^" + group(PseudoExtras, Number_, Funny, ContStr, Ident);
    const pseudoprog = new RegExp(PseudoToken);
    const single3prog = new RegExp(Single3, "g");
    const double3prog = new RegExp(Double3, "g");
    const endprogs = {
        "'": new RegExp(Single, "g"), '"': new RegExp(Double_, "g"),
        "'''": single3prog, '"""': double3prog,
        "r'''": single3prog, 'r"""': double3prog,
        "u'''": single3prog, 'u"""': double3prog,
        "b'''": single3prog, 'b"""': double3prog,
        "ur'''": single3prog, 'ur"""': double3prog,
        "br'''": single3prog, 'br"""': double3prog,
        "R'''": single3prog, 'R"""': double3prog,
        "U'''": single3prog, 'U"""': double3prog,
        "B'''": single3prog, 'B"""': double3prog,
        "uR'''": single3prog, 'uR"""': double3prog,
        "Ur'''": single3prog, 'Ur"""': double3prog,
        "UR'''": single3prog, 'UR"""': double3prog,
        "bR'''": single3prog, 'bR"""': double3prog,
        "Br'''": single3prog, 'Br"""': double3prog,
        "BR'''": single3prog, 'BR"""': double3prog,
        'r': null, 'R': null,
        'u': null, 'U': null,
        'b': null, 'B': null
    };
    const triple_quoted = {
        "'''": true, '"""': true,
        "r'''": true, 'r"""': true, "R'''": true, 'R"""': true,
        "u'''": true, 'u"""': true, "U'''": true, 'U"""': true,
        "b'''": true, 'b"""': true, "B'''": true, 'B"""': true,
        "ur'''": true, 'ur"""': true, "Ur'''": true, 'Ur"""': true,
        "uR'''": true, 'uR"""': true, "UR'''": true, 'UR"""': true,
        "br'''": true, 'br"""': true, "Br'''": true, 'Br"""': true,
        "bR'''": true, 'bR"""': true, "BR'''": true, 'BR"""': true
    };
    const single_quoted = {
        "'": true, '"': true,
        "r'": true, 'r"': true, "R'": true, 'R"': true,
        "u'": true, 'u"': true, "U'": true, 'U"': true,
        "b'": true, 'b"': true, "B'": true, 'B"': true,
        "ur'": true, 'ur"': true, "Ur'": true, 'Ur"': true,
        "uR'": true, 'uR"': true, "UR'": true, 'UR"': true,
        "br'": true, 'br"': true, "Br'": true, 'Br"': true,
        "bR'": true, 'bR"': true, "BR'": true, 'BR"': true
    };
    const tabsize = 8;
    const NAMECHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
    const NUMCHARS = '0123456789';
    /**
     * The index of the line in the LineColumn array.
     */
    const LINE = 0;
    /**
     * The index of the column in the LineColumn array.
     */
    const COLUMN = 1;
    const Done = 'done';
    const Failed = 'failed';
    /**
     * This is a port of tokenize.py by Ka-Ping Yee.
     *
     * each call to readline should return one line of input as a string, or
     * undefined if it's finished.
     *
     * callback is called for each token with 5 args:
     * 1. the token type
     * 2. the token string
     * 3. [ start_row, start_col ]
     * 4. [ end_row, end_col ]
     * 5. logical line where the token was found, including continuation lines
     *
     * callback can return true to abort.
     */
    class Tokenizer {
        /**
         *
         */
        constructor(interactive, callback) {
            this.callback = callback;
            /**
             * Cache of the beginning of a token.
             * This will change by token so consumers must copy the values out.
             */
            this.begin = [-1, -1];
            /**
             * Cache of the end of a token.
             * This will change by token so consumers must copy the values out.
             */
            this.end = [-1, -1];
            /**
             * The line number. This must be copied into the begin[LINE] and end[LINE] properties.
             */
            this.lnum = 0;
            this.parenlev = 0;
            this.strstart = [-1, -1];
            this.callback = callback;
            this.continued = false;
            this.contstr = '';
            this.needcont = false;
            this.contline = undefined;
            this.indents = [0];
            this.endprog = /.*/;
            this.interactive = interactive;
            this.doneFunc = function doneOrFailed() {
                const begin = this.begin;
                const end = this.end;
                begin[LINE] = end[LINE] = this.lnum;
                begin[COLUMN] = end[COLUMN] = 0;
                const N = this.indents.length;
                for (let i = 1; i < N; ++i) {
                    if (callback(T_DEDENT, '', begin, end, '')) {
                        return Done;
                    }
                }
                if (callback(T_ENDMARKER$1, '', begin, end, '')) {
                    return Done;
                }
                return Failed;
            };
        }
        /**
         * @param line
         * @return 'done' or 'failed' or true?
         */
        generateTokens(line) {
            let endmatch;
            let column;
            let endIndex;
            if (!line) {
                line = '';
            }
            this.lnum += 1;
            let pos = 0;
            let max = line.length;
            /**
             * Local variable for performance and brevity.
             */
            const callback = this.callback;
            const begin = this.begin;
            begin[LINE] = this.lnum;
            const end = this.end;
            end[LINE] = this.lnum;
            if (this.contstr.length > 0) {
                if (!line) {
                    throw new TokenError("EOF in multi-line string", this.strstart[LINE], this.strstart[COLUMN]);
                }
                this.endprog.lastIndex = 0;
                endmatch = this.endprog.test(line);
                if (endmatch) {
                    pos = endIndex = this.endprog.lastIndex;
                    end[COLUMN] = endIndex;
                    if (callback(T_STRING, this.contstr + line.substring(0, endIndex), this.strstart, end, this.contline + line)) {
                        return Done;
                    }
                    this.contstr = '';
                    this.needcont = false;
                    this.contline = undefined;
                }
                else if (this.needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
                    // Either contline is a string or the callback must allow undefined.
                    assert(typeof this.contline === 'string');
                    end[COLUMN] = line.length;
                    if (callback(T_ERRORTOKEN, this.contstr + line, this.strstart, end, this.contline)) {
                        return Done;
                    }
                    this.contstr = '';
                    this.contline = undefined;
                    return false;
                }
                else {
                    this.contstr += line;
                    this.contline = this.contline + line;
                    return false;
                }
            }
            else if (this.parenlev === 0 && !this.continued) {
                if (!line)
                    return this.doneFunc();
                column = 0;
                while (pos < max) {
                    const ch = line.charAt(pos);
                    if (ch === ' ') {
                        column += 1;
                    }
                    else if (ch === '\t') {
                        column = (column / tabsize + 1) * tabsize;
                    }
                    else if (ch === '\f') {
                        column = 0;
                    }
                    else {
                        break;
                    }
                    pos = pos + 1;
                }
                if (pos === max)
                    return this.doneFunc();
                if ("#\r\n".indexOf(line.charAt(pos)) !== -1) {
                    if (line.charAt(pos) === '#') {
                        const comment_token = rstrip(line.substring(pos), '\r\n');
                        const nl_pos = pos + comment_token.length;
                        begin[COLUMN] = pos;
                        end[COLUMN] = nl_pos;
                        if (callback(T_COMMENT$1, comment_token, begin, end, line)) {
                            return Done;
                        }
                        begin[COLUMN] = nl_pos;
                        end[COLUMN] = line.length;
                        if (callback(T_NL$1, line.substring(nl_pos), begin, end, line)) {
                            return Done;
                        }
                        return false;
                    }
                    else {
                        begin[COLUMN] = pos;
                        end[COLUMN] = line.length;
                        if (callback(T_NL$1, line.substring(pos), begin, end, line)) {
                            return Done;
                        }
                        if (!this.interactive)
                            return false;
                    }
                }
                if ("'''".indexOf(line.charAt(pos)) !== -1) {
                    if (line.charAt(pos) === "'") {
                        const comment_token = line.substring(pos);
                        const nl_pos = pos + comment_token.length;
                        begin[COLUMN] = pos;
                        end[COLUMN] = nl_pos;
                        if (callback(T_COMMENT$1, comment_token, begin, end, line)) {
                            return Done;
                        }
                        begin[COLUMN] = nl_pos;
                        end[COLUMN] = line.length;
                        if (callback(T_NL$1, line.substring(nl_pos), begin, end, line)) {
                            return Done;
                        }
                        return false;
                    }
                    else {
                        begin[COLUMN] = pos;
                        end[COLUMN] = line.length;
                        if (callback(T_NL$1, line.substring(pos), begin, end, line)) {
                            return Done;
                        }
                        if (!this.interactive)
                            return false;
                    }
                }
                if (column > this.indents[this.indents.length - 1]) {
                    this.indents.push(column);
                    begin[COLUMN] = 0;
                    end[COLUMN] = pos;
                    if (callback(T_INDENT, line.substring(0, pos), begin, end, line)) {
                        return Done;
                    }
                }
                while (column < this.indents[this.indents.length - 1]) {
                    if (!contains(this.indents, column)) {
                        begin[COLUMN] = 0;
                        end[COLUMN] = pos;
                        throw indentationError("unindent does not match any outer indentation level", begin, end);
                    }
                    this.indents.splice(this.indents.length - 1, 1);
                    begin[COLUMN] = pos;
                    end[COLUMN] = pos;
                    if (callback(T_DEDENT, '', begin, end, line)) {
                        return Done;
                    }
                }
            }
            else {
                if (!line) {
                    throw new TokenError("EOF in multi-line statement", this.lnum, 0);
                }
                this.continued = false;
            }
            while (pos < max) {
                // js regexes don't return any info about matches, other than the
                // content. we'd like to put a \w+ before pseudomatch, but then we
                // can't get any data
                let capos = line.charAt(pos);
                while (capos === ' ' || capos === '\f' || capos === '\t') {
                    pos += 1;
                    capos = line.charAt(pos);
                }
                pseudoprog.lastIndex = 0;
                const pseudomatch = pseudoprog.exec(line.substring(pos));
                if (pseudomatch) {
                    const startIndex = pos;
                    endIndex = startIndex + pseudomatch[1].length;
                    begin[COLUMN] = startIndex;
                    end[COLUMN] = endIndex;
                    pos = endIndex;
                    const token = line.substring(startIndex, endIndex);
                    const initial = line.charAt(startIndex);
                    if (NUMCHARS.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {
                        if (callback(T_NUMBER, token, begin, end, line)) {
                            return Done;
                        }
                    }
                    else if (initial === '\r' || initial === '\n') {
                        let newl = T_NEWLINE;
                        if (this.parenlev > 0)
                            newl = T_NL$1;
                        if (callback(newl, token, begin, end, line)) {
                            return Done;
                        }
                    }
                    else if (initial === '#' || initial === "'''") {
                        if (callback(T_COMMENT$1, token, begin, end, line)) {
                            return Done;
                        }
                    }
                    else if (triple_quoted.hasOwnProperty(token)) {
                        this.endprog = endprogs[token];
                        this.endprog.lastIndex = 0;
                        endmatch = this.endprog.test(line.substring(pos));
                        if (endmatch) {
                            pos = this.endprog.lastIndex + pos;
                            const token = line.substring(startIndex, pos);
                            end[COLUMN] = pos;
                            if (callback(T_STRING, token, begin, end, line)) {
                                return Done;
                            }
                        }
                        else {
                            this.strstart[LINE] = this.lnum;
                            this.strstart[COLUMN] = startIndex;
                            this.contstr = line.substring(startIndex);
                            this.contline = line;
                            return false;
                        }
                    }
                    else if (single_quoted.hasOwnProperty(initial) ||
                        single_quoted.hasOwnProperty(token.substring(0, 2)) ||
                        single_quoted.hasOwnProperty(token.substring(0, 3))) {
                        if (token[token.length - 1] === '\n') {
                            this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];
                            assert(this.endprog instanceof RegExp);
                            this.contstr = line.substring(startIndex);
                            this.needcont = true;
                            this.contline = line;
                            return false;
                        }
                        else {
                            if (callback(T_STRING, token, begin, end, line)) {
                                return Done;
                            }
                        }
                    }
                    else if (NAMECHARS.indexOf(initial) !== -1) {
                        if (callback(T_NAME$1, token, begin, end, line)) {
                            return Done;
                        }
                    }
                    else if (initial === '\\') {
                        end[COLUMN] = pos;
                        if (callback(T_NL$1, token, begin, end, line)) {
                            return Done;
                        }
                        this.continued = true;
                    }
                    else {
                        if ('([{'.indexOf(initial) !== -1) {
                            this.parenlev += 1;
                        }
                        else if (')]}'.indexOf(initial) !== -1) {
                            this.parenlev -= 1;
                        }
                        if (callback(T_OP$1, token, begin, end, line)) {
                            return Done;
                        }
                    }
                }
                else {
                    begin[COLUMN] = pos;
                    end[COLUMN] = pos + 1;
                    if (callback(T_ERRORTOKEN, line.charAt(pos), begin, end, line)) {
                        return Done;
                    }
                    pos += 1;
                }
            }
            return false;
        }
    }
    function group(x, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
        const args = Array.prototype.slice.call(arguments);
        return '(' + args.join('|') + ')';
    }
    function maybe(x) { return group.apply(null, arguments) + "?"; }
    function contains(a, obj) {
        let i = a.length;
        while (i--) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    }
    function rstrip(input, what) {
        let i;
        for (i = input.length; i > 0; --i) {
            if (what.indexOf(input.charAt(i - 1)) === -1)
                break;
        }
        return input.substring(0, i);
    }
    /**
     * @param message
     * @param begin
     * @param end
     * @param {string|undefined} text
     */
    function indentationError(message, begin, end, text) {
        assert(Array.isArray(begin), "begin must be an Array");
        assert(Array.isArray(end), "end must be an Array");
        const e = new SyntaxError(message /*, fileName*/);
        e.name = "IndentationError";
        if (begin) {
            e['lineNumber'] = begin[LINE];
            e['columnNumber'] = begin[COLUMN];
        }
        return e;
    }

    class Position {
        /**
         *
         */
        constructor(line, column) {
            this.line = line;
            this.column = column;
        }
        /**
         * 0-based row number.
         */
        get row() {
            return this.line - 1;
        }
        toString() {
            return `[${this.line}, ${this.column}]`;
        }
    }

    /**
     * @param message
     * @param lineNumber
     */
    function syntaxError$1(message, range) {
        assert(isString(message), "message must be a string");
        if (isDef(range)) {
            assert(isNumber(range.begin.line), "lineNumber must be a number");
        }
        const e = new SyntaxError(message /*, fileName*/);
        if (range) {
            assert(isNumber(range.begin.line), "lineNumber must be a number");
            if (typeof range.begin.line === 'number') {
                e['lineNumber'] = range.begin.line;
            }
        }
        return e;
    }
    /*
    export interface Position {
        row: number;
        column: number;
    }
    */
    /**
     *
     */
    class ParseError extends SyntaxError {
        constructor(message) {
            super(message);
            this.name = 'ParseError';
        }
    }
    /**
     * Indicates that the parser could not transition from its current state to another state because of the token received.
     */
    class UnexpectedTokenError extends ParseError {
        /**
         * @param tokenName The name of the token.
         * @param begin The position of the beginning of the token.
         * @param end The position of the ending of the token.
         */
        constructor(tokenName, begin, end) {
            super(`Unexpected ${tokenName} at ${JSON.stringify([begin[0], begin[1] + 1])}`);
            this.tokenName = tokenName;
            this.name = 'UnexpectedTokenError';
            if (Array.isArray(begin)) {
                this.begin = new Position(begin[0], begin[1]);
            }
            if (Array.isArray(end)) {
                this.end = new Position(end[0], end[1]);
            }
        }
    }
    /**
     * @param message
     * @param begin
     * @param end
     */
    function parseError(message, begin, end) {
        const e = new ParseError(message);
        // Copying from begin and end is important because they change for each token.
        // Notice that the Line is 1-based, but that row is 0-based.
        // Both column and Column are 0-based.
        if (Array.isArray(begin)) {
            e.begin = new Position(begin[0], begin[1]);
        }
        if (Array.isArray(end)) {
            e.end = new Position(end[0], end[1]);
        }
        return e;
    }

    class Range {
        /**
         *
         */
        constructor(begin, end) {
            assert(begin, "begin must be defined");
            assert(end, "end must be defined");
            this.begin = begin;
            this.end = end;
        }
        toString() {
            return `${this.begin} to ${this.end}`;
        }
    }

    /**
     * Prepare the source text into lines to feed to the `generateTokens` method of the tokenizer.
     * The source text is split using the newline, '\n', character.
     * @param sourceText The source text.
     * @returns The source text split into lines with the newline character retained.
     */
    function splitSourceTextIntoLines(sourceText) {
        const lines = [];
        // Why do we normalize the sourceText in this manner?
        if (sourceText.substr(IDXLAST(sourceText), 1) !== "\n") {
            sourceText += "\n";
        }
        // Splitting this way will create a final line that is the zero-length string.
        const pieces = sourceText.split("\n");
        const N = pieces.length;
        for (let i = 0; i < N; ++i) {
            // We're adding back newline characters for all but the last line.
            const line = pieces[i] + ((i === IDXLAST(pieces)) ? "" : "\n");
            lines.push(line);
        }
        return lines;
    }

    // Dereference certain tokens for performance.
    const T_COMMENT = exports.Tokens.T_COMMENT;
    const T_ENDMARKER = exports.Tokens.T_ENDMARKER;
    const T_NAME = exports.Tokens.T_NAME;
    const T_NL = exports.Tokens.T_NL;
    const T_NT_OFFSET = exports.Tokens.T_NT_OFFSET;
    const T_OP = exports.Tokens.T_OP;
    // TODO: The parser does not report whitespace nodes.
    // It would be nice if there were an ignoreWhitespace option.
    /**
     * Low level parser to a concrete syntax tree, derived from cpython's lib2to3.
     */
    class Parser {
        /**
         *
         */
        constructor(grammar) {
            this.stack = [];
            this.used_names = {};
            this.grammar = grammar;
        }
        /**
         * Pushes an element onto the stack of the type specified in the start parameter.
         * @param start Usually ParseTables.sym.file_input or eval_input or single_input. Default is the grammar.start passed in the constructor.
         */
        setup(start) {
            start = start || this.grammar.start;
            const newnode = {
                type: start,
                range: null,
                value: null,
                children: []
            };
            const stackentry = {
                dfa: this.grammar.dfas[start][IDX_DFABT_DFA],
                beginTokens: this.grammar.dfas[start][IDX_DFABT_BEGIN_TOKENS],
                stateId: 0,
                node: newnode
            };
            this.stack.push(stackentry);
        }
        /**
         * Add a token; return true if we're done.
         * @param type
         * @param value
         * @param context [start, end, line]
         */
        addtoken(type, value, begin, end, line) {
            /**
             * The symbol for the token being added.
             */
            const tokenSymbol = this.classify(type, value, begin, end, line);
            /**
             * Local variable for performance.
             */
            const stack = this.stack;
            // More local variables for performance.
            const g = this.grammar;
            const dfas = g.dfas;
            const labels = g.labels;
            // This code is very performance sensitive.
            OUTERWHILE: while (true) {
                let stackTop = stack[stack.length - 1];
                let dfa = stackTop.dfa;
                // This is not being used. Why?
                // let first = tp.dfa[DFA_SECOND];
                const arcs = dfa[stackTop.stateId];
                // look for a to-state with this label
                for (const arc of arcs) {
                    const arcSymbol = arc[ARC_SYMBOL_LABEL];
                    const newState = arc[ARC_TO_STATE];
                    const t = labels[arcSymbol][0];
                    // const v = labels[arcSymbol][1];
                    // console.lg(`t => ${t}, v => ${v}`);
                    if (tokenSymbol === arcSymbol) {
                        this.shiftToken(type, value, newState, begin, end, line);
                        // pop while we are in an accept-only state
                        let stateId = newState;
                        /**
                         * Temporary variable to save a few CPU cycles.
                         */
                        let statesOfState = dfa[stateId];
                        while (statesOfState.length === 1 && statesOfState[0][ARC_SYMBOL_LABEL] === 0 && statesOfState[0][ARC_TO_STATE] === stateId) {
                            this.popNonTerminal();
                            // Much of the time we won't be done so cache the stack length.
                            const stackLength = stack.length;
                            if (stackLength === 0) {
                                // done!
                                return true;
                            }
                            else {
                                stackTop = stack[stackLength - 1];
                                stateId = stackTop.stateId;
                                dfa = stackTop.dfa;
                                // first = stackTop.beginTokens;
                                // first = top.dfa[1];
                                statesOfState = dfa[stateId];
                            }
                        }
                        // done with this token
                        return false;
                    }
                    else if (isNonTerminal(t)) {
                        const dfabt = dfas[t];
                        const dfa = dfabt[IDX_DFABT_DFA];
                        const beginTokens = dfabt[IDX_DFABT_BEGIN_TOKENS];
                        if (beginTokens.hasOwnProperty(tokenSymbol)) {
                            this.pushNonTerminal(t, dfa, beginTokens, newState, begin, end, line);
                            continue OUTERWHILE;
                        }
                    }
                }
                // We've exhaused all the arcs for the for the state.
                if (existsTransition(arcs, [T_ENDMARKER, stackTop.stateId])) {
                    // an accepting state, pop it and try something else
                    this.popNonTerminal();
                    if (stack.length === 0) {
                        throw parseError("too much input");
                    }
                }
                else {
                    const tokenName = grammarName(stackTop.stateId);
                    throw new UnexpectedTokenError(tokenName, begin, end);
                }
            }
        }
        /**
         * Turn a token into a symbol (something that labels an arc in the DFA).
         * The context is only used for error reporting.
         * @param type
         * @param value
         * @param context [begin, end, line]
         */
        classify(type, value, begin, end, line) {
            // Assertion commented out for efficiency.
            assertTerminal(type);
            const g = this.grammar;
            if (type === T_NAME) {
                this.used_names[value] = true;
                const keywordToSymbol = g.keywords;
                if (keywordToSymbol.hasOwnProperty(value)) {
                    const ilabel = keywordToSymbol[value];
                    // assert(typeof ilabel === 'number', "How can it not be?");
                    return ilabel;
                }
            }
            const tokenToSymbol = g.tokens;
            let ilabel;
            if (tokenToSymbol.hasOwnProperty(type)) {
                ilabel = tokenToSymbol[type];
            }
            if (!ilabel) {
                // console.lg(`ilabel = ${ilabel}, type = ${type}, value = ${value}, begin = ${JSON.stringify(begin)}, end = ${JSON.stringify(end)}`);
                throw parseError("bad token", begin, end);
            }
            return ilabel;
        }
        /**
         * Shifting a token (terminal).
         * 1. A new node is created representing the token.
         * 2. The new node is added as a child to the topmost node on the stack.
         * 3. The state of the topmost element on the stack is updated to be the new state.
         */
        shiftToken(type, value, newState, begin, end, line) {
            // assertTerminal(type);
            // Local variable for efficiency.
            const stack = this.stack;
            /**
             * The topmost element in the stack is affected by shifting a token.
             */
            const stackTop = stack[stack.length - 1];
            const node = stackTop.node;
            const newnode = {
                type: type,
                value: value,
                range: new Range(new Position(begin[0], begin[1]), new Position(end[0], end[1])),
                children: null
            };
            if (newnode && node.children) {
                node.children.push(newnode);
            }
            stackTop.stateId = newState;
        }
        /**
         * Push a non-terminal symbol onto the stack as a new node.
         * 1. Update the state of the topmost element on the stack to be newState.
         * 2. Push a new element onto the stack corresponding to the symbol.
         * The new stack elements uses the newDfa and has state 0.
         */
        pushNonTerminal(type, dfa, beginTokens, newState, begin, end, line) {
            // Based on how this function is called, there is really no need for this assertion.
            // Retain it for now while it is not the performance bottleneck.
            // assertNonTerminal(type);
            // Local variable for efficiency.
            const stack = this.stack;
            const stackTop = stack[stack.length - 1];
            stackTop.stateId = newState;
            const beginPos = begin ? new Position(begin[0], begin[1]) : null;
            const endPos = end ? new Position(end[0], end[1]) : null;
            const newnode = { type, value: null, range: new Range(beginPos, endPos), children: [] };
            // TODO: Is there a symbolic constant for the zero state?
            stack.push({ dfa, beginTokens, stateId: 0, node: newnode });
        }
        /**
         * Pop a nonterminal.
         * Popping an element from the stack causes the node to be added to the children of the new top element.
         * The exception is when the stack becomes empty, in which case the node becomes the root node.
         */
        popNonTerminal() {
            // Local variable for efficiency.
            const stack = this.stack;
            const poppedElement = stack.pop();
            if (poppedElement) {
                const poppedNode = poppedElement.node;
                // Remove this assertion only when it becomes a performance issue.
                // assertNonTerminal(poppedNode.type);
                if (poppedNode) {
                    /**
                     * The length of the stack following the pop operation.
                     */
                    const N = stack.length;
                    if (N !== 0) {
                        const node = stack[N - 1].node;
                        const children = node.children;
                        if (children) {
                            children.push(poppedNode);
                        }
                    }
                    else {
                        // If the length of the stack following the pop is zero then the popped element becomes the root node.
                        this.rootNode = poppedNode;
                        poppedNode.used_names = this.used_names;
                    }
                }
            }
        }
    }
    /**
     * FIXME: This is O(N). Can we do better?
     * Finds the specified
     * @param a An array of arrays where each element is an array of two integers.
     * @param obj An array containing two integers.
     */
    function existsTransition(arcs, obj) {
        let i = arcs.length;
        while (i--) {
            const arc = arcs[i];
            if (arc[ARC_SYMBOL_LABEL] === obj[ARC_SYMBOL_LABEL] && arc[ARC_TO_STATE] === obj[ARC_TO_STATE]) {
                return true;
            }
        }
        return false;
    }
    /**
     * Constructs a Parser for interactive input.
     * Returns a function that should be called with a single line as input as they are entered.
     * The function will return false until the input is complete, when it will return the rootnode of the parse.
     *
     * @param style root of parse tree (optional)
     */
    function makeParser(sourceKind) {
        if (sourceKind === undefined)
            sourceKind = exports.SourceKind.File;
        const p = new Parser(ParseTables);
        // TODO: Can we do this over the symbolic constants?
        switch (sourceKind) {
            case exports.SourceKind.File: {
                p.setup(ParseTables.sym.file_input);
                break;
            }
            case exports.SourceKind.Eval: {
                p.setup(ParseTables.sym.eval_input);
                break;
            }
            case exports.SourceKind.Single: {
                p.setup(ParseTables.sym.single_input);
                break;
            }
            default: {
                throw new Error("SourceKind must be one of File, Eval, or Single.");
            }
        }
        // let prefix = "";
        const tokenizer = new Tokenizer(sourceKind === exports.SourceKind.Single, function tokenizerCallback(type, value, start, end, line) {
            start[0];
            start[1];
            if (type === T_COMMENT || type === T_NL) {
                // prefix += value;
                end[0];
                end[1];
                if (value[value.length - 1] === "\n") ;
                return undefined;
            }
            if (type === T_OP) {
                type = OpMap[value];
            }
            // FIXME: We're creating an array object here for every token.
            if (p.addtoken(type, value, start, end, line)) {
                return true;
            }
            return undefined;
        });
        return function (line) {
            const ret = tokenizer.generateTokens(line);
            if (ret) {
                if (ret !== "done") {
                    throw parseError("incomplete input");
                }
                return p.rootNode;
            }
            return false;
        };
    }
    /**
     * Determines the starting point in the grammar for parsing the source.
     */
    exports.SourceKind = void 0;
    (function (SourceKind) {
        /**
         * Suitable for a module.
         */
        SourceKind[SourceKind["File"] = 0] = "File";
        /**
         * Suitable for execution.
         */
        SourceKind[SourceKind["Eval"] = 1] = "Eval";
        /**
         * Suitable for a REPL.
         */
        SourceKind[SourceKind["Single"] = 2] = "Single";
    })(exports.SourceKind || (exports.SourceKind = {}));
    /**
     * Parses the sourceText into a Concrete Syntax Tree (the Parse Tree representation).
     * @param sourceText The source text
     * @param sourceKind The source kind (Default is File).
     * @returns
     */
    function parse(sourceText, sourceKind = exports.SourceKind.File) {
        const parser = makeParser(sourceKind);
        const lines = splitSourceTextIntoLines(sourceText);
        // FIXME: Mixing the types this way is awkward for the consumer.
        let ret = false;
        for (const line of lines) {
            ret = parser(line);
        }
        return ret;
    }
    /**
     * Concrete Syntax Tree
     */
    function cstDump(parseTree) {
        function parseTreeDump(n, indent) {
            let ret = "";
            if (isNonTerminal(n.type)) {
                ret += indent + ParseTables.number2symbol[n.type] + "\n";
                if (n.children) {
                    for (let i = 0; i < n.children.length; ++i) {
                        ret += parseTreeDump(n.children[i], "  " + indent);
                    }
                }
            }
            else {
                ret += indent + tokenNames[n.type] + ": " + n.value + "\n";
            }
            return ret;
        }
        return parseTreeDump(parseTree, "");
    }
    /**
     * Terminal symbols hsould be less than T_NT_OFFSET.
     * NT_OFFSET means non-terminal offset.
     */
    function assertTerminal(type) {
        assert(type < T_NT_OFFSET, "terminal symbols should be less than T_NT_OFFSET");
    }
    /*
    function assertNonTerminal(type: number): void {
        assert(isNonTerminal(type), "non terminal symbols should be greater than or equal to T_NT_OFFSET");
    }
    */
    function isNonTerminal(type) {
        return type >= T_NT_OFFSET;
    }

    /**
     * @param s
     */
    function floatAST(s) {
        const thing = {
            text: s,
            value: parseFloat(s),
            isFloat: function () { return true; },
            isInt: function () { return false; },
            isLong: function () { return false; },
            toString: function () { return s; }
        };
        return thing;
    }
    /**
     * @param n
     */
    function intAST(n) {
        const thing = {
            value: n,
            isFloat: function () { return false; },
            isInt: function () { return true; },
            isLong: function () { return false; },
            toString: function () { return '' + n; }
        };
        return thing;
    }
    /**
     * @param {string} s
     */
    function longAST(s, radix) {
        const thing = {
            text: s,
            radix: radix,
            isFloat: function () { return false; },
            isInt: function () { return false; },
            isLong: function () { return true; },
            toString: function () { return s; }
        };
        return thing;
    }

    class Load {
    }
    class Store {
    }
    class Del {
    }
    class AugLoad {
    }
    class AugStore {
    }
    class Param {
    }
    /**
     * Logical AND (&&)
     */
    class And {
    }
    /**
     * Logical OR (||)
     */
    class Or {
    }
    /**
     * Addition (+)
     */
    class Add {
    }
    /**
     * Subtraction (-)
     */
    class Sub {
    }
    /**
     * Multiplication (*)
     */
    class Mult {
    }
    /**
     * Division (/)
     */
    class Div {
    }
    /**
     * Remainder (%)
     */
    class Mod {
    }
    /**
     * Exponentiation '**'
     */
    class Pow {
    }
    /**
     * Bitwise Left Shift (<<)
     */
    class LShift {
    }
    /**
     * Bitwise Right Shift (>>)
     */
    class RShift {
    }
    /**
     * Bitwise OR (|)
     */
    class BitOr {
    }
    /**
     * Bitwise XOR (^)
     */
    class BitXor {
    }
    /**
     * Bitwise AND (&)
     */
    class BitAnd {
    }
    /**
     * (//)
     */
    class FloorDiv {
    }
    /**
     * Bitwise NOT (~)
     */
    class Invert {
    }
    /**
     * Logical NOT (not)
     */
    class Not {
    }
    /**
     * Unary Plus (+)
     */
    class UAdd {
    }
    /**
     * Unary Minus (-)
     */
    class USub {
    }
    class Eq {
    }
    class NotEq {
    }
    class Lt {
    }
    class LtE {
    }
    class Gt {
    }
    class GtE {
    }
    class Is {
    }
    class IsNot {
    }
    class In {
    }
    class NotIn {
    }
    class RangeAnnotated {
        constructor(value, range) {
            this.value = value;
            this.range = range;
            assert(typeof value !== 'undefined', "value must be defined.");
        }
    }
    class Expression {
        constructor() {
            // Do noting yet.
        }
        accept(visitor) {
            // accept must be implemented by derived classes.
            throw new Error(`"Expression.accept" is not implemented. this=${JSON.stringify(this, null, 2)}`);
        }
    }
    class Statement {
        accept(visitor) {
            // accept must be implemented by derived classes.
            throw new Error(`"Statement.accept" is not implemented.`);
        }
    }
    class IterationStatement extends Statement {
    }
    class Module {
        constructor(body) {
            this.body = body;
        }
        accept(visitor) {
            visitor.module(this);
        }
    }
    class Interactive {
        constructor(body) {
            this.body = body;
        }
    }
    class UnaryExpression extends Expression {
    }
    class Suite {
        constructor(body) {
            this.body = body;
        }
    }
    class FunctionDef extends Statement {
        constructor(name, args, body, returnType, decorator_list, range) {
            super();
            this.range = range;
            this.name = name;
            this.args = args;
            this.body = body;
            this.decorator_list = decorator_list;
            this.returnType = returnType;
        }
        accept(visitor) {
            visitor.functionDef(this);
        }
    }
    class FunctionParamDef {
        constructor(name, type) {
            this.name = name;
            if (type) {
                this.type = type;
            }
            else {
                this.type = null;
            }
        }
    }
    class ClassDef extends Statement {
        constructor(name, bases, body, decorator_list, range) {
            super();
            this.range = range;
            this.name = name;
            this.bases = bases;
            this.body = body;
            this.decorator_list = decorator_list;
        }
        accept(visitor) {
            visitor.classDef(this);
        }
    }
    class ReturnStatement extends Statement {
        constructor(value, range) {
            super();
            this.range = range;
            this.value = value;
        }
        accept(visitor) {
            visitor.returnStatement(this);
        }
    }
    class DeleteStatement extends Statement {
        constructor(targets, range) {
            super();
            this.range = range;
            this.targets = targets;
        }
    }
    class Assign extends Statement {
        constructor(targets, value, range, eqRange, type) {
            super();
            this.range = range;
            this.eqRange = eqRange;
            this.targets = targets;
            this.value = value;
            if (type) {
                this.type = type;
            }
        }
        accept(visitor) {
            visitor.assign(this);
        }
    }
    class AugAssign extends Statement {
        constructor(target, op, value, range) {
            super();
            this.range = range;
            this.target = target;
            this.op = op;
            this.value = value;
        }
    }
    class AnnAssign extends Statement {
        constructor(type, target, range) {
            super();
            this.range = range;
            this.value = type;
            this.target = target;
        }
        accept(visitor) {
            visitor.annAssign(this);
        }
    }
    class Print extends Statement {
        constructor(dest, values, nl, range) {
            super();
            this.range = range;
            this.dest = dest;
            this.values = values;
            this.nl = nl;
        }
        accept(visitor) {
            visitor.print(this);
        }
    }
    class ForStatement extends Statement {
        constructor(target, iter, body, orelse, range) {
            super();
            this.range = range;
            this.target = target;
            this.iter = iter;
            this.body = body;
            this.orelse = orelse;
        }
        accept(visitor) {
            visitor.forStatement(this);
        }
    }
    class WhileStatement extends IterationStatement {
        constructor(test, body, orelse, range) {
            super();
            this.range = range;
            this.test = test;
            this.body = body;
            this.orelse = orelse;
        }
    }
    class IfStatement extends Statement {
        constructor(test, consequent, alternate, range) {
            super();
            this.range = range;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
        }
        accept(visitor) {
            visitor.ifStatement(this);
        }
    }
    class WithStatement extends Statement {
        constructor(context_expr, optional_vars, body, range) {
            super();
            this.range = range;
            this.context_expr = context_expr;
            this.optional_vars = optional_vars;
            this.body = body;
        }
    }
    class Raise extends Statement {
        constructor(type, inst, tback, range) {
            super();
            this.range = range;
            this.type = type;
            this.inst = inst;
            this.tback = tback;
        }
    }
    class TryExcept extends Statement {
        constructor(body, handlers, orelse, range) {
            super();
            this.range = range;
            this.body = body;
            this.handlers = handlers;
            this.orelse = orelse;
        }
    }
    class TryFinally extends Statement {
        constructor(body, finalbody, range) {
            super();
            this.range = range;
            this.body = body;
            this.finalbody = finalbody;
        }
    }
    class Assert extends Statement {
        constructor(test, msg, range) {
            super();
            this.range = range;
            this.test = test;
            this.msg = msg;
        }
    }
    class ImportStatement extends Statement {
        constructor(names, range) {
            super();
            this.range = range;
            this.names = names;
        }
    }
    class ImportFrom extends Statement {
        constructor(module, names, level, range) {
            super();
            this.range = range;
            assert(typeof module.value === 'string', "module must be a string.");
            assert(Array.isArray(names), "names must be an Array.");
            this.module = module;
            this.names = names;
            this.level = level;
        }
        accept(visitor) {
            visitor.importFrom(this);
        }
    }
    class Exec extends Statement {
        constructor(body, globals, locals, range) {
            super();
            this.range = range;
            this.body = body;
            this.globals = globals;
            this.locals = locals;
        }
    }
    class Global extends Statement {
        constructor(names, range) {
            super();
            this.range = range;
            this.names = names;
        }
    }
    class NonLocal extends Statement {
        constructor(names, range) {
            super();
            this.range = range;
            this.names = names;
        }
    }
    class ExpressionStatement extends Statement {
        constructor(value, range) {
            super();
            this.range = range;
            this.value = value;
        }
        accept(visitor) {
            visitor.expressionStatement(this);
        }
    }
    class Pass extends Statement {
        constructor(range) {
            super();
            this.range = range;
        }
    }
    class BreakStatement extends Statement {
        constructor(range) {
            super();
            this.range = range;
        }
    }
    class ContinueStatement extends Statement {
        constructor(range) {
            super();
            this.range = range;
        }
    }
    class BoolOp extends Expression {
        constructor(op, values, range) {
            super();
            this.range = range;
            this.op = op;
            this.values = values;
        }
    }
    class BinOp extends Expression {
        constructor(lhs, ops, rhs, range) {
            super();
            this.range = range;
            this.lhs = lhs;
            this.op = ops.op;
            this.opRange = ops.range;
            this.rhs = rhs;
        }
        accept(visitor) {
            visitor.binOp(this);
        }
    }
    class UnaryOp extends Expression {
        constructor(op, operand, range) {
            super();
            this.op = op;
            this.operand = operand;
            this.range = range;
            assert(op === UAdd || op === USub || op === Invert || op === Not, "op must be defined.");
            assert(!!operand, "operand must be defined");
        }
        accept(visitor) {
            visitor.unaryOp(this);
        }
    }
    class Lambda extends Expression {
        constructor(args, body, range) {
            super();
            this.range = range;
            this.args = args;
            this.body = body;
        }
    }
    class IfExp extends Expression {
        constructor(test, body, orelse, range) {
            super();
            this.range = range;
            this.test = test;
            this.body = body;
            this.orelse = orelse;
        }
    }
    class Dict extends Expression {
        constructor(keys, values, range) {
            super();
            this.range = range;
            this.keys = keys;
            this.values = values;
        }
        accept(visitor) {
            visitor.dict(this);
        }
    }
    class ListComp extends Expression {
        constructor(elt, generators, range) {
            super();
            this.range = range;
            this.elt = elt;
            this.generators = generators;
        }
    }
    class GeneratorExp extends Expression {
        constructor(elt, generators, range) {
            super();
            this.range = range;
            this.elt = elt;
            this.generators = generators;
        }
    }
    class Yield extends Expression {
        constructor(value, range) {
            super();
            this.range = range;
            this.value = value;
        }
    }
    class Compare extends Expression {
        constructor(left, ops, comparators, range) {
            super();
            this.range = range;
            this.left = left;
            for (const op of ops) {
                switch (op) {
                    case Eq: {
                        break;
                    }
                    case NotEq: {
                        break;
                    }
                    case Gt: {
                        break;
                    }
                    case GtE: {
                        break;
                    }
                    case Lt: {
                        break;
                    }
                    case LtE: {
                        break;
                    }
                    case In: {
                        break;
                    }
                    case NotIn: {
                        break;
                    }
                    case Is: {
                        break;
                    }
                    case IsNot: {
                        break;
                    }
                    default: {
                        throw new Error(`ops must only contain CompareOperator(s) but contains ${op}`);
                    }
                }
            }
            this.ops = ops;
            this.comparators = comparators;
        }
        accept(visitor) {
            visitor.compareExpression(this);
        }
    }
    class Call extends Expression {
        constructor(func, args, keywords, starargs, kwargs) {
            super();
            this.func = func;
            this.args = args;
            this.keywords = keywords;
            this.starargs = starargs;
            this.kwargs = kwargs;
        }
        accept(visitor) {
            visitor.callExpression(this);
        }
    }
    class Num extends Expression {
        constructor(n) {
            super();
            this.n = n;
        }
        accept(visitor) {
            visitor.num(this);
        }
    }
    class Str extends Expression {
        constructor(s) {
            super();
            this.s = s;
        }
        accept(visitor) {
            visitor.str(this);
        }
    }
    class Attribute extends Expression {
        constructor(value, attr, ctx, range) {
            super();
            this.range = range;
            this.value = value;
            this.attr = attr;
            this.ctx = ctx;
        }
        accept(visitor) {
            visitor.attribute(this);
        }
    }
    class Subscript extends Expression {
        constructor(value, slice, ctx, range) {
            super();
            this.range = range;
            this.value = value;
            this.slice = slice;
            this.ctx = ctx;
        }
        accept(visitor) {
            visitor.subscript(this);
        }
    }
    class Name extends Expression {
        constructor(id, ctx) {
            super();
            this.id = id;
            this.ctx = ctx;
        }
        accept(visitor) {
            visitor.name(this);
        }
    }
    class List extends Expression {
        constructor(elts, ctx, range) {
            super();
            this.range = range;
            this.elts = elts;
            this.ctx = ctx;
        }
        accept(visitor) {
            visitor.list(this);
        }
    }
    class Tuple extends Expression {
        constructor(elts, ctx, range) {
            super();
            this.range = range;
            this.elts = elts;
            this.ctx = ctx;
        }
    }
    class Ellipsis {
        constructor() {
            // Do nothing yet.
        }
    }
    class Slice {
        constructor(lower, upper, step) {
            this.lower = lower;
            this.upper = upper;
            this.step = step;
        }
    }
    class ExtSlice {
        constructor(dims) {
            this.dims = dims;
        }
    }
    class Index {
        constructor(value) {
            this.value = value;
        }
    }
    class Comprehension {
        constructor(target, iter, ifs, range) {
            this.range = range;
            this.target = target;
            this.iter = iter;
            this.ifs = ifs;
        }
    }
    class ExceptHandler {
        constructor(type, name, body, range) {
            this.range = range;
            this.type = type;
            this.name = name;
            this.body = body;
        }
    }
    class Arguments {
        constructor(args, vararg, kwarg, defaults) {
            this.args = args;
            this.vararg = vararg;
            this.kwarg = kwarg;
            this.defaults = defaults;
        }
    }
    class Keyword {
        constructor(arg, value) {
            this.arg = arg;
            this.value = value;
        }
    }
    class Alias {
        constructor(name, asname) {
            assert(typeof name.value === 'string');
            assert(typeof asname === 'string' || asname === null);
            this.name = name;
            this.asname = asname;
        }
        toString() {
            return `${this.name.value} as ${this.asname}`;
        }
    }
    Module.prototype['_astname'] = 'Module';
    Module.prototype['_fields'] = [
        'body', function (n) { return n.body; }
    ];
    Interactive.prototype['_astname'] = 'Interactive';
    Interactive.prototype['_fields'] = [
        'body', function (n) { return n.body; }
    ];
    Expression.prototype['_astname'] = 'Expression';
    Expression.prototype['_fields'] = [
        'body', function (n) {
            // TOD: Expression is abstract so we should not be here?
            return void 0;
        }
    ];
    Suite.prototype['_astname'] = 'Suite';
    Suite.prototype['_fields'] = [
        'body', function (n) { return n.body; }
    ];
    FunctionDef.prototype['_astname'] = 'FunctionDef';
    FunctionDef.prototype['_fields'] = [
        'name', function (n) { return n.name.value; },
        'args', function (n) { return n.args; },
        'body', function (n) { return n.body; },
        'returnType', function (n) { return n.returnType; },
        'decorator_list', function (n) { return n.decorator_list; }
    ];
    ClassDef.prototype['_astname'] = 'ClassDef';
    ClassDef.prototype['_fields'] = [
        'name', function (n) { return n.name.value; },
        'bases', function (n) { return n.bases; },
        'body', function (n) { return n.body; },
        'decorator_list', function (n) { return n.decorator_list; }
    ];
    ReturnStatement.prototype['_astname'] = 'ReturnStatement';
    ReturnStatement.prototype['_fields'] = [
        'value', function (n) { return n.value; }
    ];
    DeleteStatement.prototype['_astname'] = 'DeleteStatement';
    DeleteStatement.prototype['_fields'] = [
        'targets', function (n) { return n.targets; }
    ];
    Assign.prototype['_astname'] = 'Assign';
    Assign.prototype['_fields'] = [
        'targets', function (n) { return n.targets; },
        'value', function (n) { return n.value; }
    ];
    AugAssign.prototype['_astname'] = 'AugAssign';
    AugAssign.prototype['_fields'] = [
        'target', function (n) { return n.target; },
        'op', function (n) { return n.op; },
        'value', function (n) { return n.value; }
    ];
    AnnAssign.prototype['_astname'] = 'AnnAssign';
    AnnAssign.prototype['_fields'] = [
        'target', function (n) { return n.target; },
        'type', function (n) { return n.value; }
    ];
    Print.prototype['_astname'] = 'Print';
    Print.prototype['_fields'] = [
        'dest', function (n) { return n.dest; },
        'values', function (n) { return n.values; },
        'nl', function (n) { return n.nl; }
    ];
    ForStatement.prototype['_astname'] = 'ForStatement';
    ForStatement.prototype['_fields'] = [
        'target', function (n) { return n.target; },
        'iter', function (n) { return n.iter; },
        'body', function (n) { return n.body; },
        'orelse', function (n) { return n.orelse; }
    ];
    WhileStatement.prototype['_astname'] = 'WhileStatement';
    WhileStatement.prototype['_fields'] = [
        'test', function (n) { return n.test; },
        'body', function (n) { return n.body; },
        'orelse', function (n) { return n.orelse; }
    ];
    IfStatement.prototype['_astname'] = 'IfStatement';
    IfStatement.prototype['_fields'] = [
        'test', function (n) { return n.test; },
        'consequent', function (n) { return n.consequent; },
        'alternate', function (n) { return n.alternate; }
    ];
    WithStatement.prototype['_astname'] = 'WithStatement';
    WithStatement.prototype['_fields'] = [
        'context_expr', function (n) { return n.context_expr; },
        'optional_vars', function (n) { return n.optional_vars; },
        'body', function (n) { return n.body; }
    ];
    Raise.prototype['_astname'] = 'Raise';
    Raise.prototype['_fields'] = [
        'type', function (n) { return n.type; },
        'inst', function (n) { return n.inst; },
        'tback', function (n) { return n.tback; }
    ];
    TryExcept.prototype['_astname'] = 'TryExcept';
    TryExcept.prototype['_fields'] = [
        'body', function (n) { return n.body; },
        'handlers', function (n) { return n.handlers; },
        'orelse', function (n) { return n.orelse; }
    ];
    TryFinally.prototype['_astname'] = 'TryFinally';
    TryFinally.prototype['_fields'] = [
        'body', function (n) { return n.body; },
        'finalbody', function (n) { return n.finalbody; }
    ];
    Assert.prototype['_astname'] = 'Assert';
    Assert.prototype['_fields'] = [
        'test', function (n) { return n.test; },
        'msg', function (n) { return n.msg; }
    ];
    ImportStatement.prototype['_astname'] = 'Import';
    ImportStatement.prototype['_fields'] = [
        'names', function (n) { return n.names; }
    ];
    ImportFrom.prototype['_astname'] = 'ImportFrom';
    ImportFrom.prototype['_fields'] = [
        'module', function (n) { return n.module.value; },
        'names', function (n) { return n.names; },
        'level', function (n) { return n.level; }
    ];
    Exec.prototype['_astname'] = 'Exec';
    Exec.prototype['_fields'] = [
        'body', function (n) { return n.body; },
        'globals', function (n) { return n.globals; },
        'locals', function (n) { return n.locals; }
    ];
    Global.prototype['_astname'] = 'Global';
    Global.prototype['_fields'] = [
        'names', function (n) { return n.names; }
    ];
    NonLocal.prototype['_astname'] = 'NonLocal';
    NonLocal.prototype['_fields'] = [
        'names', function (n) { return n.names; }
    ];
    ExpressionStatement.prototype['_astname'] = 'ExpressionStatement';
    ExpressionStatement.prototype['_fields'] = [
        'value', function (n) { return n.value; }
    ];
    Pass.prototype['_astname'] = 'Pass';
    Pass.prototype['_fields'] = [];
    BreakStatement.prototype['_astname'] = 'BreakStatement';
    BreakStatement.prototype['_fields'] = [];
    ContinueStatement.prototype['_astname'] = 'ContinueStatement';
    ContinueStatement.prototype['_fields'] = [];
    BoolOp.prototype['_astname'] = 'BoolOp';
    BoolOp.prototype['_fields'] = [
        'op', function (n) { return n.op; },
        'values', function (n) { return n.values; }
    ];
    BinOp.prototype['_astname'] = 'BinOp';
    BinOp.prototype['_fields'] = [
        'lhs', function (n) { return n.lhs; },
        'op', function (n) { return n.op; },
        'rhs', function (n) { return n.rhs; }
    ];
    UnaryOp.prototype['_astname'] = 'UnaryOp';
    UnaryOp.prototype['_fields'] = [
        'op', function (n) { return n.op; },
        'operand', function (n) { return n.operand; }
    ];
    Lambda.prototype['_astname'] = 'Lambda';
    Lambda.prototype['_fields'] = [
        'args', function (n) { return n.args; },
        'body', function (n) { return n.body; }
    ];
    IfExp.prototype['_astname'] = 'IfExp';
    IfExp.prototype['_fields'] = [
        'test', function (n) { return n.test; },
        'body', function (n) { return n.body; },
        'orelse', function (n) { return n.orelse; }
    ];
    Dict.prototype['_astname'] = 'Dict';
    Dict.prototype['_fields'] = [
        'keys', function (n) { return n.keys; },
        'values', function (n) { return n.values; }
    ];
    ListComp.prototype['_astname'] = 'ListComp';
    ListComp.prototype['_fields'] = [
        'elt', function (n) { return n.elt; },
        'generators', function (n) { return n.generators; }
    ];
    GeneratorExp.prototype['_astname'] = 'GeneratorExp';
    GeneratorExp.prototype['_fields'] = [
        'elt', function (n) { return n.elt; },
        'generators', function (n) { return n.generators; }
    ];
    Yield.prototype['_astname'] = 'Yield';
    Yield.prototype['_fields'] = [
        'value', function (n) { return n.value; }
    ];
    Compare.prototype['_astname'] = 'Compare';
    Compare.prototype['_fields'] = [
        'left', function (n) { return n.left; },
        'ops', function (n) { return n.ops; },
        'comparators', function (n) { return n.comparators; }
    ];
    Call.prototype['_astname'] = 'Call';
    Call.prototype['_fields'] = [
        'func', function (n) { return n.func; },
        'args', function (n) { return n.args; },
        'keywords', function (n) { return n.keywords; },
        'starargs', function (n) { return n.starargs; },
        'kwargs', function (n) { return n.kwargs; }
    ];
    Num.prototype['_astname'] = 'Num';
    Num.prototype['_fields'] = [
        'n', function (n) { return n.n.value; }
    ];
    Str.prototype['_astname'] = 'Str';
    Str.prototype['_fields'] = [
        's', function (n) { return n.s.value; }
    ];
    Attribute.prototype['_astname'] = 'Attribute';
    Attribute.prototype['_fields'] = [
        'value', function (n) { return n.value; },
        'attr', function (n) { return n.attr.value; },
        'ctx', function (n) { return n.ctx; }
    ];
    Subscript.prototype['_astname'] = 'Subscript';
    Subscript.prototype['_fields'] = [
        'value', function (n) { return n.value; },
        'slice', function (n) { return n.slice; },
        'ctx', function (n) { return n.ctx; }
    ];
    Name.prototype['_astname'] = 'Name';
    Name.prototype['_fields'] = [
        'id', function (n) { return n.id.value; },
        'ctx', function (n) { return n.ctx; }
    ];
    List.prototype['_astname'] = 'List';
    List.prototype['_fields'] = [
        'elts', function (n) { return n.elts; },
        'ctx', function (n) { return n.ctx; }
    ];
    Tuple.prototype['_astname'] = 'Tuple';
    Tuple.prototype['_fields'] = [
        'elts', function (n) { return n.elts; },
        'ctx', function (n) { return n.ctx; }
    ];
    Load.prototype['_astname'] = 'Load';
    Load.prototype['_isenum'] = true;
    Store.prototype['_astname'] = 'Store';
    Store.prototype['_isenum'] = true;
    Del.prototype['_astname'] = 'Del';
    Del.prototype['_isenum'] = true;
    AugLoad.prototype['_astname'] = 'AugLoad';
    AugLoad.prototype['_isenum'] = true;
    AugStore.prototype['_astname'] = 'AugStore';
    AugStore.prototype['_isenum'] = true;
    Param.prototype['_astname'] = 'Param';
    Param.prototype['_isenum'] = true;
    Ellipsis.prototype['_astname'] = 'Ellipsis';
    Ellipsis.prototype['_fields'] = [];
    Slice.prototype['_astname'] = 'Slice';
    Slice.prototype['_fields'] = [
        'lower', function (n) { return n.lower; },
        'upper', function (n) { return n.upper; },
        'step', function (n) { return n.step; }
    ];
    ExtSlice.prototype['_astname'] = 'ExtSlice';
    ExtSlice.prototype['_fields'] = [
        'dims', function (n) { return n.dims; }
    ];
    Index.prototype['_astname'] = 'Index';
    Index.prototype['_fields'] = [
        'value', function (n) { return n.value; }
    ];
    And.prototype['_astname'] = 'And';
    And.prototype['_isenum'] = true;
    Or.prototype['_astname'] = 'Or';
    Or.prototype['_isenum'] = true;
    Add.prototype['_astname'] = 'Add';
    Add.prototype['_isenum'] = true;
    Sub.prototype['_astname'] = 'Sub';
    Sub.prototype['_isenum'] = true;
    Mult.prototype['_astname'] = 'Mult';
    Mult.prototype['_isenum'] = true;
    Div.prototype['_astname'] = 'Div';
    Div.prototype['_isenum'] = true;
    Mod.prototype['_astname'] = 'Mod';
    Mod.prototype['_isenum'] = true;
    Pow.prototype['_astname'] = 'Pow';
    Pow.prototype['_isenum'] = true;
    LShift.prototype['_astname'] = 'LShift';
    LShift.prototype['_isenum'] = true;
    RShift.prototype['_astname'] = 'RShift';
    RShift.prototype['_isenum'] = true;
    BitOr.prototype['_astname'] = 'BitOr';
    BitOr.prototype['_isenum'] = true;
    BitXor.prototype['_astname'] = 'BitXor';
    BitXor.prototype['_isenum'] = true;
    BitAnd.prototype['_astname'] = 'BitAnd';
    BitAnd.prototype['_isenum'] = true;
    FloorDiv.prototype['_astname'] = 'FloorDiv';
    FloorDiv.prototype['_isenum'] = true;
    Invert.prototype['_astname'] = 'Invert';
    Invert.prototype['_isenum'] = true;
    Not.prototype['_astname'] = 'Not';
    Not.prototype['_isenum'] = true;
    UAdd.prototype['_astname'] = 'UAdd';
    UAdd.prototype['_isenum'] = true;
    USub.prototype['_astname'] = 'USub';
    USub.prototype['_isenum'] = true;
    Eq.prototype['_astname'] = 'Eq';
    Eq.prototype['_isenum'] = true;
    NotEq.prototype['_astname'] = 'NotEq';
    NotEq.prototype['_isenum'] = true;
    Lt.prototype['_astname'] = 'Lt';
    Lt.prototype['_isenum'] = true;
    LtE.prototype['_astname'] = 'LtE';
    LtE.prototype['_isenum'] = true;
    Gt.prototype['_astname'] = 'Gt';
    Gt.prototype['_isenum'] = true;
    GtE.prototype['_astname'] = 'GtE';
    GtE.prototype['_isenum'] = true;
    Is.prototype['_astname'] = 'Is';
    Is.prototype['_isenum'] = true;
    IsNot.prototype['_astname'] = 'IsNot';
    IsNot.prototype['_isenum'] = true;
    In.prototype['_astname'] = 'In';
    In.prototype['_isenum'] = true;
    NotIn.prototype['_astname'] = 'NotIn';
    NotIn.prototype['_isenum'] = true;
    Comprehension.prototype['_astname'] = 'Comprehension';
    Comprehension.prototype['_fields'] = [
        'target', function (n) { return n.target; },
        'iter', function (n) { return n.iter; },
        'ifs', function (n) { return n.ifs; }
    ];
    ExceptHandler.prototype['_astname'] = 'ExceptHandler';
    ExceptHandler.prototype['_fields'] = [
        'type', function (n) { return n.type; },
        'name', function (n) { return n.name; },
        'body', function (n) { return n.body; }
    ];
    Arguments.prototype['_astname'] = 'Arguments';
    Arguments.prototype['_fields'] = [
        'args', function (n) { return n.args; },
        'vararg', function (n) { return n.vararg; },
        'kwarg', function (n) { return n.kwarg; },
        'defaults', function (n) { return n.defaults; }
    ];
    Keyword.prototype['_astname'] = 'Keyword';
    Keyword.prototype['_fields'] = [
        'arg', function (n) { return n.arg.value; },
        'value', function (n) { return n.value; }
    ];
    FunctionParamDef.prototype['_astname'] = 'FunctionParamDef';
    FunctionParamDef.prototype['_fields'] = [
        'name', function (n) { return n.name; },
        'type', function (n) { return n.type; }
    ];
    Alias.prototype['_astname'] = 'Alias';
    Alias.prototype['_fields'] = [
        'name', function (n) { return n.name.value; },
        'asname', function (n) { return n.asname; }
    ];

    //
    // This is pretty much a straight port of ast.c from CPython 2.6.5.
    //
    // The previous version was easier to work with and more JS-ish, but having a
    // somewhat different ast structure than cpython makes testing more difficult.
    //
    // This way, we can use a dump from the ast module on any arbitrary python
    // code and know that we're the same up to ast level, at least.
    //
    const SYM = ParseTables.sym;
    /**
     *
     */
    const LONG_THRESHOLD = Math.pow(2, 53);
    /**
     * FIXME: Consolidate with parseError in parser.
     */
    function syntaxError(message, range) {
        assert(isString(message), "message must be a string");
        assert(isNumber(range.begin.line), "lineNumber must be a number");
        const e = new SyntaxError(message /*, fileName*/);
        e['lineNumber'] = range.begin.line;
        return e;
    }
    class Compiling {
        constructor(encoding) {
            this.c_encoding = encoding;
        }
    }
    /**
     * Asserts that the type of the node is that specified.
     */
    function REQ(n, type) {
        // Avoid the cost of building the message string when there is no issue.
        if (n.type !== type) {
            fail(`node must have type ${type} = ${grammarName(type)}, but was ${n.type} = ${grammarName(n.type)}.`);
        }
    }
    /**
     * Nothing more than assertion that the argument is a string.
     */
    function strobj(s) {
        // Avoid the cost of building the message string when there is no issue.
        if (typeof s !== 'string') {
            fail("expecting string, got " + (typeof s));
        }
        // This previously constructed the runtime representation.
        // That may have had an string intern side effect?
        return s;
    }
    function numStmts(n) {
        switch (n.type) {
            case SYM.single_input:
                if (CHILD(n, 0).type === exports.Tokens.T_NEWLINE)
                    return 0;
                else
                    return numStmts(CHILD(n, 0));
            case SYM.file_input:
                let cnt = 0;
                for (let i = 0; i < NCH(n); ++i) {
                    const ch = CHILD(n, i);
                    if (ch.type === SYM.stmt) {
                        cnt += numStmts(ch);
                    }
                }
                return cnt;
            case SYM.stmt:
                return numStmts(CHILD(n, 0));
            case SYM.compound_stmt:
                return 1;
            case SYM.simple_stmt:
                return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s
            case SYM.suite:
                if (NCH(n) === 1)
                    return numStmts(CHILD(n, 0));
                else {
                    let cnt = 0;
                    for (let i = 2; i < NCH(n) - 1; ++i) {
                        cnt += numStmts(CHILD(n, i));
                    }
                    return cnt;
                }
            default: {
                throw new Error("Non-statement found");
            }
        }
    }
    function forbiddenCheck(c, n, x, range) {
        if (x === "None")
            throw syntaxError("assignment to None", range);
        if (x === "True" || x === "False")
            throw syntaxError("assignment to True or False is forbidden", range);
    }
    /**
     * Set the context ctx for e, recursively traversing e.
     *
     * Only sets context for expr kinds that can appear in assignment context as
     * per the asdl file.
     */
    function setContext(c, e, ctx, n) {
        assert(ctx !== AugStore && ctx !== AugLoad);
        let s = null;
        let exprName = null;
        if (e instanceof Attribute) {
            if (ctx === Store)
                forbiddenCheck(c, n, e.attr.value, n.range);
            e.ctx = ctx;
        }
        else if (e instanceof Name) {
            if (ctx === Store)
                forbiddenCheck(c, n, /*e.attr*/ void 0, n.range);
            e.ctx = ctx;
        }
        else if (e instanceof Subscript) {
            e.ctx = ctx;
        }
        else if (e instanceof List) {
            e.ctx = ctx;
            s = e.elts;
        }
        else if (e instanceof Tuple) {
            if (e.elts.length === 0) {
                throw syntaxError("can't assign to ()", n.range);
            }
            e.ctx = ctx;
            s = e.elts;
        }
        else if (e instanceof Lambda) {
            exprName = "lambda";
        }
        else if (e instanceof Call) {
            exprName = "function call";
        }
        else if (e instanceof BoolOp) {
            exprName = "operator";
        }
        else {
            switch (e.constructor) {
                case BoolOp:
                case BinOp:
                case UnaryOp:
                    exprName = "operator";
                    break;
                case GeneratorExp:
                    exprName = "generator expression";
                    break;
                case Yield:
                    exprName = "yield expression";
                    break;
                case ListComp:
                    exprName = "list comprehension";
                    break;
                case Dict:
                case Num:
                case Str:
                    exprName = "literal";
                    break;
                case Compare:
                    exprName = "comparison expression";
                    break;
                case IfExp:
                    exprName = "conditional expression";
                    break;
                default: {
                    throw new Error("unhandled expression in assignment");
                }
            }
        }
        if (exprName) {
            throw syntaxError("can't " + (ctx === Store ? "assign to" : "delete") + " " + exprName, n.range);
        }
        if (s) {
            for (const e of s) {
                setContext(c, e, ctx, n);
            }
        }
    }
    /**
     * Contains a map from a token identifier to an operator class.
     * Missing: JavaScript Bitwise Unsigned Right Shift (>>>)
     * Missing: "Relational" operators... Less Than, LessThan Or Equal WHY?
     * Missing: "Equality" Operators. WHY?
     */
    const operatorMap = {};
    (function () {
        // Exponentiation
        operatorMap[exports.Tokens.T_DOUBLESTAR] = Pow;
        // Multiplication
        operatorMap[exports.Tokens.T_STAR] = Mult;
        // Division
        operatorMap[exports.Tokens.T_SLASH] = Div;
        // Remainder
        operatorMap[exports.Tokens.T_PERCENT] = Mod;
        // Addition
        operatorMap[exports.Tokens.T_PLUS] = Add;
        // Subtraction
        operatorMap[exports.Tokens.T_MINUS] = Sub;
        // Bitwise Left Shift
        operatorMap[exports.Tokens.T_LEFTSHIFT] = LShift;
        // Bitwise Right Shift
        operatorMap[exports.Tokens.T_RIGHTSHIFT] = RShift;
        // Bitwise AND (&)
        operatorMap[exports.Tokens.T_AMPER] = BitAnd;
        // Bitwise XOR (^)
        operatorMap[exports.Tokens.T_CIRCUMFLEX] = BitXor;
        // Bitwise OR (|)
        operatorMap[exports.Tokens.T_VBAR] = BitOr;
        // Python FloorDiv
        operatorMap[exports.Tokens.T_DOUBLESLASH] = FloorDiv;
    }());
    /**
     * Creates the structure for describing an operator and its range.
     * Looks up the operator class in the operatorMap.
     * Use the range from the concrete syntax tree node.
     *
     * @param n The node in the concrete syntax tree.
     */
    function getOperator(n) {
        assert(operatorMap[n.type] !== undefined, `${n.type}`);
        return { op: operatorMap[n.type], range: n.range };
    }
    function astForCompOp(c, n) {
        // comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is' |'is' 'not'
        REQ(n, SYM.comp_op);
        if (NCH(n) === 1) {
            n = CHILD(n, 0);
            switch (n.type) {
                case exports.Tokens.T_LESS: return Lt;
                case exports.Tokens.T_GREATER: return Gt;
                case exports.Tokens.T_EQEQUAL: return Eq;
                case exports.Tokens.T_LESSEQUAL: return LtE;
                case exports.Tokens.T_GREATEREQUAL: return GtE;
                case exports.Tokens.T_NOTEQUAL: return NotEq;
                case exports.Tokens.T_NAME:
                    if (n.value === "in")
                        return In;
                    if (n.value === "is")
                        return Is;
            }
        }
        else if (NCH(n) === 2) {
            if (CHILD(n, 0).type === exports.Tokens.T_NAME) {
                if (CHILD(n, 1).value === "in")
                    return NotIn;
                if (CHILD(n, 0).value === "is")
                    return IsNot;
            }
        }
        throw new Error("invalid comp_op");
    }
    function seqForTestlist(c, n) {
        /* testlist: test (',' test)* [','] */
        assert(n.type === SYM.testlist ||
            n.type === SYM.listmaker ||
            n.type === SYM.testlist_gexp ||
            n.type === SYM.testlist_safe ||
            n.type === SYM.testlist1);
        const seq = [];
        for (let i = 0; i < NCH(n); i += 2) {
            assert(CHILD(n, i).type === SYM.IfExpr || CHILD(n, i).type === SYM.old_test);
            seq[i / 2] = astForExpr(c, CHILD(n, i));
        }
        return seq;
    }
    function astForSuite(c, n) {
        /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
        REQ(n, SYM.suite);
        const seq = [];
        let pos = 0;
        let ch;
        if (CHILD(n, 0).type === SYM.simple_stmt) {
            n = CHILD(n, 0);
            /* simple_stmt always ends with an NEWLINE and may have a trailing
                * SEMI. */
            let end = NCH(n) - 1;
            if (CHILD(n, end - 1).type === exports.Tokens.T_SEMI) {
                end -= 1;
            }
            // by 2 to skip
            for (let i = 0; i < end; i += 2) {
                seq[pos++] = astForStmt(c, CHILD(n, i));
            }
        }
        else {
            for (let i = 2; i < NCH(n) - 1; ++i) {
                ch = CHILD(n, i);
                REQ(ch, SYM.stmt);
                let num = numStmts(ch);
                if (num === 1) {
                    // small_stmt or compound_stmt w/ only 1 child
                    seq[pos++] = astForStmt(c, ch);
                }
                else {
                    ch = CHILD(ch, 0);
                    REQ(ch, SYM.simple_stmt);
                    for (let j = 0; j < NCH(ch); j += 2) {
                        if (NCH(CHILD(ch, j)) === 0) {
                            assert(j + 1 === NCH(ch));
                            break;
                        }
                        seq[pos++] = astForStmt(c, CHILD(ch, j));
                    }
                }
            }
        }
        assert(pos === numStmts(n));
        return seq;
    }
    function astForExceptClause(c, exc, body) {
        /* except_clause: 'except' [test [(',' | 'as') test]] */
        REQ(exc, SYM.except_clause);
        REQ(body, SYM.suite);
        if (NCH(exc) === 1) {
            return new ExceptHandler(null, null, astForSuite(c, body), exc.range);
        }
        else if (NCH(exc) === 2)
            return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.range);
        else if (NCH(exc) === 4) {
            const e = astForExpr(c, CHILD(exc, 3));
            setContext(c, e, Store, CHILD(exc, 3));
            return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.range);
        }
        else {
            throw new Error("wrong number of children for except clause");
        }
    }
    function astForTryStmt(c, n) {
        const nc = NCH(n);
        let nexcept = (nc - 3) / 3;
        let orelse = [];
        let finally_ = null;
        REQ(n, SYM.try_stmt);
        let body = astForSuite(c, CHILD(n, 2));
        if (CHILD(n, nc - 3).type === exports.Tokens.T_NAME) {
            if (CHILD(n, nc - 3).value === "finally") {
                if (nc >= 9 && CHILD(n, nc - 6).type === exports.Tokens.T_NAME) {
                    /* we can assume it's an "else",
                        because nc >= 9 for try-else-finally and
                        it would otherwise have a type of except_clause */
                    orelse = astForSuite(c, CHILD(n, nc - 4));
                    nexcept--;
                }
                finally_ = astForSuite(c, CHILD(n, nc - 1));
                nexcept--;
            }
            else {
                /* we can assume it's an "else",
                    otherwise it would have a type of except_clause */
                orelse = astForSuite(c, CHILD(n, nc - 1));
                nexcept--;
            }
        }
        else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
            throw syntaxError("malformed 'try' statement", n.range);
        }
        if (nexcept > 0) {
            const handlers = [];
            for (let i = 0; i < nexcept; ++i) {
                handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
            }
            const exceptSt = new TryExcept(body, handlers, orelse, n.range);
            if (!finally_)
                return exceptSt;
            /* if a 'finally' is present too, we nest the TryExcept within a
                TryFinally to emulate try ... except ... finally */
            body = [exceptSt];
        }
        assert(finally_ !== null);
        return new TryFinally(body, finally_, n.range);
    }
    function astForDottedName(c, n) {
        REQ(n, SYM.dotted_name);
        const child = CHILD(n, 0);
        let id = new RangeAnnotated(child.value, child.range);
        let e = new Name(id, Load);
        for (let i = 2; i < NCH(n); i += 2) {
            const child = CHILD(n, i);
            id = new RangeAnnotated(child.value, child.range);
            e = new Attribute(e, id, Load, n.range);
        }
        return e;
    }
    function astForDecorator(c, n) {
        /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
        REQ(n, SYM.decorator);
        REQ(CHILD(n, 0), exports.Tokens.T_AT);
        REQ(CHILD(n, NCH(n) - 1), exports.Tokens.T_NEWLINE);
        const nameExpr = astForDottedName(c, CHILD(n, 1));
        if (NCH(n) === 3) // no args
            return nameExpr;
        else if (NCH(n) === 5) // call with no args
            return new Call(nameExpr, [], [], null, null);
        else
            return astForCall(c, CHILD(n, 3), nameExpr);
    }
    function astForDecorators(c, n) {
        REQ(n, SYM.decorators);
        const decoratorSeq = [];
        for (let i = 0; i < NCH(n); ++i) {
            decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
        }
        return decoratorSeq;
    }
    function astForDecorated(c, n) {
        REQ(n, SYM.decorated);
        const decoratorSeq = astForDecorators(c, CHILD(n, 0));
        assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);
        let thing = null;
        if (CHILD(n, 1).type === SYM.funcdef) {
            thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);
        }
        else if (CHILD(n, 1).type === SYM.classdef) {
            thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);
        }
        else {
            throw new Error("astForDecorated");
        }
        return thing;
    }
    function astForWithVar(c, n) {
        REQ(n, SYM.with_var);
        return astForExpr(c, CHILD(n, 1));
    }
    function astForWithStmt(c, n) {
        /* with_stmt: 'with' test [ with_var ] ':' suite */
        let suiteIndex = 3; // skip with, test, :
        assert(n.type === SYM.with_stmt);
        const contextExpr = astForExpr(c, CHILD(n, 1));
        let optionalVars;
        if (CHILD(n, 2).type === SYM.with_var) {
            optionalVars = astForWithVar(c, CHILD(n, 2));
            setContext(c, optionalVars, Store, n);
            suiteIndex = 4;
        }
        return new WithStatement(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.range);
    }
    function astForExecStmt(c, n) {
        let globals = null;
        let locals = null;
        const nchildren = NCH(n);
        assert(nchildren === 2 || nchildren === 4 || nchildren === 6);
        /* exec_stmt: 'exec' expr ['in' test [',' test]] */
        REQ(n, SYM.exec_stmt);
        const expr1 = astForExpr(c, CHILD(n, 1));
        if (nchildren >= 4) {
            globals = astForExpr(c, CHILD(n, 3));
        }
        if (nchildren === 6) {
            locals = astForExpr(c, CHILD(n, 5));
        }
        return new Exec(expr1, globals, locals, n.range);
    }
    function astForIfStmt(c, n) {
        /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
            ['else' ':' suite]
        */
        REQ(n, SYM.if_stmt);
        if (NCH(n) === 4)
            return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.range);
        const s = CHILD(n, 4).value;
        const decider = s.charAt(2); // elSe or elIf
        if (decider === 's') {
            return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.range);
        }
        else if (decider === 'i') {
            let nElif = NCH(n) - 4;
            let hasElse = false;
            let orelse = [];
            /* must reference the child nElif+1 since 'else' token is third, not
                * fourth child from the end. */
            if (CHILD(n, nElif + 1).type === exports.Tokens.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === 's') {
                hasElse = true;
                nElif -= 3;
            }
            nElif /= 4;
            if (hasElse) {
                orelse = [
                    new IfStatement(astForExpr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).range)
                ];
                nElif--;
            }
            for (let i = 0; i < nElif; ++i) {
                const off = 5 + (nElif - i - 1) * 4;
                orelse = [
                    new IfStatement(astForExpr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).range)
                ];
            }
            return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.range);
        }
        throw new Error("unexpected token in 'if' statement");
    }
    function astForExprlist(c, n, context) {
        REQ(n, SYM.ExprList);
        const seq = [];
        for (let i = 0; i < NCH(n); i += 2) {
            const e = astForExpr(c, CHILD(n, i));
            seq[i / 2] = e;
            if (context)
                setContext(c, e, context, CHILD(n, i));
        }
        return seq;
    }
    function astForDelStmt(c, n) {
        REQ(n, SYM.del_stmt);
        return new DeleteStatement(astForExprlist(c, CHILD(n, 1), Del), n.range);
    }
    function astForGlobalStmt(c, n) {
        REQ(n, SYM.GlobalStmt);
        const s = [];
        for (let i = 1; i < NCH(n); i += 2) {
            s[(i - 1) / 2] = strobj(CHILD(n, i).value);
        }
        return new Global(s, n.range);
    }
    function astForNonLocalStmt(c, n) {
        REQ(n, SYM.NonLocalStmt);
        const s = [];
        for (let i = 1; i < NCH(n); i += 2) {
            s[(i - 1) / 2] = strobj(CHILD(n, i).value);
        }
        return new NonLocal(s, n.range);
    }
    function astForAssertStmt(c, n) {
        /* assert_stmt: 'assert' test [',' test] */
        REQ(n, SYM.assert_stmt);
        if (NCH(n) === 2) {
            return new Assert(astForExpr(c, CHILD(n, 1)), null, n.range);
        }
        else if (NCH(n) === 4) {
            return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.range);
        }
        throw new Error("improper number of parts to assert stmt");
    }
    function aliasForImportName(c, n) {
        /*
            ImportSpecifier: NAME ['as' NAME]
            dotted_as_name: dotted_name ['as' NAME]
            dotted_name: NAME ('.' NAME)*
        */
        loop: while (true) {
            switch (n.type) {
                case SYM.ImportSpecifier: {
                    let str = null;
                    const nameNode = CHILD(n, 0);
                    const name = strobj(nameNode.value);
                    const nameRange = nameNode.range;
                    if (NCH(n) === 3) {
                        str = CHILD(n, 2).value;
                    }
                    return new Alias(new RangeAnnotated(name, nameRange), str == null ? null : strobj(str));
                }
                case SYM.dotted_as_name:
                    if (NCH(n) === 1) {
                        n = CHILD(n, 0);
                        continue loop;
                    }
                    else {
                        const a = aliasForImportName(c, CHILD(n, 0));
                        assert(!a.asname);
                        a.asname = strobj(CHILD(n, 2).value);
                        return a;
                    }
                case SYM.dotted_name:
                    if (NCH(n) === 1) {
                        const nameNode = CHILD(n, 0);
                        const name = strobj(nameNode.value);
                        const nameRange = nameNode.range;
                        return new Alias(new RangeAnnotated(name, nameRange), null);
                    }
                    else {
                        // create a string of the form a.b.c
                        let str = '';
                        for (let i = 0; i < NCH(n); i += 2) {
                            str += CHILD(n, i).value + ".";
                        }
                        return new Alias(new RangeAnnotated(str.substr(0, str.length - 1), null), null);
                    }
                case exports.Tokens.T_STAR: {
                    return new Alias(new RangeAnnotated("*", n.range), null);
                }
                case exports.Tokens.T_NAME: {
                    // Temporary.
                    return new Alias(new RangeAnnotated(n.value, n.range), null);
                }
                default: {
                    throw syntaxError(`unexpected import name ${grammarName(n.type)}`, n.range);
                }
            }
        }
    }
    function parseModuleSpecifier(c, moduleSpecifierNode) {
        REQ(moduleSpecifierNode, SYM.ModuleSpecifier);
        const N = NCH(moduleSpecifierNode);
        let ret = "";
        let range;
        for (let i = 0; i < N; ++i) {
            const child = CHILD(moduleSpecifierNode, i);
            ret = ret + parsestr(c, child.value);
            range = child.range;
        }
        return { value: ret, range };
    }
    function astForImportStmt(c, importStatementNode) {
        REQ(importStatementNode, SYM.import_stmt);
        let nameOrFrom = CHILD(importStatementNode, 0);
        if (nameOrFrom.type === SYM.import_name) {
            const n = CHILD(nameOrFrom, 1);
            REQ(n, SYM.dotted_as_names);
            const aliases = [];
            for (let i = 0; i < NCH(n); i += 2) {
                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
            }
            return new ImportStatement(aliases, importStatementNode.range);
        }
        else if (nameOrFrom.type === SYM.import_from) {
            // let mod: Alias = null;
            let moduleSpec;
            let ndots = 0;
            let nchildren;
            let idx;
            for (idx = 1; idx < NCH(nameOrFrom); ++idx) {
                const child = CHILD(nameOrFrom, idx);
                const childType = child.type;
                if (childType === SYM.dotted_name) {
                    // This should be dead code since we support ECMAScript 2015 modules.
                    throw syntaxError(`unknown import statement ${grammarName(childType)}.`, child.range);
                    // mod = aliasForImportName(c, child);
                    // idx++;
                    // break;
                }
                else if (childType === SYM.ModuleSpecifier) {
                    moduleSpec = parseModuleSpecifier(c, child);
                    break;
                }
                else if (childType !== exports.Tokens.T_DOT) {
                    // Let's be more specific...
                    throw syntaxError(`unknown import statement ${grammarName(childType)}.`, child.range);
                    // break;
                }
                ndots++;
            }
            ++idx; // skip the import keyword
            let n = nameOrFrom;
            switch (CHILD(nameOrFrom, idx).type) {
                case exports.Tokens.T_STAR: {
                    // from ... import
                    n = CHILD(nameOrFrom, idx);
                    nchildren = 1;
                    break;
                }
                case exports.Tokens.T_LPAR: {
                    // from ... import (x, y, z)
                    n = CHILD(n, idx + 1);
                    nchildren = NCH(n);
                    break;
                }
                case SYM.ImportList: {
                    // from ... import x, y, z
                    n = CHILD(n, idx);
                    nchildren = NCH(n);
                    if (nchildren % 2 === 0) {
                        throw syntaxError("trailing comma not allowed without surrounding parentheses", n.range);
                    }
                }
            }
            const aliases = [];
            if (n.type === exports.Tokens.T_STAR) {
                aliases[0] = aliasForImportName(c, n);
            }
            else {
                REQ(n, SYM.import_from);
                const importListNode = CHILD(n, FIND(n, SYM.ImportList));
                astForImportList(c, importListNode, aliases);
            }
            // moduleName = mod ? mod.name : moduleName;
            assert(typeof moduleSpec.value === 'string');
            return new ImportFrom(new RangeAnnotated(moduleSpec.value, moduleSpec.range), aliases, ndots, importStatementNode.range);
        }
        else {
            throw syntaxError(`unknown import statement ${grammarName(nameOrFrom.type)}.`, nameOrFrom.range);
        }
    }
    function astForImportList(c, importListNode, aliases) {
        REQ(importListNode, SYM.ImportList);
        const N = NCH(importListNode);
        for (let i = 0; i < N; i++) {
            const child = CHILD(importListNode, i);
            if (child.type === SYM.ImportSpecifier) {
                aliases.push(aliasForImportName(c, child));
            }
        }
    }
    function astForTestlistGexp(c, n) {
        assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
        if (NCH(n) > 1 && CHILD(n, 1).type === SYM.gen_for)
            return astForGenexp(c, n);
        return astForTestlist(c, n);
    }
    function astForListcomp(c, n) {
        function countListFors(c, n) {
            let nfors = 0;
            let ch = CHILD(n, 1);
            count_list_for: while (true) {
                nfors++;
                REQ(ch, SYM.list_for);
                if (NCH(ch) === 5)
                    ch = CHILD(ch, 4);
                else
                    return nfors;
                count_list_iter: while (true) {
                    REQ(ch, SYM.list_iter);
                    ch = CHILD(ch, 0);
                    if (ch.type === SYM.list_for)
                        continue count_list_for;
                    else if (ch.type === SYM.list_if) {
                        if (NCH(ch) === 3) {
                            ch = CHILD(ch, 2);
                            continue count_list_iter;
                        }
                        else
                            return nfors;
                    }
                    break;
                }
                // FIXME: What does a break at the end of a function do?
                break;
            }
            throw new Error("TODO: Should this be returning void 0?");
        }
        function countListIfs(c, n) {
            let nifs = 0;
            while (true) {
                REQ(n, SYM.list_iter);
                if (CHILD(n, 0).type === SYM.list_for)
                    return nifs;
                n = CHILD(n, 0);
                REQ(n, SYM.list_if);
                nifs++;
                if (NCH(n) === 2)
                    return nifs;
                n = CHILD(n, 2);
            }
        }
        REQ(n, SYM.listmaker);
        assert(NCH(n) > 1);
        const elt = astForExpr(c, CHILD(n, 0));
        const nfors = countListFors(c, n);
        const listcomps = [];
        let ch = CHILD(n, 1);
        for (let i = 0; i < nfors; ++i) {
            REQ(ch, SYM.list_for);
            const forch = CHILD(ch, 1);
            const t = astForExprlist(c, forch, Store);
            const expression = astForTestlist(c, CHILD(ch, 3));
            let lc;
            if (NCH(forch) === 1)
                lc = new Comprehension(t[0], expression, []);
            else
                lc = new Comprehension(new Tuple(t, Store, ch.range), expression, []);
            if (NCH(ch) === 5) {
                ch = CHILD(ch, 4);
                const nifs = countListIfs(c, ch);
                const ifs = [];
                for (let j = 0; j < nifs; ++j) {
                    REQ(ch, SYM.list_iter);
                    ch = CHILD(ch, 0);
                    REQ(ch, SYM.list_if);
                    ifs[j] = astForExpr(c, CHILD(ch, 1));
                    if (NCH(ch) === 3)
                        ch = CHILD(ch, 2);
                }
                if (ch.type === SYM.list_iter)
                    ch = CHILD(ch, 0);
                lc.ifs = ifs;
            }
            listcomps[i] = lc;
        }
        return new ListComp(elt, listcomps, n.range);
    }
    function astForUnaryExpr(c, n) {
        if (CHILD(n, 0).type === exports.Tokens.T_MINUS && NCH(n) === 2) {
            const pfactor = CHILD(n, 1);
            if (pfactor.type === SYM.UnaryExpr && NCH(pfactor) === 1) {
                const ppower = CHILD(pfactor, 0);
                if (ppower.type === SYM.PowerExpr && NCH(ppower) === 1) {
                    const patom = CHILD(ppower, 0);
                    if (patom.type === SYM.AtomExpr) {
                        const pnum = CHILD(patom, 0);
                        if (pnum.type === exports.Tokens.T_NUMBER) {
                            pnum.value = "-" + pnum.value;
                            return astForAtomExpr(c, patom);
                        }
                    }
                }
            }
        }
        const expression = astForExpr(c, CHILD(n, 1));
        switch (CHILD(n, 0).type) {
            case exports.Tokens.T_PLUS: return new UnaryOp(UAdd, expression, n.range);
            case exports.Tokens.T_MINUS: return new UnaryOp(USub, expression, n.range);
            case exports.Tokens.T_TILDE: return new UnaryOp(Invert, expression, n.range);
        }
        throw new Error("unhandled UnaryExpr");
    }
    function astForForStmt(c, n) {
        let seq = [];
        REQ(n, SYM.for_stmt);
        if (NCH(n) === 9) {
            seq = astForSuite(c, CHILD(n, 8));
        }
        const nodeTarget = CHILD(n, 1);
        const _target = astForExprlist(c, nodeTarget, Store);
        let target;
        if (NCH(nodeTarget) === 1)
            target = _target[0];
        else
            target = new Tuple(_target, Store, n.range);
        return new ForStatement(target, astForTestlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.range);
    }
    function astForCall(c, n, func) {
        /*
            arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
                    | '**' test)
            argument: [test '='] test [gen_for]        # Really [keyword '='] test
        */
        REQ(n, SYM.arglist);
        let nargs = 0;
        let nkeywords = 0;
        let ngens = 0;
        for (let i = 0; i < NCH(n); ++i) {
            const ch = CHILD(n, i);
            if (ch.type === SYM.argument) {
                if (NCH(ch) === 1)
                    nargs++;
                else if (CHILD(ch, 1).type === SYM.gen_for)
                    ngens++;
                else
                    nkeywords++;
            }
        }
        if (ngens > 1 || (ngens && (nargs || nkeywords)))
            throw syntaxError("Generator expression must be parenthesized if not sole argument", n.range);
        if (nargs + nkeywords + ngens > 255)
            throw syntaxError("more than 255 arguments", n.range);
        const args = [];
        const keywords = [];
        nargs = 0;
        nkeywords = 0;
        let vararg = null;
        let kwarg = null;
        for (let i = 0; i < NCH(n); ++i) {
            const ch = CHILD(n, i);
            if (ch.type === SYM.argument) {
                if (NCH(ch) === 1) {
                    if (nkeywords)
                        throw syntaxError("non-keyword arg after keyword arg", n.range);
                    if (vararg)
                        throw syntaxError("only named arguments may follow *expression", n.range);
                    args[nargs++] = astForExpr(c, CHILD(ch, 0));
                }
                else if (CHILD(ch, 1).type === SYM.gen_for)
                    args[nargs++] = astForGenexp(c, ch);
                else {
                    const e = astForExpr(c, CHILD(ch, 0));
                    if (e.constructor === Lambda) {
                        throw syntaxError("lambda cannot contain assignment", n.range);
                    }
                    else if (e.constructor !== Name) {
                        throw syntaxError("keyword can't be an expression", n.range);
                    }
                    // TODO: Why does TypeScript think that the type is never?
                    const key = e.id;
                    forbiddenCheck(c, CHILD(ch, 0), key.value, n.range);
                    for (let k = 0; k < nkeywords; ++k) {
                        const tmp = keywords[k].arg.value;
                        if (tmp === key.value)
                            throw syntaxError("keyword argument repeated", n.range);
                    }
                    keywords[nkeywords++] = new Keyword(key, astForExpr(c, CHILD(ch, 2)));
                }
            }
            else if (ch.type === exports.Tokens.T_STAR)
                vararg = astForExpr(c, CHILD(n, ++i));
            else if (ch.type === exports.Tokens.T_DOUBLESTAR)
                kwarg = astForExpr(c, CHILD(n, ++i));
        }
        // Convert keywords to a Dict, which is one arg
        const keywordDict = keywordsToDict(keywords);
        if (keywordDict.keys.length !== 0) {
            args.push(keywordDict);
        }
        return new Call(func, args, [], vararg, kwarg);
    }
    function keywordsToDict(keywords) {
        let keys = [];
        let values = [];
        for (const keyword of keywords) {
            values.push(keyword.value);
            keys.push(new Name(new RangeAnnotated(keyword.arg.value, keyword.arg.range), Load));
        }
        return new Dict(keys, values);
    }
    function astForTrailer(c, node, leftExpr) {
        /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
            subscriptlist: subscript (',' subscript)* [',']
            subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
            */
        const n = node;
        const childZero = CHILD(n, 0);
        const childOne = CHILD(n, 1);
        const childTwo = CHILD(n, 2);
        REQ(n, SYM.trailer);
        if (childZero.type === exports.Tokens.T_LPAR) {
            if (NCH(n) === 2) {
                return new Call(leftExpr, [], [], null, null);
            }
            else {
                return astForCall(c, childOne, leftExpr);
            }
        }
        else if (childZero.type === exports.Tokens.T_DOT) {
            return new Attribute(leftExpr, new RangeAnnotated(childOne.value, childOne.range), Load, n.range);
        }
        else {
            REQ(childZero, exports.Tokens.T_LSQB);
            REQ(childTwo, exports.Tokens.T_RSQB);
            const n = childOne;
            if (NCH(n) === 1)
                return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.range);
            else {
                /* The grammar is ambiguous here. The ambiguity is resolved
                    by treating the sequence as a tuple literal if there are
                    no slice features.
                */
                let simple = true;
                const slices = [];
                for (let j = 0; j < NCH(n); j += 2) {
                    const slc = astForSlice(c, CHILD(n, j));
                    if (slc.constructor !== Index) {
                        simple = false;
                    }
                    slices[j / 2] = slc;
                }
                if (!simple) {
                    return new Subscript(leftExpr, new ExtSlice(slices), Load, n.range);
                }
                const elts = [];
                for (let j = 0; j < slices.length; ++j) {
                    let slc = slices[j];
                    if (slc instanceof Index) {
                        assert(slc.value !== null && slc.value !== undefined);
                        elts[j] = slc.value;
                    }
                    else {
                        assert(slc instanceof Index);
                    }
                }
                const tuple = new Tuple(elts, Load, n.range);
                return new Subscript(leftExpr, new Index(tuple), Load, n.range);
            }
        }
    }
    function astForFlowStmt(c, n) {
        REQ(n, SYM.flow_stmt);
        const ch = CHILD(n, 0);
        switch (ch.type) {
            case SYM.break_stmt: return new BreakStatement(n.range);
            case SYM.continue_stmt: return new ContinueStatement(n.range);
            case SYM.yield_stmt:
                return new ExpressionStatement(astForExpr(c, CHILD(ch, 0)), n.range);
            case SYM.return_stmt:
                if (NCH(ch) === 1)
                    return new ReturnStatement(null, n.range);
                else
                    return new ReturnStatement(astForTestlist(c, CHILD(ch, 1)), n.range);
            case SYM.raise_stmt: {
                if (NCH(ch) === 1)
                    return new Raise(null, null, null, n.range);
                else if (NCH(ch) === 2)
                    return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.range);
                else if (NCH(ch) === 4)
                    return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), null, n.range);
                else if (NCH(ch) === 6)
                    return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), astForExpr(c, CHILD(ch, 5)), n.range);
                else {
                    throw new Error("unhandled flow statement");
                }
            }
            default: {
                throw new Error("unexpected flow_stmt");
            }
        }
    }
    function astForArguments(c, n) {
        /* parameters: '(' [varargslist] ')'
            varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]
                | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']
        */
        let ch;
        let vararg = null;
        let kwarg = null;
        if (n.type === SYM.parameters) {
            if (NCH(n) === 2) // () as arglist
                return new Arguments([], null, null, []);
            n = CHILD(n, 1); // n is a varargslist here on out
        }
        REQ(n, SYM.varargslist);
        const args = [];
        const defaults = [];
        /* fpdef: NAME [':' IfExpr] | '(' fplist ')'
            fplist: fpdef (',' fpdef)* [',']
        */
        let foundDefault = false;
        let i = 0;
        let j = 0; // index for defaults
        let k = 0; // index for args
        // loop through the children of the varargslist
        while (i < NCH(n)) {
            ch = CHILD(n, i);
            switch (ch.type) {
                // If it is a fpdef - act here
                case SYM.fpdef:
                    let complexArgs = 0;
                    let parenthesized = false;
                    handle_fpdef: while (true) {
                        if (i + 1 < NCH(n) && CHILD(n, i + 1).type === exports.Tokens.T_EQUAL) {
                            defaults[j++] = astForExpr(c, CHILD(n, i + 2));
                            i += 2;
                            foundDefault = true;
                        }
                        else if (foundDefault) {
                            /* def f((x)=4): pass should raise an error.
                                def f((x, (y))): pass will just incur the tuple unpacking warning. */
                            if (parenthesized && !complexArgs)
                                throw syntaxError("parenthesized arg with default", n.range);
                            throw syntaxError("non-default argument follows default argument", n.range);
                        }
                        // For unpacking a tuple
                        if (NCH(ch) === 3 && ch.children[2].type === exports.Tokens.T_RPAR) {
                            ch = CHILD(ch, 1);
                            // def foo((x)): is not complex, special case.
                            if (NCH(ch) !== 1) {
                                throw syntaxError("tuple parameter unpacking has been removed", n.range);
                            }
                            else {
                                /* def foo((x)): setup for checking NAME below. */
                                /* Loop because there can be many parens and tuple
                                    unpacking mixed in. */
                                parenthesized = true;
                                ch = CHILD(ch, 0);
                                assert(ch.type === SYM.fpdef);
                                continue handle_fpdef;
                            }
                        }
                        // childzero here is possibly the 'NAME' in fpdef: NAME [':' IfExpr]
                        const childZero = CHILD(ch, 0);
                        if (childZero.type === exports.Tokens.T_NAME) {
                            forbiddenCheck(c, n, childZero.value, n.range);
                            const id = new RangeAnnotated(childZero.value, childZero.range);
                            /**
                             * Setting the type of the param here, will be third child of fpdef if it exists
                             * If it doesn't exist then set the type as null and have typescript attempt to infer it later
                             */
                            const paramTypeNode = CHILD(ch, 2);
                            if (paramTypeNode) {
                                let paramTypeExpr = astForExpr(c, paramTypeNode);
                                args[k++] = new FunctionParamDef(new Name(id, Param), paramTypeExpr);
                            }
                            else {
                                args[k++] = new FunctionParamDef(new Name(id, Param));
                            }
                        }
                        i += 2;
                        if (parenthesized)
                            throw syntaxError("parenthesized argument names are invalid", n.range);
                        break;
                    }
                    break;
                case exports.Tokens.T_STAR:
                    forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.range);
                    vararg = strobj(CHILD(n, i + 1).value);
                    i += 3;
                    break;
                case exports.Tokens.T_DOUBLESTAR:
                    forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.range);
                    kwarg = strobj(CHILD(n, i + 1).value);
                    i += 3;
                    break;
                default: {
                    throw new Error("unexpected node in varargslist");
                }
            }
        }
        return new Arguments(args, vararg, kwarg, defaults);
    }
    function astForFuncdef(c, n, decoratorSeq) {
        /**
         * funcdef: ['export'] def' NAME parameters ['->' IfExpr] ':' suite
         */
        REQ(n, SYM.funcdef);
        const numberOfChildren = NCH(n);
        let ch1;
        let name;
        let args;
        // Name and args are 1 node further if 'export' exists
        if (numberOfChildren !== 8 && numberOfChildren !== 6) {
            ch1 = CHILD(n, 1);
            name = strobj(ch1.value);
            forbiddenCheck(c, ch1, name, n.range);
            args = astForArguments(c, CHILD(n, 2));
        }
        else {
            ch1 = CHILD(n, 2);
            name = strobj(ch1.value);
            forbiddenCheck(c, ch1, name, n.range);
            args = astForArguments(c, CHILD(n, 3));
        }
        // suite is either 4, 6 or 7, depending on whether functype exists
        let body;
        let returnType;
        // Neither Export nor FuncType exist
        if (numberOfChildren === 5) {
            body = astForSuite(c, CHILD(n, 4));
            returnType = null;
        }
        // Only Export exists
        else if (numberOfChildren === 6) {
            body = astForSuite(c, CHILD(n, 5));
            returnType = null;
        }
        // Only FuncType exists
        else if (numberOfChildren === 7) {
            returnType = astForExpr(c, CHILD(n, 4));
            body = astForSuite(c, CHILD(n, 6));
        }
        // Export AND FuncType exist
        else if (numberOfChildren === 8) {
            returnType = astForExpr(c, CHILD(n, 5));
            body = astForSuite(c, CHILD(n, 7));
        }
        else {
            fail(`Was expecting 5, 7 or 8 children, received ${numberOfChildren} children`);
        }
        return new FunctionDef(new RangeAnnotated(name, ch1.range), args, body, returnType, decoratorSeq, n.range);
    }
    function astForClassBases(c, n) {
        const numberOfChildren = NCH(n);
        assert(numberOfChildren > 0);
        REQ(n, SYM.testlist);
        if (numberOfChildren === 1) {
            return [astForExpr(c, CHILD(n, 0))];
        }
        return seqForTestlist(c, n);
    }
    function astForClassdef(c, node, decoratorSeq) {
        /**
         * ['export'] 'class' NAME ['(' [testlist] ')'] ':' suite
         */
        const n = node;
        const numberOfChildren = NCH(n);
        REQ(n, SYM.classdef);
        let nameNode;
        let className;
        let nameRange;
        if (numberOfChildren !== 5 && numberOfChildren !== 8) {
            if (numberOfChildren !== 7 || CHILD(n, 4).type !== exports.Tokens.T_RPAR) {
                nameNode = CHILD(n, 1);
                forbiddenCheck(c, n, nameNode.value, n.range);
                className = strobj(nameNode.value);
                nameRange = nameNode.range;
            }
        }
        else {
            nameNode = CHILD(n, 2);
            forbiddenCheck(c, n, nameNode.value, n.range);
            className = strobj(nameNode.value);
            nameRange = nameNode.range;
        }
        // If grammar looks like 'class NAME : suite'
        if (numberOfChildren === 4) {
            return new ClassDef(new RangeAnnotated(className, nameRange), [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.range);
        }
        // If grammar looks like 'export class NAME '(' ')' : suite'
        if (numberOfChildren === 7 && CHILD(n, 3).type !== exports.Tokens.T_RPAR) ;
        const c3 = CHILD(n, 3);
        // If grammar looks like 'class NAME '(' ')' : suite'
        if (c3.type === exports.Tokens.T_RPAR) {
            return new ClassDef(new RangeAnnotated(className, nameRange), [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.range);
        }
        // Otherwise grammar looks like 'class NAME '(' testlist ')' : suite'
        // ClassBases are 'testlist'
        const bases = astForClassBases(c, c3);
        const s = astForSuite(c, CHILD(n, 6));
        return new ClassDef(new RangeAnnotated(className, nameRange), bases, s, decoratorSeq, n.range);
    }
    function astForLambdef(c, n) {
        let args;
        let expression;
        if (NCH(n) === 3) {
            args = new Arguments([], null, null, []);
            expression = astForExpr(c, CHILD(n, 2));
        }
        else {
            args = astForArguments(c, CHILD(n, 1));
            expression = astForExpr(c, CHILD(n, 3));
        }
        return new Lambda(args, expression, n.range);
    }
    function astForGenexp(c, n) {
        /* testlist_gexp: test ( gen_for | (',' test)* [','] )
            argument: [test '='] test [gen_for]       # Really [keyword '='] test */
        assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
        assert(NCH(n) > 1);
        function countGenFors(c, n) {
            let nfors = 0;
            let ch = CHILD(n, 1);
            count_gen_for: while (true) {
                nfors++;
                REQ(ch, SYM.gen_for);
                if (NCH(ch) === 5)
                    ch = CHILD(ch, 4);
                else
                    return nfors;
                count_gen_iter: while (true) {
                    REQ(ch, SYM.gen_iter);
                    ch = CHILD(ch, 0);
                    if (ch.type === SYM.gen_for)
                        continue count_gen_for;
                    else if (ch.type === SYM.gen_if) {
                        if (NCH(ch) === 3) {
                            ch = CHILD(ch, 2);
                            continue count_gen_iter;
                        }
                        else
                            return nfors;
                    }
                    break;
                }
                break;
            }
            throw new Error("logic error in countGenFors");
        }
        function countGenIfs(c, n) {
            let nifs = 0;
            while (true) {
                REQ(n, SYM.gen_iter);
                if (CHILD(n, 0).type === SYM.gen_for)
                    return nifs;
                n = CHILD(n, 0);
                REQ(n, SYM.gen_if);
                nifs++;
                if (NCH(n) === 2)
                    return nifs;
                n = CHILD(n, 2);
            }
        }
        const elt = astForExpr(c, CHILD(n, 0));
        const nfors = countGenFors(c, n);
        const genexps = [];
        let ch = CHILD(n, 1);
        for (let i = 0; i < nfors; ++i) {
            REQ(ch, SYM.gen_for);
            const forch = CHILD(ch, 1);
            const t = astForExprlist(c, forch, Store);
            let expression = astForExpr(c, CHILD(ch, 3));
            let ge;
            if (NCH(forch) === 1)
                ge = new Comprehension(t[0], expression, []);
            else
                ge = new Comprehension(new Tuple(t, Store, ch.range), expression, []);
            if (NCH(ch) === 5) {
                ch = CHILD(ch, 4);
                const nifs = countGenIfs(c, ch);
                const ifs = [];
                for (let j = 0; j < nifs; ++j) {
                    REQ(ch, SYM.gen_iter);
                    ch = CHILD(ch, 0);
                    REQ(ch, SYM.gen_if);
                    expression = astForExpr(c, CHILD(ch, 1));
                    ifs[j] = expression;
                    if (NCH(ch) === 3)
                        ch = CHILD(ch, 2);
                }
                if (ch.type === SYM.gen_iter)
                    ch = CHILD(ch, 0);
                ge.ifs = ifs;
            }
            genexps[i] = ge;
        }
        return new GeneratorExp(elt, genexps, n.range);
    }
    function astForWhileStmt(c, n) {
        /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
        REQ(n, SYM.while_stmt);
        if (NCH(n) === 4)
            return new WhileStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.range);
        else if (NCH(n) === 7)
            return new WhileStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.range);
        throw new Error("wrong number of tokens for 'while' stmt");
    }
    function astForAugassign(c, n) {
        REQ(n, SYM.augassign);
        n = CHILD(n, 0);
        switch (n.value.charAt(0)) {
            case '+': return Add;
            case '-': return Sub;
            case '/': {
                if (n.value.charAt(1) === '/') {
                    return FloorDiv;
                }
                else {
                    return Div;
                }
            }
            case '%': return Mod;
            case '<': return LShift;
            case '>': return RShift;
            case '&': return BitAnd;
            case '^': return BitXor;
            case '|': return BitOr;
            case '*': {
                if (n.value.charAt(1) === '*') {
                    return Pow;
                }
                else {
                    return Mult;
                }
            }
            default: {
                throw new Error("invalid augassign");
            }
        }
    }
    function astForBinop(c, n) {
        /* Must account for a sequence of expressions.
            How should A op B op C by represented?
            BinOp(BinOp(A, op, B), op, C).
        */
        let result = new BinOp(astForExpr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), astForExpr(c, CHILD(n, 2)), n.range);
        const nops = (NCH(n) - 1) / 2;
        for (let i = 1; i < nops; ++i) {
            const nextOper = CHILD(n, i * 2 + 1);
            const tmp = astForExpr(c, CHILD(n, i * 2 + 2));
            result = new BinOp(result, getOperator(nextOper), tmp, nextOper.range);
        }
        return result;
    }
    function astForTestlist(c, n) {
        /* testlist_gexp: test (',' test)* [','] */
        /* testlist: test (',' test)* [','] */
        /* testlist_safe: test (',' test)+ [','] */
        /* testlist1: test (',' test)* */
        assert(NCH(n) > 0);
        if (n.type === SYM.testlist_gexp) {
            if (NCH(n) > 1) {
                assert(CHILD(n, 1).type !== SYM.gen_for);
            }
        }
        else {
            assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
        }
        if (NCH(n) === 1) {
            return astForExpr(c, CHILD(n, 0));
        }
        else {
            return new Tuple(seqForTestlist(c, n), Load, n.range);
        }
    }
    function astForExprStmt(c, node) {
        // Prevent assignment.
        const n = node;
        REQ(n, SYM.ExprStmt);
        if (NCH(n) === 1) {
            return new ExpressionStatement(astForTestlist(c, CHILD(n, 0)), n.range);
        }
        else if (CHILD(n, 1).type === SYM.augassign) {
            let ch = CHILD(n, 0);
            const expr1 = astForTestlist(c, ch);
            switch (expr1.constructor) {
                case GeneratorExp: throw syntaxError("augmented assignment to generator expression not possible", n.range);
                case Yield: throw syntaxError("augmented assignment to yield expression not possible", n.range);
                case Name: {
                    const varName = expr1.id;
                    forbiddenCheck(c, ch, varName.value, n.range);
                    break;
                }
                case Attribute:
                case Subscript:
                    break;
                default:
                    throw syntaxError("illegal expression for augmented assignment", n.range);
            }
            setContext(c, expr1, Store, ch);
            ch = CHILD(n, 2);
            let expr2;
            if (ch.type === SYM.testlist) {
                expr2 = astForTestlist(c, ch);
            }
            else
                expr2 = astForExpr(c, ch);
            return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.range);
        }
        else if (CHILD(n, 1).type === SYM.annasign) {
            // annasign
            // ':' 'IfExpr' ['=' 'IfExpr]
            const ch = CHILD(n, 0);
            const annasignChild = CHILD(n, 1);
            const type = astForExpr(c, CHILD(annasignChild, 1));
            const eq = CHILD(annasignChild, 2); // Equals sign
            if (eq) {
                REQ(eq, exports.Tokens.T_EQUAL);
                const variable = [astForTestlist(c, ch)]; // variable is the first node (before the annasign)
                const valueNode = CHILD(annasignChild, 3);
                let value;
                if (valueNode.type === SYM.testlist) {
                    value = astForTestlist(c, valueNode);
                }
                else {
                    value = astForExpr(c, valueNode);
                }
                return new Assign(variable, value, n.range, eq.range, type);
            }
            else {
                return new AnnAssign(type, astForTestlist(c, ch), n.range);
            }
        }
        else {
            // normal assignment
            const eq = CHILD(n, 1);
            REQ(eq, exports.Tokens.T_EQUAL);
            const targets = [];
            const N = NCH(n);
            for (let i = 0; i < N - 2; i += 2) {
                const ch = CHILD(n, i);
                if (ch.type === SYM.YieldExpr)
                    throw syntaxError("assignment to yield expression not possible", n.range);
                const e = astForTestlist(c, ch);
                setContext(c, e, Store, CHILD(n, i));
                targets[i / 2] = e;
            }
            const value = CHILD(n, N - 1);
            let expression;
            if (value.type === SYM.testlist)
                expression = astForTestlist(c, value);
            else
                expression = astForExpr(c, value);
            return new Assign(targets, expression, n.range, eq.range);
        }
    }
    function astForIfexpr(c, n) {
        assert(NCH(n) === 5);
        return new IfExp(astForExpr(c, CHILD(n, 2)), astForExpr(c, CHILD(n, 0)), astForExpr(c, CHILD(n, 4)), n.range);
    }
    // escape() was deprecated in JavaScript 1.5. Use encodeURI or encodeURIComponent instead.
    function escape(s) {
        return encodeURIComponent(s);
    }
    /**
     * s is a python-style string literal, including quote characters and u/r/b
     * prefixes. Returns decoded string object.
     */
    function parsestr(c, s) {
        // const encodeUtf8 = function(s) { return unescape(encodeURIComponent(s)); };
        const decodeUtf8 = function (s) { return decodeURIComponent(escape(s)); };
        const decodeEscape = function (s, quote) {
            const len = s.length;
            let ret = '';
            for (let i = 0; i < len; ++i) {
                let c = s.charAt(i);
                if (c === '\\') {
                    ++i;
                    c = s.charAt(i);
                    if (c === 'n')
                        ret += "\n";
                    else if (c === '\\')
                        ret += "\\";
                    else if (c === 't')
                        ret += "\t";
                    else if (c === 'r')
                        ret += "\r";
                    else if (c === 'b')
                        ret += "\b";
                    else if (c === 'f')
                        ret += "\f";
                    else if (c === 'v')
                        ret += "\v";
                    else if (c === '0')
                        ret += "\0";
                    else if (c === '"')
                        ret += '"';
                    else if (c === '\'')
                        ret += '\'';
                    else if (c === '\n') /* escaped newline, join lines */ ;
                    else if (c === 'x') {
                        const d0 = s.charAt(++i);
                        const d1 = s.charAt(++i);
                        ret += String.fromCharCode(parseInt(d0 + d1, 16));
                    }
                    else if (c === 'u' || c === 'U') {
                        const d0 = s.charAt(++i);
                        const d1 = s.charAt(++i);
                        const d2 = s.charAt(++i);
                        const d3 = s.charAt(++i);
                        ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));
                    }
                    else {
                        // Leave it alone
                        ret += "\\" + c;
                    }
                }
                else {
                    ret += c;
                }
            }
            return ret;
        };
        let quote = s.charAt(0);
        let rawmode = false;
        if (quote === 'u' || quote === 'U') {
            s = s.substr(1);
            quote = s.charAt(0);
        }
        else if (quote === 'r' || quote === 'R') {
            s = s.substr(1);
            quote = s.charAt(0);
            rawmode = true;
        }
        assert(quote !== 'b' && quote !== 'B', "todo; haven't done b'' strings yet");
        assert(quote === "'" || quote === '"' && s.charAt(s.length - 1) === quote);
        s = s.substr(1, s.length - 2);
        if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
            assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
            s = s.substr(2, s.length - 4);
        }
        if (rawmode || s.indexOf('\\') === -1) {
            return strobj(decodeUtf8(s));
        }
        return strobj(decodeEscape(s));
    }
    /**
     *
     */
    function parsestrplus(c, n) {
        REQ(CHILD(n, 0), exports.Tokens.T_STRING);
        let ret = "";
        for (let i = 0; i < NCH(n); ++i) {
            const child = CHILD(n, i);
            try {
                ret = ret + parsestr(c, child.value);
            }
            catch (x) {
                throw syntaxError("invalid string (possibly contains a unicode character)", child.range);
            }
        }
        return ret;
    }
    function parsenumber(c, s, range) {
        const endChar = s.charAt(s.length - 1);
        if (endChar === 'j' || endChar === 'J') {
            throw syntaxError("complex numbers are currently unsupported", range);
        }
        if (s.indexOf('.') !== -1) {
            return floatAST(s);
        }
        // Handle integers of various bases
        let tmp = s;
        let value;
        let radix = 10;
        let neg = false;
        if (s.charAt(0) === '-') {
            tmp = s.substr(1);
            neg = true;
        }
        if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X')) {
            // Hex
            tmp = tmp.substring(2);
            value = parseInt(tmp, 16);
            radix = 16;
        }
        else if ((s.indexOf('e') !== -1) || (s.indexOf('E') !== -1)) {
            // Float with exponent (needed to make sure e/E wasn't hex first)
            return floatAST(s);
        }
        else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B')) {
            // Binary
            tmp = tmp.substring(2);
            value = parseInt(tmp, 2);
            radix = 2;
        }
        else if (tmp.charAt(0) === '0') {
            if (tmp === "0") {
                // Zero
                value = 0;
            }
            else {
                // Octal (Leading zero, but not actually zero)
                if (endChar === 'l' || endChar === 'L') {
                    return longAST(s.substr(0, s.length - 1), 8);
                }
                else {
                    radix = 8;
                    tmp = tmp.substring(1);
                    if ((tmp.charAt(0) === 'o') || (tmp.charAt(0) === 'O')) {
                        tmp = tmp.substring(1);
                    }
                    value = parseInt(tmp, 8);
                }
            }
        }
        else {
            // Decimal
            if (endChar === 'l' || endChar === 'L') {
                return longAST(s.substr(0, s.length - 1), radix);
            }
            else {
                value = parseInt(tmp, radix);
            }
        }
        // Convert to long
        if (value > LONG_THRESHOLD && Math.floor(value) === value && (s.indexOf('e') === -1 && s.indexOf('E') === -1)) {
            // TODO: Does radix zero make sense?
            return longAST(s, 0);
        }
        if (endChar === 'l' || endChar === 'L') {
            return longAST(s.substr(0, s.length - 1), radix);
        }
        else {
            if (neg) {
                return intAST(-value);
            }
            else {
                return intAST(value);
            }
        }
    }
    function astForSlice(c, node) {
        const n = node;
        REQ(n, SYM.subscript);
        let ch = CHILD(n, 0);
        let lower = null;
        let upper = null;
        let step = null;
        if (ch.type === exports.Tokens.T_DOT) {
            return new Ellipsis();
        }
        if (NCH(n) === 1 && ch.type === SYM.IfExpr) {
            const value = astForExpr(c, ch);
            return new Index(value);
        }
        if (ch.type === SYM.IfExpr) {
            lower = astForExpr(c, ch);
        }
        if (ch.type === exports.Tokens.T_COLON) {
            if (NCH(n) > 1) {
                const n2 = CHILD(n, 1);
                if (n2.type === SYM.IfExpr)
                    upper = astForExpr(c, n2);
            }
        }
        else if (NCH(n) > 2) {
            const n2 = CHILD(n, 2);
            if (n2.type === SYM.IfExpr) {
                upper = astForExpr(c, n2);
            }
        }
        ch = CHILD(n, NCH(n) - 1);
        if (ch.type === SYM.sliceop) {
            if (NCH(ch) === 1) {
                ch = CHILD(ch, 0);
                step = new Name(new RangeAnnotated("None", null), Load);
            }
            else {
                ch = CHILD(ch, 1);
                if (ch.type === SYM.IfExpr)
                    step = astForExpr(c, ch);
            }
        }
        return new Slice(lower, upper, step);
    }
    function astForAtomExpr(c, n) {
        const c0 = CHILD(n, 0);
        switch (c0.type) {
            case exports.Tokens.T_NAME:
                // All names start in Load context, but may be changed later
                return new Name(new RangeAnnotated(c0.value, c0.range), Load);
            case exports.Tokens.T_STRING: {
                // FIXME: Owing to the way that Python allows string concatenation, this is imprecise.
                return new Str(new RangeAnnotated(parsestrplus(c, n), n.range));
            }
            case exports.Tokens.T_NUMBER: {
                return new Num(new RangeAnnotated(parsenumber(c, c0.value, c0.range), n.range));
            }
            case exports.Tokens.T_LPAR: { // various uses for parens
                const c1 = CHILD(n, 1);
                if (c1.type === exports.Tokens.T_RPAR) {
                    return new Tuple([], Load, n.range);
                }
                if (c1.type === SYM.YieldExpr) {
                    return astForExpr(c, c1);
                }
                if (NCH(c1) > 1 && CHILD(c1, 1).type === SYM.gen_for) {
                    return astForGenexp(c, c1);
                }
                return astForTestlistGexp(c, c1);
            }
            case exports.Tokens.T_LSQB: { // list or listcomp
                const c1 = CHILD(n, 1);
                if (c1.type === exports.Tokens.T_RSQB)
                    return new List([], Load, n.range);
                REQ(c1, SYM.listmaker);
                if (NCH(c1) === 1 || CHILD(c1, 1).type === exports.Tokens.T_COMMA)
                    return new List(seqForTestlist(c, c1), Load, n.range);
                else
                    return astForListcomp(c, c1);
            }
            case exports.Tokens.T_LBRACE: {
                /* dictmaker: test ':' test (',' test ':' test)* [','] */
                const c1 = CHILD(n, 1);
                const N = NCH(c1);
                // var size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case
                const keys = [];
                const values = [];
                for (let i = 0; i < N; i += 4) {
                    keys[i / 4] = astForExpr(c, CHILD(c1, i));
                    values[i / 4] = astForExpr(c, CHILD(c1, i + 2));
                }
                return new Dict(keys, values, n.range);
            }
            case exports.Tokens.T_BACKQUOTE: {
                throw syntaxError("backquote not supported, use repr()", n.range);
            }
            default: {
                throw new Error(`unhandled atom '${grammarName(c0.type)}'`);
            }
        }
    }
    /**
     * PowerExpr: AtomExpr trailer* ['**' UnaryExpr]
     */
    function astForPowerExpr(c, node) {
        const n = node;
        REQ(n, SYM.PowerExpr);
        const N = NCH(n);
        const NminusOne = N - 1;
        let lhs = astForAtomExpr(c, CHILD(n, 0));
        // If there is only one child then we have an AtomExpr with no trailer.
        if (N === 1)
            return lhs;
        for (let i = 1; i < N; ++i) {
            const ch = CHILD(n, i);
            if (ch.type !== SYM.trailer) {
                break;
            }
            lhs = astForTrailer(c, ch, lhs);
        }
        if (CHILD(n, NminusOne).type === SYM.UnaryExpr) {
            const rhs = astForExpr(c, CHILD(n, NminusOne));
            return new BinOp(lhs, getOperator(CHILD(n, N - 2)), rhs, n.range);
        }
        else {
            return lhs;
        }
    }
    function astForExpr(c, n) {
        LOOP: while (true) {
            switch (n.type) {
                case SYM.IfExpr:
                case SYM.old_test:
                    if (CHILD(n, 0).type === SYM.LambdaExpr || CHILD(n, 0).type === SYM.old_LambdaExpr)
                        return astForLambdef(c, CHILD(n, 0));
                    else if (NCH(n) > 1)
                        return astForIfexpr(c, n);
                // fallthrough
                case SYM.OrExpr:
                case SYM.AndExpr:
                    if (NCH(n) === 1) {
                        n = CHILD(n, 0);
                        continue LOOP;
                    }
                    const seq = [];
                    for (let i = 0; i < NCH(n); i += 2) {
                        seq[i / 2] = astForExpr(c, CHILD(n, i));
                    }
                    if (CHILD(n, 1).value === "and") {
                        return new BoolOp(And, seq, n.range);
                    }
                    assert(CHILD(n, 1).value === "or");
                    return new BoolOp(Or, seq, n.range);
                case SYM.NotExpr:
                    if (NCH(n) === 1) {
                        n = CHILD(n, 0);
                        continue LOOP;
                    }
                    else {
                        return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.range);
                    }
                case SYM.ComparisonExpr:
                    if (NCH(n) === 1) {
                        n = CHILD(n, 0);
                        continue LOOP;
                    }
                    else {
                        const ops = [];
                        const cmps = [];
                        for (let i = 1; i < NCH(n); i += 2) {
                            ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
                            cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));
                        }
                        return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.range);
                    }
                case SYM.ArithmeticExpr:
                case SYM.GeometricExpr:
                case SYM.ShiftExpr:
                case SYM.BitwiseOrExpr:
                case SYM.BitwiseXorExpr:
                case SYM.BitwiseAndExpr:
                    if (NCH(n) === 1) {
                        n = CHILD(n, 0);
                        continue LOOP;
                    }
                    return astForBinop(c, n);
                case SYM.YieldExpr:
                    let exp = null;
                    if (NCH(n) === 2) {
                        exp = astForTestlist(c, CHILD(n, 1));
                    }
                    return new Yield(exp, n.range);
                case SYM.UnaryExpr:
                    if (NCH(n) === 1) {
                        n = CHILD(n, 0);
                        continue LOOP;
                    }
                    return astForUnaryExpr(c, n);
                case SYM.PowerExpr:
                    return astForPowerExpr(c, n);
                default: {
                    // TODO: Opportunity for structured Error here.
                    throw new Error(`unhandled expr: n.type: ${n.type}, n.value: ${n.value}, n.range= ${n.range}, dump=${cstDump(n)}`);
                }
            }
        }
    }
    function astForPrintStmt(c, n) {
        let start = 1;
        let dest = null;
        REQ(n, SYM.print_stmt);
        if (NCH(n) >= 2 && CHILD(n, 1).type === exports.Tokens.T_RIGHTSHIFT) {
            dest = astForExpr(c, CHILD(n, 2));
            start = 4;
        }
        const seq = [];
        for (let i = start, j = 0; i < NCH(n); i += 2, ++j) {
            seq[j] = astForExpr(c, CHILD(n, i));
        }
        const nl = (CHILD(n, NCH(n) - 1)).type === exports.Tokens.T_COMMA ? false : true;
        return new Print(dest, seq, nl, n.range);
    }
    function astForStmt(c, n) {
        if (n.type === SYM.stmt) {
            assert(NCH(n) === 1);
            n = CHILD(n, 0);
        }
        if (n.type === SYM.simple_stmt) {
            assert(numStmts(n) === 1);
            n = CHILD(n, 0);
        }
        if (n.type === SYM.small_stmt) {
            REQ(n, SYM.small_stmt);
            n = CHILD(n, 0);
            switch (n.type) {
                case SYM.ExprStmt: return astForExprStmt(c, n);
                case SYM.print_stmt: return astForPrintStmt(c, n);
                case SYM.del_stmt: return astForDelStmt(c, n);
                case SYM.pass_stmt: return new Pass(n.range);
                case SYM.flow_stmt: return astForFlowStmt(c, n);
                case SYM.import_stmt: return astForImportStmt(c, n);
                case SYM.GlobalStmt: return astForGlobalStmt(c, n);
                case SYM.NonLocalStmt: return astForNonLocalStmt(c, n);
                case SYM.exec_stmt: return astForExecStmt(c, n);
                case SYM.assert_stmt: return astForAssertStmt(c, n);
                default: {
                    throw new Error("unhandled small_stmt");
                }
            }
        }
        else {
            const ch = CHILD(n, 0);
            REQ(n, SYM.compound_stmt);
            switch (ch.type) {
                case SYM.if_stmt: return astForIfStmt(c, ch);
                case SYM.while_stmt: return astForWhileStmt(c, ch);
                case SYM.for_stmt: return astForForStmt(c, ch);
                case SYM.try_stmt: return astForTryStmt(c, ch);
                case SYM.with_stmt: return astForWithStmt(c, ch);
                case SYM.funcdef: return astForFuncdef(c, ch, []);
                case SYM.classdef: return astForClassdef(c, ch, []);
                case SYM.decorated: return astForDecorated(c, ch);
                default: {
                    throw new Error("unhandled compound_stmt");
                }
            }
        }
    }
    function astFromExpression(n) {
        const c = new Compiling("utf-8");
        return astForExpr(c, n);
    }
    /**
     * TODO: Documentation
     * @param n
     * @returns
     */
    function astFromParse(n) {
        const c = new Compiling("utf-8");
        const stmts = [];
        let k = 0;
        for (let i = 0; i < NCH(n) - 1; ++i) {
            let ch = CHILD(n, i);
            if (n.type === exports.Tokens.T_NEWLINE)
                continue;
            REQ(ch, SYM.stmt);
            const num = numStmts(ch);
            if (num === 1) {
                stmts[k++] = astForStmt(c, ch);
            }
            else {
                ch = CHILD(ch, 0);
                REQ(ch, SYM.simple_stmt);
                for (let j = 0; j < num; ++j) {
                    stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
                }
            }
        }
        return stmts;
        /*
        switch (n.type) {
            case SYM.file_input:
            case SYM.eval_input: {
                throw new Error("todo;");
            }
            case SYM.single_input: {
                throw new Error("todo;");
            }
            default: {
                throw new Error("todo;");
            }
        }
        */
    }
    /**
     * TODO; Documentation
     * @param node
     * @returns
     */
    function astDump(node) {
        const _format = function (node) {
            if (node === null) {
                return "None";
            }
            else if (node['prototype'] && node['prototype']._astname !== undefined && node['prototype']._isenum) {
                // TODO: Replace the _isenum classes with real TypeScript enum.
                // TODO: Why do we have the parens?
                return node['prototype']._astname + "()";
            }
            else if (node['_astname'] !== undefined) {
                const fields = [];
                for (let i = 0; i < node['_fields'].length; i += 2) {
                    const a = node['_fields'][i]; // field name
                    const b = node['_fields'][i + 1](node); // field getter func
                    fields.push([a, _format(b)]);
                }
                const attrs = [];
                for (let i = 0; i < fields.length; ++i) {
                    const field = fields[i];
                    attrs.push(field[0] + "=" + field[1].replace(/^\s+/, ''));
                }
                const fieldstr = attrs.join(',');
                return node['_astname'] + "(" + fieldstr + ")";
            }
            else if (Array.isArray(node)) {
                const elems = [];
                for (let i = 0; i < node.length; ++i) {
                    const x = node[i];
                    elems.push(_format(x));
                }
                const elemsstr = elems.join(',');
                return "[" + elemsstr.replace(/^\s+/, '') + "]";
            }
            else {
                let ret;
                if (node === true)
                    ret = "True";
                else if (node === false)
                    ret = "False";
                else
                    ret = "" + node;
                return ret;
            }
        };
        return _format(node);
    }

    /* Flags for def-use information */
    const DEF_GLOBAL = 1 << 0; /* global stmt */
    const DEF_LOCAL = 2 << 0; /* assignment in code block */
    const DEF_PARAM = 2 << 1; /* formal parameter */
    const USE = 2 << 2; /* name is used */
    const DEF_FREE_CLASS = 2 << 8; /* free variable from class's method */
    const DEF_IMPORT = 2 << 9; /* assignment occurred via import */
    const DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);
    /* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol
       table.  GLOBAL is returned from PyST_GetScope() for either of them.
       It is stored in ste_symbols at bits 12-14.
    */
    const SCOPE_OFF = 11;
    const SCOPE_MASK = 7;
    const LOCAL = 1;
    const GLOBAL_EXPLICIT = 2;
    const GLOBAL_IMPLICIT = 3;
    const FREE = 4;
    const CELL = 5;
    const ModuleBlock = 'module';
    const FunctionBlock = 'function';
    const ClassBlock = 'class';

    class Symbol {
        /**
         * @param name
         * @param flags
         * @param namespaces
         */
        constructor(name, flags, namespaces) {
            this.__name = name;
            this.__flags = flags;
            this.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK;
            this.__namespaces = namespaces || [];
        }
        get_name() { return this.__name; }
        is_referenced() { return !!(this.__flags & USE); }
        is_parameter() {
            return !!(this.__flags & DEF_PARAM);
        }
        is_global() {
            return this.__scope === GLOBAL_IMPLICIT || this.__scope === GLOBAL_EXPLICIT;
        }
        is_declared_global() {
            return this.__scope === GLOBAL_EXPLICIT;
        }
        is_local() {
            return !!(this.__flags & DEF_BOUND);
        }
        is_free() { return this.__scope === FREE; }
        is_imported() { return !!(this.__flags & DEF_IMPORT); }
        is_assigned() { return !!(this.__flags & DEF_LOCAL); }
        is_namespace() { return this.__namespaces && this.__namespaces.length > 0; }
        get_namespaces() { return this.__namespaces; }
    }

    function dictUpdate(a, b) {
        for (let kb in b) {
            if (b.hasOwnProperty(kb)) {
                a[kb] = b[kb];
            }
        }
    }

    /**
     * @param priv
     * @param name
     */
    function mangleName(priv, name) {
        let strpriv = null;
        if (priv === null || name === null || name.charAt(0) !== '_' || name.charAt(1) !== '_') {
            return name;
        }
        // don't mangle dunder (double underscore) names e.g. __id__.
        if (name.charAt(name.length - 1) === '_' && name.charAt(name.length - 2) === '_') {
            return name;
        }
        // don't mangle classes that are all _ (obscure much?)
        strpriv = priv;
        strpriv.replace(/_/g, '');
        if (strpriv === '') {
            return name;
        }
        strpriv = priv;
        strpriv.replace(/^_*/, '');
        strpriv = '_' + strpriv + name;
        return strpriv;
    }

    let astScopeCounter = 0;
    /**
     * A SymbolTableScope is created for nodes in the AST.
     * It is created only when the SymbolTable enters a block.
     */
    class SymbolTableScope {
        /**
         * @param table
         * @param name The name of the node defining the scope.
         * @param blockType
         * @param astNode
         * @param range
         */
        constructor(table, name, blockType, astNode, range) {
            /**
             * A mapping from the name of a symbol to its flags.
             */
            this.symFlags = {};
            /**
             * A list of (local) variables that exists in the current scope.
             * This is populated by the addDef method in SymbolTable.
             * e.g. Name, FunctionDef, ClassDef, Global?, Lambda, Alias.
             * Note that global variables are maintained in the SymbolTable to which we have access.
             */
            this.varnames = [];
            this.children = [];
            // this.table = table;
            this.name = name;
            this.blockType = blockType;
            astNode.scopeId = astScopeCounter++;
            table.stss[astNode.scopeId] = this;
            this.range = range;
            if (table.cur && (table.cur.isNested || table.cur.blockType === FunctionBlock)) {
                this.isNested = true;
            }
            else {
                this.isNested = false;
            }
            this.hasFree = false;
            this.childHasFree = false; // true if child block has free vars including free refs to globals
            this.generator = false;
            this.varargs = false;
            this.varkeywords = false;
            this.returnsValue = false;
            // cache of Symbols for returning to other parts of code
            this.symbols = {};
        }
        get_type() { return this.blockType; }
        get_name() { return this.name; }
        get_range() { return this.range; }
        is_nested() { return this.isNested; }
        has_children() { return this.children.length > 0; }
        get_identifiers() { return this._identsMatching(function (x) { return true; }); }
        lookup(name) {
            let sym;
            if (!this.symbols.hasOwnProperty(name)) {
                const flags = this.symFlags[name];
                const namespaces = this.__check_children(name);
                sym = this.symbols[name] = new Symbol(name, flags, namespaces);
            }
            else {
                sym = this.symbols[name];
            }
            return sym;
        }
        __check_children(name) {
            // print("  check_children:", name);
            const ret = [];
            for (let i = 0; i < this.children.length; ++i) {
                const child = this.children[i];
                if (child.name === name)
                    ret.push(child);
            }
            return ret;
        }
        /**
         * Looks in the bindings for this scope and returns the names of the nodes that match the mask filter.
         */
        _identsMatching(filter) {
            const ret = [];
            for (let k in this.symFlags) {
                if (this.symFlags.hasOwnProperty(k)) {
                    if (filter(this.symFlags[k]))
                        ret.push(k);
                }
            }
            ret.sort();
            return ret;
        }
        /**
         * Returns the names of parameters (DEF_PARAM) for function scopes.
         */
        get_parameters() {
            assert(this.get_type() === 'function', "get_parameters only valid for function scopes");
            if (!this._funcParams) {
                this._funcParams = this._identsMatching(function (x) { return !!(x & DEF_PARAM); });
            }
            return this._funcParams;
        }
        /**
         * Returns the names of local variables (DEF_BOUND) for function scopes.
         */
        get_locals() {
            assert(this.get_type() === 'function', "get_locals only valid for function scopes");
            if (!this._funcLocals) {
                this._funcLocals = this._identsMatching(function (x) { return !!(x & DEF_BOUND); });
            }
            return this._funcLocals;
        }
        /**
         * Returns the names of global variables for function scopes.
         */
        get_globals() {
            assert(this.get_type() === 'function', "get_globals only valid for function scopes");
            if (!this._funcGlobals) {
                this._funcGlobals = this._identsMatching(function (x) {
                    const masked = (x >> SCOPE_OFF) & SCOPE_MASK;
                    return masked === GLOBAL_IMPLICIT || masked === GLOBAL_EXPLICIT;
                });
            }
            return this._funcGlobals;
        }
        /**
         * Returns the names of free variables for function scopes.
         */
        get_frees() {
            assert(this.get_type() === 'function', "get_frees only valid for function scopes");
            if (!this._funcFrees) {
                this._funcFrees = this._identsMatching(function (x) {
                    const masked = (x >> SCOPE_OFF) & SCOPE_MASK;
                    return masked === FREE;
                });
            }
            return this._funcFrees;
        }
        /**
         * Returns the names of methods for class scopes.
         */
        get_methods() {
            assert(this.get_type() === 'class', "get_methods only valid for class scopes");
            if (!this._classMethods) {
                // todo; uniq?
                const all = [];
                for (let i = 0; i < this.children.length; ++i)
                    all.push(this.children[i].name);
                all.sort();
                this._classMethods = all;
            }
            return this._classMethods;
        }
        /**
         * I think this returns the scopeId of a node with the specified name.
         */
        getScope(name) {
            // print("getScope");
            // for (var k in this.symFlags) print(k);
            const v = this.symFlags[name];
            if (v === undefined)
                return 0;
            return (v >> SCOPE_OFF) & SCOPE_MASK;
        }
    }

    /**
     * The symbol table uses the abstract synntax tree (not the parse tree).
     */
    class SymbolTable {
        /**
         *
         */
        constructor() {
            this.cur = null;
            this.top = null;
            this.stack = [];
            this.global = null; // points at top level module symFlags
            this.curClass = null; // current class or null
            this.tmpname = 0;
            // mapping from ast nodes to their scope if they have one. we add an
            // id to the ast node when a scope is created for it, and store it in
            // here for the compiler to lookup later.
            this.stss = {};
        }
        /**
         * Lookup the SymbolTableScope for a scopeId of the AST.
         */
        getStsForAst(ast) {
            assert(ast.scopeId !== undefined, "ast wasn't added to st?");
            const v = this.stss[ast.scopeId];
            assert(v !== undefined, "unknown sym tab entry");
            return v;
        }
        SEQStmt(nodes) {
            const len = nodes.length;
            for (let i = 0; i < len; ++i) {
                const val = nodes[i];
                if (val)
                    this.visitStmt(val);
            }
        }
        SEQExpr(nodes) {
            const len = nodes.length;
            for (let i = 0; i < len; ++i) {
                const val = nodes[i];
                if (val)
                    this.visitExpr(val);
            }
        }
        /**
         * A block represents a scope.
         * The following nodes in the AST define new blocks of the indicated type and name:
         * Module        ModuleBlock   = 'module'    name = 'top'
         * FunctionDef   FunctionBlock = 'function'  name = The name of the function.
         * ClassDef      ClassBlock    = 'class'     name = The name of the class.
         * Lambda        FunctionBlock = 'function'  name = 'lambda'
         * GeneratoeExp  FunctionBlock = 'function'  name = 'genexpr'
         *
         * @param name
         * @param blockType
         * @param astNode The AST node that is defining the block.
         * @param lineno
         */
        enterBlock(name, blockType, astNode, range) {
            //  name = fixReservedNames(name);
            let prev = null;
            if (this.cur) {
                prev = this.cur;
                this.stack.push(this.cur);
            }
            this.cur = new SymbolTableScope(this, name, blockType, astNode, range);
            if (name === 'top') {
                this.global = this.cur.symFlags;
            }
            if (prev) {
                prev.children.push(this.cur);
            }
        }
        exitBlock() {
            // print("exitBlock");
            this.cur = null;
            if (this.stack.length > 0)
                this.cur = this.stack.pop();
        }
        visitParams(args, toplevel) {
            for (let i = 0; i < args.length; ++i) {
                const arg = args[i];
                if (arg.name.constructor === Name) {
                    assert(arg.name.ctx === Param || (arg.name.ctx === Store && !toplevel));
                    this.addDef(arg.name.id.value, DEF_PARAM, arg.name.id.range);
                }
                else {
                    // Tuple isn't supported
                    throw syntaxError$1("invalid expression in parameter list");
                }
            }
        }
        visitArguments(a, range) {
            if (a.args)
                this.visitParams(a.args, true);
            if (a.vararg) {
                this.addDef(a.vararg, DEF_PARAM, range);
                this.cur.varargs = true;
            }
            if (a.kwarg) {
                this.addDef(a.kwarg, DEF_PARAM, range);
                this.cur.varkeywords = true;
            }
        }
        /**
         *
         */
        newTmpname(range) {
            this.addDef("_[" + (++this.tmpname) + "]", DEF_LOCAL, range);
        }
        /**
         * 1. Modifies symbol flags for the current scope.
         * 2.a Adds a variable name for the current scope, OR
         * 2.b Sets the SymbolFlags for a global variable.
         * @param name
         * @param flags
         * @param lineno
         */
        addDef(name, flags, range) {
            const mangled = mangleName(this.curClass, name);
            //  mangled = fixReservedNames(mangled);
            // Modify symbol flags for the current scope.
            let val = this.cur.symFlags[mangled];
            if (val !== undefined) {
                if ((flags & DEF_PARAM) && (val & DEF_PARAM)) {
                    throw syntaxError$1("duplicate argument '" + name + "' in function definition", range);
                }
                val |= flags;
            }
            else {
                val = flags;
            }
            this.cur.symFlags[mangled] = val;
            if (flags & DEF_PARAM) {
                this.cur.varnames.push(mangled);
            }
            else if (flags & DEF_GLOBAL) {
                val = flags;
                const fromGlobal = this.global[mangled];
                if (fromGlobal !== undefined)
                    val |= fromGlobal;
                this.global[mangled] = val;
            }
        }
        visitSlice(s) {
            if (s instanceof Slice) {
                if (s.lower)
                    this.visitExpr(s.lower);
                if (s.upper)
                    this.visitExpr(s.upper);
                if (s.step)
                    this.visitExpr(s.step);
            }
            else if (s instanceof ExtSlice) {
                for (let i = 0; i < s.dims.length; ++i) {
                    this.visitSlice(s.dims[i]);
                }
            }
            else if (s instanceof Index) {
                this.visitExpr(s.value);
            }
            else ;
        }
        /**
         *
         */
        visitStmt(s) {
            assert(s !== undefined, "visitStmt called with undefined");
            if (s instanceof FunctionDef) {
                this.addDef(s.name.value, DEF_LOCAL, s.range);
                if (s.args.defaults)
                    this.SEQExpr(s.args.defaults);
                if (s.decorator_list)
                    this.SEQExpr(s.decorator_list);
                this.enterBlock(s.name.value, FunctionBlock, s, s.range);
                this.visitArguments(s.args, s.range);
                this.SEQStmt(s.body);
                this.exitBlock();
            }
            else if (s instanceof ClassDef) {
                this.addDef(s.name.value, DEF_LOCAL, s.range);
                this.SEQExpr(s.bases);
                if (s.decorator_list)
                    this.SEQExpr(s.decorator_list);
                this.enterBlock(s.name.value, ClassBlock, s, s.range);
                const tmp = this.curClass;
                this.curClass = s.name.value;
                this.SEQStmt(s.body);
                this.curClass = tmp;
                this.exitBlock();
            }
            else if (s instanceof ReturnStatement) {
                if (s.value) {
                    this.visitExpr(s.value);
                    this.cur.returnsValue = true;
                    if (this.cur.generator) {
                        throw syntaxError$1("'return' with argument inside generator");
                    }
                }
            }
            else if (s instanceof DeleteStatement) {
                this.SEQExpr(s.targets);
            }
            else if (s instanceof Assign) {
                this.SEQExpr(s.targets);
                this.visitExpr(s.value);
            }
            else if (s instanceof AugAssign) {
                this.visitExpr(s.target);
                this.visitExpr(s.value);
            }
            else if (s instanceof AnnAssign) {
                this.visitExpr(s.target);
                this.visitExpr(s.value);
            }
            else if (s instanceof Print) {
                if (s.dest)
                    this.visitExpr(s.dest);
                this.SEQExpr(s.values);
            }
            else if (s instanceof ForStatement) {
                this.visitExpr(s.target);
                this.visitExpr(s.iter);
                this.SEQStmt(s.body);
                if (s.orelse)
                    this.SEQStmt(s.orelse);
            }
            else if (s instanceof WhileStatement) {
                this.visitExpr(s.test);
                this.SEQStmt(s.body);
                if (s.orelse)
                    this.SEQStmt(s.orelse);
            }
            else if (s instanceof IfStatement) {
                this.visitExpr(s.test);
                this.SEQStmt(s.consequent);
                if (s.alternate) {
                    this.SEQStmt(s.alternate);
                }
            }
            else if (s instanceof Raise) {
                if (s.type) {
                    this.visitExpr(s.type);
                    if (s.inst) {
                        this.visitExpr(s.inst);
                        if (s.tback)
                            this.visitExpr(s.tback);
                    }
                }
            }
            else if (s instanceof TryExcept) {
                this.SEQStmt(s.body);
                this.SEQStmt(s.orelse);
                this.visitExcepthandlers(s.handlers);
            }
            else if (s instanceof TryFinally) {
                this.SEQStmt(s.body);
                this.SEQStmt(s.finalbody);
            }
            else if (s instanceof Assert) {
                this.visitExpr(s.test);
                if (s.msg)
                    this.visitExpr(s.msg);
            }
            else if (s instanceof ImportStatement) {
                const imps = s;
                this.visitAlias(imps.names, imps.range);
            }
            else if (s instanceof ImportFrom) {
                const impFrom = s;
                this.visitAlias(impFrom.names, impFrom.range);
            }
            else if (s instanceof Exec) {
                this.visitExpr(s.body);
                if (s.globals) {
                    this.visitExpr(s.globals);
                    if (s.locals)
                        this.visitExpr(s.locals);
                }
            }
            else if (s instanceof Global) {
                const nameslen = s.names.length;
                for (let i = 0; i < nameslen; ++i) {
                    const name = mangleName(this.curClass, s.names[i]);
                    //              name = fixReservedNames(name);
                    const cur = this.cur.symFlags[name];
                    if (cur & (DEF_LOCAL | USE)) {
                        if (cur & DEF_LOCAL) {
                            throw syntaxError$1("name '" + name + "' is assigned to before global declaration", s.range);
                        }
                        else {
                            throw syntaxError$1("name '" + name + "' is used prior to global declaration", s.range);
                        }
                    }
                    this.addDef(name, DEF_GLOBAL, s.range);
                }
            }
            else if (s instanceof ExpressionStatement) {
                this.visitExpr(s.value);
            }
            else if (s instanceof Pass || s instanceof BreakStatement || s instanceof ContinueStatement) ;
            else if (s instanceof WithStatement) {
                const ws = s;
                this.newTmpname(ws.range);
                this.visitExpr(ws.context_expr);
                if (ws.optional_vars) {
                    this.newTmpname(ws.range);
                    this.visitExpr(ws.optional_vars);
                }
                this.SEQStmt(ws.body);
            }
            else {
                fail("Unhandled type " + s.constructor.name + " in visitStmt");
            }
        }
        visitExpr(e) {
            assert(e !== undefined, "visitExpr called with undefined");
            if (e instanceof BoolOp) {
                this.SEQExpr(e.values);
            }
            else if (e instanceof BinOp) {
                this.visitExpr(e.lhs);
                this.visitExpr(e.rhs);
            }
            else if (e instanceof UnaryOp) {
                this.visitExpr(e.operand);
            }
            else if (e instanceof Lambda) {
                this.addDef("lambda", DEF_LOCAL, e.range);
                if (e.args.defaults)
                    this.SEQExpr(e.args.defaults);
                this.enterBlock("lambda", FunctionBlock, e, e.range);
                this.visitArguments(e.args, e.range);
                this.visitExpr(e.body);
                this.exitBlock();
            }
            else if (e instanceof IfExp) {
                this.visitExpr(e.test);
                this.visitExpr(e.body);
                this.visitExpr(e.orelse);
            }
            else if (e instanceof Dict) {
                this.SEQExpr(e.keys);
                this.SEQExpr(e.values);
            }
            else if (e instanceof ListComp) {
                this.newTmpname(e.range);
                this.visitExpr(e.elt);
                this.visitComprehension(e.generators, 0);
            }
            else if (e instanceof GeneratorExp) {
                this.visitGenexp(e);
            }
            else if (e instanceof Yield) {
                if (e.value)
                    this.visitExpr(e.value);
                this.cur.generator = true;
                if (this.cur.returnsValue) {
                    throw syntaxError$1("'return' with argument inside generator");
                }
            }
            else if (e instanceof Compare) {
                this.visitExpr(e.left);
                this.SEQExpr(e.comparators);
            }
            else if (e instanceof Call) {
                this.visitExpr(e.func);
                this.SEQExpr(e.args);
                for (let i = 0; i < e.keywords.length; ++i)
                    this.visitExpr(e.keywords[i].value);
                // print(JSON.stringify(e.starargs, null, 2));
                // print(JSON.stringify(e.kwargs, null,2));
                if (e.starargs)
                    this.visitExpr(e.starargs);
                if (e.kwargs)
                    this.visitExpr(e.kwargs);
            }
            else if (e instanceof Num || e instanceof Str) ;
            else if (e instanceof Attribute) {
                this.visitExpr(e.value);
            }
            else if (e instanceof Subscript) {
                this.visitExpr(e.value);
                this.visitSlice(e.slice);
            }
            else if (e instanceof Name) {
                this.addDef(e.id.value, e.ctx === Load ? USE : DEF_LOCAL, e.id.range);
            }
            else if (e instanceof List || e instanceof Tuple) {
                this.SEQExpr(e.elts);
            }
            else {
                fail("Unhandled type " + e.constructor.name + " in visitExpr");
            }
        }
        visitComprehension(lcs, startAt) {
            const len = lcs.length;
            for (let i = startAt; i < len; ++i) {
                const lc = lcs[i];
                this.visitExpr(lc.target);
                this.visitExpr(lc.iter);
                this.SEQExpr(lc.ifs);
            }
        }
        /**
         * This is probably not correct for names. What are they?
         * @param names
         * @param range
         */
        visitAlias(names, range) {
            /* Compute store_name, the name actually bound by the import
                operation.  It is diferent than a->name when a->name is a
                dotted package name (e.g. spam.eggs)
            */
            for (const a of names) {
                const name = a.asname === null ? a.name.value : a.asname;
                let storename = name;
                const dot = name.indexOf('.');
                if (dot !== -1)
                    storename = name.substr(0, dot);
                if (name !== "*") {
                    this.addDef(storename, DEF_IMPORT, range);
                }
                else {
                    if (this.cur.blockType !== ModuleBlock) {
                        throw syntaxError$1("import * only allowed at module level");
                    }
                }
            }
        }
        /**
         *
         */
        visitGenexp(e) {
            const outermost = e.generators[0];
            // outermost is evaled in current scope
            this.visitExpr(outermost.iter);
            this.enterBlock("genexpr", FunctionBlock, e, e.range);
            this.cur.generator = true;
            this.addDef(".0", DEF_PARAM, e.range);
            this.visitExpr(outermost.target);
            this.SEQExpr(outermost.ifs);
            this.visitComprehension(e.generators, 1);
            this.visitExpr(e.elt);
            this.exitBlock();
        }
        visitExcepthandlers(handlers) {
            for (let i = 0, eh; eh = handlers[i]; ++i) {
                if (eh.type)
                    this.visitExpr(eh.type);
                if (eh.name)
                    this.visitExpr(eh.name);
                this.SEQStmt(eh.body);
            }
        }
        /**
         * @param ste The Symbol Table Scope.
         */
        analyzeBlock(ste, bound, free, global) {
            const local = {};
            const scope = {};
            const newglobal = {};
            const newbound = {};
            const newfree = {};
            if (ste.blockType === ClassBlock) {
                dictUpdate(newglobal, global);
                if (bound)
                    dictUpdate(newbound, bound);
            }
            for (let name in ste.symFlags) {
                if (ste.symFlags.hasOwnProperty(name)) {
                    const flags = ste.symFlags[name];
                    this.analyzeName(ste, scope, name, flags, bound, local, free, global);
                }
            }
            if (ste.blockType !== ClassBlock) {
                if (ste.blockType === FunctionBlock)
                    dictUpdate(newbound, local);
                if (bound)
                    dictUpdate(newbound, bound);
                dictUpdate(newglobal, global);
            }
            const allfree = {};
            const childlen = ste.children.length;
            for (let i = 0; i < childlen; ++i) {
                const c = ste.children[i];
                this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);
                if (c.hasFree || c.childHasFree)
                    ste.childHasFree = true;
            }
            dictUpdate(newfree, allfree);
            if (ste.blockType === FunctionBlock)
                this.analyzeCells(scope, newfree);
            this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);
            dictUpdate(free, newfree);
        }
        analyzeChildBlock(entry, bound, free, global, childFree) {
            const tempBound = {};
            dictUpdate(tempBound, bound);
            const tempFree = {};
            dictUpdate(tempFree, free);
            const tempGlobal = {};
            dictUpdate(tempGlobal, global);
            this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);
            dictUpdate(childFree, tempFree);
        }
        analyzeCells(scope, free) {
            for (let name in scope) {
                if (scope.hasOwnProperty(name)) {
                    const flags = scope[name];
                    if (flags !== LOCAL)
                        continue;
                    if (free[name] === undefined)
                        continue;
                    scope[name] = CELL;
                    delete free[name];
                }
            }
        }
        /**
         * store scope info back into the st symbols dict. symbols is modified,
         * others are not.
         */
        updateSymbols(symbols, scope, bound, free, classflag) {
            for (let name in symbols) {
                if (symbols.hasOwnProperty(name)) {
                    let flags = symbols[name];
                    const w = scope[name];
                    flags |= w << SCOPE_OFF;
                    symbols[name] = flags;
                }
            }
            const freeValue = FREE << SCOPE_OFF;
            for (let name in free) {
                if (free.hasOwnProperty(name)) {
                    const o = symbols[name];
                    if (o !== undefined) {
                        // it could be a free variable in a method of the class that has
                        // the same name as a local or global in the class scope
                        if (classflag && (o & (DEF_BOUND | DEF_GLOBAL))) {
                            const i = o | DEF_FREE_CLASS;
                            symbols[name] = i;
                        }
                        // else it's not free, probably a cell
                        continue;
                    }
                    if (bound[name] === undefined)
                        continue;
                    symbols[name] = freeValue;
                }
            }
        }
        /**
         * @param {Object} ste The Symbol Table Scope.
         * @param {string} name
         */
        analyzeName(ste, dict, name, flags, bound, local, free, global) {
            if (flags & DEF_GLOBAL) {
                if (flags & DEF_PARAM)
                    throw syntaxError$1("name '" + name + "' is local and global", ste.range);
                dict[name] = GLOBAL_EXPLICIT;
                global[name] = null;
                if (bound && bound[name] !== undefined)
                    delete bound[name];
                return;
            }
            if (flags & DEF_BOUND) {
                dict[name] = LOCAL;
                local[name] = null;
                delete global[name];
                return;
            }
            if (bound && bound[name] !== undefined) {
                dict[name] = FREE;
                ste.hasFree = true;
                free[name] = null;
            }
            else if (global && global[name] !== undefined) {
                dict[name] = GLOBAL_IMPLICIT;
            }
            else {
                if (ste.isNested)
                    ste.hasFree = true;
                dict[name] = GLOBAL_IMPLICIT;
            }
        }
        analyze() {
            const free = {};
            const global = {};
            this.analyzeBlock(this.top, null, free, global);
        }
    }

    // import { Symbol } from './Symbol';
    /**
     * Creates a SymbolTable for the specified Module.
     */
    function semanticsOfModule(mod) {
        const st = new SymbolTable();
        st.enterBlock("top", ModuleBlock, mod, null);
        st.top = st.cur;
        // This is a good place to dump the AST for debugging.
        for (const stmt of mod.body) {
            st.visitStmt(stmt);
        }
        st.exitBlock();
        st.analyze();
        return st;
    }

    exports.Add = Add;
    exports.Alias = Alias;
    exports.And = And;
    exports.AnnAssign = AnnAssign;
    exports.Arguments = Arguments;
    exports.Assert = Assert;
    exports.Assign = Assign;
    exports.Attribute = Attribute;
    exports.AugAssign = AugAssign;
    exports.AugLoad = AugLoad;
    exports.AugStore = AugStore;
    exports.BinOp = BinOp;
    exports.BitAnd = BitAnd;
    exports.BitOr = BitOr;
    exports.BitXor = BitXor;
    exports.BoolOp = BoolOp;
    exports.BreakStatement = BreakStatement;
    exports.Call = Call;
    exports.ClassDef = ClassDef;
    exports.Compare = Compare;
    exports.Comprehension = Comprehension;
    exports.ContinueStatement = ContinueStatement;
    exports.DEF_LOCAL = DEF_LOCAL;
    exports.Del = Del;
    exports.DeleteStatement = DeleteStatement;
    exports.Dict = Dict;
    exports.Div = Div;
    exports.Ellipsis = Ellipsis;
    exports.Eq = Eq;
    exports.ExceptHandler = ExceptHandler;
    exports.Exec = Exec;
    exports.Expression = Expression;
    exports.ExpressionStatement = ExpressionStatement;
    exports.ExtSlice = ExtSlice;
    exports.FloorDiv = FloorDiv;
    exports.ForStatement = ForStatement;
    exports.FunctionDef = FunctionDef;
    exports.FunctionParamDef = FunctionParamDef;
    exports.GeneratorExp = GeneratorExp;
    exports.Global = Global;
    exports.Gt = Gt;
    exports.GtE = GtE;
    exports.IfExp = IfExp;
    exports.IfStatement = IfStatement;
    exports.ImportFrom = ImportFrom;
    exports.ImportStatement = ImportStatement;
    exports.In = In;
    exports.Index = Index;
    exports.Interactive = Interactive;
    exports.Invert = Invert;
    exports.Is = Is;
    exports.IsNot = IsNot;
    exports.IterationStatement = IterationStatement;
    exports.Keyword = Keyword;
    exports.LShift = LShift;
    exports.Lambda = Lambda;
    exports.List = List;
    exports.ListComp = ListComp;
    exports.Load = Load;
    exports.Lt = Lt;
    exports.LtE = LtE;
    exports.Mod = Mod;
    exports.Module = Module;
    exports.Mult = Mult;
    exports.Name = Name;
    exports.NonLocal = NonLocal;
    exports.Not = Not;
    exports.NotEq = NotEq;
    exports.NotIn = NotIn;
    exports.Num = Num;
    exports.Or = Or;
    exports.Param = Param;
    exports.ParseError = ParseError;
    exports.Pass = Pass;
    exports.Position = Position;
    exports.Pow = Pow;
    exports.Print = Print;
    exports.RShift = RShift;
    exports.Raise = Raise;
    exports.Range = Range;
    exports.RangeAnnotated = RangeAnnotated;
    exports.ReturnStatement = ReturnStatement;
    exports.Slice = Slice;
    exports.Statement = Statement;
    exports.Store = Store;
    exports.Str = Str;
    exports.Sub = Sub;
    exports.Subscript = Subscript;
    exports.Suite = Suite;
    exports.Symbol = Symbol;
    exports.SymbolTable = SymbolTable;
    exports.SymbolTableScope = SymbolTableScope;
    exports.TokenError = TokenError;
    exports.TryExcept = TryExcept;
    exports.TryFinally = TryFinally;
    exports.Tuple = Tuple;
    exports.UAdd = UAdd;
    exports.USub = USub;
    exports.UnaryExpression = UnaryExpression;
    exports.UnaryOp = UnaryOp;
    exports.UnexpectedTokenError = UnexpectedTokenError;
    exports.WhileStatement = WhileStatement;
    exports.WithStatement = WithStatement;
    exports.Yield = Yield;
    exports.astDump = astDump;
    exports.astFromExpression = astFromExpression;
    exports.astFromParse = astFromParse;
    exports.cstDump = cstDump;
    exports.parse = parse;
    exports.semanticsOfModule = semanticsOfModule;

}));
//# sourceMappingURL=index.js.map
