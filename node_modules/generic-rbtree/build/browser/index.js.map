{"version":3,"file":"index.js","sources":["../../src/RBNode.ts","../../src/RBTree.ts"],"sourcesContent":["/**\n * \n */\nexport class RBNode<K, V> {\n    /**\n     * The left child link.\n     */\n    l: RBNode<K, V>;\n    /**\n     * The right child link.\n     */\n    r: RBNode<K, V>;\n    /**\n     * The parent of the node.\n     */\n    p: RBNode<K, V>;\n    /**\n     * The red (true) / black (false) flag.\n     */\n    flag = false;\n    /**\n     * Constructs a red-black binary tree node.\n     */\n    constructor(public key: K, public value: V) {\n        this.l = this;\n        this.r = this;\n        this.p = this;\n    }\n    /*\n    get red(): boolean {\n        return this.flag;\n    }\n    set red(red: boolean) {\n        this.flag = red;\n    }\n    get black(): boolean {\n        return !this.flag;\n    }\n    set black(black: boolean) {\n        this.flag = !black;\n    }\n    */\n    toString(): string {\n        return `${this.flag ? 'red' : 'black'} ${this.key}`;\n    }\n}\n","import { RBNode } from './RBNode';\n\nexport interface Comparator<K> {\n    (a: K, b: K): (-1 | 1 | 0);\n}\n\nexport class RBTree<K, V> {\n    /**\n     * The \"head\" node is provided to make insertion easier.\n     * It is not the root.\n     * It is not actually part of the tree.\n     * The right link of head points to the actual root node of the tree.\n     * The left link of the `head` is not used, so we store the tail node, z in it.\n     * The key for head is smaller than all other keys, consistent with the use of the right link.\n     */\n    public readonly head: RBNode<K, V>;\n    /**\n     * The number of keys inserted.\n     */\n    public N = 0;\n\n    private highNode: RBNode<K, V>;\n    private lowNode: RBNode<K, V>;\n\n    /**\n     * Initializes an RBTree.\n     * It is important to define a key that is smaller than all expected keys\n     * so that the first insert becomes the root (head.r).\n     *\n     * @param lowKey A key that is smaller than all expected keys.\n     * @param highKey A key that is larger than all expected keys.\n     * @param nilValue The value to return when a search is not successful.\n     * @param comp The comparator used for comparing keys.\n     */\n    constructor(lowKey: K, public readonly highKey: K, nilValue: V, private comp: Comparator<K>) {\n        this.lowNode = new RBNode<K, V>(lowKey, nilValue);\n        this.highNode = new RBNode<K, V>(highKey, nilValue);\n        // Notice that z does not have a key because it has to be less than and greater than every other key.\n        const z = new RBNode<K, V>(null as unknown as K, nilValue);\n        this.head = new RBNode<K, V>(lowKey, nilValue);\n        // Head left is never used or changed so we'll store the tail node there.\n        this.head.l = z;\n        // Head right refers the the actual tree root which is currently empty.\n        this.head.r = z;\n        this.head.p = this.head;\n    }\n\n    get root(): RBNode<K, V> {\n        return this.head.r;\n    }\n\n    set root(root: RBNode<K, V>) {\n        this.head.r = root;\n    }\n\n    /**\n     * The \"tail\" node.\n     * This allows our subtrees never to be undefined or null.\n     * All searches will result in a node, but misses will return the tail node.\n     */\n    get z(): RBNode<K, V> {\n        return this.head.l;\n    }\n\n    get lowKey(): K {\n        return this.head.key;\n    }\n\n    /**\n     * Legal means that is greater than the key stored in the head node.\n     * The key does not have to exist.\n     */\n    private assertLegalKey(key: K, comp: Comparator<K>): void {\n        if (comp(key, this.lowKey) <= 0) {\n            throw new Error(`key, ${key}, must be greater than the low key, ${this.lowKey}.`);\n        }\n        if (comp(key, this.highKey) >= 0) {\n            throw new Error(`key, ${key}, must be less than the high key, ${this.highKey}.`);\n        }\n    }\n\n    /**\n     *\n     */\n    insert(key: K, value: V): RBNode<K, V> {\n        const comp = this.comp;\n        this.assertLegalKey(key, comp);\n\n        const n = new RBNode(key, value);\n\n        rbInsert(this, n, comp);\n\n        this.root.flag = false;\n        // Update the count of nodes inserted.\n        this.N += 1;\n        return n;\n    }\n\n    /**\n     * Greatest Lower Bound of a key.\n     * Returns the node corresponding to the key if it exists, or the next lowest key.\n     * Returns null if there is no smaller key in the tree.\n     */\n    glb(key: K): RBNode<K, V> | null {\n        const comp = this.comp;\n        this.assertLegalKey(key, comp);\n        const low = this.lowNode;\n        const node = glb(this, this.root, key, comp, low);\n        if (node !== low) {\n            return node;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Least Upper Bound of a key.\n     * Returns the node corresponding to the key if it exists, or the next highest key.\n     * Returns null if there is no greater key in the tree.\n     */\n    lub(key: K): RBNode<K, V> | null {\n        const comp = this.comp;\n        this.assertLegalKey(key, comp);\n        const high = this.highNode;\n        const node = lub(this, this.root, key, comp, high);\n        if (node !== high) {\n            return node;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     *\n     */\n    search(key: K): V {\n        const comp = this.comp;\n        this.assertLegalKey(key, comp);\n        /**\n         * The current node for the search.\n         */\n        let x = this.root;\n\n        // The search will always be \"successful\" but may end with z.\n        this.z.key = key;\n\n        while (comp(key, x.key) !== 0) {\n            x = comp(key, x.key) < 0 ? x.l : x.r;\n        }\n\n        return x.value;\n    }\n\n    /**\n     *\n     * @param key\n     */\n    remove(key: K): void {\n        const comp = this.comp;\n        this.assertLegalKey(key, comp);\n\n        const head = this.head;\n        const z = this.z;\n        /**\n         * The current node for the search, we begin at the root.\n         */\n        let x = this.root;\n\n        /**\n         * The parent of the current node.\n         */\n        let p = head;\n\n        // The search will always be \"successful\" but may end with z.\n        z.key = key;\n\n        // Search in the normal way to get p and x.\n        while (comp(key, x.key) !== 0) {\n            p = x;\n            x = comp(key, x.key) < 0 ? x.l : x.r;\n        }\n\n        // Our search has terminated and x is either the node to be removed or z.\n        /**\n         * A reference to the node that we will be removing.\n         * This may point to z, but the following code also works in that case.\n         */\n        const t = x;\n\n        // From now on we will be making x reference the node that replaces t.\n\n        if (t.r === z) {\n            // The node t has no right child.\n            // The node that replaces t will be the left child of t.\n            x = t.l;\n        }\n        else if (t.r.l === z) {\n            // The node t has a right child with no left child.\n            // This empty slot can be used to accept t.l\n            x = t.r;\n            x.l = t.l;\n        }\n        else {\n            // The node with the next highest key must be in the r-l-l-l-l... path with a left child equal to z.\n            // It can't be anywhere else of there would be an intervening key.\n            // Note also that the previous tests have eliminated the case where\n            // there is no highets key. This node with the next highest key must have\n            // the property that it has an empty left child.\n            let c = t.r;\n            while (c.l.l !== z) {\n                c = c.l;\n            }\n            // We exit from the loop when c.l.l equals z, which means that c.l is the node that\n            // we want to use to replace t.\n            x = c.l;\n\n            c.l = x.r;\n            x.l = t.l;\n            x.r = t.r;\n        }\n        // We can now free the t node (if we need to do so).\n        // Finally, account for whether t was the left or right child of p.\n        if (comp(key, p.key) < 0) {\n            p.l = x;\n        }\n        else {\n            p.r = x;\n        }\n    }\n\n    /**\n     * Determines whether this tree satisfies the height invariant.\n     * The height invariant is that the number of black nodes in every path to leaf nodes should be the same.\n     * This property is for testing only; it traverses the tree and so affects performance.\n     */\n    get heightInvariant(): boolean {\n        return heightInv(this.root, this.z);\n    }\n    /**\n     * Determines whether this tree satisfies the color invarant.\n     * The color invariant is that no two adjacent nodes should be colored red.\n     * This property is for testing only; it traverses the treeand so affects performance.\n     */\n    get colorInvariant(): boolean {\n        return colorInv(this.root, this.head.flag, this.z);\n    }\n}\n\nfunction colorFlip<K, V>(p: RBNode<K, V>, g: RBNode<K, V>, gg: RBNode<K, V>): RBNode<K, V> {\n    p.flag = false;\n    g.flag = true;\n    gg.flag = false;\n    return g;\n}\n\n/**\n * z, x, y are in diamond-left formation.\n * z is the initial leader and is black.\n * x and y are initially red.\n *\n * z moves right and back.\n * y takes the lead.\n * children a,b of y are adopted by x and z.\n * x becomes black.\n *\n *    z          y\n * x    =>    x     z\n *    y        a   b\n *  a   b\n */\nfunction diamondLeftToVic<K, V>(lead: RBNode<K, V>): RBNode<K, V> {\n    const m = lead.p;\n    const z = lead;\n    const x = z.l;\n    const y = x.r;\n    const a = y.l;\n    const b = y.r;\n    x.flag = false;\n    y.l = x; x.p = y;\n    y.r = z; z.p = y;\n    x.r = a; a.p = x;\n    z.l = b; b.p = z;\n    if (m.r === lead) { m.r = y; } else { m.l = y; } y.p = m;\n    return y;\n}\n\n/**\n * x, z, y are in diamond-right formation.\n * x is the initial leader and is black.\n * z and y are initially red.\n *\n * x moves left and back\n * y takes the lead.\n * z becomes black.\n *\n *    x          y\n *       z => x     z\n *    y        a   b\n *  a   b\n */\nfunction diamondRightToVic<K, V>(lead: RBNode<K, V>): RBNode<K, V> {\n    const m = lead.p;\n    const x = lead;\n    const z = x.r;\n    const y = z.l;\n    const a = y.l;\n    const b = y.r;\n    z.flag = false;\n    y.l = x; x.p = y;\n    y.r = z; z.p = y;\n    x.r = a; a.p = x;\n    z.l = b; b.p = z;\n    if (m.r === lead) { m.r = y; } else { m.l = y; } y.p = m;\n    return y;\n}\n\nfunction echelonLeftToVic<K, V>(lead: RBNode<K, V>): RBNode<K, V> {\n    const m = lead.p;\n    const z = lead;\n    const y = z.l;\n    const a = y.r;\n    y.l.flag = false;\n    y.r = z; z.p = y;\n    z.l = a; a.p = z;\n    if (m.r === lead) { m.r = y; } else { m.l = y; } y.p = m;\n    return y;\n}\n\nfunction echelonRightToVic<K, V>(lead: RBNode<K, V>): RBNode<K, V> {\n    const m = lead.p;\n    const x = lead;\n    const y = x.r;\n    const a = y.l;\n    y.r.flag = false;\n    y.l = x; x.p = y;\n    x.r = a; a.p = x;\n    if (m.r === lead) { m.r = y; } else { m.l = y; } y.p = m;\n    return y;\n}\n\nfunction colorInv<K, V>(node: RBNode<K, V>, redParent: boolean, z: RBNode<K, V>): boolean {\n    if (node === z) {\n        return true;\n    }\n    else if (redParent && node.flag) {\n        return false;\n    }\n    else {\n        return colorInv(node.l, node.flag, z) && colorInv(node.r, node.flag, z);\n    }\n}\n\nfunction heightInv<K, V>(node: RBNode<K, V>, z: RBNode<K, V>): boolean {\n    return blackHeight(node, z) >= 0;\n}\n\n/**\n * Computes the number of black nodes (including z) on the path from x to leaf, not counting x.\n * The height does not include itself.\n * z nodes are black.\n */\nfunction blackHeight<K, V>(x: RBNode<K, V>, z: RBNode<K, V>): number {\n    if (x === z) {\n        return 0;\n    }\n    else {\n        const hL = blackHeight(x.l, z);\n        if (hL >= 0) {\n            const hR = blackHeight(x.r, z);\n            if (hR >= 0) {\n                if (hR === hR) {\n                    return x.flag ? hL : hL + 1;\n                }\n            }\n        }\n        return -1;\n    }\n}\n\nfunction rbInsert<K, V>(tree: RBTree<K, V>, n: RBNode<K, V>, comp: Comparator<K>): void {\n    const key = n.key;\n    const z = tree.z;\n    let x = tree.root;\n    x.p = tree.head;\n\n    while (x !== z) {\n        x.l.p = x;\n        x.r.p = x;\n        x = comp(key, x.key) < 0 ? x.l : x.r;\n    }\n\n    n.p = x.p;\n\n    if (x.p === tree.head) {\n        tree.root = n;\n    }\n    else {\n        if (comp(key, x.p.key) < 0) {\n            x.p.l = n;\n        }\n        else {\n            x.p.r = n;\n        }\n    }\n    n.l = z;\n    n.r = z;\n    if (n.p.flag) {\n        rbInsertFixup(tree, n);\n    }\n    else {\n        n.flag = true;\n    }\n}\n\n/**\n * In this algorithm we start with the node that has been inserted and make our way up the tree.\n * This requires carefully maintaining parent pointers.\n */\nfunction rbInsertFixup<K, V>(tree: RBTree<K, V>, n: RBNode<K, V>): void {\n    // When inserting the node (at any place other than the root), we always color it red.\n    // This is so that we don't violate the height invariant.\n    // However, this may violate the color invariant, which we address by recursing back up the tree.\n    n.flag = true;\n\n    if (!n.p.flag) {\n        throw new Error(\"n.p must be red.\");\n    }\n\n    while (n.flag) {\n        /**\n         * The parent of n.\n         */\n        const p = n.p;\n        if (n === tree.root) {\n            tree.root.flag = false;\n            return;\n        }\n        else if (p === tree.root) {\n            tree.root.flag = false;\n            return;\n        }\n        /**\n         * The leader of the formation.\n         */\n        const lead = p.p;\n        // Establish the n = red, p = red, g = black condition for a transformation.\n        if (p.flag && !lead.flag) {\n            if (p === lead.l) {\n                const aux = lead.r;\n                if (aux.flag) {\n                    n = colorFlip(p, lead, aux);\n                }\n                else if (n === p.r) {\n                    n = diamondLeftToVic(lead);\n                }\n                else {\n                    n = echelonLeftToVic(lead);\n                }\n            }\n            else {\n                const aux = lead.l;\n                if (aux.flag) {\n                    n = colorFlip(p, lead, aux);\n                }\n                else if (n === n.p.l) {\n                    n = diamondRightToVic(lead);\n                }\n                else {\n                    n = echelonRightToVic(lead);\n                }\n            }\n        }\n        else {\n            break;\n        }\n    }\n    tree.root.flag = false;\n}\n\n/**\n * Recursive implementation to compute the Greatest Lower Bound.\n * The largest key such that glb <= key.\n */\nfunction glb<K, V>(tree: RBTree<K, V>, node: RBNode<K, V>, key: K, comp: Comparator<K>, low: RBNode<K, V>): RBNode<K, V> {\n    if (node === tree.z) {\n        return low;\n    }\n    else if (comp(key, node.key) >= 0) {\n        // The node key is a valid lower bound, but may not be the greatest.\n        // Take the right link in search of larger keys.\n        return maxNode(node, glb(tree, node.r, key, comp, low), comp);\n    }\n    else {\n        // Take the left link in search of smaller keys.\n        return glb(tree, node.l, key, comp, low);\n    }\n}\n\n/**\n * Recursive implementation to compute the Least Upper Bound.\n * The smallest key such that key <= lub.\n */\nfunction lub<K, V>(tree: RBTree<K, V>, node: RBNode<K, V>, key: K, comp: Comparator<K>, high: RBNode<K, V>): RBNode<K, V> {\n    if (node === tree.z) {\n        return high;\n    }\n    else if (comp(key, node.key) <= 0) {\n        // The node key is a valid upper bound, but may not be the least.\n        return minNode(node, lub(tree, node.l, key, comp, high), comp);\n    }\n    else {\n        // Take the right link in search of bigger keys.\n        return lub(tree, node.r, key, comp, high);\n    }\n}\n\nfunction maxNode<K, V>(a: RBNode<K, V>, b: RBNode<K, V>, comp: Comparator<K>): RBNode<K, V> {\n    if (comp(a.key, b.key) > 0) {\n        return a;\n    }\n    else if (comp(a.key, b.key) < 0) {\n        return b;\n    }\n    else {\n        return a;\n    }\n}\n\nfunction minNode<K, V>(a: RBNode<K, V>, b: RBNode<K, V>, comp: Comparator<K>): RBNode<K, V> {\n    if (comp(a.key, b.key) < 0) {\n        return a;\n    }\n    else if (comp(a.key, b.key) > 0) {\n        return b;\n    }\n    else {\n        return a;\n    }\n}\n"],"names":[],"mappings":"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"}