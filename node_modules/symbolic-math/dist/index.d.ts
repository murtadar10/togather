import bigInt from 'big-integer';

/**
 * The handle for any expression in the system.
 */
interface U {
    /**
     * Contains the name of the type.
     */
    readonly name: string;
    meta: number;
    contains(needle: U): boolean;
    equals(other: U): boolean;
    isCons(): boolean;
    isNil(): boolean;
    reset(meta: number): void;
    readonly pos?: number;
    readonly end?: number;
}
/**
 * Symbolic expressions are built by connecting Cons structures.
 *
 * For example, (a * b + c) is built like this:
 *
 * The car links go downwards, the cdr links go to the right.
 *
 *           _______      _______                                            _______      _______
 *          |CONS   |--->|CONS   |----------------------------------------->|CONS   |--->|NIL    |
 *          |       |    |       |                                          |       |    |       |
 *          |_______|    |_______|                                          |_______|    |_______|
 *              |            |                                                  |
 *           ___v___      ___v___      _______      _______      _______     ___v___
 *          |SYM +  |    |CONS   |--->|CONS   |--->|CONS   |--->|NIL    |   |SYM c  |
 *          |       |    |       |    |       |    |       |    |       |   |       |
 *          |_______|    |_______|    |_______|    |_______|    |_______|   |_______|
 *                           |            |            |
 *                        ___v___      ___v___      ___v___
 *                       |SYM *  |    |SYM a  |    |SYM b  |
 *                       |       |    |       |    |       |
 *                       |_______|    |_______|    |_______|
 *
 * A NIL is a special kind of Cons in which the isCons method returns false.
 * A SYM is never a cdr. There will be a CONS with a NIL cdr and a car containing the SYM.
 *
 */
declare class Cons implements U {
    #private;
    readonly pos?: number | undefined;
    readonly end?: number | undefined;
    constructor(meta: number, car: U | undefined, cdr: U | undefined, pos?: number | undefined, end?: number | undefined);
    get meta(): number;
    set meta(meta: number);
    get name(): 'Cons' | 'Nil';
    /**
     * Returns the car property if it is defined, otherwise NIL.
     */
    get car(): U;
    /**
     * Returns the cdr property if it is defined, otherwise NIL.
     */
    get cdr(): Cons;
    /**
     * Exactly the same as the cdr property. Used for code-as-documentation.
     */
    get argList(): Cons;
    contains(needle: U): boolean;
    equals(other: U): boolean;
    isCons(): boolean;
    isNil(): boolean;
    reset(meta: number): void;
    toString(): string;
    /**
     * Provides an iterator over the Cons, returning the items is the list.
     * The first element returned will be car(cons).
     * The subsequent elements are obtained from walking the cdr's.
     * Hint: Using the ... operator inside [] returns all the items in the list.
     */
    [Symbol.iterator](): Generator<U, void, unknown>;
    /**
     * Exactly the same as the car property. Used for code-as-documentation.
     */
    get head(): U;
    /**
     * Return everything except the first item in the list.
     */
    tail(): U[];
    /**
     * Maps the elements of the list using a mapping function.
     */
    map(f: (a: U) => U): Cons;
    /**
     * Returns the length of the list.
     */
    get length(): number;
    /**
     * A convenience property for the method item(0).
     * A useful shortcut when working with operators.
     */
    get opr(): U;
    /**
     * A convenience property for the method item(1).
     * A useful shortcut when working with unary operators.
     */
    get arg(): U;
    /**
     * A convenience property for the method item(1).
     * A useful shortcut when working with binary operators.
     */
    get lhs(): U;
    /**
     * A convenience property for the method item(2).
     * A useful shortcut when working with binary operators.
     */
    get rhs(): U;
    /**
     * Returns the item at the specified (zero-based) index.
     *
     * (item0 item1 item2 ...)
     */
    item(index: number): U;
}
declare function cons(car: U, cdr: U): Cons;
declare function items_to_cons(...items: U[]): Cons;
/**
 * The empty list.
 */
declare const nil: Cons;
declare function is_atom(expr: U): boolean;
/**
 * Returns true if arg is a Cons and is not NIL.
 * For NIL testing, test for identical equality to NIL.
 */
declare function is_cons(expr: U): expr is Cons;
declare function is_nil(expr: U): boolean;
/**
 * Returns the car property of the tree node if it is a Cons.
 * Otherwise, returns NIL.
 */
declare function car(node: U): U;
/**
 * Returns the cdr property of the tree node if it is a Cons.
 * Otherwise, returns NIL.
 */
declare function cdr(node: U): U;

declare abstract class Atom<NAME extends string> implements U {
    #private;
    readonly name: NAME;
    readonly pos?: number | undefined;
    readonly end?: number | undefined;
    constructor(name: NAME, pos?: number | undefined, end?: number | undefined);
    reset(meta: number): void;
    get meta(): number;
    set meta(meta: number);
    contains(needle: U): boolean;
    equals(other: U): boolean;
    isCons(): boolean;
    isNil(): boolean;
}

/**
 * A matrix. This may be used to represent a tensor.
 * While the syntactic representation of a tensor is that of nested arrays,
 * the elements of the tensor are stored in a flattened manner. Presumambly,
 * this makes things easier in the case when a Tensor is used as a square matrix.
 */
declare class Tensor<T extends U = U> extends Atom<'Tensor'> {
    #private;
    /**
     * @param dims The lengths of each dimension.
     * @param elems The elements containing all the data.
     */
    constructor(dims: number[], elems: T[], pos?: number, end?: number);
    get rank(): number;
    get ndim(): number;
    get nelem(): number;
    contains(needle: U): boolean;
    copyDimensions(): number[];
    /**
     * Returns a copy of the data in this tensor.
     */
    copyElements(): T[];
    /**
     * Returns the size of the specified dimension.
     * This is the number of elements at the specified level of nesting.
     * @param n The zero-based index of the dimension.
     */
    dim(n: number): number;
    elem(index: number): T;
    equals(other: U): boolean;
    /**
     * Applies the predicate to every element of this tensor.
     * @param predicate The predicate applied.
     * @returns true if every element satisfies the predicate.
     */
    everyElement(predicate: (element: T) => boolean): boolean;
    filterElements(callbackfn: (value: T, index: number, array: T[]) => boolean): U[];
    map<X extends U>(callbackfn: (value: T, index: number, array: T[]) => X): Tensor<X>;
    mapElements<X>(callbackfn: (value: T, index: number, array: T[]) => X): X[];
    isCons(): boolean;
    /**
     * @override
     */
    isNil(): boolean;
    sameDimensions(other: Tensor): boolean;
    sliceDimensions(start?: number, end?: number): number[];
    someElements(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
    toInfixString(): string;
    toListString(): string;
    toString(): string;
    /**
     * Returns a new tensor with the same dimensions as this, but with different elements.
     * This element avoids the copy of the dims array.
     */
    withElements<X extends U>(elems: X[]): Tensor<X>;
}

/**
 * Creates a Tensor from an array of elements. If the elements themselves are tensors,
 * then that elements must be flattened, but the dimensionality is computed and incorporated
 * into the created Tensor.
 */
declare function create_tensor(elements: U[]): Tensor;

/**
 * Natively implemented concepts.
 * Uppercase elements correspond to constants.
 * Lowercase elements correspond to functions.
 */
declare enum Native {
    E = 0,
    IMU = 1,
    MASH = 2,
    NIL = 3,
    PI = 4,
    abs = 5,
    add = 6,
    arctan = 7,
    arg = 8,
    conj = 9,
    cos = 10,
    divide = 11,
    exp = 12,
    imag = 13,
    inner = 14,
    inverse = 15,
    is_complex = 16,
    is_real = 17,
    is_zero = 18,
    lco = 19,
    log = 20,
    /**
     * mod(a,b) returns the remainder of the result of a divided by b.
     */
    mod = 21,
    multiply = 22,
    outer = 23,
    pow = 24,
    real = 25,
    rect = 26,
    rco = 27,
    sin = 28,
    spread = 29,
    subtract = 30,
    succ = 31,
    /**
     * tau(x) = 2 * PI * x
     */
    tau = 32,
    test_eq = 33,
    test_ge = 34,
    test_gt = 35,
    test_le = 36,
    test_lt = 37,
    test_ne = 38
}

interface IsInteger<T> {
    isInteger(): T;
}
/**
 * "God gave us the integers, all else is the work of man" - Kronecker.
 */
declare class Rat extends Atom<'Rat'> implements IsInteger<boolean> {
    a: bigInt.BigInteger;
    b: bigInt.BigInteger;
    /**
     * @param a The numerator.
     * @param b The denominator.
     */
    constructor(a: bigInt.BigInteger, b: bigInt.BigInteger, pos?: number, end?: number);
    abs(): Rat;
    add(rhs: Rat): Rat;
    ceiling(): Rat;
    compare(rhs: Rat): -1 | 0 | 1;
    denom(): Rat;
    div(rhs: Rat): Rat;
    equals(other: U): boolean;
    equalsRat(other: Rat): boolean;
    gcd(other: Rat): Rat;
    inv(): Rat;
    isDenom(n: number): boolean;
    /**
     * Convenience method for !Rat.isInteger()
     */
    isFraction(): boolean;
    isHalf(): boolean;
    /**
     * Convenience method for Rat.isDenom(1)
     */
    isInteger(): boolean;
    isIntegerNumber(x: number): boolean;
    isNegative(): boolean;
    isNumer(n: number): boolean;
    isMinusOne(): boolean;
    isOne(): boolean;
    isPositive(): boolean;
    isPositiveInteger(): boolean;
    isTwo(): boolean;
    isZero(): boolean;
    mul(rhs: Rat): Rat;
    neg(): Rat;
    numer(): Rat;
    pred(): Rat;
    sub(rhs: Rat): Rat;
    succ(): Rat;
    toInfixString(): string;
    toListString(): string;
    toNumber(): number;
    toString(): string;
}
/**
 * Constructor function for Num from integer which is a primitive number.
 */
declare function create_int(n: number, pos?: number, end?: number): Rat;
declare function create_rat(numer: number, denom: number, pos?: number, end?: number): Rat;
/**
 * The canonical representation of the identity element for ordinary multiplication.
 */
declare const one: Rat;
/**
 * The canonical representation of the identity element for ordinary addition.
 */
declare const zero: Rat;

declare function create_sym(text: string, pos?: number, end?: number): Sym;
declare class Sym extends Atom<'Sym'> {
    #private;
    /**
     * Use create_sym to create a new Sym instance.
     */
    constructor(secret: number, text: string, pos?: number, end?: number);
    compare(other: Sym): 1 | -1 | 0;
    contains(needle: U): boolean;
    /**
     * Creates a new symbol with exactly the same local name and namespace as this symbol.
     * However it allows scanning information to be carried along with the new instance.
     * @param pos The start position of the symbol in the source text.
     * @param end The end position of the symbol in the source text.
     */
    clone(pos: number | undefined, end: number | undefined): Sym;
    equals(other: U): boolean;
    equalsSym(other: Sym): boolean;
    key(): string;
    get text(): string;
    toString(): string;
}

interface EnvConfig {
    assumes: {
        [name: string]: Partial<SymbolProps>;
    };
    dependencies: FEATURE[];
    disable: ('expand' | 'factor')[];
    noOptimize: boolean;
    useCaretForExponentiation: boolean;
    useDefinitions: boolean;
}

type Sign = -1 | 0 | 1;
type TFLAGS = number;
/**
 * @hidden
 */
type FEATURE = 'Blade' | 'Flt' | 'Imu' | 'Uom' | 'Vector';
declare enum Directive {
    /**
     * Mutually exclusive with factor.
     */
    expand = 0,
    /**
     * Determines whether numeric types are converted to floating point numbers for numeric evaluation.
     *
     * The default value as false.
     */
    evaluatingAsFloat = 1,
    /**
     * Determines whether complex numbers are driven towards rectangular or polar notation.
     *
     * The default value is false.
     */
    evaluatingAsPolar = 2,
    evaluatingAsClock = 3,
    /**
     * Determines whether trigonometric functions are converted to exponential form.
     *
     * The default is false.
     */
    evaluatingTrigAsExp = 4,
    /**
     * Determines whether zero terms are kept in sums in attempt to preserve the dynamic type.
     * The alternative is to use a canonical zero value, usually that for rational numbers.
     *
     * The default value is false.
     */
    keepZeroTermsInSums = 5,
    /**
     * Mutually exclusive with expand.
     */
    factor = 6,
    /**
     * Determines whether floating point numbers are rendered as EcmaScript numbers.
     * If not, floating point numbers are rendered in a proprietary format.
     *
     * The default value is false.
     */
    renderFloatAsEcmaScript = 7,
    /**
     * Determines whether caret token '^' will be used for exponentiation or for the exterior product.
     * Using the caret token for exponetitation is common in mathematical tools but not in programming languages.
     *
     * The default value is false.
     */
    useCaretForExponentiation = 8
}
interface PrintHandler {
    print(...items: string[]): void;
}
type CompareFn = (lhs: U, rhs: U) => Sign;
interface ExprComparator {
    compare(lhs: U, rhs: U, $: ExtensionEnv): Sign;
}
/**
 * Not to be confused with the LegacyExpr.
 * Here the first argument is the argument list and does not include the operator.
 */
type LambdaExpr = (argList: Cons, $: ExtensionEnv) => U;
/**
 * Not to be confused with a LambdaExpr.
 * Here the first argument is the expression including the operator.
 */
type LegacyExpr = (expr: Cons, $: ExtensionEnv) => U;
type KeywordRunner = ($: ExtensionEnv) => void;
interface SymbolProps {
    /**
     * An algebraic number is any number that is a root of a non-zero polynomial having rational coefficients.
     * All algebraic numbers are complex.
     * An algebraic number may or may not be real.
     * Includes all rational numbers.
     */
    algebraic: boolean;
    /**
     * An element of the field of antihermitian operators.
     * Defaults to false.
     */
    antihermitian: boolean;
    /**
     * A commutative expression.
     * A commutative expression commutes with all other expressions under multiplication.
     * If an expression a has commutative then a * b == b * a for any other expression b (even if b is not commutative).
     * Unlike all other assumptions predicates commutative must always be true or false and can never be undefined.
     * Also unlike all other predicates commutative defaults to true.
     */
    commutative: boolean;
    /**
     * A complex number is any number of the form x+i*y where x and y are real.
     * All complex numbers are finite. Includes all real numbers.
     */
    complex: boolean;
    extended_negative: boolean;
    extended_nonnegative: boolean;
    extended_nonpositive: boolean;
    extended_nonzero: boolean;
    extended_positive: boolean;
    /**
     * An element of the real number line extended to include infinity.
     * Default is true.
     */
    extended_real: boolean;
    /**
     * A finite expression.
     * Any expression that is not infinite is considered finite.
     */
    finite: boolean;
    /**
     * An element of the field of Hermitian operators.
     */
    hermitian: boolean;
    imaginary: boolean;
    /**
     * An infinite expression.
     */
    infinite: boolean;
    integer: boolean;
    irrational: boolean;
    negative: boolean;
    noninteger: boolean;
    nonnegative: boolean;
    nonpositive: boolean;
    nonzero: boolean;
    positive: boolean;
    rational: boolean;
    real: boolean;
    /**
     * A complex number that is not algebraic.
     * All transcendental numbers are complex.
     * A transcendental number may or may not be real but can never be rational.
     * Defaults to false.
     */
    transcendental: boolean;
    zero: boolean;
}
interface ExtensionEnv {
    getPrintHandler(): PrintHandler;
    setPrintHandler(handler: PrintHandler): void;
    /**
     *
     */
    add(...args: U[]): U;
    arctan(expr: U): U;
    arg(expr: U): U;
    conj(expr: U): U;
    cos(expr: U): U;
    evaluate(opr: Native, ...args: U[]): U;
    exp(expr: U): U;
    clearBindings(): void;
    clearOperators(): void;
    compareFn(sym: Sym): CompareFn;
    /**
     * Defines the implementation of a function that is used to transform (name ...) expressions.
     */
    defineLegacyTransformer(opr: Sym, transformer: LegacyExpr): void;
    defineFunction(match: U, lambda: LambdaExpr): void;
    defineKeyword(sym: Sym, runner: KeywordRunner): void;
    defineOperator(builder: OperatorBuilder<U>): void;
    defineAssociative(opr: Sym, id: Rat): void;
    divide(lhs: U, rhs: U): U;
    /**
     *
     */
    equals(lhs: U, rhs: U): boolean;
    /**
     * @deprecated
     */
    factorize(poly: U, x: U): U;
    getCustomDirective(directive: string): boolean;
    getNativeDirective(directive: Directive): boolean;
    getSymbolProps(sym: Sym | string): SymbolProps;
    /**
     * Used during rendering.
     */
    getSymbolPrintName(sym: Sym): string;
    getSymbolValue(sym: Sym | string): U;
    getSymbolsInfo(): {
        sym: Sym;
        value: U;
    }[];
    /**
     * Used to make the environment ready after all operator builders have been added.
     */
    buildOperators(): void;
    imag(expr: U): U;
    /**
     *
     */
    inner(lhs: U, rhs: U): U;
    /**
     * Generalized predicate testing.
     * @param predicate
     * @param expr
     */
    is(predicate: Sym, expr: U): boolean;
    isExpanding(): boolean;
    isFactoring(): boolean;
    /**
     * Meaning is imaginary valued. i.e. evaluates to i times a real number.
     */
    is_imag(expr: U): boolean;
    isMinusOne(expr: U): boolean;
    isOne(expr: U): boolean;
    /**
     * Corresponds to the 'real' property.
     */
    is_complex(expr: U): boolean;
    /**
    * Corresponds to the 'real' property.
    */
    is_real(expr: U): boolean;
    /**
     * Determines whether expr is scalar-valued.
     */
    isScalar(expr: U): boolean;
    /**
     * A convenience for appling the predicate function to the expression.
     */
    is_zero(expr: U): boolean;
    /**
     *
     */
    multiply(lhs: U, rhs: U): U;
    /**
     *
     */
    negate(expr: U): U;
    /**
     * Returns the operator for interacting with the expression.
     * Operator(s) are reference counted and so the operator MUST be released when no longer needed.
     */
    operatorFor(expr: U): Operator<U>;
    /**
     *
     */
    outer(lhs: U, rhs: U): U;
    /**
     *
     */
    power(base: U, expo: U): U;
    real(expr: U): U;
    remove(varName: Sym): void;
    setCustomDirective(directive: string, value: boolean): void;
    pushNativeDirective(directive: Directive, value: boolean): void;
    popNativeDirective(): void;
    setSymbolOrder(sym: Sym, order: ExprComparator): void;
    setSymbolProps(sym: Sym, overrides: Partial<SymbolProps>): void;
    setSymbolPrintName(sym: Sym, printName: string): void;
    setSymbolValue(sym: Sym, value: U): void;
    sin(expr: U): U;
    /**
     *
     */
    subtract(lhs: U, rhs: U): U;
    toInfixString(expr: U): string;
    toLatexString(expr: U): string;
    toSExprString(expr: U): string;
    transform(expr: U): [TFLAGS, U];
    valueOf(expr: U): U;
}
/**
 * The interface that MUST be implemented by extensions to the environment.
 * The type parameter,T, allows you to constrain the argument types of the
 * methods that you implement. e.g. If isKind() only matches a Cons, then set T
 * to be Cons. If isKind() only matches Sym, set T to be Sym. In more general
 * cases, use a more general type. The rule is that isKind determines which expression are matched,
 * and when the other method are called (they all contain at least one argument that matches T),
 * it determines the possible dynamic types for T.
 */
interface OperatorBuilder<T extends U> {
    create($: ExtensionEnv, config: Readonly<EnvConfig>): Operator<T>;
}
/**
 * Use to handle an expression, especially to evaluate it.
 * This is the means of extending the system to include other atoms.
 * Every object in the system is an opaque handle.
 * Methods don't take a $ parameter because it is hidden state.
 */
interface Operator<T extends U> {
    readonly key?: string;
    readonly name: string;
    readonly hash?: string;
    readonly phases?: number;
    readonly dependencies?: FEATURE[];
    /**
     * @deprecated We don't want to have predicates hard-coded.
     */
    isImag(expr: T): boolean;
    /**
     * Determines whether this operator can be used to evaluate the expression.
     */
    isKind(expr: U): expr is T;
    /**
     * @deprecated We don't want to have predicates hard-coded.
     */
    isMinusOne(expr: T): boolean;
    /**
     * @deprecated We don't want to have predicates hard-coded.
     */
    isOne(expr: T): boolean;
    /**
     * @deprecated We don't want to have predicates hard-coded.
     */
    isReal(expr: T): boolean;
    /**
     * @deprecated We don't want to have predicates hard-coded.
     */
    isScalar(expr: T): boolean;
    /**
     * @deprecated We don't want to have predicates hard-coded.
     */
    isZero(expr: T): boolean;
    subst(expr: T, oldExpr: U, newExpr: U): U;
    toInfixString(expr: T): string;
    toLatexString(expr: T): string;
    toListString(expr: T): string;
    /**
     * Applies the procedure managed by this extension to the argList.
     * @param argList
     */
    evaluate(opr: T, argList: Cons): [TFLAGS, U];
    /**
     * Evaluates the expression and also returns some information about the returned expression.
     */
    transform(expr: T): [TFLAGS, U];
    /**
     * Evaluates the expression.
     */
    valueOf(expr: T): U;
}
/**
 *
 */
interface Extension<T extends U> {
    readonly key?: string;
    readonly name: string;
    readonly hash?: string;
    readonly phases?: number;
    readonly dependencies?: FEATURE[];
    isImag(expr: T, $: ExtensionEnv): boolean;
    isKind(expr: U, $: ExtensionEnv): boolean;
    isMinusOne(expr: T, $: ExtensionEnv): boolean;
    isOne(expr: T, $: ExtensionEnv): boolean;
    isReal(expr: T, $: ExtensionEnv): boolean;
    isScalar(expr: T, $: ExtensionEnv): boolean;
    isZero(expr: T, $: ExtensionEnv): boolean;
    subst(expr: T, oldExpr: U, newExpr: U, $: ExtensionEnv): U;
    toInfixString(expr: T, $: ExtensionEnv): string;
    toLatexString(expr: T, $: ExtensionEnv): string;
    toListString(expr: T, $: ExtensionEnv): string;
    evaluate(expr: T, argList: Cons, $: ExtensionEnv): [TFLAGS, U];
    transform(expr: U, $: ExtensionEnv): [TFLAGS, U];
    valueOf(expr: T, $: ExtensionEnv): U;
}

declare function native_sym(code: Native): Sym;

/**
 * TODO: Trim down this interface if methods are not used by the symbolic library.
 */
interface BasisBlade<T, K> extends U {
    /**
     * The bitmap representation.
     */
    bitmap: number;
    __abs__(): K;
    __add__(rhs: BasisBlade<T, K> | K): K;
    __radd__(rhs: BasisBlade<T, K>): K;
    __sub__(rhs: BasisBlade<T, K>): K;
    __rsub__(rhs: BasisBlade<T, K>): K;
    __mul__(rhs: T | BasisBlade<T, K>): K;
    __rmul__(lhs: T | BasisBlade<T, K>): K;
    __div__(rhs: T | BasisBlade<T, K>): K;
    __lshift__(rhs: BasisBlade<T, K>): K;
    __rshift__(rhs: BasisBlade<T, K>): K;
    __vbar__(rhs: BasisBlade<T, K>): K;
    __wedge__(rhs: BasisBlade<T, K>): K;
    __eq__(rhs: BasisBlade<T, K>): boolean;
    __ge__(rhs: BasisBlade<T, K>): boolean;
    __gt__(rhs: BasisBlade<T, K>): boolean;
    __le__(rhs: BasisBlade<T, K>): boolean;
    __lt__(rhs: BasisBlade<T, K>): boolean;
    __ne__(rhs: BasisBlade<T, K>): boolean;
    __bang__(): K;
    __pos__(): K;
    __neg__(): K;
    __tilde__(): K;
    add(rhs: BasisBlade<T, K>): K;
    asString(names: string[], wedge: string): string;
    cliffordConjugate(): K;
    /**
     * This doesn't really make sense now that this structure is a blade.
     * direction(M) = M / sqrt(M * ~M)
     */
    direction(): K;
    div(rhs: BasisBlade<T, K>): K;
    divByScalar(alpha: T): K;
    /**
     * dual(M) = M << I, where I is the pseudoscalar of the space.
     */
    dual(): K | BasisBlade<T, K>;
    contains(needle: U): boolean;
    equals(rhs: U): boolean;
    /**
     * Returns the universal exponential function, exp, applied to this, i.e. exp(this).
     */
    exp(): K;
    extractGrade(grade: number): K;
    gradeInversion(): K;
    inv(): K;
    isCompatible(rhs: BasisBlade<T, K>): boolean;
    map(f: (weight: T) => T): K;
    mul(rhs: BasisBlade<T, K>): K;
    neg(): K;
    rev(): K;
    scalarCoordinate(): T;
    /**
     * Returns the scalar product of this multivector with rhs, i.e. this | rhs.
     */
    scp(rhs: BasisBlade<T, K>): K;
    sqrt(): K;
    sub(rhs: BasisBlade<T, K>): K;
    toInfixString(): string;
    toLatexString(): string;
    toListString(): string;
    toString(): string;
}

/**
 * The type representing a geometric algebra basis blade.
 * This is a generalization of a vector.
 */
interface Blade extends BasisBlade<U, U> {
}

declare function is_blade(arg: unknown): arg is Blade;

/**
 * The implementation of a Logical Boolean value.
 */
declare class Boo extends Atom<'Boo'> {
    private readonly b;
    constructor(b: boolean, pos?: number, end?: number);
    equals(other: U): boolean;
    equalsBoo(other: Boo): boolean;
    isTrue(): boolean;
    toString(): string;
    static valueOf(b: boolean): Boo;
}
declare function create_boo(b: boolean): Boo;
declare const booT: Boo;
declare const booF: Boo;

declare function is_boo(p: unknown): p is Boo;

/**
 * Constructs a floating point number object from a number primitive.
 * @param value The floating point number value.
 * @param pos The start position of the number in the source text.
 * @param end The end position of the number in the source text.
 */
declare function create_flt(value: number, pos?: number, end?: number): Flt;
declare class Flt extends Atom<'Flt'> {
    readonly d: number;
    /**
     * Use the factory method instead. This may not exist in future.
     */
    constructor(d: number, pos?: number, end?: number);
    abs(): Flt;
    add(rhs: Flt): Flt;
    compare(other: Flt): 1 | -1 | 0;
    equals(other: U): boolean;
    equalsFlt(other: Flt): boolean;
    inv(): Flt;
    /**
     * Returns true if this number is less than zero.
     */
    isNegative(): boolean;
    isMinusOne(): boolean;
    isOne(): boolean;
    isPositive(): boolean;
    isZero(): boolean;
    mul(rhs: Flt): Flt;
    neg(): Flt;
    sub(rhs: Flt): Flt;
    toInfixString(): string;
    toListString(): string;
    toNumber(): number;
    toString(): string;
}
declare const zeroAsFlt: Flt;
declare const oneAsFlt: Flt;

declare function is_flt(expr: U): expr is Flt;

declare class Hyp extends Atom<'Hyp'> {
    readonly printname: string;
    constructor(printname: string, pos?: number, end?: number);
    equals(other: U): boolean;
    equalsHyp(other: Hyp): boolean;
    toInfixString(): string;
    toListString(): string;
    toString(): string;
}
declare function create_hyp(printname: string): Hyp;
declare const epsilon: Hyp;
declare const delta: Hyp;

declare function is_hyp(expr: U): expr is Hyp;

/**
 * The implementation of the imaginary unit.
 */
declare class Imu extends Atom<'Imu'> {
    constructor(pos?: number, end?: number);
    equals(other: U): boolean;
    toString(): string;
}
declare const imu: Imu;

/**
 * @hidden
 */
type IMU_TYPE = Imu;
/**
 * Determines whether expr is the imaginary unit (imu), (expt -1 1/2).
 * @param expr The expression to test.
 */
declare function is_imu(expr: U): expr is IMU_TYPE;

/**
 * The Num type is the union of Flt and Rat (and maybe Int in future).
 * While the concept of a number in mathematics may be quite general, in this case we me the
 * set of things that we can calculate with. Not surprisingly, these need to be treated as a
 * combined entity so that simlifications can be performed.
 */
type Num = Flt | Rat;

/**
 * Determines whether an atom belongs to the class of numbers.
 * Numbers in this context are things that are treated similarly because they can calculate.
 * e.g. We could introduce an Int type, which would have to be classed as a Num.
 * @param expr The value being tested.
 * @returns true iff x is a Flt or a Rat.
 */
declare function is_num(expr: U): expr is Num;

declare function is_rat(expr: U): expr is Rat;

/**
 * TODO: This class SHOULD (MUST) be escaping the string and the printer SHOULD NOT not then need to escape.
 * By escaping here, this class gets written into expression correctly.
 * As it works now, if we escape here then tests break because of double-duty escaping.
 */
declare class Str extends Atom<'Str'> {
    readonly str: string;
    /**
     * @param str The parsed representation of the string. i.e. Delimiters and escaping have been removed.
     * @param pos The zero-based start position of the original text.
     * @param end The zero-based end position of the original text.
     */
    constructor(str: string, pos?: number, end?: number);
    equals(other: U): boolean;
    equalsStr(other: Str): boolean;
    toInfixString(): string;
    toListString(): string;
    toString(): string;
}

declare function create_str(s: string): Str;

declare function is_str(expr: U): expr is Str;

declare function is_sym(expr: U): expr is Sym;

declare function is_tensor(p: U): p is Tensor;

/**
 * The QQ class represents a rational number, ℚ.
 *
 * The QQ implementation is that of an <em>immutable</em> (value) type.
 *
 * The numerator and denominator are reduced to their lowest form.
 *
 * Construct new instances using the static <code>valueOf</code> method.
 */
declare class QQ {
    #private;
    /**
     * Intentionally undocumented.
     * @hidden
     */
    constructor(n: number, d: number, code: number);
    /**
     *
     * @readOnly
     */
    get numer(): number;
    set numer(unused: number);
    /**
     *
     * @readOnly
     */
    get denom(): number;
    set denom(unused: number);
    /**
     * @param rhs
     * @returns
     */
    add(rhs: QQ): QQ;
    /**
     * @param rhs
     * @returns
     */
    sub(rhs: QQ): QQ;
    /**
     * @param rhs
     * @returns
     */
    mul(rhs: QQ): QQ;
    /**
     * @param rhs
     * @returns
     */
    div(rhs: QQ): QQ;
    /**
     * @returns
     */
    isOne(): boolean;
    /**
     * @returns
     */
    isZero(): boolean;
    /**
     * @returns
     */
    hashCode(): number;
    /**
     * Computes the multiplicative inverse of this rational number.
     *
     * @returns
     */
    inv(): QQ;
    /**
     * Computes the additive inverse of this rational number.
     *
     * @returns
     */
    neg(): QQ;
    /**
     * Determines whether two rational numbers are equal.
     *
     * @param other
     * @returns
     */
    equals(other: QQ): boolean;
    /**
     * Computes a non-normative string representation of this rational.
     *
     * @returns
     */
    toString(): string;
    /**
     * @param rhs
     * @returns
     */
    __add__(rhs: QQ): QQ | undefined;
    /**
     * @param lhs
     * @returns
     */
    __radd__(lhs: QQ): QQ | undefined;
    /**
     * @param rhs
     * @returns
     */
    __sub__(rhs: QQ): QQ | undefined;
    /**
     * @param lhs
     * @returns
     */
    __rsub__(lhs: QQ): QQ | undefined;
    /**
     * @param rhs
     * @returns
     */
    __mul__(rhs: QQ): QQ | undefined;
    /**
     * @param lhs
     * @returns
     */
    __rmul__(lhs: QQ): QQ | undefined;
    /**
     * @param div
     * @returns
     */
    __div__(rhs: QQ): QQ | undefined;
    /**
     * @param lhs
     * @returns
     */
    __rdiv__(lhs: QQ): QQ | undefined;
    /**
     * @returns
     */
    __pos__(): QQ;
    /**
     * @returns
     */
    __neg__(): QQ;
    private static POS_08_01;
    private static POS_07_01;
    private static POS_06_01;
    private static POS_05_01;
    private static POS_04_01;
    private static POS_03_01;
    private static POS_02_01;
    private static ONE;
    private static POS_01_02;
    private static POS_01_03;
    private static POS_01_04;
    private static POS_01_05;
    private static ZERO;
    private static NEG_01_03;
    private static NEG_01_01;
    private static NEG_02_01;
    private static NEG_03_01;
    private static POS_02_03;
    /**
     * @param numer
     * @param denom
     * @returns
     */
    static valueOf(n: number, d: number): QQ;
}

/**
 * Keeps track of the dimensions of a physical quantity using seven rational exponents.
 * Each of the exponents corresponds to a dimension in the S.I. system of units.
 */
declare class Dimensions {
    readonly M: QQ;
    readonly L: QQ;
    readonly T: QQ;
    readonly Q: QQ;
    readonly temperature: QQ;
    readonly amount: QQ;
    readonly intensity: QQ;
    /**
     * All exponents are zero, a dimensionless quantity.
     */
    static ONE: Dimensions;
    /**
     * M<sup>1</sup>
     */
    static MASS: Dimensions;
    /**
     * L<sup>1</sup>
     */
    static LENGTH: Dimensions;
    /**
     * T<sup>1</sup>
     */
    static TIME: Dimensions;
    /**
     * Q<sup>1</sup>
     */
    static CHARGE: Dimensions;
    /**
     * Q<sup>1</sup>T<sup>-1<sup>
     */
    static CURRENT: Dimensions;
    /**
     *
     */
    static TEMPERATURE: Dimensions;
    /**
     *
     */
    static AMOUNT: Dimensions;
    /**
     *
     */
    static INTENSITY: Dimensions;
    /**
     * The Dimensions class captures the physical dimensions associated with a unit of measure.
     *
     * @param M The mass component of the dimensions object.
     * @param L The length component of the dimensions object.
     * @param T The time component of the dimensions object.
     * @param Q The charge component of the dimensions object.
     * @param temperature The temperature component of the dimensions object.
     * @param amount The amount component of the dimensions object.
     * @param intensity The intensity component of the dimensions object.
     */
    constructor(M: QQ, L: QQ, T: QQ, Q: QQ, temperature: QQ, amount: QQ, intensity: QQ);
    /**
     * Returns the dimensions if they are all equal, otherwise throws an Error.
     *
     * @param rhs
     * @returns
     */
    compatible(rhs: Dimensions): Dimensions;
    /**
     * Multiplies dimensions by adding rational exponents.
     *
     * @param rhs
     * @returns <code>this * rhs</code>
     */
    mul(rhs: Dimensions): Dimensions;
    /**
     * Divides dimensions by subtracting rational exponents.
     *
     * @param rhs
     * @returns <code>this / rhs</code>
     */
    div(rhs: Dimensions): Dimensions;
    equals(rhs: Dimensions): boolean;
    /**
     * Computes the power function by multiplying rational exponents.
     */
    pow(exponent: QQ): Dimensions;
    /**
     * Computes the square root by dividing each rational component by two.
     *
     * @returns
     */
    sqrt(): Dimensions;
    /**
     * Determines whether all the exponents of this dimensions number are zero.
     * This implies a dimensionless quantity.
     *
     * @returns <code>true</code> if all the exponents are zero, otherwise <code>false</code>.
     */
    isOne(): boolean;
    /**
     * Computes the multiplicative inverse of this dimensions number.
     * This is achived by changing the signs of all the exponent quantities.
     *
     * @returns
     */
    inv(): Dimensions;
    /**
     * Intentionally undocumented.
     */
    neg(): Dimensions;
    /**
     * Creates a representation of this <code>Dimensions</code> instance.
     *
     * @returns
     */
    toString(): string;
    /**
     * @param rhs
     * @returns
     */
    __add__(rhs: Dimensions): Dimensions | undefined;
    /**
     * @param lhs
     * @returns
     */
    __radd__(lhs: Dimensions): Dimensions | undefined;
    /**
     *
     * @param rhs
     * @returns
     */
    __sub__(rhs: Dimensions): Dimensions | undefined;
    /**
     *
     * @param lhs
     * @returns
     */
    __rsub__(lhs: Dimensions): Dimensions | undefined;
    /**
     *
     * @param rhs
     * @returns
     */
    __mul__(rhs: Dimensions): Dimensions | undefined;
    /**
     *
     * @param lhs
     * @returns
     */
    __rmul__(lhs: Dimensions): Dimensions | undefined;
    /**
     *
     * @param rhs
     * @returns
     */
    __div__(rhs: Dimensions): Dimensions | undefined;
    /**
     * @param lhs
     * @returns
     */
    __rdiv__(lhs: Dimensions): Dimensions | undefined;
    /**
     * @returns
     */
    __pos__(): Dimensions;
    /**
     *
     * @returns
     */
    __neg__(): Dimensions;
}

/**
 * The Uom class represents the units for a measure.
 */
declare class Uom extends Atom<'Uom'> {
    dimensions: Dimensions;
    labels: string[];
    /**
     *
     */
    static ZERO: Uom;
    /**
     *
     */
    static ONE: Uom;
    /**
     *
     */
    static KILOGRAM: Uom;
    /**
     *
     */
    static METER: Uom;
    /**
     *
     */
    static SECOND: Uom;
    /**
     *
     */
    static COULOMB: Uom;
    /**
     *
     */
    static AMPERE: Uom;
    /**
     *
     */
    static KELVIN: Uom;
    /**
     *
     */
    static MOLE: Uom;
    /**
     *
     */
    static CANDELA: Uom;
    /**
     * @param dimensions
     * @param labels The label strings to use for each dimension.
     */
    constructor(dimensions: Dimensions, labels: string[]);
    /**
     * @param rhs
     * @returns
     */
    compatible(rhs: Uom): Uom;
    equals(other: U): boolean;
    /**
     * @param rhs
     * @returns
     */
    mul(rhs: Uom): Uom;
    /**
     * @param rhs
     * @returns
     */
    div(rhs: Uom): Uom;
    /**
     * Intentionaly undocumented.
     */
    pattern(): string;
    /**
     * @param exponent
     * @returns
     */
    pow(exponent: QQ): Uom;
    /**
     * @returns
     */
    inv(): Uom;
    /**
     * @returns true if this unit is dimensionless and the multiplier is unity.
     */
    isOne(): boolean;
    /**
     *
     */
    lerp(target: Uom, α: number): Uom;
    /**
     * @returns
     */
    quad(): Uom;
    /**
     * @param n
     * @returns
     */
    reflect(n: Uom): Uom;
    /**
     * @param rotor
     * @returns
     */
    rotate(rotor: Uom): Uom;
    /**
     * @param target
     * @param α
     * @returns
     */
    slerp(target: Uom, α: number): Uom;
    /**
     * @returns
     */
    sqrt(): Uom;
    /**
     * @param σ
     * @returns
     */
    stress(σ: Uom): Uom;
    /**
     * @param fractionDigits
     * @param compact Determines whether a multiplier of unity will be included in the result.
     * @returns
     */
    toExponential(fractionDigits?: number, compact?: boolean): string;
    /**
     * @param fractionDigits
     * @param compact Determines whether a multiplier of unity will be included in the result.
     * @returns
     */
    toFixed(fractionDigits?: number, compact?: boolean): string;
    toInfixString(): string;
    toListString(): string;
    /**
     * @param precision
     * @param compact Determines whether a multiplier of unity will be included in the result.
     * @returns
     */
    toPrecision(precision?: number, compact?: boolean): string;
    /**
     * @param radix
     * @param compact Determines whether a multiplier of unity will be included in the result.
     * @returns
     */
    toString(radix?: number, compact?: boolean): string;
    /**
     * @param uom
     * @returns
     */
    static isOne(uom: Uom): boolean;
    /**
     * @param uom
     * @returns
     */
    static assertDimensionless(uom: Uom): void;
    /**
     * @param lhs
     * @param rhs
     * @returns
     */
    static compatible(lhs: Uom, rhs: Uom): Uom | undefined;
    /**
     * @param lhs
     * @param rhs
     * @returns
     */
    static mul(lhs: Uom, rhs: Uom): Uom | undefined;
    /**
     * @param lhs
     * @param rhs
     * @returns
     */
    static div(lhs: Uom, rhs: Uom): Uom | undefined;
    /**
     * @param uom
     * @returns
     */
    static sqrt(uom: Uom): Uom | undefined;
}

declare function is_uom(expr: U): expr is Uom;

declare function create_uom(name: 'kilogram' | 'meter' | 'second' | 'coulomb' | 'ampere' | 'kelvin' | 'mole' | 'candela'): Uom;

declare enum SyntaxKind {
    /**
     * Based on Algebrite, which was derived from Eigenmath.
     */
    Native = 1,
    /**
     * Python Programming Language.
     */
    Python = 2,
    /**
     * Scheme Programming Language, a dialect of Lisp.
     */
    Scheme = 3
}
declare function human_readable_syntax_kind(syntaxKind: SyntaxKind): string;
declare const syntaxKinds: SyntaxKind[];
interface ParseOptions {
    syntaxKind?: SyntaxKind;
    /**
     * Determines whether the caret symbol '^' is used to denote exponentiation.
     * The alternative is to use '**', which frees the caret symbol to denote the outer product.
     */
    useCaretForExponentiation?: boolean;
    /**
     * Determines whether the parser makes associativity explicit or implicit in additive expressions.
     */
    explicitAssocAdd?: boolean;
    /**
     * Determines whether the parser makes associativity explicit or implicit in multiplicative expressions.
     */
    explicitAssocMul?: boolean;
}
declare function parse_expr(sourceText: string, options?: ParseOptions): U;
declare function parse_script(fileName: string, sourceText: string, options?: ParseOptions): {
    trees: U[];
    errors: Error[];
};

interface ScriptExecuteOptions {
    /**
     * Determines what kind of parser is used for the sourceText.
     */
    syntaxKind?: SyntaxKind;
}
interface ScriptContextOptions extends ScriptExecuteOptions {
    /**
     * The assumptions about unbound symbols.
     */
    assumes?: {
        [name: string]: Partial<SymbolProps>;
    };
    dependencies?: string[];
    disable?: ('expand' | 'factor')[];
    /**
     * Determines whether the circumflex (caret) character, '^', will be used during parsing to denote exponentiation.
     * The alternative is to use '**', freeing the caret character for use with outer products which is convenient
     * in applications using Geometric Algebra. The default value is false.
     */
    useCaretForExponentiation?: boolean;
    /**
     *
     */
    useDefinitions?: boolean;
}
interface ScriptContext {
    clearBindings(): void;
    defineFunction(pattern: U, impl: LambdaExpr): ScriptContext;
    getSymbolProps(sym: Sym | string): SymbolProps;
    getSymbolValue(sym: Sym | string): U;
    getSymbolsInfo(): {
        sym: Sym;
        value: U;
    }[];
    evaluate(tree: U): {
        value: U;
        prints: string[];
        errors: Error[];
    };
    useStandardDefinitions(): void;
    executeScript(sourceText: string, options?: ScriptExecuteOptions): {
        values: U[];
        prints: string[];
        errors: Error[];
    };
    renderAsAscii(expr: U): string;
    renderAsHuman(expr: U): string;
    renderAsInfix(expr: U): string;
    renderAsLaTeX(expr: U): string;
    renderAsSExpr(expr: U): string;
    addRef(): void;
    release(): void;
}
/**
 * Creates an engine for executing scripts.
 * The returned engine is reference counted and should be released when no longer needed.
 */
declare function create_script_context(contextOptions?: ScriptContextOptions): ScriptContext;

export { Atom, BasisBlade, Blade, Boo, CompareFn, Cons, Dimensions, Directive, ExprComparator, Extension, ExtensionEnv, Flt, Hyp, Imu, LambdaExpr, Native, Num, ParseOptions, PrintHandler, QQ, Rat, ScriptContext, ScriptContextOptions, ScriptExecuteOptions, Sign, Str, Sym, SymbolProps, SyntaxKind, Tensor, U, Uom, booF, booT, car, cdr, cons, create_boo, create_flt, create_hyp, create_int, create_rat, create_script_context, create_str, create_sym, create_tensor, create_uom, delta, epsilon, human_readable_syntax_kind, imu, is_atom, is_blade, is_boo, is_cons, is_flt, is_hyp, is_imu, is_nil, is_num, is_rat, is_str, is_sym, is_tensor, is_uom, items_to_cons, native_sym, nil, one, oneAsFlt, parse_expr, parse_script, syntaxKinds, zero, zeroAsFlt };
