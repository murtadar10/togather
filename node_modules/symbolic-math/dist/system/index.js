/**
* symbolic-math 0.9.102
* (c) David Geo Holmes david.geo.holmes@gmail.com
* Released under the MIT License.
*/
System.register([], (function (exports) {
    'use strict';
    return {
        execute: (function () {

            exports({
                car: car,
                cdr: cdr,
                cons: cons,
                create_boo: create_boo,
                create_flt: create_flt,
                create_hyp: create_hyp,
                create_int: create_int,
                create_rat: create_rat,
                create_script_context: create_script_context,
                create_str: create_str,
                create_sym: create_sym,
                create_tensor: create_tensor,
                create_uom: create_uom,
                human_readable_syntax_kind: human_readable_syntax_kind,
                is_atom: is_atom,
                is_blade: is_blade$1,
                is_boo: is_boo,
                is_cons: is_cons,
                is_flt: is_flt$1,
                is_hyp: is_hyp,
                is_imu: is_imu,
                is_nil: is_nil,
                is_num: is_num,
                is_rat: is_rat$1,
                is_str: is_str$1,
                is_sym: is_sym,
                is_tensor: is_tensor,
                is_uom: is_uom$1,
                items_to_cons: items_to_cons$1,
                native_sym: native_sym,
                parse_expr: parse_expr,
                parse_script: parse_script
            });

            /******************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */

            function __classPrivateFieldGet(receiver, state, kind, f) {
                if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
                if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
            }

            function __classPrivateFieldSet(receiver, state, value, kind, f) {
                if (kind === "m") throw new TypeError("Private method is not writable");
                if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
                if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
            }

            var _Cons_car, _Cons_cdr, _Cons_meta;
            function reset_meta_flag(current, which) {
                const retval = current & ~which;
                return retval;
            }
            /**
             * Determines whether a Cons expression contains a single item.
             * @param expr
             * @returns
             */
            function is_singleton(expr) {
                if (nil === expr) {
                    // Nope, it's the empty list.
                    return false;
                }
                const cdr_expr = expr.cdr;
                if (nil === cdr_expr) {
                    return true;
                }
                else {
                    return false;
                }
            }
            /**
             * Symbolic expressions are built by connecting Cons structures.
             *
             * For example, (a * b + c) is built like this:
             *
             * The car links go downwards, the cdr links go to the right.
             *
             *           _______      _______                                            _______      _______
             *          |CONS   |--->|CONS   |----------------------------------------->|CONS   |--->|NIL    |
             *          |       |    |       |                                          |       |    |       |
             *          |_______|    |_______|                                          |_______|    |_______|
             *              |            |                                                  |
             *           ___v___      ___v___      _______      _______      _______     ___v___
             *          |SYM +  |    |CONS   |--->|CONS   |--->|CONS   |--->|NIL    |   |SYM c  |
             *          |       |    |       |    |       |    |       |    |       |   |       |
             *          |_______|    |_______|    |_______|    |_______|    |_______|   |_______|
             *                           |            |            |
             *                        ___v___      ___v___      ___v___
             *                       |SYM *  |    |SYM a  |    |SYM b  |
             *                       |       |    |       |    |       |
             *                       |_______|    |_______|    |_______|
             *
             * A NIL is a special kind of Cons in which the isCons method returns false.
             * A SYM is never a cdr. There will be a CONS with a NIL cdr and a car containing the SYM.
             *
             */
            class Cons {
                constructor(meta, car, cdr, pos, end) {
                    this.pos = pos;
                    this.end = end;
                    _Cons_car.set(this, void 0);
                    _Cons_cdr.set(this, void 0);
                    _Cons_meta.set(this, void 0);
                    __classPrivateFieldSet(this, _Cons_car, car, "f");
                    __classPrivateFieldSet(this, _Cons_cdr, cdr, "f");
                    __classPrivateFieldSet(this, _Cons_meta, meta, "f");
                }
                get meta() {
                    return __classPrivateFieldGet(this, _Cons_meta, "f");
                }
                set meta(meta) {
                    __classPrivateFieldSet(this, _Cons_meta, meta, "f");
                }
                get name() {
                    if (__classPrivateFieldGet(this, _Cons_car, "f")) {
                        return 'Cons';
                    }
                    else {
                        return 'Nil';
                    }
                }
                /**
                 * Returns the car property if it is defined, otherwise NIL.
                 */
                get car() {
                    if (__classPrivateFieldGet(this, _Cons_car, "f")) {
                        return __classPrivateFieldGet(this, _Cons_car, "f");
                    }
                    else {
                        return nil;
                    }
                }
                /**
                 * Returns the cdr property if it is defined, otherwise NIL.
                 */
                get cdr() {
                    if (__classPrivateFieldGet(this, _Cons_cdr, "f")) {
                        if (__classPrivateFieldGet(this, _Cons_cdr, "f") instanceof Cons) {
                            return __classPrivateFieldGet(this, _Cons_cdr, "f");
                        }
                        else {
                            throw new Error();
                        }
                    }
                    else {
                        return nil;
                    }
                }
                /**
                 * Exactly the same as the cdr property. Used for code-as-documentation.
                 */
                get argList() {
                    return this.cdr;
                }
                contains(needle) {
                    if (this === needle || this.equals(needle)) {
                        return true;
                    }
                    if (__classPrivateFieldGet(this, _Cons_car, "f") && __classPrivateFieldGet(this, _Cons_cdr, "f")) {
                        return __classPrivateFieldGet(this, _Cons_car, "f").contains(needle) || __classPrivateFieldGet(this, _Cons_cdr, "f").contains(needle);
                    }
                    return false;
                }
                equals(other) {
                    if (this === other) {
                        return true;
                    }
                    if (is_cons(other)) {
                        return equal_cons_cons(this, other);
                    }
                    else {
                        return false;
                    }
                }
                isCons() {
                    if (__classPrivateFieldGet(this, _Cons_car, "f")) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                isNil() {
                    if (__classPrivateFieldGet(this, _Cons_car, "f")) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
                reset(meta) {
                    // console.lg(`Cons.reset(meta=${meta})`);
                    this.meta = reset_meta_flag(this.meta, meta);
                    if (__classPrivateFieldGet(this, _Cons_car, "f")) {
                        __classPrivateFieldGet(this, _Cons_car, "f").reset(meta);
                    }
                    if (__classPrivateFieldGet(this, _Cons_cdr, "f")) {
                        __classPrivateFieldGet(this, _Cons_cdr, "f").reset(meta);
                    }
                }
                toString() {
                    // If you call car or cdr you get an infinite loop because NIL is a Cons.
                    const head = __classPrivateFieldGet(this, _Cons_car, "f");
                    const tail = __classPrivateFieldGet(this, _Cons_cdr, "f");
                    if (head) {
                        return `(${head} ${tail})`;
                    }
                    else {
                        return '()';
                    }
                }
                /**
                 * Provides an iterator over the Cons, returning the items is the list.
                 * The first element returned will be car(cons).
                 * The subsequent elements are obtained from walking the cdr's.
                 * Hint: Using the ... operator inside [] returns all the items in the list.
                 */
                *[(_Cons_car = new WeakMap(), _Cons_cdr = new WeakMap(), _Cons_meta = new WeakMap(), Symbol.iterator)]() {
                    // eslint-disable-next-line @typescript-eslint/no-this-alias
                    let u = this;
                    while (is_cons(u)) {
                        yield u.car;
                        u = u.cdr;
                    }
                }
                /**
                 * Exactly the same as the car property. Used for code-as-documentation.
                 */
                get head() {
                    return this.car;
                }
                /**
                 * Return everything except the first item in the list.
                 */
                tail() {
                    if (this !== nil) {
                        const cdr = __classPrivateFieldGet(this, _Cons_cdr, "f");
                        if (cdr && is_cons(cdr)) {
                            return [...cdr];
                        }
                        else {
                            return [];
                        }
                    }
                    throw new Error("tail property is not allowed for the empty list.");
                }
                /**
                 * Maps the elements of the list using a mapping function.
                 */
                map(f) {
                    if (this !== nil) {
                        const a = this.car;
                        const b = this.cdr;
                        return new Cons(0, f(a), is_cons(b) ? b.map(f) : b);
                    }
                    else {
                        return nil;
                    }
                }
                /**
                 * Returns the length of the list.
                 */
                get length() {
                    // console.lg("Cons.length", "is_cons", is_cons(this), "is_nil", is_nil(this));
                    if (this !== nil) {
                        const argList = this.argList;
                        if (is_cons(argList)) {
                            return argList.length + 1;
                        }
                        else {
                            return 1;
                        }
                    }
                    else {
                        return 0;
                    }
                }
                /**
                 * A convenience property for the method item(0).
                 * A useful shortcut when working with operators.
                 */
                get opr() {
                    // TODO: this.car woul be more optimal.
                    return this.item(0);
                }
                /**
                 * A convenience property for the method item(1).
                 * A useful shortcut when working with unary operators.
                 */
                get arg() {
                    return this.item(1);
                }
                /**
                 * A convenience property for the method item(1).
                 * A useful shortcut when working with binary operators.
                 */
                get lhs() {
                    return this.item(1);
                }
                /**
                 * A convenience property for the method item(2).
                 * A useful shortcut when working with binary operators.
                 */
                get rhs() {
                    return this.item(2);
                }
                /**
                 * Returns the item at the specified (zero-based) index.
                 *
                 * (item0 item1 item2 ...)
                 */
                item(index) {
                    if (index >= 0 && this !== nil) {
                        if (index === 0) {
                            return this.car;
                        }
                        else {
                            const argList = this.argList;
                            if (is_cons(argList)) {
                                return argList.item(index - 1);
                            }
                        }
                    }
                    throw new Error("index out of bounds.");
                }
            } exports('Cons', Cons);
            function cons(car, cdr) {
                if (cdr instanceof Cons) {
                    return new Cons(0, car, cdr);
                }
                else {
                    throw new Error();
                }
            }
            function items_to_cons$1(...items) {
                let node = nil;
                // Iterate in reverse order so that we build up a NIL-terminated list from the right (NIL).
                for (let i = items.length - 1; i >= 0; i--) {
                    node = new Cons(0, items[i], node);
                }
                return node;
            }
            /**
             * The empty list.
             */
            const nil = exports('nil', new Cons(0, void 0, void 0));
            function is_atom(expr) {
                if (is_cons(expr)) {
                    return false;
                }
                else if (is_nil(expr)) {
                    return false;
                }
                else {
                    return true;
                }
            }
            /**
             * Returns true if arg is a Cons and is not NIL.
             * For NIL testing, test for identical equality to NIL.
             */
            function is_cons(expr) {
                if (typeof expr === 'undefined') {
                    return false;
                }
                else {
                    if (expr instanceof Cons) {
                        return !is_nil(expr);
                    }
                    else {
                        return false;
                    }
                }
            }
            function is_nil(expr) {
                return expr.equals(nil);
            }
            /**
             * Returns the car property of the tree node if it is a Cons.
             * Otherwise, returns NIL.
             */
            function car(node) {
                if (is_cons(node)) {
                    return node.car;
                }
                else {
                    return nil;
                }
            }
            /**
             * Returns the cdr property of the tree node if it is a Cons.
             * Otherwise, returns NIL.
             */
            function cdr(node) {
                if (is_cons(node)) {
                    return node.cdr;
                }
                else {
                    return nil;
                }
            }
            function equal_cons_cons(lhs, rhs) {
                let p1 = lhs;
                let p2 = rhs;
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    if (is_cons(p1) && is_cons(p2)) {
                        if (p1.car.equals(p2.car)) {
                            p1 = p1.cdr;
                            p2 = p2.cdr;
                            continue;
                        }
                        else {
                            return false;
                        }
                    }
                    if (is_cons(p1)) {
                        return false;
                    }
                    if (is_cons(p2)) {
                        return false;
                    }
                    if (p1.equals(p2)) {
                        // They are equal if there is nowhere else to go.
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }

            var _Atom_meta;
            class Atom {
                constructor(name, pos, end) {
                    this.name = name;
                    this.pos = pos;
                    this.end = end;
                    _Atom_meta.set(this, 0);
                }
                reset(meta) {
                    __classPrivateFieldSet(this, _Atom_meta, reset_meta_flag(__classPrivateFieldGet(this, _Atom_meta, "f"), meta), "f");
                }
                get meta() {
                    return __classPrivateFieldGet(this, _Atom_meta, "f");
                }
                set meta(meta) {
                    __classPrivateFieldSet(this, _Atom_meta, meta, "f");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                contains(needle) {
                    return this.equals(needle);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                equals(other) {
                    throw new Error(`Atom(name=${this.name}).equals(other=${other}) Method not implemented.`);
                }
                isCons() {
                    return false;
                }
                isNil() {
                    return false;
                }
            } exports('Atom', Atom);
            _Atom_meta = new WeakMap();

            var _Tensor_dims, _Tensor_elems;
            function equals_number_arrays(arrL, arrR) {
                if (arrL.length === arrR.length) {
                    for (let i = 0; i < arrL.length; i++) {
                        if (arrL[i] !== arrR[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                else {
                    return false;
                }
            }
            function equals_U_arrays(arrL, arrR) {
                if (arrL.length === arrR.length) {
                    for (let i = 0; i < arrL.length; i++) {
                        if (!arrL[i].equals(arrR[i])) {
                            return false;
                        }
                    }
                    return true;
                }
                else {
                    return false;
                }
            }
            /**
             * A matrix. This may be used to represent a tensor.
             * While the syntactic representation of a tensor is that of nested arrays,
             * the elements of the tensor are stored in a flattened manner. Presumambly,
             * this makes things easier in the case when a Tensor is used as a square matrix.
             */
            class Tensor extends Atom {
                /**
                 * @param dims The lengths of each dimension.
                 * @param elems The elements containing all the data.
                 */
                constructor(dims, elems, pos, end) {
                    super('Tensor', pos, end);
                    _Tensor_dims.set(this, void 0);
                    _Tensor_elems.set(this, void 0);
                    __classPrivateFieldSet(this, _Tensor_dims, dims, "f");
                    __classPrivateFieldSet(this, _Tensor_elems, elems, "f");
                }
                get rank() {
                    for (const elem of __classPrivateFieldGet(this, _Tensor_elems, "f")) {
                        if (is_tensor(elem)) {
                            return __classPrivateFieldGet(this, _Tensor_dims, "f").length + elem.rank;
                        }
                    }
                    return __classPrivateFieldGet(this, _Tensor_dims, "f").length;
                }
                get ndim() {
                    return __classPrivateFieldGet(this, _Tensor_dims, "f").length;
                }
                get nelem() {
                    return __classPrivateFieldGet(this, _Tensor_elems, "f").length;
                }
                contains(needle) {
                    if (this.equals(needle)) {
                        return true;
                    }
                    return this.someElements(function (element) {
                        return element.contains(needle);
                    });
                }
                copyDimensions() {
                    return [...__classPrivateFieldGet(this, _Tensor_dims, "f")];
                }
                /**
                 * Returns a copy of the data in this tensor.
                 */
                copyElements() {
                    return [...__classPrivateFieldGet(this, _Tensor_elems, "f")];
                }
                /**
                 * Returns the size of the specified dimension.
                 * This is the number of elements at the specified level of nesting.
                 * @param n The zero-based index of the dimension.
                 */
                dim(n) {
                    if (n < 0) {
                        throw new Error(`n must be greater than or equal to zero.`);
                    }
                    if (n > __classPrivateFieldGet(this, _Tensor_dims, "f").length - 1) {
                        throw new Error(`n + 1 must be less than ndim.`);
                    }
                    return __classPrivateFieldGet(this, _Tensor_dims, "f")[n];
                }
                elem(index) {
                    return __classPrivateFieldGet(this, _Tensor_elems, "f")[index];
                }
                equals(other) {
                    if (other instanceof Tensor) {
                        if (equals_number_arrays(__classPrivateFieldGet(this, _Tensor_dims, "f"), __classPrivateFieldGet(other, _Tensor_dims, "f"))) {
                            if (equals_U_arrays(__classPrivateFieldGet(this, _Tensor_elems, "f"), __classPrivateFieldGet(other, _Tensor_elems, "f"))) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                /**
                 * Applies the predicate to every element of this tensor.
                 * @param predicate The predicate applied.
                 * @returns true if every element satisfies the predicate.
                 */
                everyElement(predicate) {
                    return __classPrivateFieldGet(this, _Tensor_elems, "f").every(predicate);
                }
                filterElements(callbackfn) {
                    return __classPrivateFieldGet(this, _Tensor_elems, "f").filter(callbackfn);
                }
                map(callbackfn) {
                    return this.withElements(__classPrivateFieldGet(this, _Tensor_elems, "f").map(callbackfn));
                }
                mapElements(callbackfn) {
                    return __classPrivateFieldGet(this, _Tensor_elems, "f").map(callbackfn);
                }
                isCons() {
                    return false;
                }
                /**
                 * @override
                 */
                isNil() {
                    return false;
                }
                sameDimensions(other) {
                    if (this.ndim !== other.ndim) {
                        return false;
                    }
                    return __classPrivateFieldGet(this, _Tensor_dims, "f").every((size, i) => size === other.dim(i));
                }
                sliceDimensions(start, end) {
                    return __classPrivateFieldGet(this, _Tensor_dims, "f").slice(start, end);
                }
                someElements(callbackfn) {
                    return __classPrivateFieldGet(this, _Tensor_elems, "f").some(callbackfn);
                }
                toInfixString() {
                    return '<tensor>';
                }
                toListString() {
                    return '<tensor>';
                }
                toString() {
                    return `${this.name}(ndim=${this.ndim}, dim=[${__classPrivateFieldGet(this, _Tensor_dims, "f")}], elems=[${__classPrivateFieldGet(this, _Tensor_elems, "f").map(function (elem) {
            return `${elem}`;
        }).join(',')}])`;
                }
                /**
                 * Returns a new tensor with the same dimensions as this, but with different elements.
                 * This element avoids the copy of the dims array.
                 */
                withElements(elems) {
                    return new Tensor(__classPrivateFieldGet(this, _Tensor_dims, "f"), elems);
                }
            } exports('Tensor', Tensor);
            _Tensor_dims = new WeakMap(), _Tensor_elems = new WeakMap();

            function is_tensor(p) {
                return p instanceof Tensor;
            }

            /**
             * Creates a Tensor from an array of elements. If the elements themselves are tensors,
             * then that elements must be flattened, but the dimensionality is computed and incorporated
             * into the created Tensor.
             */
            function create_tensor(elements) {
                if (elements.length > 0) {
                    // The dimensions of the new tensor.
                    const dims = [elements.length];
                    /**
                     * The elements of the new tensor.
                     */
                    const elems = [];
                    let seenTensor = false;
                    for (let i = 0; i < elements.length; i++) {
                        const element = elements[i];
                        if (is_tensor(element)) {
                            const M = element;
                            if (seenTensor) ;
                            else {
                                for (let j = 0; j < M.ndim; j++) {
                                    dims[j + 1] = M.dim(j);
                                }
                                seenTensor = true;
                            }
                            for (let j = 0; j < M.nelem; j++) {
                                elems.push(M.elem(j));
                            }
                        }
                        else {
                            elems.push(element);
                        }
                    }
                    return new Tensor(dims, elems);
                }
                else {
                    return new Tensor([0], []);
                }
            }

            const SIGN_LT = -1;
            const SIGN_EQ = 0;
            const SIGN_GT = 1;
            /**
             * The expression was ignored by the transformer, usually because it did not match the transformer.
             */
            const TFLAG_NONE = 0;
            /**
             * The expression changed as a result of the transformation.
             */
            const TFLAG_DIFF = 1 << 0;
            /**
             * The expression did not change as a result of the transformation because it is stable.
             */
            const TFLAG_HALT = 1 << 1;
            /**
             * The expression node should be preserved.
             */
            const TFLAG_KEEP = 1 << 2;
            /**
             * Returns true if flags has the "diff" bit set.
             */
            function diffFlag(flags) {
                return (flags & TFLAG_DIFF) === TFLAG_DIFF;
            }
            /**
             * Returns true if flags has the "keep" bit set.
             */
            function keepFlag(flags) {
                return (flags & TFLAG_KEEP) === TFLAG_KEEP;
            }
            var Directive; exports('Directive', Directive);
            (function (Directive) {
                /**
                 * Mutually exclusive with factor.
                 */
                Directive[Directive["expand"] = 0] = "expand";
                /**
                 * Determines whether numeric types are converted to floating point numbers for numeric evaluation.
                 *
                 * The default value as false.
                 */
                Directive[Directive["evaluatingAsFloat"] = 1] = "evaluatingAsFloat";
                /**
                 * Determines whether complex numbers are driven towards rectangular or polar notation.
                 *
                 * The default value is false.
                 */
                Directive[Directive["evaluatingAsPolar"] = 2] = "evaluatingAsPolar";
                Directive[Directive["evaluatingAsClock"] = 3] = "evaluatingAsClock";
                /**
                 * Determines whether trigonometric functions are converted to exponential form.
                 *
                 * The default is false.
                 */
                Directive[Directive["evaluatingTrigAsExp"] = 4] = "evaluatingTrigAsExp";
                /**
                 * Determines whether zero terms are kept in sums in attempt to preserve the dynamic type.
                 * The alternative is to use a canonical zero value, usually that for rational numbers.
                 *
                 * The default value is false.
                 */
                Directive[Directive["keepZeroTermsInSums"] = 5] = "keepZeroTermsInSums";
                /**
                 * Mutually exclusive with expand.
                 */
                Directive[Directive["factor"] = 6] = "factor";
                /**
                 * Determines whether floating point numbers are rendered as EcmaScript numbers.
                 * If not, floating point numbers are rendered in a proprietary format.
                 *
                 * The default value is false.
                 */
                Directive[Directive["renderFloatAsEcmaScript"] = 7] = "renderFloatAsEcmaScript";
                /**
                 * Determines whether caret token '^' will be used for exponentiation or for the exterior product.
                 * Using the caret token for exponetitation is common in mathematical tools but not in programming languages.
                 *
                 * The default value is false.
                 */
                Directive[Directive["useCaretForExponentiation"] = 8] = "useCaretForExponentiation";
            })(Directive || (exports('Directive', Directive = {})));
            const MODE_EXPANDING = 1;
            const MODE_FACTORING = 2;
            const MODE_SEQUENCE = [MODE_EXPANDING, MODE_FACTORING];
            const MODE_FLAGS_ALL = MODE_EXPANDING | MODE_FACTORING;
            const PHASE_FLAGS_EXPANDING_UNION_FACTORING = MODE_EXPANDING | MODE_FACTORING;

            /**
             * Natively implemented concepts.
             * Uppercase elements correspond to constants.
             * Lowercase elements correspond to functions.
             */
            var Native; exports('Native', Native);
            (function (Native) {
                // Constants (upper case)
                Native[Native["E"] = 0] = "E";
                Native[Native["IMU"] = 1] = "IMU";
                Native[Native["MASH"] = 2] = "MASH";
                Native[Native["NIL"] = 3] = "NIL";
                Native[Native["PI"] = 4] = "PI";
                // Functions (lower case)
                Native[Native["abs"] = 5] = "abs";
                Native[Native["add"] = 6] = "add";
                Native[Native["arctan"] = 7] = "arctan";
                Native[Native["arg"] = 8] = "arg";
                Native[Native["conj"] = 9] = "conj";
                Native[Native["cos"] = 10] = "cos";
                Native[Native["divide"] = 11] = "divide";
                Native[Native["exp"] = 12] = "exp";
                Native[Native["imag"] = 13] = "imag";
                Native[Native["inner"] = 14] = "inner";
                Native[Native["inverse"] = 15] = "inverse";
                Native[Native["is_complex"] = 16] = "is_complex";
                Native[Native["is_real"] = 17] = "is_real";
                Native[Native["is_zero"] = 18] = "is_zero";
                Native[Native["lco"] = 19] = "lco";
                Native[Native["log"] = 20] = "log";
                /**
                 * mod(a,b) returns the remainder of the result of a divided by b.
                 */
                Native[Native["mod"] = 21] = "mod";
                Native[Native["multiply"] = 22] = "multiply";
                Native[Native["outer"] = 23] = "outer";
                Native[Native["pow"] = 24] = "pow";
                Native[Native["real"] = 25] = "real";
                Native[Native["rect"] = 26] = "rect";
                Native[Native["rco"] = 27] = "rco";
                Native[Native["sin"] = 28] = "sin";
                Native[Native["spread"] = 29] = "spread";
                Native[Native["subtract"] = 30] = "subtract";
                Native[Native["succ"] = 31] = "succ";
                /**
                 * tau(x) = 2 * PI * x
                 */
                Native[Native["tau"] = 32] = "tau";
                Native[Native["test_eq"] = 33] = "test_eq";
                Native[Native["test_ge"] = 34] = "test_ge";
                Native[Native["test_gt"] = 35] = "test_gt";
                Native[Native["test_le"] = 36] = "test_le";
                Native[Native["test_lt"] = 37] = "test_lt";
                Native[Native["test_ne"] = 38] = "test_ne";
            })(Native || (exports('Native', Native = {})));

            var _Sym_text;
            function strcmp$1(str1, str2) {
                if (str1 === str2) {
                    return 0;
                }
                else if (str1 > str2) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            const secretToEnforceUsingCreateSym = Math.random();
            const cache$2 = new Map();
            function create_sym(text, pos, end) {
                const cached = cache$2.get(text);
                if (cached) {
                    return cached;
                }
                const sym = new Sym(secretToEnforceUsingCreateSym, text, pos, end);
                cache$2.set(text, sym);
                return sym;
            }
            class Sym extends Atom {
                /**
                 * Use create_sym to create a new Sym instance.
                 */
                constructor(secret, text, pos, end) {
                    super('Sym', pos, end);
                    _Sym_text.set(this, void 0);
                    __classPrivateFieldSet(this, _Sym_text, text, "f");
                    if (secret !== secretToEnforceUsingCreateSym) {
                        throw new Error("Sym instances must be created using the create_sym function.");
                    }
                }
                compare(other) {
                    // console.lg("compare", "this", this.ln, "other", other.ln);
                    return strcmp$1(__classPrivateFieldGet(this, _Sym_text, "f"), __classPrivateFieldGet(other, _Sym_text, "f"));
                }
                contains(needle) {
                    if (needle instanceof Sym) {
                        return this.equalsSym(needle);
                    }
                    return false;
                }
                /**
                 * Creates a new symbol with exactly the same local name and namespace as this symbol.
                 * However it allows scanning information to be carried along with the new instance.
                 * @param pos The start position of the symbol in the source text.
                 * @param end The end position of the symbol in the source text.
                 */
                clone(pos, end) {
                    return create_sym(__classPrivateFieldGet(this, _Sym_text, "f"), pos, end);
                }
                equals(other) {
                    if (other instanceof Sym) {
                        return this.equalsSym(other);
                    }
                    return false;
                }
                equalsSym(other) {
                    if (this === other) {
                        return true;
                    }
                    else {
                        return __classPrivateFieldGet(this, _Sym_text, "f") === __classPrivateFieldGet(other, _Sym_text, "f");
                    }
                }
                key() {
                    return __classPrivateFieldGet(this, _Sym_text, "f");
                }
                get text() {
                    return __classPrivateFieldGet(this, _Sym_text, "f");
                }
                toString() {
                    return __classPrivateFieldGet(this, _Sym_text, "f");
                }
            } exports('Sym', Sym);
            _Sym_text = new WeakMap();

            const cache$1 = new Map();
            function native_sym(code) {
                const sym = cache$1.get(code);
                if (sym) {
                    return sym;
                }
                else {
                    const s = build_sym(code);
                    cache$1.set(code, s);
                    return s;
                }
            }
            function build_sym(code) {
                switch (code) {
                    // Constants (upper case)...
                    case Native.E: return create_sym('E');
                    case Native.IMU: return create_sym('IMU');
                    case Native.MASH: return create_sym('MASH');
                    case Native.NIL: return create_sym('NIL');
                    case Native.PI: return create_sym('PI');
                    // Functions (lower case)...
                    case Native.abs: return create_sym('abs');
                    case Native.add: return create_sym('add');
                    case Native.arctan: return create_sym('arctan');
                    case Native.arg: return create_sym('arg');
                    case Native.conj: return create_sym('conj');
                    case Native.cos: return create_sym('cos');
                    case Native.divide: return create_sym('/');
                    case Native.exp: return create_sym('exp');
                    case Native.imag: return create_sym('imag');
                    case Native.inner: return create_sym('inner');
                    case Native.inverse: return create_sym('inv');
                    case Native.is_complex: return create_sym('iscomplex');
                    case Native.is_real: return create_sym('isreal');
                    case Native.is_zero: return create_sym('iszero');
                    case Native.lco: return create_sym('<<');
                    case Native.log: return create_sym('log');
                    case Native.mod: return create_sym('mod');
                    case Native.multiply: return create_sym('*');
                    case Native.outer: return create_sym('outer');
                    case Native.pow: return create_sym('pow');
                    case Native.real: return create_sym('real');
                    case Native.rect: return create_sym('rect');
                    case Native.rco: return create_sym('>>');
                    case Native.sin: return create_sym('sin');
                    case Native.spread: return create_sym('...');
                    case Native.subtract: return create_sym('-');
                    case Native.succ: return create_sym('succ');
                    case Native.tau: return create_sym('tau');
                    case Native.test_eq: return create_sym('==');
                    case Native.test_ge: return create_sym('>=');
                    case Native.test_gt: return create_sym('>');
                    case Native.test_le: return create_sym('<=');
                    case Native.test_lt: return create_sym('<');
                    case Native.test_ne: return create_sym('!=');
                    default: throw new Error(`${code}`);
                }
            }

            function is_blade$1(arg) {
                // We have to use duck-typing because Vec is an interface, not a class.
                if (typeof arg === 'object') {
                    const duck = arg;
                    return duck.name === 'Blade';
                }
                else {
                    return false;
                }
            }

            /**
             * The implementation of a Logical Boolean value.
             */
            class Boo extends Atom {
                constructor(b, pos, end) {
                    super('Boo', pos, end);
                    this.b = b;
                }
                equals(other) {
                    if (this === other) {
                        return true;
                    }
                    if (other instanceof Boo) {
                        return this.equalsBoo(other);
                    }
                    else {
                        return false;
                    }
                }
                equalsBoo(other) {
                    return this.b === other.b;
                }
                isTrue() {
                    return this.b;
                }
                toString() {
                    return this.b ? `${this.name}(true)` : `${this.name}(false)`;
                }
                static valueOf(b) {
                    return b ? booT : booF;
                }
            } exports('Boo', Boo);
            function create_boo(b) {
                return Boo.valueOf(b);
            }
            const booT = exports('booT', new Boo(true));
            const booF = exports('booF', new Boo(false));

            function is_boo(p) {
                return p instanceof Boo;
            }

            /**
             * Constructs a floating point number object from a number primitive.
             * @param value The floating point number value.
             * @param pos The start position of the number in the source text.
             * @param end The end position of the number in the source text.
             */
            function create_flt(value, pos, end) {
                if (value === zeroAsFlt.d) {
                    return zeroAsFlt;
                }
                if (value === oneAsFlt.d) {
                    return oneAsFlt;
                }
                if (value === negOneAsFlt.d) {
                    return negOneAsFlt;
                }
                if (value === twoAsFlt.d) {
                    return twoAsFlt;
                }
                if (value === negTwoAsFlt.d) {
                    return negTwoAsFlt;
                }
                // console.lg("wrap_as_flt", value);
                return new Flt(value, pos, end);
            }
            class Flt extends Atom {
                /**
                 * Use the factory method instead. This may not exist in future.
                 */
                constructor(d, pos, end) {
                    super('Flt', pos, end);
                    this.d = d;
                }
                abs() {
                    return this.d >= 0 ? this : this.neg();
                }
                add(rhs) {
                    return create_flt(this.d + rhs.d);
                }
                compare(other) {
                    if (this.d > other.d) {
                        return 1;
                    }
                    if (this.d < other.d) {
                        return -1;
                    }
                    return 0;
                }
                equals(other) {
                    if (this === other) {
                        return true;
                    }
                    if (other instanceof Flt) {
                        return this.equalsFlt(other);
                    }
                    else {
                        return false;
                    }
                }
                equalsFlt(other) {
                    return this.d === other.d;
                }
                inv() {
                    return new Flt(1 / this.d, this.pos, this.end);
                }
                /**
                 * Returns true if this number is less than zero.
                 */
                isNegative() {
                    return this.d < 0;
                }
                isMinusOne() {
                    return this.d === -1;
                }
                isOne() {
                    return this.d === 1;
                }
                isPositive() {
                    return this.d > 0;
                }
                isZero() {
                    return this.d === 0;
                }
                mul(rhs) {
                    return create_flt(this.d * rhs.d);
                }
                neg() {
                    return create_flt(-this.d);
                }
                sub(rhs) {
                    return create_flt(this.d - rhs.d);
                }
                toInfixString() {
                    return `${this.d}`;
                }
                toListString() {
                    return `${this.d}`;
                }
                toNumber() {
                    return this.d;
                }
                toString() {
                    return `${this.name}(${this.d})`;
                }
            } exports('Flt', Flt);
            const zeroAsFlt = exports('zeroAsFlt', new Flt(0.0));
            const oneAsFlt = exports('oneAsFlt', new Flt(1.0));
            const twoAsFlt = new Flt(2.0);
            const piAsFlt = new Flt(Math.PI);
            new Flt(1e-6);
            const eAsFlt = new Flt(Math.E);
            const negOneAsFlt = new Flt(-1.0);
            const negTwoAsFlt = new Flt(-2.0);

            function is_flt$1(expr) {
                return expr instanceof Flt;
            }

            class Hyp extends Atom {
                constructor(printname, pos, end) {
                    super('Hyp', pos, end);
                    this.printname = printname;
                }
                equals(other) {
                    if (other instanceof Hyp) {
                        return this.equalsHyp(other);
                    }
                    return false;
                }
                equalsHyp(other) {
                    if (this === other) {
                        return true;
                    }
                    return this.printname === other.printname;
                }
                toInfixString() {
                    throw new Error("Hyp Method not implemented.");
                }
                toListString() {
                    throw new Error("Hyp Method not implemented.");
                }
                toString() {
                    return `${this.name}()`;
                }
            } exports('Hyp', Hyp);
            function create_hyp(printname) {
                return new Hyp(printname);
            }
            const epsilon = exports('epsilon', new Hyp('ε'));
            const delta = exports('delta', new Hyp('δ'));

            function is_hyp(expr) {
                return expr instanceof Hyp;
            }

            /**
             * The implementation of the imaginary unit.
             */
            class Imu extends Atom {
                constructor(pos, end) {
                    super('Imu', pos, end);
                }
                equals(other) {
                    if (this === other) {
                        return true;
                    }
                    if (other instanceof Imu) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                toString() {
                    return 'i';
                }
            } exports('Imu', Imu);
            const imu = exports('imu', new Imu());

            // import { BCons } from "../operators/helpers/BCons";
            // export type IMU_TYPE = BCons<Sym, Rat, Rat>;
            /**
             * Determines whether expr is the imaginary unit (imu), (expt -1 1/2).
             * @param expr The expression to test.
             */
            function is_imu(expr) {
                return expr instanceof Imu;
                /*
                if (is_cons(expr) && is_pow_2_rat_rat(expr)) {
                    const base = expr.lhs;
                    const expo = expr.rhs;
                    return base.isMinusOne() && expo.isHalf();
                }
                return false;
                */
            }

            var BigIntegerExports = {};
            var BigInteger = {
              get exports(){ return BigIntegerExports; },
              set exports(v){ BigIntegerExports = v; },
            };

            (function (module) {
            	var bigInt = (function (undefined$1) {

            	    var BASE = 1e7,
            	        LOG_BASE = 7,
            	        MAX_INT = 9007199254740992,
            	        MAX_INT_ARR = smallToArray(MAX_INT),
            	        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

            	    var supportsNativeBigInt = typeof BigInt === "function";

            	    function Integer(v, radix, alphabet, caseSensitive) {
            	        if (typeof v === "undefined") return Integer[0];
            	        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
            	        return parseValue(v);
            	    }

            	    function BigInteger(value, sign) {
            	        this.value = value;
            	        this.sign = sign;
            	        this.isSmall = false;
            	    }
            	    BigInteger.prototype = Object.create(Integer.prototype);

            	    function SmallInteger(value) {
            	        this.value = value;
            	        this.sign = value < 0;
            	        this.isSmall = true;
            	    }
            	    SmallInteger.prototype = Object.create(Integer.prototype);

            	    function NativeBigInt(value) {
            	        this.value = value;
            	    }
            	    NativeBigInt.prototype = Object.create(Integer.prototype);

            	    function isPrecise(n) {
            	        return -MAX_INT < n && n < MAX_INT;
            	    }

            	    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
            	        if (n < 1e7)
            	            return [n];
            	        if (n < 1e14)
            	            return [n % 1e7, Math.floor(n / 1e7)];
            	        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
            	    }

            	    function arrayToSmall(arr) { // If BASE changes this function may need to change
            	        trim(arr);
            	        var length = arr.length;
            	        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            	            switch (length) {
            	                case 0: return 0;
            	                case 1: return arr[0];
            	                case 2: return arr[0] + arr[1] * BASE;
            	                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            	            }
            	        }
            	        return arr;
            	    }

            	    function trim(v) {
            	        var i = v.length;
            	        while (v[--i] === 0);
            	        v.length = i + 1;
            	    }

            	    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
            	        var x = new Array(length);
            	        var i = -1;
            	        while (++i < length) {
            	            x[i] = 0;
            	        }
            	        return x;
            	    }

            	    function truncate(n) {
            	        if (n > 0) return Math.floor(n);
            	        return Math.ceil(n);
            	    }

            	    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
            	        var l_a = a.length,
            	            l_b = b.length,
            	            r = new Array(l_a),
            	            carry = 0,
            	            base = BASE,
            	            sum, i;
            	        for (i = 0; i < l_b; i++) {
            	            sum = a[i] + b[i] + carry;
            	            carry = sum >= base ? 1 : 0;
            	            r[i] = sum - carry * base;
            	        }
            	        while (i < l_a) {
            	            sum = a[i] + carry;
            	            carry = sum === base ? 1 : 0;
            	            r[i++] = sum - carry * base;
            	        }
            	        if (carry > 0) r.push(carry);
            	        return r;
            	    }

            	    function addAny(a, b) {
            	        if (a.length >= b.length) return add(a, b);
            	        return add(b, a);
            	    }

            	    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
            	        var l = a.length,
            	            r = new Array(l),
            	            base = BASE,
            	            sum, i;
            	        for (i = 0; i < l; i++) {
            	            sum = a[i] - base + carry;
            	            carry = Math.floor(sum / base);
            	            r[i] = sum - carry * base;
            	            carry += 1;
            	        }
            	        while (carry > 0) {
            	            r[i++] = carry % base;
            	            carry = Math.floor(carry / base);
            	        }
            	        return r;
            	    }

            	    BigInteger.prototype.add = function (v) {
            	        var n = parseValue(v);
            	        if (this.sign !== n.sign) {
            	            return this.subtract(n.negate());
            	        }
            	        var a = this.value, b = n.value;
            	        if (n.isSmall) {
            	            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
            	        }
            	        return new BigInteger(addAny(a, b), this.sign);
            	    };
            	    BigInteger.prototype.plus = BigInteger.prototype.add;

            	    SmallInteger.prototype.add = function (v) {
            	        var n = parseValue(v);
            	        var a = this.value;
            	        if (a < 0 !== n.sign) {
            	            return this.subtract(n.negate());
            	        }
            	        var b = n.value;
            	        if (n.isSmall) {
            	            if (isPrecise(a + b)) return new SmallInteger(a + b);
            	            b = smallToArray(Math.abs(b));
            	        }
            	        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
            	    };
            	    SmallInteger.prototype.plus = SmallInteger.prototype.add;

            	    NativeBigInt.prototype.add = function (v) {
            	        return new NativeBigInt(this.value + parseValue(v).value);
            	    };
            	    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

            	    function subtract(a, b) { // assumes a and b are arrays with a >= b
            	        var a_l = a.length,
            	            b_l = b.length,
            	            r = new Array(a_l),
            	            borrow = 0,
            	            base = BASE,
            	            i, difference;
            	        for (i = 0; i < b_l; i++) {
            	            difference = a[i] - borrow - b[i];
            	            if (difference < 0) {
            	                difference += base;
            	                borrow = 1;
            	            } else borrow = 0;
            	            r[i] = difference;
            	        }
            	        for (i = b_l; i < a_l; i++) {
            	            difference = a[i] - borrow;
            	            if (difference < 0) difference += base;
            	            else {
            	                r[i++] = difference;
            	                break;
            	            }
            	            r[i] = difference;
            	        }
            	        for (; i < a_l; i++) {
            	            r[i] = a[i];
            	        }
            	        trim(r);
            	        return r;
            	    }

            	    function subtractAny(a, b, sign) {
            	        var value;
            	        if (compareAbs(a, b) >= 0) {
            	            value = subtract(a, b);
            	        } else {
            	            value = subtract(b, a);
            	            sign = !sign;
            	        }
            	        value = arrayToSmall(value);
            	        if (typeof value === "number") {
            	            if (sign) value = -value;
            	            return new SmallInteger(value);
            	        }
            	        return new BigInteger(value, sign);
            	    }

            	    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
            	        var l = a.length,
            	            r = new Array(l),
            	            carry = -b,
            	            base = BASE,
            	            i, difference;
            	        for (i = 0; i < l; i++) {
            	            difference = a[i] + carry;
            	            carry = Math.floor(difference / base);
            	            difference %= base;
            	            r[i] = difference < 0 ? difference + base : difference;
            	        }
            	        r = arrayToSmall(r);
            	        if (typeof r === "number") {
            	            if (sign) r = -r;
            	            return new SmallInteger(r);
            	        } return new BigInteger(r, sign);
            	    }

            	    BigInteger.prototype.subtract = function (v) {
            	        var n = parseValue(v);
            	        if (this.sign !== n.sign) {
            	            return this.add(n.negate());
            	        }
            	        var a = this.value, b = n.value;
            	        if (n.isSmall)
            	            return subtractSmall(a, Math.abs(b), this.sign);
            	        return subtractAny(a, b, this.sign);
            	    };
            	    BigInteger.prototype.minus = BigInteger.prototype.subtract;

            	    SmallInteger.prototype.subtract = function (v) {
            	        var n = parseValue(v);
            	        var a = this.value;
            	        if (a < 0 !== n.sign) {
            	            return this.add(n.negate());
            	        }
            	        var b = n.value;
            	        if (n.isSmall) {
            	            return new SmallInteger(a - b);
            	        }
            	        return subtractSmall(b, Math.abs(a), a >= 0);
            	    };
            	    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

            	    NativeBigInt.prototype.subtract = function (v) {
            	        return new NativeBigInt(this.value - parseValue(v).value);
            	    };
            	    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

            	    BigInteger.prototype.negate = function () {
            	        return new BigInteger(this.value, !this.sign);
            	    };
            	    SmallInteger.prototype.negate = function () {
            	        var sign = this.sign;
            	        var small = new SmallInteger(-this.value);
            	        small.sign = !sign;
            	        return small;
            	    };
            	    NativeBigInt.prototype.negate = function () {
            	        return new NativeBigInt(-this.value);
            	    };

            	    BigInteger.prototype.abs = function () {
            	        return new BigInteger(this.value, false);
            	    };
            	    SmallInteger.prototype.abs = function () {
            	        return new SmallInteger(Math.abs(this.value));
            	    };
            	    NativeBigInt.prototype.abs = function () {
            	        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
            	    };


            	    function multiplyLong(a, b) {
            	        var a_l = a.length,
            	            b_l = b.length,
            	            l = a_l + b_l,
            	            r = createArray(l),
            	            base = BASE,
            	            product, carry, i, a_i, b_j;
            	        for (i = 0; i < a_l; ++i) {
            	            a_i = a[i];
            	            for (var j = 0; j < b_l; ++j) {
            	                b_j = b[j];
            	                product = a_i * b_j + r[i + j];
            	                carry = Math.floor(product / base);
            	                r[i + j] = product - carry * base;
            	                r[i + j + 1] += carry;
            	            }
            	        }
            	        trim(r);
            	        return r;
            	    }

            	    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
            	        var l = a.length,
            	            r = new Array(l),
            	            base = BASE,
            	            carry = 0,
            	            product, i;
            	        for (i = 0; i < l; i++) {
            	            product = a[i] * b + carry;
            	            carry = Math.floor(product / base);
            	            r[i] = product - carry * base;
            	        }
            	        while (carry > 0) {
            	            r[i++] = carry % base;
            	            carry = Math.floor(carry / base);
            	        }
            	        return r;
            	    }

            	    function shiftLeft(x, n) {
            	        var r = [];
            	        while (n-- > 0) r.push(0);
            	        return r.concat(x);
            	    }

            	    function multiplyKaratsuba(x, y) {
            	        var n = Math.max(x.length, y.length);

            	        if (n <= 30) return multiplyLong(x, y);
            	        n = Math.ceil(n / 2);

            	        var b = x.slice(n),
            	            a = x.slice(0, n),
            	            d = y.slice(n),
            	            c = y.slice(0, n);

            	        var ac = multiplyKaratsuba(a, c),
            	            bd = multiplyKaratsuba(b, d),
            	            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

            	        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
            	        trim(product);
            	        return product;
            	    }

            	    // The following function is derived from a surface fit of a graph plotting the performance difference
            	    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
            	    function useKaratsuba(l1, l2) {
            	        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
            	    }

            	    BigInteger.prototype.multiply = function (v) {
            	        var n = parseValue(v),
            	            a = this.value, b = n.value,
            	            sign = this.sign !== n.sign,
            	            abs;
            	        if (n.isSmall) {
            	            if (b === 0) return Integer[0];
            	            if (b === 1) return this;
            	            if (b === -1) return this.negate();
            	            abs = Math.abs(b);
            	            if (abs < BASE) {
            	                return new BigInteger(multiplySmall(a, abs), sign);
            	            }
            	            b = smallToArray(abs);
            	        }
            	        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            	            return new BigInteger(multiplyKaratsuba(a, b), sign);
            	        return new BigInteger(multiplyLong(a, b), sign);
            	    };

            	    BigInteger.prototype.times = BigInteger.prototype.multiply;

            	    function multiplySmallAndArray(a, b, sign) { // a >= 0
            	        if (a < BASE) {
            	            return new BigInteger(multiplySmall(b, a), sign);
            	        }
            	        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
            	    }
            	    SmallInteger.prototype._multiplyBySmall = function (a) {
            	        if (isPrecise(a.value * this.value)) {
            	            return new SmallInteger(a.value * this.value);
            	        }
            	        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
            	    };
            	    BigInteger.prototype._multiplyBySmall = function (a) {
            	        if (a.value === 0) return Integer[0];
            	        if (a.value === 1) return this;
            	        if (a.value === -1) return this.negate();
            	        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
            	    };
            	    SmallInteger.prototype.multiply = function (v) {
            	        return parseValue(v)._multiplyBySmall(this);
            	    };
            	    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

            	    NativeBigInt.prototype.multiply = function (v) {
            	        return new NativeBigInt(this.value * parseValue(v).value);
            	    };
            	    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

            	    function square(a) {
            	        //console.assert(2 * BASE * BASE < MAX_INT);
            	        var l = a.length,
            	            r = createArray(l + l),
            	            base = BASE,
            	            product, carry, i, a_i, a_j;
            	        for (i = 0; i < l; i++) {
            	            a_i = a[i];
            	            carry = 0 - a_i * a_i;
            	            for (var j = i; j < l; j++) {
            	                a_j = a[j];
            	                product = 2 * (a_i * a_j) + r[i + j] + carry;
            	                carry = Math.floor(product / base);
            	                r[i + j] = product - carry * base;
            	            }
            	            r[i + l] = carry;
            	        }
            	        trim(r);
            	        return r;
            	    }

            	    BigInteger.prototype.square = function () {
            	        return new BigInteger(square(this.value), false);
            	    };

            	    SmallInteger.prototype.square = function () {
            	        var value = this.value * this.value;
            	        if (isPrecise(value)) return new SmallInteger(value);
            	        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
            	    };

            	    NativeBigInt.prototype.square = function (v) {
            	        return new NativeBigInt(this.value * this.value);
            	    };

            	    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
            	        var a_l = a.length,
            	            b_l = b.length,
            	            base = BASE,
            	            result = createArray(b.length),
            	            divisorMostSignificantDigit = b[b_l - 1],
            	            // normalization
            	            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            	            remainder = multiplySmall(a, lambda),
            	            divisor = multiplySmall(b, lambda),
            	            quotientDigit, shift, carry, borrow, i, l, q;
            	        if (remainder.length <= a_l) remainder.push(0);
            	        divisor.push(0);
            	        divisorMostSignificantDigit = divisor[b_l - 1];
            	        for (shift = a_l - b_l; shift >= 0; shift--) {
            	            quotientDigit = base - 1;
            	            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            	                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            	            }
            	            // quotientDigit <= base - 1
            	            carry = 0;
            	            borrow = 0;
            	            l = divisor.length;
            	            for (i = 0; i < l; i++) {
            	                carry += quotientDigit * divisor[i];
            	                q = Math.floor(carry / base);
            	                borrow += remainder[shift + i] - (carry - q * base);
            	                carry = q;
            	                if (borrow < 0) {
            	                    remainder[shift + i] = borrow + base;
            	                    borrow = -1;
            	                } else {
            	                    remainder[shift + i] = borrow;
            	                    borrow = 0;
            	                }
            	            }
            	            while (borrow !== 0) {
            	                quotientDigit -= 1;
            	                carry = 0;
            	                for (i = 0; i < l; i++) {
            	                    carry += remainder[shift + i] - base + divisor[i];
            	                    if (carry < 0) {
            	                        remainder[shift + i] = carry + base;
            	                        carry = 0;
            	                    } else {
            	                        remainder[shift + i] = carry;
            	                        carry = 1;
            	                    }
            	                }
            	                borrow += carry;
            	            }
            	            result[shift] = quotientDigit;
            	        }
            	        // denormalization
            	        remainder = divModSmall(remainder, lambda)[0];
            	        return [arrayToSmall(result), arrayToSmall(remainder)];
            	    }

            	    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
            	        // Performs faster than divMod1 on larger input sizes.
            	        var a_l = a.length,
            	            b_l = b.length,
            	            result = [],
            	            part = [],
            	            base = BASE,
            	            guess, xlen, highx, highy, check;
            	        while (a_l) {
            	            part.unshift(a[--a_l]);
            	            trim(part);
            	            if (compareAbs(part, b) < 0) {
            	                result.push(0);
            	                continue;
            	            }
            	            xlen = part.length;
            	            highx = part[xlen - 1] * base + part[xlen - 2];
            	            highy = b[b_l - 1] * base + b[b_l - 2];
            	            if (xlen > b_l) {
            	                highx = (highx + 1) * base;
            	            }
            	            guess = Math.ceil(highx / highy);
            	            do {
            	                check = multiplySmall(b, guess);
            	                if (compareAbs(check, part) <= 0) break;
            	                guess--;
            	            } while (guess);
            	            result.push(guess);
            	            part = subtract(part, check);
            	        }
            	        result.reverse();
            	        return [arrayToSmall(result), arrayToSmall(part)];
            	    }

            	    function divModSmall(value, lambda) {
            	        var length = value.length,
            	            quotient = createArray(length),
            	            base = BASE,
            	            i, q, remainder, divisor;
            	        remainder = 0;
            	        for (i = length - 1; i >= 0; --i) {
            	            divisor = remainder * base + value[i];
            	            q = truncate(divisor / lambda);
            	            remainder = divisor - q * lambda;
            	            quotient[i] = q | 0;
            	        }
            	        return [quotient, remainder | 0];
            	    }

            	    function divModAny(self, v) {
            	        var value, n = parseValue(v);
            	        if (supportsNativeBigInt) {
            	            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
            	        }
            	        var a = self.value, b = n.value;
            	        var quotient;
            	        if (b === 0) throw new Error("Cannot divide by zero");
            	        if (self.isSmall) {
            	            if (n.isSmall) {
            	                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            	            }
            	            return [Integer[0], self];
            	        }
            	        if (n.isSmall) {
            	            if (b === 1) return [self, Integer[0]];
            	            if (b == -1) return [self.negate(), Integer[0]];
            	            var abs = Math.abs(b);
            	            if (abs < BASE) {
            	                value = divModSmall(a, abs);
            	                quotient = arrayToSmall(value[0]);
            	                var remainder = value[1];
            	                if (self.sign) remainder = -remainder;
            	                if (typeof quotient === "number") {
            	                    if (self.sign !== n.sign) quotient = -quotient;
            	                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
            	                }
            	                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            	            }
            	            b = smallToArray(abs);
            	        }
            	        var comparison = compareAbs(a, b);
            	        if (comparison === -1) return [Integer[0], self];
            	        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

            	        // divMod1 is faster on smaller input sizes
            	        if (a.length + b.length <= 200)
            	            value = divMod1(a, b);
            	        else value = divMod2(a, b);

            	        quotient = value[0];
            	        var qSign = self.sign !== n.sign,
            	            mod = value[1],
            	            mSign = self.sign;
            	        if (typeof quotient === "number") {
            	            if (qSign) quotient = -quotient;
            	            quotient = new SmallInteger(quotient);
            	        } else quotient = new BigInteger(quotient, qSign);
            	        if (typeof mod === "number") {
            	            if (mSign) mod = -mod;
            	            mod = new SmallInteger(mod);
            	        } else mod = new BigInteger(mod, mSign);
            	        return [quotient, mod];
            	    }

            	    BigInteger.prototype.divmod = function (v) {
            	        var result = divModAny(this, v);
            	        return {
            	            quotient: result[0],
            	            remainder: result[1]
            	        };
            	    };
            	    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;


            	    BigInteger.prototype.divide = function (v) {
            	        return divModAny(this, v)[0];
            	    };
            	    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
            	        return new NativeBigInt(this.value / parseValue(v).value);
            	    };
            	    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

            	    BigInteger.prototype.mod = function (v) {
            	        return divModAny(this, v)[1];
            	    };
            	    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
            	        return new NativeBigInt(this.value % parseValue(v).value);
            	    };
            	    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

            	    BigInteger.prototype.pow = function (v) {
            	        var n = parseValue(v),
            	            a = this.value,
            	            b = n.value,
            	            value, x, y;
            	        if (b === 0) return Integer[1];
            	        if (a === 0) return Integer[0];
            	        if (a === 1) return Integer[1];
            	        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
            	        if (n.sign) {
            	            return Integer[0];
            	        }
            	        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
            	        if (this.isSmall) {
            	            if (isPrecise(value = Math.pow(a, b)))
            	                return new SmallInteger(truncate(value));
            	        }
            	        x = this;
            	        y = Integer[1];
            	        while (true) {
            	            if (b & 1 === 1) {
            	                y = y.times(x);
            	                --b;
            	            }
            	            if (b === 0) break;
            	            b /= 2;
            	            x = x.square();
            	        }
            	        return y;
            	    };
            	    SmallInteger.prototype.pow = BigInteger.prototype.pow;

            	    NativeBigInt.prototype.pow = function (v) {
            	        var n = parseValue(v);
            	        var a = this.value, b = n.value;
            	        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
            	        if (b === _0) return Integer[1];
            	        if (a === _0) return Integer[0];
            	        if (a === _1) return Integer[1];
            	        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
            	        if (n.isNegative()) return new NativeBigInt(_0);
            	        var x = this;
            	        var y = Integer[1];
            	        while (true) {
            	            if ((b & _1) === _1) {
            	                y = y.times(x);
            	                --b;
            	            }
            	            if (b === _0) break;
            	            b /= _2;
            	            x = x.square();
            	        }
            	        return y;
            	    };

            	    BigInteger.prototype.modPow = function (exp, mod) {
            	        exp = parseValue(exp);
            	        mod = parseValue(mod);
            	        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
            	        var r = Integer[1],
            	            base = this.mod(mod);
            	        if (exp.isNegative()) {
            	            exp = exp.multiply(Integer[-1]);
            	            base = base.modInv(mod);
            	        }
            	        while (exp.isPositive()) {
            	            if (base.isZero()) return Integer[0];
            	            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            	            exp = exp.divide(2);
            	            base = base.square().mod(mod);
            	        }
            	        return r;
            	    };
            	    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

            	    function compareAbs(a, b) {
            	        if (a.length !== b.length) {
            	            return a.length > b.length ? 1 : -1;
            	        }
            	        for (var i = a.length - 1; i >= 0; i--) {
            	            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
            	        }
            	        return 0;
            	    }

            	    BigInteger.prototype.compareAbs = function (v) {
            	        var n = parseValue(v),
            	            a = this.value,
            	            b = n.value;
            	        if (n.isSmall) return 1;
            	        return compareAbs(a, b);
            	    };
            	    SmallInteger.prototype.compareAbs = function (v) {
            	        var n = parseValue(v),
            	            a = Math.abs(this.value),
            	            b = n.value;
            	        if (n.isSmall) {
            	            b = Math.abs(b);
            	            return a === b ? 0 : a > b ? 1 : -1;
            	        }
            	        return -1;
            	    };
            	    NativeBigInt.prototype.compareAbs = function (v) {
            	        var a = this.value;
            	        var b = parseValue(v).value;
            	        a = a >= 0 ? a : -a;
            	        b = b >= 0 ? b : -b;
            	        return a === b ? 0 : a > b ? 1 : -1;
            	    };

            	    BigInteger.prototype.compare = function (v) {
            	        // See discussion about comparison with Infinity:
            	        // https://github.com/peterolson/BigInteger.js/issues/61
            	        if (v === Infinity) {
            	            return -1;
            	        }
            	        if (v === -Infinity) {
            	            return 1;
            	        }

            	        var n = parseValue(v),
            	            a = this.value,
            	            b = n.value;
            	        if (this.sign !== n.sign) {
            	            return n.sign ? 1 : -1;
            	        }
            	        if (n.isSmall) {
            	            return this.sign ? -1 : 1;
            	        }
            	        return compareAbs(a, b) * (this.sign ? -1 : 1);
            	    };
            	    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

            	    SmallInteger.prototype.compare = function (v) {
            	        if (v === Infinity) {
            	            return -1;
            	        }
            	        if (v === -Infinity) {
            	            return 1;
            	        }

            	        var n = parseValue(v),
            	            a = this.value,
            	            b = n.value;
            	        if (n.isSmall) {
            	            return a == b ? 0 : a > b ? 1 : -1;
            	        }
            	        if (a < 0 !== n.sign) {
            	            return a < 0 ? -1 : 1;
            	        }
            	        return a < 0 ? 1 : -1;
            	    };
            	    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

            	    NativeBigInt.prototype.compare = function (v) {
            	        if (v === Infinity) {
            	            return -1;
            	        }
            	        if (v === -Infinity) {
            	            return 1;
            	        }
            	        var a = this.value;
            	        var b = parseValue(v).value;
            	        return a === b ? 0 : a > b ? 1 : -1;
            	    };
            	    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

            	    BigInteger.prototype.equals = function (v) {
            	        return this.compare(v) === 0;
            	    };
            	    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

            	    BigInteger.prototype.notEquals = function (v) {
            	        return this.compare(v) !== 0;
            	    };
            	    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

            	    BigInteger.prototype.greater = function (v) {
            	        return this.compare(v) > 0;
            	    };
            	    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

            	    BigInteger.prototype.lesser = function (v) {
            	        return this.compare(v) < 0;
            	    };
            	    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

            	    BigInteger.prototype.greaterOrEquals = function (v) {
            	        return this.compare(v) >= 0;
            	    };
            	    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

            	    BigInteger.prototype.lesserOrEquals = function (v) {
            	        return this.compare(v) <= 0;
            	    };
            	    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

            	    BigInteger.prototype.isEven = function () {
            	        return (this.value[0] & 1) === 0;
            	    };
            	    SmallInteger.prototype.isEven = function () {
            	        return (this.value & 1) === 0;
            	    };
            	    NativeBigInt.prototype.isEven = function () {
            	        return (this.value & BigInt(1)) === BigInt(0);
            	    };

            	    BigInteger.prototype.isOdd = function () {
            	        return (this.value[0] & 1) === 1;
            	    };
            	    SmallInteger.prototype.isOdd = function () {
            	        return (this.value & 1) === 1;
            	    };
            	    NativeBigInt.prototype.isOdd = function () {
            	        return (this.value & BigInt(1)) === BigInt(1);
            	    };

            	    BigInteger.prototype.isPositive = function () {
            	        return !this.sign;
            	    };
            	    SmallInteger.prototype.isPositive = function () {
            	        return this.value > 0;
            	    };
            	    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

            	    BigInteger.prototype.isNegative = function () {
            	        return this.sign;
            	    };
            	    SmallInteger.prototype.isNegative = function () {
            	        return this.value < 0;
            	    };
            	    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

            	    BigInteger.prototype.isUnit = function () {
            	        return false;
            	    };
            	    SmallInteger.prototype.isUnit = function () {
            	        return Math.abs(this.value) === 1;
            	    };
            	    NativeBigInt.prototype.isUnit = function () {
            	        return this.abs().value === BigInt(1);
            	    };

            	    BigInteger.prototype.isZero = function () {
            	        return false;
            	    };
            	    SmallInteger.prototype.isZero = function () {
            	        return this.value === 0;
            	    };
            	    NativeBigInt.prototype.isZero = function () {
            	        return this.value === BigInt(0);
            	    };

            	    BigInteger.prototype.isDivisibleBy = function (v) {
            	        var n = parseValue(v);
            	        if (n.isZero()) return false;
            	        if (n.isUnit()) return true;
            	        if (n.compareAbs(2) === 0) return this.isEven();
            	        return this.mod(n).isZero();
            	    };
            	    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

            	    function isBasicPrime(v) {
            	        var n = v.abs();
            	        if (n.isUnit()) return false;
            	        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
            	        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
            	        if (n.lesser(49)) return true;
            	        // we don't know if it's prime: let the other functions figure it out
            	    }

            	    function millerRabinTest(n, a) {
            	        var nPrev = n.prev(),
            	            b = nPrev,
            	            r = 0,
            	            d, i, x;
            	        while (b.isEven()) b = b.divide(2), r++;
            	        next: for (i = 0; i < a.length; i++) {
            	            if (n.lesser(a[i])) continue;
            	            x = bigInt(a[i]).modPow(b, n);
            	            if (x.isUnit() || x.equals(nPrev)) continue;
            	            for (d = r - 1; d != 0; d--) {
            	                x = x.square().mod(n);
            	                if (x.isUnit()) return false;
            	                if (x.equals(nPrev)) continue next;
            	            }
            	            return false;
            	        }
            	        return true;
            	    }

            	    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
            	    BigInteger.prototype.isPrime = function (strict) {
            	        var isPrime = isBasicPrime(this);
            	        if (isPrime !== undefined$1) return isPrime;
            	        var n = this.abs();
            	        var bits = n.bitLength();
            	        if (bits <= 64)
            	            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
            	        var logN = Math.log(2) * bits.toJSNumber();
            	        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
            	        for (var a = [], i = 0; i < t; i++) {
            	            a.push(bigInt(i + 2));
            	        }
            	        return millerRabinTest(n, a);
            	    };
            	    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

            	    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
            	        var isPrime = isBasicPrime(this);
            	        if (isPrime !== undefined$1) return isPrime;
            	        var n = this.abs();
            	        var t = iterations === undefined$1 ? 5 : iterations;
            	        for (var a = [], i = 0; i < t; i++) {
            	            a.push(bigInt.randBetween(2, n.minus(2), rng));
            	        }
            	        return millerRabinTest(n, a);
            	    };
            	    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

            	    BigInteger.prototype.modInv = function (n) {
            	        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
            	        while (!newR.isZero()) {
            	            q = r.divide(newR);
            	            lastT = t;
            	            lastR = r;
            	            t = newT;
            	            r = newR;
            	            newT = lastT.subtract(q.multiply(newT));
            	            newR = lastR.subtract(q.multiply(newR));
            	        }
            	        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
            	        if (t.compare(0) === -1) {
            	            t = t.add(n);
            	        }
            	        if (this.isNegative()) {
            	            return t.negate();
            	        }
            	        return t;
            	    };

            	    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

            	    BigInteger.prototype.next = function () {
            	        var value = this.value;
            	        if (this.sign) {
            	            return subtractSmall(value, 1, this.sign);
            	        }
            	        return new BigInteger(addSmall(value, 1), this.sign);
            	    };
            	    SmallInteger.prototype.next = function () {
            	        var value = this.value;
            	        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
            	        return new BigInteger(MAX_INT_ARR, false);
            	    };
            	    NativeBigInt.prototype.next = function () {
            	        return new NativeBigInt(this.value + BigInt(1));
            	    };

            	    BigInteger.prototype.prev = function () {
            	        var value = this.value;
            	        if (this.sign) {
            	            return new BigInteger(addSmall(value, 1), true);
            	        }
            	        return subtractSmall(value, 1, this.sign);
            	    };
            	    SmallInteger.prototype.prev = function () {
            	        var value = this.value;
            	        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
            	        return new BigInteger(MAX_INT_ARR, true);
            	    };
            	    NativeBigInt.prototype.prev = function () {
            	        return new NativeBigInt(this.value - BigInt(1));
            	    };

            	    var powersOfTwo = [1];
            	    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
            	    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

            	    function shift_isSmall(n) {
            	        return Math.abs(n) <= BASE;
            	    }

            	    BigInteger.prototype.shiftLeft = function (v) {
            	        var n = parseValue(v).toJSNumber();
            	        if (!shift_isSmall(n)) {
            	            throw new Error(String(n) + " is too large for shifting.");
            	        }
            	        if (n < 0) return this.shiftRight(-n);
            	        var result = this;
            	        if (result.isZero()) return result;
            	        while (n >= powers2Length) {
            	            result = result.multiply(highestPower2);
            	            n -= powers2Length - 1;
            	        }
            	        return result.multiply(powersOfTwo[n]);
            	    };
            	    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

            	    BigInteger.prototype.shiftRight = function (v) {
            	        var remQuo;
            	        var n = parseValue(v).toJSNumber();
            	        if (!shift_isSmall(n)) {
            	            throw new Error(String(n) + " is too large for shifting.");
            	        }
            	        if (n < 0) return this.shiftLeft(-n);
            	        var result = this;
            	        while (n >= powers2Length) {
            	            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
            	            remQuo = divModAny(result, highestPower2);
            	            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            	            n -= powers2Length - 1;
            	        }
            	        remQuo = divModAny(result, powersOfTwo[n]);
            	        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            	    };
            	    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

            	    function bitwise(x, y, fn) {
            	        y = parseValue(y);
            	        var xSign = x.isNegative(), ySign = y.isNegative();
            	        var xRem = xSign ? x.not() : x,
            	            yRem = ySign ? y.not() : y;
            	        var xDigit = 0, yDigit = 0;
            	        var xDivMod = null, yDivMod = null;
            	        var result = [];
            	        while (!xRem.isZero() || !yRem.isZero()) {
            	            xDivMod = divModAny(xRem, highestPower2);
            	            xDigit = xDivMod[1].toJSNumber();
            	            if (xSign) {
            	                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            	            }

            	            yDivMod = divModAny(yRem, highestPower2);
            	            yDigit = yDivMod[1].toJSNumber();
            	            if (ySign) {
            	                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            	            }

            	            xRem = xDivMod[0];
            	            yRem = yDivMod[0];
            	            result.push(fn(xDigit, yDigit));
            	        }
            	        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
            	        for (var i = result.length - 1; i >= 0; i -= 1) {
            	            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
            	        }
            	        return sum;
            	    }

            	    BigInteger.prototype.not = function () {
            	        return this.negate().prev();
            	    };
            	    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

            	    BigInteger.prototype.and = function (n) {
            	        return bitwise(this, n, function (a, b) { return a & b; });
            	    };
            	    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

            	    BigInteger.prototype.or = function (n) {
            	        return bitwise(this, n, function (a, b) { return a | b; });
            	    };
            	    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

            	    BigInteger.prototype.xor = function (n) {
            	        return bitwise(this, n, function (a, b) { return a ^ b; });
            	    };
            	    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;

            	    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
            	    function roughLOB(n) { // get lowestOneBit (rough)
            	        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
            	        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
            	        var v = n.value,
            	            x = typeof v === "number" ? v | LOBMASK_I :
            	                typeof v === "bigint" ? v | BigInt(LOBMASK_I) :
            	                    v[0] + v[1] * BASE | LOBMASK_BI;
            	        return x & -x;
            	    }

            	    function integerLogarithm(value, base) {
            	        if (base.compareTo(value) <= 0) {
            	            var tmp = integerLogarithm(value, base.square(base));
            	            var p = tmp.p;
            	            var e = tmp.e;
            	            var t = p.multiply(base);
            	            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
            	        }
            	        return { p: bigInt(1), e: 0 };
            	    }

            	    BigInteger.prototype.bitLength = function () {
            	        var n = this;
            	        if (n.compareTo(bigInt(0)) < 0) {
            	            n = n.negate().subtract(bigInt(1));
            	        }
            	        if (n.compareTo(bigInt(0)) === 0) {
            	            return bigInt(0);
            	        }
            	        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
            	    };
            	    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

            	    function max(a, b) {
            	        a = parseValue(a);
            	        b = parseValue(b);
            	        return a.greater(b) ? a : b;
            	    }
            	    function min(a, b) {
            	        a = parseValue(a);
            	        b = parseValue(b);
            	        return a.lesser(b) ? a : b;
            	    }
            	    function gcd(a, b) {
            	        a = parseValue(a).abs();
            	        b = parseValue(b).abs();
            	        if (a.equals(b)) return a;
            	        if (a.isZero()) return b;
            	        if (b.isZero()) return a;
            	        var c = Integer[1], d, t;
            	        while (a.isEven() && b.isEven()) {
            	            d = min(roughLOB(a), roughLOB(b));
            	            a = a.divide(d);
            	            b = b.divide(d);
            	            c = c.multiply(d);
            	        }
            	        while (a.isEven()) {
            	            a = a.divide(roughLOB(a));
            	        }
            	        do {
            	            while (b.isEven()) {
            	                b = b.divide(roughLOB(b));
            	            }
            	            if (a.greater(b)) {
            	                t = b; b = a; a = t;
            	            }
            	            b = b.subtract(a);
            	        } while (!b.isZero());
            	        return c.isUnit() ? a : a.multiply(c);
            	    }
            	    function lcm(a, b) {
            	        a = parseValue(a).abs();
            	        b = parseValue(b).abs();
            	        return a.divide(gcd(a, b)).multiply(b);
            	    }
            	    function randBetween(a, b, rng) {
            	        a = parseValue(a);
            	        b = parseValue(b);
            	        var usedRNG = rng || Math.random;
            	        var low = min(a, b), high = max(a, b);
            	        var range = high.subtract(low).add(1);
            	        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
            	        var digits = toBase(range, BASE).value;
            	        var result = [], restricted = true;
            	        for (var i = 0; i < digits.length; i++) {
            	            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
            	            var digit = truncate(usedRNG() * top);
            	            result.push(digit);
            	            if (digit < digits[i]) restricted = false;
            	        }
            	        return low.add(Integer.fromArray(result, BASE, false));
            	    }

            	    var parseBase = function (text, base, alphabet, caseSensitive) {
            	        alphabet = alphabet || DEFAULT_ALPHABET;
            	        text = String(text);
            	        if (!caseSensitive) {
            	            text = text.toLowerCase();
            	            alphabet = alphabet.toLowerCase();
            	        }
            	        var length = text.length;
            	        var i;
            	        var absBase = Math.abs(base);
            	        var alphabetValues = {};
            	        for (i = 0; i < alphabet.length; i++) {
            	            alphabetValues[alphabet[i]] = i;
            	        }
            	        for (i = 0; i < length; i++) {
            	            var c = text[i];
            	            if (c === "-") continue;
            	            if (c in alphabetValues) {
            	                if (alphabetValues[c] >= absBase) {
            	                    if (c === "1" && absBase === 1) continue;
            	                    throw new Error(c + " is not a valid digit in base " + base + ".");
            	                }
            	            }
            	        }
            	        base = parseValue(base);
            	        var digits = [];
            	        var isNegative = text[0] === "-";
            	        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            	            var c = text[i];
            	            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            	            else if (c === "<") {
            	                var start = i;
            	                do { i++; } while (text[i] !== ">" && i < text.length);
            	                digits.push(parseValue(text.slice(start + 1, i)));
            	            }
            	            else throw new Error(c + " is not a valid character");
            	        }
            	        return parseBaseFromArray(digits, base, isNegative);
            	    };

            	    function parseBaseFromArray(digits, base, isNegative) {
            	        var val = Integer[0], pow = Integer[1], i;
            	        for (i = digits.length - 1; i >= 0; i--) {
            	            val = val.add(digits[i].times(pow));
            	            pow = pow.times(base);
            	        }
            	        return isNegative ? val.negate() : val;
            	    }

            	    function stringify(digit, alphabet) {
            	        alphabet = alphabet || DEFAULT_ALPHABET;
            	        if (digit < alphabet.length) {
            	            return alphabet[digit];
            	        }
            	        return "<" + digit + ">";
            	    }

            	    function toBase(n, base) {
            	        base = bigInt(base);
            	        if (base.isZero()) {
            	            if (n.isZero()) return { value: [0], isNegative: false };
            	            throw new Error("Cannot convert nonzero numbers to base 0.");
            	        }
            	        if (base.equals(-1)) {
            	            if (n.isZero()) return { value: [0], isNegative: false };
            	            if (n.isNegative())
            	                return {
            	                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))
            	                        .map(Array.prototype.valueOf, [1, 0])
            	                    ),
            	                    isNegative: false
            	                };

            	            var arr = Array.apply(null, Array(n.toJSNumber() - 1))
            	                .map(Array.prototype.valueOf, [0, 1]);
            	            arr.unshift([1]);
            	            return {
            	                value: [].concat.apply([], arr),
            	                isNegative: false
            	            };
            	        }

            	        var neg = false;
            	        if (n.isNegative() && base.isPositive()) {
            	            neg = true;
            	            n = n.abs();
            	        }
            	        if (base.isUnit()) {
            	            if (n.isZero()) return { value: [0], isNegative: false };

            	            return {
            	                value: Array.apply(null, Array(n.toJSNumber()))
            	                    .map(Number.prototype.valueOf, 1),
            	                isNegative: neg
            	            };
            	        }
            	        var out = [];
            	        var left = n, divmod;
            	        while (left.isNegative() || left.compareAbs(base) >= 0) {
            	            divmod = left.divmod(base);
            	            left = divmod.quotient;
            	            var digit = divmod.remainder;
            	            if (digit.isNegative()) {
            	                digit = base.minus(digit).abs();
            	                left = left.next();
            	            }
            	            out.push(digit.toJSNumber());
            	        }
            	        out.push(left.toJSNumber());
            	        return { value: out.reverse(), isNegative: neg };
            	    }

            	    function toBaseString(n, base, alphabet) {
            	        var arr = toBase(n, base);
            	        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            	            return stringify(x, alphabet);
            	        }).join('');
            	    }

            	    BigInteger.prototype.toArray = function (radix) {
            	        return toBase(this, radix);
            	    };

            	    SmallInteger.prototype.toArray = function (radix) {
            	        return toBase(this, radix);
            	    };

            	    NativeBigInt.prototype.toArray = function (radix) {
            	        return toBase(this, radix);
            	    };

            	    BigInteger.prototype.toString = function (radix, alphabet) {
            	        if (radix === undefined$1) radix = 10;
            	        if (radix !== 10) return toBaseString(this, radix, alphabet);
            	        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
            	        while (--l >= 0) {
            	            digit = String(v[l]);
            	            str += zeros.slice(digit.length) + digit;
            	        }
            	        var sign = this.sign ? "-" : "";
            	        return sign + str;
            	    };

            	    SmallInteger.prototype.toString = function (radix, alphabet) {
            	        if (radix === undefined$1) radix = 10;
            	        if (radix != 10) return toBaseString(this, radix, alphabet);
            	        return String(this.value);
            	    };

            	    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

            	    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); };

            	    BigInteger.prototype.valueOf = function () {
            	        return parseInt(this.toString(), 10);
            	    };
            	    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

            	    SmallInteger.prototype.valueOf = function () {
            	        return this.value;
            	    };
            	    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
            	    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
            	        return parseInt(this.toString(), 10);
            	    };

            	    function parseStringValue(v) {
            	        if (isPrecise(+v)) {
            	            var x = +v;
            	            if (x === truncate(x))
            	                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            	            throw new Error("Invalid integer: " + v);
            	        }
            	        var sign = v[0] === "-";
            	        if (sign) v = v.slice(1);
            	        var split = v.split(/e/i);
            	        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            	        if (split.length === 2) {
            	            var exp = split[1];
            	            if (exp[0] === "+") exp = exp.slice(1);
            	            exp = +exp;
            	            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            	            var text = split[0];
            	            var decimalPlace = text.indexOf(".");
            	            if (decimalPlace >= 0) {
            	                exp -= text.length - decimalPlace - 1;
            	                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            	            }
            	            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            	            text += (new Array(exp + 1)).join("0");
            	            v = text;
            	        }
            	        var isValid = /^([0-9][0-9]*)$/.test(v);
            	        if (!isValid) throw new Error("Invalid integer: " + v);
            	        if (supportsNativeBigInt) {
            	            return new NativeBigInt(BigInt(sign ? "-" + v : v));
            	        }
            	        var r = [], max = v.length, l = LOG_BASE, min = max - l;
            	        while (max > 0) {
            	            r.push(+v.slice(min, max));
            	            min -= l;
            	            if (min < 0) min = 0;
            	            max -= l;
            	        }
            	        trim(r);
            	        return new BigInteger(r, sign);
            	    }

            	    function parseNumberValue(v) {
            	        if (supportsNativeBigInt) {
            	            return new NativeBigInt(BigInt(v));
            	        }
            	        if (isPrecise(v)) {
            	            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            	            return new SmallInteger(v);
            	        }
            	        return parseStringValue(v.toString());
            	    }

            	    function parseValue(v) {
            	        if (typeof v === "number") {
            	            return parseNumberValue(v);
            	        }
            	        if (typeof v === "string") {
            	            return parseStringValue(v);
            	        }
            	        if (typeof v === "bigint") {
            	            return new NativeBigInt(v);
            	        }
            	        return v;
            	    }
            	    // Pre-define numbers in range [-999,999]
            	    for (var i = 0; i < 1000; i++) {
            	        Integer[i] = parseValue(i);
            	        if (i > 0) Integer[-i] = parseValue(-i);
            	    }
            	    // Backwards compatibility
            	    Integer.one = Integer[1];
            	    Integer.zero = Integer[0];
            	    Integer.minusOne = Integer[-1];
            	    Integer.max = max;
            	    Integer.min = min;
            	    Integer.gcd = gcd;
            	    Integer.lcm = lcm;
            	    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };
            	    Integer.randBetween = randBetween;

            	    Integer.fromArray = function (digits, base, isNegative) {
            	        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
            	    };

            	    return Integer;
            	})();

            	// Node.js check
            	if (module.hasOwnProperty("exports")) {
            	    module.exports = bigInt;
            	}
            } (BigInteger));

            /**
             *
             */
            var RBNode = /** @class */ (function () {
                /**
                 * Constructs a red-black binary tree node.
                 */
                function RBNode(key, value) {
                    this.key = key;
                    this.value = value;
                    /**
                     * The red (true) / black (false) flag.
                     */
                    this.flag = false;
                    this.l = this;
                    this.r = this;
                    this.p = this;
                }
                /*
                get red(): boolean {
                    return this.flag;
                }
                set red(red: boolean) {
                    this.flag = red;
                }
                get black(): boolean {
                    return !this.flag;
                }
                set black(black: boolean) {
                    this.flag = !black;
                }
                */
                RBNode.prototype.toString = function () {
                    return "".concat(this.flag ? 'red' : 'black', " ").concat(this.key);
                };
                return RBNode;
            }());

            var RBTree = /** @class */ (function () {
                /**
                 * Initializes an RBTree.
                 * It is important to define a key that is smaller than all expected keys
                 * so that the first insert becomes the root (head.r).
                 *
                 * @param lowKey A key that is smaller than all expected keys.
                 * @param highKey A key that is larger than all expected keys.
                 * @param nilValue The value to return when a search is not successful.
                 * @param comp The comparator used for comparing keys.
                 */
                function RBTree(lowKey, highKey, nilValue, comp) {
                    this.highKey = highKey;
                    this.comp = comp;
                    /**
                     * The number of keys inserted.
                     */
                    this.N = 0;
                    this.lowNode = new RBNode(lowKey, nilValue);
                    this.highNode = new RBNode(highKey, nilValue);
                    // Notice that z does not have a key because it has to be less than and greater than every other key.
                    var z = new RBNode(null, nilValue);
                    this.head = new RBNode(lowKey, nilValue);
                    // Head left is never used or changed so we'll store the tail node there.
                    this.head.l = z;
                    // Head right refers the the actual tree root which is currently empty.
                    this.head.r = z;
                    this.head.p = this.head;
                }
                Object.defineProperty(RBTree.prototype, "root", {
                    get: function () {
                        return this.head.r;
                    },
                    set: function (root) {
                        this.head.r = root;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(RBTree.prototype, "z", {
                    /**
                     * The "tail" node.
                     * This allows our subtrees never to be undefined or null.
                     * All searches will result in a node, but misses will return the tail node.
                     */
                    get: function () {
                        return this.head.l;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(RBTree.prototype, "lowKey", {
                    get: function () {
                        return this.head.key;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Legal means that is greater than the key stored in the head node.
                 * The key does not have to exist.
                 */
                RBTree.prototype.assertLegalKey = function (key, comp) {
                    if (comp(key, this.lowKey) <= 0) {
                        throw new Error("key, ".concat(key, ", must be greater than the low key, ").concat(this.lowKey, "."));
                    }
                    if (comp(key, this.highKey) >= 0) {
                        throw new Error("key, ".concat(key, ", must be less than the high key, ").concat(this.highKey, "."));
                    }
                };
                /**
                 *
                 */
                RBTree.prototype.insert = function (key, value) {
                    var comp = this.comp;
                    this.assertLegalKey(key, comp);
                    var n = new RBNode(key, value);
                    rbInsert(this, n, comp);
                    this.root.flag = false;
                    // Update the count of nodes inserted.
                    this.N += 1;
                    return n;
                };
                /**
                 * Greatest Lower Bound of a key.
                 * Returns the node corresponding to the key if it exists, or the next lowest key.
                 * Returns null if there is no smaller key in the tree.
                 */
                RBTree.prototype.glb = function (key) {
                    var comp = this.comp;
                    this.assertLegalKey(key, comp);
                    var low = this.lowNode;
                    var node = glb(this, this.root, key, comp, low);
                    if (node !== low) {
                        return node;
                    }
                    else {
                        return null;
                    }
                };
                /**
                 * Least Upper Bound of a key.
                 * Returns the node corresponding to the key if it exists, or the next highest key.
                 * Returns null if there is no greater key in the tree.
                 */
                RBTree.prototype.lub = function (key) {
                    var comp = this.comp;
                    this.assertLegalKey(key, comp);
                    var high = this.highNode;
                    var node = lub(this, this.root, key, comp, high);
                    if (node !== high) {
                        return node;
                    }
                    else {
                        return null;
                    }
                };
                /**
                 *
                 */
                RBTree.prototype.search = function (key) {
                    var comp = this.comp;
                    this.assertLegalKey(key, comp);
                    /**
                     * The current node for the search.
                     */
                    var x = this.root;
                    // The search will always be "successful" but may end with z.
                    this.z.key = key;
                    while (comp(key, x.key) !== 0) {
                        x = comp(key, x.key) < 0 ? x.l : x.r;
                    }
                    return x.value;
                };
                /**
                 *
                 * @param key
                 */
                RBTree.prototype.remove = function (key) {
                    var comp = this.comp;
                    this.assertLegalKey(key, comp);
                    var head = this.head;
                    var z = this.z;
                    /**
                     * The current node for the search, we begin at the root.
                     */
                    var x = this.root;
                    /**
                     * The parent of the current node.
                     */
                    var p = head;
                    // The search will always be "successful" but may end with z.
                    z.key = key;
                    // Search in the normal way to get p and x.
                    while (comp(key, x.key) !== 0) {
                        p = x;
                        x = comp(key, x.key) < 0 ? x.l : x.r;
                    }
                    // Our search has terminated and x is either the node to be removed or z.
                    /**
                     * A reference to the node that we will be removing.
                     * This may point to z, but the following code also works in that case.
                     */
                    var t = x;
                    // From now on we will be making x reference the node that replaces t.
                    if (t.r === z) {
                        // The node t has no right child.
                        // The node that replaces t will be the left child of t.
                        x = t.l;
                    }
                    else if (t.r.l === z) {
                        // The node t has a right child with no left child.
                        // This empty slot can be used to accept t.l
                        x = t.r;
                        x.l = t.l;
                    }
                    else {
                        // The node with the next highest key must be in the r-l-l-l-l... path with a left child equal to z.
                        // It can't be anywhere else of there would be an intervening key.
                        // Note also that the previous tests have eliminated the case where
                        // there is no highets key. This node with the next highest key must have
                        // the property that it has an empty left child.
                        var c = t.r;
                        while (c.l.l !== z) {
                            c = c.l;
                        }
                        // We exit from the loop when c.l.l equals z, which means that c.l is the node that
                        // we want to use to replace t.
                        x = c.l;
                        c.l = x.r;
                        x.l = t.l;
                        x.r = t.r;
                    }
                    // We can now free the t node (if we need to do so).
                    // Finally, account for whether t was the left or right child of p.
                    if (comp(key, p.key) < 0) {
                        p.l = x;
                    }
                    else {
                        p.r = x;
                    }
                };
                Object.defineProperty(RBTree.prototype, "heightInvariant", {
                    /**
                     * Determines whether this tree satisfies the height invariant.
                     * The height invariant is that the number of black nodes in every path to leaf nodes should be the same.
                     * This property is for testing only; it traverses the tree and so affects performance.
                     */
                    get: function () {
                        return heightInv(this.root, this.z);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(RBTree.prototype, "colorInvariant", {
                    /**
                     * Determines whether this tree satisfies the color invarant.
                     * The color invariant is that no two adjacent nodes should be colored red.
                     * This property is for testing only; it traverses the treeand so affects performance.
                     */
                    get: function () {
                        return colorInv(this.root, this.head.flag, this.z);
                    },
                    enumerable: false,
                    configurable: true
                });
                return RBTree;
            }());
            function colorFlip(p, g, gg) {
                p.flag = false;
                g.flag = true;
                gg.flag = false;
                return g;
            }
            /**
             * z, x, y are in diamond-left formation.
             * z is the initial leader and is black.
             * x and y are initially red.
             *
             * z moves right and back.
             * y takes the lead.
             * children a,b of y are adopted by x and z.
             * x becomes black.
             *
             *    z          y
             * x    =>    x     z
             *    y        a   b
             *  a   b
             */
            function diamondLeftToVic(lead) {
                var m = lead.p;
                var z = lead;
                var x = z.l;
                var y = x.r;
                var a = y.l;
                var b = y.r;
                x.flag = false;
                y.l = x;
                x.p = y;
                y.r = z;
                z.p = y;
                x.r = a;
                a.p = x;
                z.l = b;
                b.p = z;
                if (m.r === lead) {
                    m.r = y;
                }
                else {
                    m.l = y;
                }
                y.p = m;
                return y;
            }
            /**
             * x, z, y are in diamond-right formation.
             * x is the initial leader and is black.
             * z and y are initially red.
             *
             * x moves left and back
             * y takes the lead.
             * z becomes black.
             *
             *    x          y
             *       z => x     z
             *    y        a   b
             *  a   b
             */
            function diamondRightToVic(lead) {
                var m = lead.p;
                var x = lead;
                var z = x.r;
                var y = z.l;
                var a = y.l;
                var b = y.r;
                z.flag = false;
                y.l = x;
                x.p = y;
                y.r = z;
                z.p = y;
                x.r = a;
                a.p = x;
                z.l = b;
                b.p = z;
                if (m.r === lead) {
                    m.r = y;
                }
                else {
                    m.l = y;
                }
                y.p = m;
                return y;
            }
            function echelonLeftToVic(lead) {
                var m = lead.p;
                var z = lead;
                var y = z.l;
                var a = y.r;
                y.l.flag = false;
                y.r = z;
                z.p = y;
                z.l = a;
                a.p = z;
                if (m.r === lead) {
                    m.r = y;
                }
                else {
                    m.l = y;
                }
                y.p = m;
                return y;
            }
            function echelonRightToVic(lead) {
                var m = lead.p;
                var x = lead;
                var y = x.r;
                var a = y.l;
                y.r.flag = false;
                y.l = x;
                x.p = y;
                x.r = a;
                a.p = x;
                if (m.r === lead) {
                    m.r = y;
                }
                else {
                    m.l = y;
                }
                y.p = m;
                return y;
            }
            function colorInv(node, redParent, z) {
                if (node === z) {
                    return true;
                }
                else if (redParent && node.flag) {
                    return false;
                }
                else {
                    return colorInv(node.l, node.flag, z) && colorInv(node.r, node.flag, z);
                }
            }
            function heightInv(node, z) {
                return blackHeight(node, z) >= 0;
            }
            /**
             * Computes the number of black nodes (including z) on the path from x to leaf, not counting x.
             * The height does not include itself.
             * z nodes are black.
             */
            function blackHeight(x, z) {
                if (x === z) {
                    return 0;
                }
                else {
                    var hL = blackHeight(x.l, z);
                    if (hL >= 0) {
                        var hR = blackHeight(x.r, z);
                        if (hR >= 0) {
                            if (hR === hR) {
                                return x.flag ? hL : hL + 1;
                            }
                        }
                    }
                    return -1;
                }
            }
            function rbInsert(tree, n, comp) {
                var key = n.key;
                var z = tree.z;
                var x = tree.root;
                x.p = tree.head;
                while (x !== z) {
                    x.l.p = x;
                    x.r.p = x;
                    x = comp(key, x.key) < 0 ? x.l : x.r;
                }
                n.p = x.p;
                if (x.p === tree.head) {
                    tree.root = n;
                }
                else {
                    if (comp(key, x.p.key) < 0) {
                        x.p.l = n;
                    }
                    else {
                        x.p.r = n;
                    }
                }
                n.l = z;
                n.r = z;
                if (n.p.flag) {
                    rbInsertFixup(tree, n);
                }
                else {
                    n.flag = true;
                }
            }
            /**
             * In this algorithm we start with the node that has been inserted and make our way up the tree.
             * This requires carefully maintaining parent pointers.
             */
            function rbInsertFixup(tree, n) {
                // When inserting the node (at any place other than the root), we always color it red.
                // This is so that we don't violate the height invariant.
                // However, this may violate the color invariant, which we address by recursing back up the tree.
                n.flag = true;
                if (!n.p.flag) {
                    throw new Error("n.p must be red.");
                }
                while (n.flag) {
                    /**
                     * The parent of n.
                     */
                    var p = n.p;
                    if (n === tree.root) {
                        tree.root.flag = false;
                        return;
                    }
                    else if (p === tree.root) {
                        tree.root.flag = false;
                        return;
                    }
                    /**
                     * The leader of the formation.
                     */
                    var lead = p.p;
                    // Establish the n = red, p = red, g = black condition for a transformation.
                    if (p.flag && !lead.flag) {
                        if (p === lead.l) {
                            var aux = lead.r;
                            if (aux.flag) {
                                n = colorFlip(p, lead, aux);
                            }
                            else if (n === p.r) {
                                n = diamondLeftToVic(lead);
                            }
                            else {
                                n = echelonLeftToVic(lead);
                            }
                        }
                        else {
                            var aux = lead.l;
                            if (aux.flag) {
                                n = colorFlip(p, lead, aux);
                            }
                            else if (n === n.p.l) {
                                n = diamondRightToVic(lead);
                            }
                            else {
                                n = echelonRightToVic(lead);
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
                tree.root.flag = false;
            }
            /**
             * Recursive implementation to compute the Greatest Lower Bound.
             * The largest key such that glb <= key.
             */
            function glb(tree, node, key, comp, low) {
                if (node === tree.z) {
                    return low;
                }
                else if (comp(key, node.key) >= 0) {
                    // The node key is a valid lower bound, but may not be the greatest.
                    // Take the right link in search of larger keys.
                    return maxNode(node, glb(tree, node.r, key, comp, low), comp);
                }
                else {
                    // Take the left link in search of smaller keys.
                    return glb(tree, node.l, key, comp, low);
                }
            }
            /**
             * Recursive implementation to compute the Least Upper Bound.
             * The smallest key such that key <= lub.
             */
            function lub(tree, node, key, comp, high) {
                if (node === tree.z) {
                    return high;
                }
                else if (comp(key, node.key) <= 0) {
                    // The node key is a valid upper bound, but may not be the least.
                    return minNode(node, lub(tree, node.l, key, comp, high), comp);
                }
                else {
                    // Take the right link in search of bigger keys.
                    return lub(tree, node.r, key, comp, high);
                }
            }
            function maxNode(a, b, comp) {
                if (comp(a.key, b.key) > 0) {
                    return a;
                }
                else if (comp(a.key, b.key) < 0) {
                    return b;
                }
                else {
                    return a;
                }
            }
            function minNode(a, b, comp) {
                if (comp(a.key, b.key) < 0) {
                    return a;
                }
                else if (comp(a.key, b.key) > 0) {
                    return b;
                }
                else {
                    return a;
                }
            }

            //
            // Our goal is to try to encapsulat the bigInt dependency so that no consumers of the Rat
            // are aware of this dependency. Additionally we don't want the Rat to have dependencies
            // so that it can be broken off into a standalone library.
            //
            // big-integer provides support for arbitrary size integers.
            // generic-rbtree provides support for a cache of integers to take the load off the Garbage Collector.
            //
            function mmul$1(a, b) {
                return a.multiply(b);
            }
            function mdiv$1(a, b) {
                return a.divide(b);
            }
            function mcmp$1(a, b) {
                return a.compare(b);
            }
            function madd(a, b) {
                return a.add(b);
            }
            function mgcd$1(u, v) {
                return BigIntegerExports.gcd(u, v);
            }
            function MSIGN$1(biggles) {
                if (biggles.isPositive()) {
                    return +1;
                }
                else if (biggles.isZero()) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
            /*
            function MLENGTH(p: bigInt.BigInteger): number {
                return p.toString().length;
            }
            */
            function MZERO(p) {
                return p.isZero();
            }
            /*
            function MEQUAL(p: bigInt.BigInteger, n: number): boolean {
                return p.equals(n);
            }
            */
            function makeSignSameAs$1(a, b) {
                if (a.isPositive()) {
                    if (b.isNegative()) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                else {
                    // a is negative
                    if (b.isPositive()) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                return a;
            }
            function setSignTo$1(a, b) {
                if (a.isPositive()) {
                    if (b < 0) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                else {
                    // a is negative
                    if (b > 0) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                return a;
            }
            function abs$2(a) {
                if (a.isPositive()) {
                    return a;
                }
                else {
                    return a.multiply(BigIntegerExports(-1));
                }
            }
            /**
             * "God gave us the integers, all else is the work of man" - Kronecker.
             */
            class Rat extends Atom {
                /**
                 * @param a The numerator.
                 * @param b The denominator.
                 */
                constructor(a, b, pos, end) {
                    super('Rat', pos, end);
                    this.a = a;
                    this.b = b;
                    // TODO: Encapsulate by making a,b private.
                    // Nothing to see here (yet), but gcd processing would be nice.
                    // Maybe we need a valueOf(...) static or module level function?
                }
                abs() {
                    return MSIGN$1(this.a) >= 0 ? this : this.neg();
                }
                add(rhs) {
                    const numer = madd(mmul$1(this.a, rhs.b), mmul$1(this.b, rhs.a));
                    if (MZERO(numer)) {
                        return zero;
                    }
                    const bb = mmul$1(this.b, rhs.b);
                    const gcdNbb = mgcd$1(numer, bb);
                    const gcdNbbSS = makeSignSameAs$1(gcdNbb, bb);
                    const a = mdiv$1(numer, gcdNbbSS);
                    const b = mdiv$1(bb, gcdNbbSS);
                    return new Rat(a, b);
                }
                ceiling() {
                    if (this.isInteger()) {
                        return this;
                    }
                    const result = new Rat(mdiv$1(this.a, this.b), BigIntegerExports.one);
                    if (!this.isNegative()) {
                        return result.succ();
                    }
                    return result;
                }
                compare(rhs) {
                    const ab = mmul$1(this.a, rhs.b);
                    const ba = mmul$1(this.b, rhs.a);
                    return mcmp$1(ab, ba);
                }
                denom() {
                    return new Rat(BigIntegerExports(this.b), BigIntegerExports.one);
                }
                div(rhs) {
                    if (rhs.isZero()) {
                        throw new Error('divide by zero');
                    }
                    if (this.isZero()) {
                        return this;
                    }
                    const aa = mmul$1(this.a, rhs.b);
                    const bb = mmul$1(this.b, rhs.a);
                    const gcdAABB = mgcd$1(aa, bb);
                    const c = makeSignSameAs$1(gcdAABB, bb);
                    return new Rat(mdiv$1(aa, c), mdiv$1(bb, c));
                }
                equals(other) {
                    if (other instanceof Rat) {
                        return this.equalsRat(other);
                    }
                    return false;
                }
                equalsRat(other) {
                    if (this === other) {
                        return true;
                    }
                    return this.compare(other) === 0;
                }
                gcd(other) {
                    const a = mgcd$1(this.a, other.a);
                    const b = mgcd$1(this.b, other.b);
                    return new Rat(abs$2(a), b);
                }
                inv() {
                    const a = this.a;
                    const b = this.b;
                    const numer = makeSignSameAs$1(b, a);
                    const denom = setSignTo$1(a, 1);
                    return new Rat(numer, denom, this.pos, this.end);
                }
                isDenom(n) {
                    return this.b.equals(n);
                }
                /**
                 * Convenience method for !Rat.isInteger()
                 */
                isFraction() {
                    return !this.isInteger();
                }
                isHalf() {
                    return this.isNumer(1) && this.isDenom(2);
                }
                /**
                 * Convenience method for Rat.isDenom(1)
                 */
                isInteger() {
                    return this.isDenom(1);
                }
                isIntegerNumber(x) {
                    return this.isNumer(x) && this.isDenom(1);
                }
                isNegative() {
                    return this.a.isNegative();
                }
                isNumer(n) {
                    return this.a.equals(n);
                }
                isMinusOne() {
                    return this.isIntegerNumber(-1);
                }
                isOne() {
                    return this.isIntegerNumber(1);
                }
                isPositive() {
                    return this.a.isPositive();
                }
                isPositiveInteger() {
                    return this.isPositive() && this.isInteger();
                }
                isTwo() {
                    return this.isIntegerNumber(2);
                }
                isZero() {
                    return MZERO(this.a);
                }
                mul(rhs) {
                    if (MZERO(this.a) || MZERO(rhs.a)) {
                        return zero;
                    }
                    const aa = mmul$1(this.a, rhs.a);
                    const bb = mmul$1(this.b, rhs.b);
                    // TODO: Consider moving this gcd stuff to the constructor so that rational is always in lowest form?
                    const gcd = mgcd$1(aa, bb);
                    const c = makeSignSameAs$1(gcd, bb);
                    return new Rat(mdiv$1(aa, c), mdiv$1(bb, c));
                }
                neg() {
                    return new Rat(BigIntegerExports(this.a.multiply(BigIntegerExports.minusOne)), BigIntegerExports(this.b), this.pos, this.end);
                }
                numer() {
                    return new Rat(BigIntegerExports(this.a), BigIntegerExports.one);
                }
                pred() {
                    return this.sub(one);
                }
                sub(rhs) {
                    return this.add(rhs.neg());
                }
                succ() {
                    return this.add(one);
                }
                toInfixString() {
                    return this.isFraction() ? `${this.a.toString()}/${this.b.toString()}` : this.a.toString();
                }
                toListString() {
                    return this.toInfixString();
                }
                toNumber() {
                    const divmod = this.a.divmod(this.b);
                    return divmod.quotient.toJSNumber() + divmod.remainder.toJSNumber() / this.b.toJSNumber();
                }
                toString() {
                    const numerString = this.a.toString();
                    if (this.isFraction()) {
                        const denomString = this.b.toString();
                        return `${this.name}(${numerString},${denomString})`;
                    }
                    else {
                        return `${this.name}(${numerString})`;
                    }
                }
            } exports('Rat', Rat);
            const numberComparator = function (x, y) {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                return 0;
            };
            const lBound = -128 - 1;
            const uBound = 127 + 1;
            const nilValue = new Rat(BigIntegerExports(lBound), BigIntegerExports.one);
            const cache = new RBTree(lBound, uBound, nilValue, numberComparator);
            for (let n = lBound + 1; n < uBound; n++) {
                cache.insert(n, new Rat(BigIntegerExports(n), BigIntegerExports.one));
            }
            /**
             * Constructor function for Num from integer which is a primitive number.
             */
            function create_int(n, pos, end) {
                if (n < uBound && n > lBound) {
                    return cache.search(n);
                }
                else {
                    return new Rat(BigIntegerExports(n), BigIntegerExports.one, pos, end);
                }
            }
            function create_rat(numer, denom, pos, end) {
                // console.lg("wrap_as_rat", numer, denom);
                return new Rat(BigIntegerExports(numer), BigIntegerExports(denom), pos, end);
            }
            /**
             * The canonical representation of the identity element for ordinary multiplication.
             */
            const one = exports('one', new Rat(BigIntegerExports(1), BigIntegerExports.one));
            const two = new Rat(BigIntegerExports(2), BigIntegerExports.one);
            const three = new Rat(BigIntegerExports(3), BigIntegerExports.one);
            const four = new Rat(BigIntegerExports(4), BigIntegerExports.one);
            const five = new Rat(BigIntegerExports(5), BigIntegerExports.one);
            const six = new Rat(BigIntegerExports(6), BigIntegerExports.one);
            const seven = new Rat(BigIntegerExports(7), BigIntegerExports.one);
            const eight = new Rat(BigIntegerExports(8), BigIntegerExports.one);
            const nine = new Rat(BigIntegerExports(9), BigIntegerExports.one);
            const ten = new Rat(BigIntegerExports(10), BigIntegerExports.one);
            const eleven = new Rat(BigIntegerExports(11), BigIntegerExports.one);
            const negOne = one.neg();
            two.neg();
            three.neg();
            const negFour = four.neg();
            five.neg();
            six.neg();
            seven.neg();
            eight.neg();
            nine.neg();
            ten.neg();
            eleven.neg();
            /**
             * The canonical representation of the identity element for ordinary addition.
             */
            const zero = exports('zero', new Rat(BigIntegerExports(0), BigIntegerExports.one));
            const half = new Rat(BigIntegerExports(1), BigIntegerExports(2));
            half.neg();
            const third = new Rat(BigIntegerExports(1), BigIntegerExports(3));

            function is_rat$1(expr) {
                return expr instanceof Rat;
            }

            /**
             * Determines whether an atom belongs to the class of numbers.
             * Numbers in this context are things that are treated similarly because they can calculate.
             * e.g. We could introduce an Int type, which would have to be classed as a Num.
             * @param expr The value being tested.
             * @returns true iff x is a Flt or a Rat.
             */
            function is_num(expr) {
                return is_flt$1(expr) || is_rat$1(expr);
            }

            /**
             * TODO: This class SHOULD (MUST) be escaping the string and the printer SHOULD NOT not then need to escape.
             * By escaping here, this class gets written into expression correctly.
             * As it works now, if we escape here then tests break because of double-duty escaping.
             */
            let Str$1 = class Str extends Atom {
                /**
                 * @param str The parsed representation of the string. i.e. Delimiters and escaping have been removed.
                 * @param pos The zero-based start position of the original text.
                 * @param end The zero-based end position of the original text.
                 */
                constructor(str, pos, end) {
                    super('Str', pos, end);
                    this.str = str;
                }
                equals(other) {
                    if (other instanceof Str) {
                        return this.equalsStr(other);
                    }
                    return false;
                }
                equalsStr(other) {
                    if (this === other) {
                        return true;
                    }
                    return this.str === other.str;
                }
                toInfixString() {
                    return JSON.stringify(this.str);
                }
                toListString() {
                    return JSON.stringify(this.str);
                }
                toString() {
                    return `${this.name}(${this.str})`;
                }
            }; exports('Str', Str$1);
            const emptyStr = new Str$1('');

            function create_str(s) {
                return new Str$1(s);
            }

            function is_str$1(expr) {
                return expr instanceof Str$1;
            }

            function is_sym(expr) {
                return expr instanceof Sym;
            }

            function mustSatisfy$1(name, condition, messageBuilder, contextBuilder) {
                if (!condition) {
                    const message = messageBuilder ? messageBuilder() : "satisfy some condition";
                    const context = contextBuilder ? " in " + contextBuilder() : "";
                    throw new Error(name + " must " + message + context + ".");
                }
            }

            function beAString() {
                return "be a string";
            }
            function mustBeString(name, value, contextBuilder) {
                mustSatisfy$1(name, typeof value === 'string', beAString, contextBuilder);
                return value;
            }

            function notSupported(name) {
                mustBeString('name', name);
                const message = {
                    get message() {
                        return "Method `" + name + "` is not supported.";
                    }
                };
                return message;
            }

            function isInteger$1(x) {
                // % coerces its operand to numbers so a typeof test is required.
                // Not ethat ECMAScript 6 provides Number.isInteger().
                return typeof x === 'number' && x % 1 === 0;
            }

            function beAnInteger$1() {
                return "be an integer";
            }
            function mustBeInteger$1(name, value, contextBuilder) {
                mustSatisfy$1(name, isInteger$1(value), beAnInteger$1, contextBuilder);
                return value;
            }

            function readOnly(name) {
                mustBeString('name', name);
                const message = {
                    get message() {
                        return "Property `" + name + "` is readonly.";
                    }
                };
                return message;
            }

            var _QQ_numer, _QQ_denom;
            const magicCode = Math.random();
            /**
             * The QQ class represents a rational number, ℚ.
             *
             * The QQ implementation is that of an <em>immutable</em> (value) type.
             *
             * The numerator and denominator are reduced to their lowest form.
             *
             * Construct new instances using the static <code>valueOf</code> method.
             */
            class QQ {
                /**
                 * Intentionally undocumented.
                 * @hidden
                 */
                constructor(n, d, code) {
                    /**
                     *
                     */
                    _QQ_numer.set(this, void 0);
                    /**
                     *
                     */
                    _QQ_denom.set(this, void 0);
                    if (code !== magicCode) {
                        throw new Error("Use the static create method instead of the constructor");
                    }
                    mustBeInteger$1('n', n);
                    mustBeInteger$1('d', d);
                    let g;
                    const gcd = function (a, b) {
                        let temp;
                        if (a < 0) {
                            a = -a;
                        }
                        if (b < 0) {
                            b = -b;
                        }
                        if (b > a) {
                            temp = a;
                            a = b;
                            b = temp;
                        }
                        // eslint-disable-next-line no-constant-condition
                        while (true) {
                            a %= b;
                            if (a === 0) {
                                return b;
                            }
                            b %= a;
                            if (b === 0) {
                                return a;
                            }
                        }
                    };
                    if (d === 0) {
                        throw new Error("denominator must not be zero");
                    }
                    if (n === 0) {
                        g = 1;
                    }
                    else {
                        g = gcd(Math.abs(n), Math.abs(d));
                    }
                    if (d < 0) {
                        n = -n;
                        d = -d;
                    }
                    __classPrivateFieldSet(this, _QQ_numer, n / g, "f");
                    __classPrivateFieldSet(this, _QQ_denom, d / g, "f");
                }
                /**
                 *
                 * @readOnly
                 */
                get numer() {
                    return __classPrivateFieldGet(this, _QQ_numer, "f");
                }
                set numer(unused) {
                    throw new Error(readOnly('numer').message);
                }
                /**
                 *
                 * @readOnly
                 */
                get denom() {
                    return __classPrivateFieldGet(this, _QQ_denom, "f");
                }
                set denom(unused) {
                    throw new Error(readOnly('denom').message);
                }
                /**
                 * @param rhs
                 * @returns
                 */
                add(rhs) {
                    return QQ.valueOf(__classPrivateFieldGet(this, _QQ_numer, "f") * __classPrivateFieldGet(rhs, _QQ_denom, "f") + __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(rhs, _QQ_numer, "f"), __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(rhs, _QQ_denom, "f"));
                }
                /**
                 * @param rhs
                 * @returns
                 */
                sub(rhs) {
                    return QQ.valueOf(__classPrivateFieldGet(this, _QQ_numer, "f") * __classPrivateFieldGet(rhs, _QQ_denom, "f") - __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(rhs, _QQ_numer, "f"), __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(rhs, _QQ_denom, "f"));
                }
                /**
                 * @param rhs
                 * @returns
                 */
                mul(rhs) {
                    return QQ.valueOf(__classPrivateFieldGet(this, _QQ_numer, "f") * __classPrivateFieldGet(rhs, _QQ_numer, "f"), __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(rhs, _QQ_denom, "f"));
                }
                /**
                 * @param rhs
                 * @returns
                 */
                div(rhs) {
                    const numer = __classPrivateFieldGet(this, _QQ_numer, "f") * __classPrivateFieldGet(rhs, _QQ_denom, "f");
                    const denom = __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(rhs, _QQ_numer, "f");
                    if (numer === 0) {
                        if (denom === 0) {
                            // How do we handle undefined?
                            return QQ.valueOf(numer, denom);
                        }
                        else {
                            return QQ.ZERO;
                        }
                    }
                    else {
                        if (denom === 0) {
                            // How do we handle division by zero.
                            return QQ.valueOf(numer, denom);
                        }
                        else {
                            return QQ.valueOf(numer, denom);
                        }
                    }
                }
                /**
                 * @returns
                 */
                isOne() {
                    return __classPrivateFieldGet(this, _QQ_numer, "f") === 1 && __classPrivateFieldGet(this, _QQ_denom, "f") === 1;
                }
                /**
                 * @returns
                 */
                isZero() {
                    return __classPrivateFieldGet(this, _QQ_numer, "f") === 0 && __classPrivateFieldGet(this, _QQ_denom, "f") === 1;
                }
                /**
                 * @returns
                 */
                hashCode() {
                    return 37 * this.numer + 13 * this.denom;
                }
                /**
                 * Computes the multiplicative inverse of this rational number.
                 *
                 * @returns
                 */
                inv() {
                    return QQ.valueOf(__classPrivateFieldGet(this, _QQ_denom, "f"), __classPrivateFieldGet(this, _QQ_numer, "f"));
                }
                /**
                 * Computes the additive inverse of this rational number.
                 *
                 * @returns
                 */
                neg() {
                    return QQ.valueOf(-__classPrivateFieldGet(this, _QQ_numer, "f"), __classPrivateFieldGet(this, _QQ_denom, "f"));
                }
                /**
                 * Determines whether two rational numbers are equal.
                 *
                 * @param other
                 * @returns
                 */
                equals(other) {
                    if (other instanceof QQ) {
                        return __classPrivateFieldGet(this, _QQ_numer, "f") * __classPrivateFieldGet(other, _QQ_denom, "f") === __classPrivateFieldGet(this, _QQ_denom, "f") * __classPrivateFieldGet(other, _QQ_numer, "f");
                    }
                    else {
                        return false;
                    }
                }
                /**
                 * Computes a non-normative string representation of this rational.
                 *
                 * @returns
                 */
                toString() {
                    return "" + __classPrivateFieldGet(this, _QQ_numer, "f") + "/" + __classPrivateFieldGet(this, _QQ_denom, "f") + "";
                }
                /**
                 * @param rhs
                 * @returns
                 */
                __add__(rhs) {
                    if (rhs instanceof QQ) {
                        return this.add(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @returns
                 */
                __radd__(lhs) {
                    if (lhs instanceof QQ) {
                        return lhs.add(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param rhs
                 * @returns
                 */
                __sub__(rhs) {
                    if (rhs instanceof QQ) {
                        return this.sub(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @returns
                 */
                __rsub__(lhs) {
                    if (lhs instanceof QQ) {
                        return lhs.sub(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param rhs
                 * @returns
                 */
                __mul__(rhs) {
                    if (rhs instanceof QQ) {
                        return this.mul(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @returns
                 */
                __rmul__(lhs) {
                    if (lhs instanceof QQ) {
                        return lhs.mul(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param div
                 * @returns
                 */
                __div__(rhs) {
                    if (rhs instanceof QQ) {
                        return this.div(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @returns
                 */
                __rdiv__(lhs) {
                    if (lhs instanceof QQ) {
                        return lhs.div(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @returns
                 */
                __pos__() {
                    return this;
                }
                /**
                 * @returns
                 */
                __neg__() {
                    return this.neg();
                }
                /**
                 * @param numer
                 * @param denom
                 * @returns
                 */
                static valueOf(n, d) {
                    if (n === 0) {
                        if (d !== 0) {
                            return QQ.ZERO;
                        }
                    }
                    else if (d === 0) ;
                    else if (n === d) {
                        return QQ.ONE;
                    }
                    else if (n === 1) {
                        if (d === 2) {
                            return QQ.POS_01_02;
                        }
                        else if (d === 3) {
                            return QQ.POS_01_03;
                        }
                        else if (d === 4) {
                            return QQ.POS_01_04;
                        }
                        else if (d === 5) {
                            return QQ.POS_01_05;
                        }
                        else if (d === -3) {
                            return QQ.NEG_01_03;
                        }
                    }
                    else if (n === -1) {
                        if (d === 1) {
                            return QQ.NEG_01_01;
                        }
                        else if (d === 3) {
                            return QQ.NEG_01_03;
                        }
                    }
                    else if (n === 2) {
                        if (d === 1) {
                            return QQ.POS_02_01;
                        }
                        else if (d === 3) {
                            return QQ.POS_02_03;
                        }
                    }
                    else if (n === -2) {
                        if (d === 1) {
                            return QQ.NEG_02_01;
                        }
                    }
                    else if (n === 3) {
                        if (d === 1) {
                            return QQ.POS_03_01;
                        }
                    }
                    else if (n === -3) {
                        if (d === 1) {
                            return QQ.NEG_03_01;
                        }
                    }
                    else if (n === 4) {
                        if (d === 1) {
                            return QQ.POS_04_01;
                        }
                    }
                    else if (n === 5) {
                        if (d === 1) {
                            return QQ.POS_05_01;
                        }
                    }
                    else if (n === 6) {
                        if (d === 1) {
                            return QQ.POS_06_01;
                        }
                    }
                    else if (n === 7) {
                        if (d === 1) {
                            return QQ.POS_07_01;
                        }
                    }
                    else if (n === 8) {
                        if (d === 1) {
                            return QQ.POS_08_01;
                        }
                    }
                    // console.warn(`QQ.valueOf(${n},${d}) is not cached.`)
                    return new QQ(n, d, magicCode);
                }
            } exports('QQ', QQ);
            _QQ_numer = new WeakMap(), _QQ_denom = new WeakMap();
            //
            // Immutable constants allow us to avoid creating
            // temporary QQ instances for the common values.
            //
            QQ.POS_08_01 = new QQ(8, 1, magicCode);
            QQ.POS_07_01 = new QQ(7, 1, magicCode);
            QQ.POS_06_01 = new QQ(6, 1, magicCode);
            QQ.POS_05_01 = new QQ(5, 1, magicCode);
            QQ.POS_04_01 = new QQ(4, 1, magicCode);
            QQ.POS_03_01 = new QQ(3, 1, magicCode);
            QQ.POS_02_01 = new QQ(2, 1, magicCode);
            QQ.ONE = new QQ(1, 1, magicCode);
            QQ.POS_01_02 = new QQ(1, 2, magicCode);
            QQ.POS_01_03 = new QQ(1, 3, magicCode);
            QQ.POS_01_04 = new QQ(1, 4, magicCode);
            QQ.POS_01_05 = new QQ(1, 5, magicCode);
            QQ.ZERO = new QQ(0, 1, magicCode);
            QQ.NEG_01_03 = new QQ(-1, 3, magicCode);
            QQ.NEG_01_01 = new QQ(-1, 1, magicCode);
            QQ.NEG_02_01 = new QQ(-2, 1, magicCode);
            QQ.NEG_03_01 = new QQ(-3, 1, magicCode);
            QQ.POS_02_03 = new QQ(2, 3, magicCode);

            const R0 = QQ.valueOf(0, 1);
            const R1 = QQ.valueOf(1, 1);
            const R2 = QQ.valueOf(2, 1);
            const M1 = QQ.valueOf(-1, 1);
            function assertArgRational(name, arg) {
                if (arg instanceof QQ) {
                    return arg;
                }
                else {
                    throw new Error("Argument '" + arg + "' must be a QQ");
                }
            }
            /**
             * Keeps track of the dimensions of a physical quantity using seven rational exponents.
             * Each of the exponents corresponds to a dimension in the S.I. system of units.
             */
            class Dimensions {
                /**
                 * The Dimensions class captures the physical dimensions associated with a unit of measure.
                 *
                 * @param M The mass component of the dimensions object.
                 * @param L The length component of the dimensions object.
                 * @param T The time component of the dimensions object.
                 * @param Q The charge component of the dimensions object.
                 * @param temperature The temperature component of the dimensions object.
                 * @param amount The amount component of the dimensions object.
                 * @param intensity The intensity component of the dimensions object.
                 */
                constructor(M, L, T, Q, temperature, amount, intensity) {
                    this.M = M;
                    this.L = L;
                    this.T = T;
                    this.Q = Q;
                    this.temperature = temperature;
                    this.amount = amount;
                    this.intensity = intensity;
                    assertArgRational('M', M);
                    assertArgRational('L', L);
                    assertArgRational('T', T);
                    assertArgRational('Q', Q);
                    assertArgRational('temperature', temperature);
                    assertArgRational('amount', amount);
                    assertArgRational('intensity', intensity);
                    if (arguments.length !== 7) {
                        throw new Error("Expecting 7 arguments");
                    }
                }
                /**
                 * Returns the dimensions if they are all equal, otherwise throws an Error.
                 *
                 * @param rhs
                 * @returns
                 */
                compatible(rhs) {
                    if (this.M.equals(rhs.M) && this.L.equals(rhs.L) && this.T.equals(rhs.T) && this.Q.equals(rhs.Q) && this.temperature.equals(rhs.temperature) && this.amount.equals(rhs.amount) && this.intensity.equals(rhs.intensity)) {
                        return this;
                    }
                    else {
                        if (this.isOne()) {
                            if (rhs.isOne()) {
                                throw new Error();
                            }
                            else {
                                throw new Error("Dimensions must be equal (dimensionless, " + rhs + ")");
                            }
                        }
                        else {
                            if (rhs.isOne()) {
                                throw new Error("Dimensions must be equal (" + this + ", dimensionless)");
                            }
                            else {
                                throw new Error("Dimensions must be equal (" + this + ", " + rhs + ")");
                            }
                        }
                    }
                }
                /**
                 * Multiplies dimensions by adding rational exponents.
                 *
                 * @param rhs
                 * @returns <code>this * rhs</code>
                 */
                mul(rhs) {
                    return new Dimensions(this.M.add(rhs.M), this.L.add(rhs.L), this.T.add(rhs.T), this.Q.add(rhs.Q), this.temperature.add(rhs.temperature), this.amount.add(rhs.amount), this.intensity.add(rhs.intensity));
                }
                /**
                 * Divides dimensions by subtracting rational exponents.
                 *
                 * @param rhs
                 * @returns <code>this / rhs</code>
                 */
                div(rhs) {
                    return new Dimensions(this.M.sub(rhs.M), this.L.sub(rhs.L), this.T.sub(rhs.T), this.Q.sub(rhs.Q), this.temperature.sub(rhs.temperature), this.amount.sub(rhs.amount), this.intensity.sub(rhs.intensity));
                }
                equals(rhs) {
                    return this.M.equals(rhs.M) &&
                        this.L.equals(rhs.L) &&
                        this.T.equals(rhs.T) &&
                        this.Q.equals(rhs.Q) &&
                        this.temperature.equals(rhs.temperature) &&
                        this.amount.equals(rhs.amount) &&
                        this.intensity.equals(rhs.intensity);
                }
                /**
                 * Computes the power function by multiplying rational exponents.
                 */
                pow(exponent) {
                    return new Dimensions(this.M.mul(exponent), this.L.mul(exponent), this.T.mul(exponent), this.Q.mul(exponent), this.temperature.mul(exponent), this.amount.mul(exponent), this.intensity.mul(exponent));
                }
                /**
                 * Computes the square root by dividing each rational component by two.
                 *
                 * @returns
                 */
                sqrt() {
                    return new Dimensions(this.M.div(R2), this.L.div(R2), this.T.div(R2), this.Q.div(R2), this.temperature.div(R2), this.amount.div(R2), this.intensity.div(R2));
                }
                /**
                 * Determines whether all the exponents of this dimensions number are zero.
                 * This implies a dimensionless quantity.
                 *
                 * @returns <code>true</code> if all the exponents are zero, otherwise <code>false</code>.
                 */
                isOne() {
                    return this.M.isZero() && this.L.isZero() && this.T.isZero() && this.Q.isZero() && this.temperature.isZero() && this.amount.isZero() && this.intensity.isZero();
                }
                /**
                 * Computes the multiplicative inverse of this dimensions number.
                 * This is achived by changing the signs of all the exponent quantities.
                 *
                 * @returns
                 */
                inv() {
                    return new Dimensions(this.M.neg(), this.L.neg(), this.T.neg(), this.Q.neg(), this.temperature.neg(), this.amount.neg(), this.intensity.neg());
                }
                /**
                 * Intentionally undocumented.
                 */
                neg() {
                    throw new Error(notSupported('neg').message);
                }
                /**
                 * Creates a representation of this <code>Dimensions</code> instance.
                 *
                 * @returns
                 */
                toString() {
                    const stringify = function (rational, label) {
                        if (rational.numer === 0) {
                            return null;
                        }
                        else if (rational.denom === 1) {
                            if (rational.numer === 1) {
                                return "" + label;
                            }
                            else {
                                return "" + label + " ** " + rational.numer;
                            }
                        }
                        return "" + label + " ** " + rational;
                    };
                    return [stringify(this.M, 'mass'), stringify(this.L, 'length'), stringify(this.T, 'time'), stringify(this.Q, 'charge'), stringify(this.temperature, 'thermodynamic temperature'), stringify(this.amount, 'amount of substance'), stringify(this.intensity, 'luminous intensity')].filter(function (x) {
                        return typeof x === 'string';
                    }).join(" * ");
                }
                /**
                 * @param rhs
                 * @returns
                 */
                __add__(rhs) {
                    if (rhs instanceof Dimensions) {
                        return this.compatible(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @returns
                 */
                __radd__(lhs) {
                    if (lhs instanceof Dimensions) {
                        return lhs.compatible(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 *
                 * @param rhs
                 * @returns
                 */
                __sub__(rhs) {
                    if (rhs instanceof Dimensions) {
                        return this.compatible(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 *
                 * @param lhs
                 * @returns
                 */
                __rsub__(lhs) {
                    if (lhs instanceof Dimensions) {
                        return lhs.compatible(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 *
                 * @param rhs
                 * @returns
                 */
                __mul__(rhs) {
                    if (rhs instanceof Dimensions) {
                        return this.mul(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 *
                 * @param lhs
                 * @returns
                 */
                __rmul__(lhs) {
                    if (lhs instanceof Dimensions) {
                        return lhs.mul(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 *
                 * @param rhs
                 * @returns
                 */
                __div__(rhs) {
                    if (rhs instanceof Dimensions) {
                        return this.div(rhs);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @returns
                 */
                __rdiv__(lhs) {
                    if (lhs instanceof Dimensions) {
                        return lhs.div(this);
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @returns
                 */
                __pos__() {
                    return this;
                }
                /**
                 *
                 * @returns
                 */
                __neg__() {
                    return this;
                }
            } exports('Dimensions', Dimensions);
            /**
             * All exponents are zero, a dimensionless quantity.
             */
            Dimensions.ONE = new Dimensions(R0, R0, R0, R0, R0, R0, R0);
            /**
             * M<sup>1</sup>
             */
            Dimensions.MASS = new Dimensions(R1, R0, R0, R0, R0, R0, R0);
            /**
             * L<sup>1</sup>
             */
            Dimensions.LENGTH = new Dimensions(R0, R1, R0, R0, R0, R0, R0);
            /**
             * T<sup>1</sup>
             */
            Dimensions.TIME = new Dimensions(R0, R0, R1, R0, R0, R0, R0);
            /**
             * Q<sup>1</sup>
             */
            Dimensions.CHARGE = new Dimensions(R0, R0, R0, R1, R0, R0, R0);
            /**
             * Q<sup>1</sup>T<sup>-1<sup>
             */
            Dimensions.CURRENT = new Dimensions(R0, R0, M1, R1, R0, R0, R0);
            /**
             *
             */
            Dimensions.TEMPERATURE = new Dimensions(R0, R0, R0, R0, R1, R0, R0);
            /**
             *
             */
            Dimensions.AMOUNT = new Dimensions(R0, R0, R0, R0, R0, R1, R0);
            /**
             *
             */
            Dimensions.INTENSITY = new Dimensions(R0, R0, R0, R0, R0, R0, R1);

            function notImplemented(name) {
                mustBeString('name', name);
                const message = {
                    get message() {
                        return `'${name}' method is not yet implemented.`;
                    }
                };
                return message;
            }

            // const NAMES_SI = ['kilogram', 'meter', 'second', 'coulomb', 'kelvin', 'mole', 'candela'];
            const SYMBOLS_SI = ['kg', 'm', 's', 'C', 'K', 'mol', 'cd'];
            const patterns = [
                [-1, 1, -3, 1, 2, 1, 2, 1, 0, 1, 0, 1, 0, 1],
                [-1, 1, -2, 1, 1, 1, 2, 1, 0, 1, 0, 1, 0, 1],
                [-1, 1, -2, 1, 2, 1, 2, 1, 0, 1, 0, 1, 0, 1],
                [-1, 1, +0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                [+0, 1, -3, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                [+0, 1, 2, 1, -2, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [+0, 1, 0, 1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [+0, 1, 0, 1, -1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                [0, 1, 1, 1, -2, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [0, 1, 1, 1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 1, 1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, -1, 1, -2, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, -1, 1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 0, 1, -3, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 0, 1, -2, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 0, 1, -1, 1, -1, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 1, 1, -3, 1, 0, 1, -1, 1, 0, 1, 0, 1],
                [1, 1, 1, 1, -2, 1, -1, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 1, 1, -2, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 1, 1, 0, 1, -2, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -2, 1, 0, 1, -1, 1, 0, 1, 0, 1],
                [0, 1, 2, 1, -2, 1, 0, 1, -1, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -2, 1, 0, 1, -1, 1, -1, 1, 0, 1],
                [1, 1, 2, 1, -2, 1, 0, 1, 0, 1, -1, 1, 0, 1],
                [1, 1, 2, 1, -2, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -3, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -2, 1, -1, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -1, 1, -2, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, 0, 1, -2, 1, 0, 1, 0, 1, 0, 1],
                [1, 1, 2, 1, -1, 1, -1, 1, 0, 1, 0, 1, 0, 1] // Wb
            ];
            const decodes = [
                ["F/m"],
                ["S"],
                ["F"],
                ["C/kg"],
                ["C/m ** 3"],
                ["J/kg"],
                ["Hz"],
                ["A"],
                ["m/s ** 2"],
                ["m/s"],
                ["kg·m/s"],
                ["Pa"],
                ["Pa·s"],
                ["W/m ** 2"],
                ["N/m"],
                ["T"],
                ["W/(m·K)"],
                ["V/m"],
                ["N"],
                ["H/m"],
                ["J/K"],
                ["J/(kg·K)"],
                ["J/(mol·K)"],
                ["J/mol"],
                ["J"],
                ["J·s"],
                ["W"],
                ["V"],
                ["Ω"],
                ["H"],
                ["Wb"]
            ];
            const dumbString = function (formatted, dimensions, labels, compact) {
                const stringify = function (rational, label) {
                    if (rational.numer === 0) {
                        return null;
                    }
                    else if (rational.denom === 1) {
                        if (rational.numer === 1) {
                            return label;
                        }
                        else {
                            return label + " ** " + rational.numer;
                        }
                    }
                    return label + " ** " + rational;
                };
                const unitsString = [stringify(dimensions.M, labels[0]), stringify(dimensions.L, labels[1]), stringify(dimensions.T, labels[2]), stringify(dimensions.Q, labels[3]), stringify(dimensions.temperature, labels[4]), stringify(dimensions.amount, labels[5]), stringify(dimensions.intensity, labels[6])].filter(function (x) {
                    return typeof x === 'string';
                }).join(" ");
                if (compact) {
                    return unitsString;
                }
                else {
                    if (unitsString) {
                        if (formatted !== "1") {
                            return `${formatted} ${unitsString}`;
                        }
                        else {
                            return unitsString;
                        }
                    }
                    else {
                        return formatted;
                    }
                }
            };
            /**
             *
             * @param multiplier
             * @param formatted
             * @param dimensions
             * @param labels
             * @param compact Determines whether a multiplier of unity will be included in the result.
             * @returns
             */
            const unitString = function (formatted, dimensions, labels, compact) {
                const M = dimensions.M;
                const L = dimensions.L;
                const T = dimensions.T;
                const Q = dimensions.Q;
                const temperature = dimensions.temperature;
                const amount = dimensions.amount;
                const intensity = dimensions.intensity;
                for (let i = 0, len = patterns.length; i < len; i++) {
                    const pattern = patterns[i];
                    if (M.numer === pattern[0] && M.denom === pattern[1] &&
                        L.numer === pattern[2] && L.denom === pattern[3] &&
                        T.numer === pattern[4] && T.denom === pattern[5] &&
                        Q.numer === pattern[6] && Q.denom === pattern[7] &&
                        temperature.numer === pattern[8] && temperature.denom === pattern[9] &&
                        amount.numer === pattern[10] && amount.denom === pattern[11] &&
                        intensity.numer === pattern[12] && intensity.denom === pattern[13]) {
                        return decodes[i][0];
                    }
                }
                return dumbString(formatted, dimensions, labels, compact);
            };
            function mul$2(lhs, rhs) {
                return new Uom(lhs.dimensions.mul(rhs.dimensions), lhs.labels);
            }
            function div$1(lhs, rhs) {
                return new Uom(lhs.dimensions.div(rhs.dimensions), lhs.labels);
            }
            /**
             * The Uom class represents the units for a measure.
             */
            class Uom extends Atom {
                /**
                 * @param dimensions
                 * @param labels The label strings to use for each dimension.
                 */
                constructor(dimensions, labels) {
                    super('Uom', 0, 0);
                    this.dimensions = dimensions;
                    this.labels = labels;
                    if (labels.length !== 7) {
                        throw new Error("Expecting 7 elements in the labels array.");
                    }
                }
                /**
                 * @param rhs
                 * @returns
                 */
                compatible(rhs) {
                    if (rhs instanceof Uom) {
                        this.dimensions.compatible(rhs.dimensions);
                        return this;
                    }
                    else {
                        throw new Error("Illegal Argument for Unit.compatible: " + rhs);
                    }
                }
                equals(other) {
                    if (other instanceof Uom) {
                        return this.dimensions.equals(other.dimensions);
                    }
                    return false;
                }
                /**
                 * @param rhs
                 * @returns
                 */
                mul(rhs) {
                    return mul$2(this, rhs);
                }
                /**
                 * @param rhs
                 * @returns
                 */
                div(rhs) {
                    return div$1(this, rhs);
                }
                /**
                 * Intentionaly undocumented.
                 */
                pattern() {
                    const ns = [];
                    ns.push(this.dimensions.M.numer);
                    ns.push(this.dimensions.M.denom);
                    ns.push(this.dimensions.L.numer);
                    ns.push(this.dimensions.L.denom);
                    ns.push(this.dimensions.T.numer);
                    ns.push(this.dimensions.T.denom);
                    ns.push(this.dimensions.Q.numer);
                    ns.push(this.dimensions.Q.denom);
                    ns.push(this.dimensions.temperature.numer);
                    ns.push(this.dimensions.temperature.denom);
                    ns.push(this.dimensions.amount.numer);
                    ns.push(this.dimensions.amount.denom);
                    ns.push(this.dimensions.intensity.numer);
                    ns.push(this.dimensions.intensity.denom);
                    return JSON.stringify(ns);
                }
                /**
                 * @param exponent
                 * @returns
                 */
                pow(exponent) {
                    return new Uom(this.dimensions.pow(exponent), this.labels);
                }
                /**
                 * @returns
                 */
                inv() {
                    return new Uom(this.dimensions.inv(), this.labels);
                }
                /**
                 * @returns true if this unit is dimensionless and the multiplier is unity.
                 */
                isOne() {
                    return this.dimensions.isOne();
                }
                /**
                 *
                 */
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                lerp(target, α) {
                    throw new Error(notImplemented('lerp').message);
                }
                /**
                 * @returns
                 */
                quad() {
                    return new Uom(this.dimensions.mul(this.dimensions), this.labels);
                }
                /**
                 * @param n
                 * @returns
                 */
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                reflect(n) {
                    return this;
                }
                /**
                 * @param rotor
                 * @returns
                 */
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                rotate(rotor) {
                    return this;
                }
                /**
                 * @param target
                 * @param α
                 * @returns
                 */
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                slerp(target, α) {
                    throw new Error(notImplemented('slerp').message);
                }
                /**
                 * @returns
                 */
                sqrt() {
                    return new Uom(this.dimensions.sqrt(), this.labels);
                }
                /**
                 * @param σ
                 * @returns
                 */
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                stress(σ) {
                    throw new Error(notSupported('stress').message);
                }
                /**
                 * @param fractionDigits
                 * @param compact Determines whether a multiplier of unity will be included in the result.
                 * @returns
                 */
                toExponential(fractionDigits, compact) {
                    return unitString(Number(1).toExponential(fractionDigits), this.dimensions, this.labels, compact);
                }
                /**
                 * @param fractionDigits
                 * @param compact Determines whether a multiplier of unity will be included in the result.
                 * @returns
                 */
                toFixed(fractionDigits, compact) {
                    return unitString(Number(1).toFixed(fractionDigits), this.dimensions, this.labels, compact);
                }
                toInfixString() {
                    const radix = 10;
                    const compact = true;
                    return unitString(Number(1).toString(radix), this.dimensions, this.labels, compact);
                }
                toListString() {
                    const radix = 10;
                    const compact = true;
                    return unitString(Number(1).toString(radix), this.dimensions, this.labels, compact);
                }
                /**
                 * @param precision
                 * @param compact Determines whether a multiplier of unity will be included in the result.
                 * @returns
                 */
                toPrecision(precision, compact) {
                    return unitString(Number(1).toPrecision(precision), this.dimensions, this.labels, compact);
                }
                /**
                 * @param radix
                 * @param compact Determines whether a multiplier of unity will be included in the result.
                 * @returns
                 */
                toString(radix, compact) {
                    return unitString(Number(1).toString(radix), this.dimensions, this.labels, compact);
                }
                /**
                 * @param uom
                 * @returns
                 */
                static isOne(uom) {
                    if (uom === void 0) {
                        return true;
                    }
                    else if (uom instanceof Uom) {
                        return uom.isOne();
                    }
                    else {
                        throw new Error("isOne argument must be a Unit or undefined.");
                    }
                }
                /**
                 * @param uom
                 * @returns
                 */
                static assertDimensionless(uom) {
                    if (!Uom.isOne(uom)) {
                        throw new Error("uom must be dimensionless.");
                    }
                }
                /**
                 * @param lhs
                 * @param rhs
                 * @returns
                 */
                static compatible(lhs, rhs) {
                    if (lhs) {
                        if (rhs) {
                            return lhs.compatible(rhs);
                        }
                        else {
                            if (lhs.isOne()) {
                                return void 0;
                            }
                            else {
                                throw new Error(lhs + " is incompatible with 1");
                            }
                        }
                    }
                    else {
                        if (rhs) {
                            if (rhs.isOne()) {
                                return void 0;
                            }
                            else {
                                throw new Error("1 is incompatible with " + rhs);
                            }
                        }
                        else {
                            return void 0;
                        }
                    }
                }
                /**
                 * @param lhs
                 * @param rhs
                 * @returns
                 */
                static mul(lhs, rhs) {
                    if (lhs) {
                        if (rhs) {
                            return lhs.mul(rhs);
                        }
                        else if (Uom.isOne(rhs)) {
                            return lhs;
                        }
                        else {
                            return void 0;
                        }
                    }
                    else if (Uom.isOne(lhs)) {
                        return rhs;
                    }
                    else {
                        return void 0;
                    }
                }
                /**
                 * @param lhs
                 * @param rhs
                 * @returns
                 */
                static div(lhs, rhs) {
                    if (lhs) {
                        if (rhs) {
                            return lhs.div(rhs);
                        }
                        else {
                            return lhs;
                        }
                    }
                    else {
                        if (rhs) {
                            return rhs.inv();
                        }
                        else {
                            return void 0;
                        }
                    }
                }
                /**
                 * @param uom
                 * @returns
                 */
                static sqrt(uom) {
                    if (typeof uom !== 'undefined') {
                        if (!uom.isOne()) {
                            return new Uom(uom.dimensions.sqrt(), uom.labels);
                        }
                        else {
                            return void 0;
                        }
                    }
                    else {
                        return void 0;
                    }
                }
            } exports('Uom', Uom);
            /**
             *
             */
            Uom.ZERO = new Uom(Dimensions.ONE, SYMBOLS_SI);
            /**
             *
             */
            Uom.ONE = new Uom(Dimensions.ONE, SYMBOLS_SI);
            /**
             *
             */
            Uom.KILOGRAM = new Uom(Dimensions.MASS, SYMBOLS_SI);
            /**
             *
             */
            Uom.METER = new Uom(Dimensions.LENGTH, SYMBOLS_SI);
            /**
             *
             */
            Uom.SECOND = new Uom(Dimensions.TIME, SYMBOLS_SI);
            /**
             *
             */
            Uom.COULOMB = new Uom(Dimensions.CHARGE, SYMBOLS_SI);
            /**
             *
             */
            Uom.AMPERE = new Uom(Dimensions.CURRENT, SYMBOLS_SI);
            /**
             *
             */
            Uom.KELVIN = new Uom(Dimensions.TEMPERATURE, SYMBOLS_SI);
            /**
             *
             */
            Uom.MOLE = new Uom(Dimensions.AMOUNT, SYMBOLS_SI);
            /**
             *
             */
            Uom.CANDELA = new Uom(Dimensions.INTENSITY, SYMBOLS_SI);

            function is_uom$1(expr) {
                return expr instanceof Uom;
            }

            function create_uom(name) {
                switch (name) {
                    case 'kilogram': {
                        return Uom.KILOGRAM;
                    }
                    case 'meter': {
                        return Uom.METER;
                    }
                    case 'second': {
                        return Uom.SECOND;
                    }
                    case 'coulomb': {
                        return Uom.COULOMB;
                    }
                    case 'ampere': {
                        return Uom.AMPERE;
                    }
                    case 'kelvin': {
                        return Uom.KELVIN;
                    }
                    case 'mole': {
                        return Uom.MOLE;
                    }
                    case 'candela': {
                        return Uom.CANDELA;
                    }
                    default: {
                        throw new Error(`Unknown name ${name}`);
                    }
                }
            }

            // The canonical keys for various mathematical symbols.
            const MATH_ADD$1 = native_sym(Native.add);
            const MATH_SUB = native_sym(Native.subtract);
            const MATH_MUL$3 = native_sym(Native.multiply);
            const MATH_DIV = native_sym(Native.divide);
            const MATH_POW$2 = native_sym(Native.pow);
            const MATH_OUTER = native_sym(Native.outer);
            const MATH_INNER = native_sym(Native.inner);
            const MATH_INV = native_sym(Native.inverse);
            const MATH_LCO = native_sym(Native.lco);
            const MATH_RCO = native_sym(Native.rco);
            const MATH_SIN$1 = native_sym(Native.sin);
            native_sym(Native.succ);
            /**
             * pred
             */
            create_sym('pred');
            const MATH_E$2 = native_sym(Native.E);
            const MATH_PI$2 = native_sym(Native.PI);
            /**
             * component e.g. (indexing into a tensor).
             */
            const MATH_COMPONENT = create_sym('component');
            /**
             * factorial
             */
            const MATH_FACTORIAL = create_sym('factorial');
            /**
             * iszero
             */
            create_sym('iszero');
            /**
             * '<'
             */
            const MATH_LT = native_sym(Native.test_lt);
            /**
             * '>'
             */
            const MATH_GT = native_sym(Native.test_gt);
            /**
             * '<='
             */
            native_sym(Native.test_le);
            /**
             * ':'
             */
            create_sym(':');
            /**
            * tau(x) = 2 * pi * x
            */
            native_sym(Native.tau);
            const MATH_IMU$1 = native_sym(Native.IMU);

            //
            /**
             * LATEX is MathJax compatible.
             */
            const PRINTMODE_LATEX = 'PRINTMODE_LATEX';
            /**
             * ASCII is a two-dimensional rendering.
             */
            const PRINTMODE_ASCII = 'PRINTMODE_ASCII';
            /**
             * INFIX is how we normally write math but whitespace is removed.
             */
            const PRINTMODE_INFIX = 'PRINTMODE_INFIX';
            /**
             * HUMAN is like INFIX but with extra whitespace.
             */
            const PRINTMODE_HUMAN = 'PRINTMODE_HUMAN';
            /**
             * SEXPR or Symbolic Expression is LISP-like.
             */
            const PRINTMODE_SEXPR = 'PRINTMODE_SEXPR';
            class Defs {
                constructor() {
                    /**
                     * TODO: This is a bit of a code smell. Maybe a hack for the test harness?
                     * What is exactly is it trying to do?
                     * It is set to true during the execution of the test harness, and reset after.
                     */
                    this.$test_flag = false;
                    /**
                     * The (default) PrintMode when using the (print ...) expression or print keyword.
                     */
                    this.$printMode = PRINTMODE_INFIX;
                    this.recursionLevelNestedRadicalsRemoval = 0;
                    this.errorMessage = '';
                    this.symbolsDependencies = {};
                    this.symbolsHavingReassignments = [];
                    this.symbolsInExpressionsWithoutAssignments = [];
                    this.patternHasBeenFound = false;
                    /**
                     * top of stack
                     */
                    this.tos = 0;
                    /**
                     * Initialized to zero at the start of top level evaluation.
                     * trigmode 1 causes sin squared terms to be replaced by cos squared during power operator application.
                     * trigmode 2 causes cos squared terms to be replaced by sin squared during power operator application.
                     */
                    this.trigmode = 0;
                    /**
                     * The program execution stack.
                     * TODO: This should be moved to the $ to achieve isolation of executions.
                     * It should also not allow undefined and null values as this requires casting elsewhere.
                     * Encapsulation with assertion may help.
                     */
                    this.stack = [];
                    this.out_count = 0;
                    /**
                     * Causes the print output to render JavaScript.
                     */
                    this.codeGen = false;
                    this.userSimplificationsInListForm = [];
                    this.userSimplificationsInStringForm = [];
                    // ========================================================================
                    // Behavior Settings
                    // ========================================================================
                    this.imuToken = 'i';
                    // Nothing to see here yet.
                }
                get printMode() {
                    return this.$printMode;
                }
                setPrintMode(printMode) {
                    this.$printMode = printMode;
                }
                get testFlag() {
                    return this.$test_flag;
                }
                setTestFlag(test_flag) {
                    this.$test_flag = test_flag;
                }
            }
            /**
             * Global (singleton) instance of Defs.
             */
            const defs = new Defs();
            /**
             * This should only be used for scripting when the stack is being used.
             * Otherwise, there should be a convenient way to throw structured Error(s).
             */
            function halt(s) {
                defs.errorMessage += 'Stop: ';
                defs.errorMessage += s;
                const message = defs.errorMessage;
                defs.errorMessage = '';
                move_top_of_stack(0);
                throw new Error(message);
            }
            function move_top_of_stack(stackPos) {
                if (defs.tos <= stackPos) {
                    // we are moving the stack pointer
                    // "up" the stack (as if we were doing a push)
                    defs.tos = stackPos;
                    return;
                }
                // we are moving the stack pointer
                // "down" the stack i.e. as if we were
                // doing a pop, we can zero-
                // out all the elements that we pass
                // so we can reclaim the memory
                while (defs.tos > stackPos) {
                    defs.stack[defs.tos] = null;
                    defs.tos--;
                }
            }
            /**
             * This is a good function to call after an abnormal program termination.
             * It is called
             *
             * 1. Resets the stack pointer.
             */
            function hard_reset() {
                // console.lg('hard_reset()');
                move_top_of_stack(0);
            }
            function noexpand_unary(func, arg, $) {
                $.pushNativeDirective(Directive.expand, false);
                try {
                    return func(arg, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            function noexpand_binary(func, lhs, rhs, $) {
                $.pushNativeDirective(Directive.expand, false);
                try {
                    return func(lhs, rhs, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            function doexpand_unary(func, arg, $) {
                $.pushNativeDirective(Directive.expand, true);
                try {
                    return func(arg, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            function doexpand_binary(func, lhs, rhs, $) {
                $.pushNativeDirective(Directive.expand, true);
                try {
                    return func(lhs, rhs, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            /**
             *
             */
            class DynamicConstants {
                static NegOne($) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? negOneAsFlt : negOne;
                }
                static Pi($) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? piAsFlt : MATH_PI$2;
                }
            }

            // TODO: Migrate to a situation of only creating these on demand by extensions.
            const ADD$7 = native_sym(Native.add);
            const ADJ = create_sym('adj');
            create_sym('algebra');
            const AND = create_sym('and');
            const APPROXRATIO = create_sym('approxratio');
            const ARCCOS = create_sym('arccos');
            const ARCCOSH = create_sym('arccosh');
            const ARCSIN = create_sym('arcsin');
            const ARCSINH = create_sym('arcsinh');
            const ARCTAN = create_sym('arctan');
            const ARCTANH = create_sym('arctanh');
            create_sym('atomize');
            const BESSELJ = create_sym('besselj');
            const BESSELY = create_sym('bessely');
            create_sym('binding');
            const BINOMIAL = create_sym('binomial');
            const CEILING = create_sym('ceiling');
            const CHECK = create_sym('check');
            const CHOOSE = create_sym('choose');
            const CIRCEXP = create_sym('circexp');
            const CLEAR = create_sym('clear');
            const CLEARALL = create_sym('clearall');
            create_sym('clearpatterns');
            const CLOCK = create_sym('clock');
            const COEFF = create_sym('coeff');
            const COFACTOR = create_sym('cofactor');
            create_sym('compare');
            create_sym('compare-factors');
            create_sym('compare-terms');
            const CONDENSE = create_sym('condense');
            const CONTRACT = create_sym('contract');
            const COS$3 = create_sym('cos');
            const COSH = create_sym('cosh');
            create_sym('decomp');
            const DEFINT = create_sym('defint');
            const DEGREE = create_sym('degree');
            const DENOMINATOR = create_sym('denominator');
            const DET = create_sym('det');
            const DIM = create_sym('dim');
            const DIRAC = create_sym('dirac');
            create_sym('divide');
            const DIVISORS = create_sym('divisors');
            const DO = create_sym('do');
            const DOT = create_sym('dot');
            create_sym('draw');
            create_sym('dsolve');
            const EIGEN = create_sym('eigen');
            const EIGENVAL = create_sym('eigenval');
            const EIGENVEC = create_sym('eigenvec');
            create_sym('equal');
            const ERF = create_sym('erf');
            const ERFC = create_sym('erfc');
            const EVAL = create_sym('eval');
            const EXP$7 = create_sym('exp');
            const EXPAND = create_sym('expand');
            const EXPCOS = create_sym('expcos');
            const EXPSIN = create_sym('expsin');
            const FACTOR = create_sym('factor');
            const FACTORIAL = MATH_FACTORIAL;
            create_sym('factorpoly');
            create_sym('filter');
            const FLOAT = create_sym('float');
            const FLOOR = create_sym('floor');
            const FOR = create_sym('for');
            const FUNCTION = create_sym('function');
            const GAMMA = create_sym('gamma');
            const GCD = create_sym('gcd');
            const HERMITE = create_sym('hermite');
            const HILBERT = create_sym('hilbert');
            create_sym('if');
            const IMAG$h = native_sym(Native.imag);
            const SYM_MATH_COMPONENT = MATH_COMPONENT;
            const INTEGRAL = create_sym('integral');
            const INV$1 = MATH_INV;
            create_sym('invg');
            create_sym('isinteger');
            const ISPRIME = create_sym('isprime');
            const LAGUERRE = create_sym('laguerre');
            create_sym('laplace');
            const LCM = create_sym('lcm');
            create_sym('lco');
            create_sym('leading');
            const LEGENDRE = create_sym('legendre');
            const LOG$1 = native_sym(Native.log);
            create_sym('lookup');
            const MULTIPLY$1 = MATH_MUL$3;
            const NOT = create_sym('not');
            const NROOTS = create_sym('nroots');
            const NUMBER = create_sym('number');
            const NUMERATOR = create_sym('numerator');
            const OPERATOR = create_sym('operator');
            const OR = create_sym('or');
            const PATTERN = create_sym('pattern');
            create_sym('patternsinfo');
            const POLAR = create_sym('polar');
            const POWER$1 = MATH_POW$2;
            create_sym('prime');
            const PRINT_LEAVE_E_ALONE = create_sym('printLeaveEAlone');
            const PRINT_LEAVE_X_ALONE = create_sym('printLeaveXAlone');
            create_sym('print');
            const PRODUCT = create_sym('product');
            const QUOTE = create_sym('quote');
            const QUOTIENT = create_sym('quotient');
            const RANK = create_sym('rank');
            const RATIONALIZE = create_sym('rationalize');
            create_sym('rco');
            const REAL$b = native_sym(Native.real);
            const PREDICATE_IS_REAL = native_sym(Native.is_real);
            const ROUND = create_sym('round');
            const RECT = native_sym(Native.rect);
            const ROOTS = create_sym('roots');
            const ASSIGN = create_sym('=');
            const SGN = create_sym('sgn');
            create_sym('silentpattern');
            const SIMPLIFY = create_sym('simplify');
            const SIN$1 = MATH_SIN$1;
            const SINH = create_sym('sinh');
            const SHAPE = create_sym('shape');
            const SQRT = create_sym('sqrt');
            create_sym('stop');
            const SUBST = create_sym('subst');
            create_sym('-');
            const SUM = create_sym('sum');
            create_sym('symbolsinfo');
            const TAN = create_sym('tan');
            const TANH = create_sym('tanh');
            const TAYLOR = create_sym('taylor');
            const TEST = create_sym('test');
            // export const TESTEQ = native_sym(Native.testeq);
            const TESTGE = create_sym('testge');
            const TESTGT = create_sym('testgt');
            const TESTLE = create_sym('testle');
            const TESTLT = create_sym('testlt');
            const TRANSPOSE = create_sym('transpose');
            const UNIT = create_sym('unit');
            create_sym('uom');
            const ZERO = create_sym('zero');
            create_sym('lastPrint');
            const LAST_ASCII_PRINT = create_sym('lastAsciiPrint');
            const LAST_INFIX_PRINT = create_sym('lastInfixPrint');
            const LAST_LATEX_PRINT = create_sym('lastLatexPrint');
            const LAST_SEXPR_PRINT = create_sym('lastSexprPrint');
            const LAST_HUMAN_PRINT = create_sym('lastHumanPrint');
            const AUTOEXPAND = create_sym('autoexpand');
            const AUTOFACTOR = create_sym('autofactor');
            const BAKE = create_sym('bake');
            const ASSUME_REAL_VARIABLES = create_sym('assumeRealVariables');
            create_sym('trace');
            const FORCE_FIXED_PRINTOUT = create_sym('forceFixedPrintout');
            const VARNAME_MAX_FIXED_PRINTOUT_DIGITS = create_sym('maxFixedPrintoutDigits');
            const DEFAULT_MAX_FIXED_PRINTOUT_DIGITS = 6;
            create_sym('$DRAWX');
            const METAA = create_sym('$METAA');
            const METAB = create_sym('$METAB');
            const METAX = create_sym('$METAX');
            const SECRETX = create_sym('$SECRETX');
            create_sym('version');
            /**
             * TODO: Don't use this. Just use MATH_PI. It's the same thing.
             */
            const PI$7 = MATH_PI$2;
            /**
             * 'a'
             */
            create_sym('a');
            create_sym('b');
            create_sym('c');
            const SYMBOL_D = create_sym('d');
            const SYMBOL_I = create_sym('i');
            const SYMBOL_J = create_sym('j');
            create_sym('n');
            create_sym('r');
            const SYMBOL_S = create_sym('s');
            const SYMBOL_T = create_sym('t');
            const SYMBOL_X = create_sym('x');
            const SYMBOL_Y = create_sym('y');
            const SYMBOL_Z = create_sym('z');
            const SYMBOL_IDENTITY_MATRIX = create_sym('I');
            const SYMBOL_A_UNDERSCORE = create_sym('a_');
            const SYMBOL_B_UNDERSCORE = create_sym('b_');
            const SYMBOL_X_UNDERSCORE = create_sym('x_');
            create_sym('$C1');
            create_sym('$C2');
            create_sym('$C3');
            create_sym('$C4');
            create_sym('$C5');
            create_sym('$C6');
            const MAXPRIMETAB = 10000;
            const MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;
            const MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;
            //define _USE_MATH_DEFINES // for MS C++
            const MAXDIM = 24;
            const predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [
                'rationalize',
                'abs',
                'e',
                'i',
                'pi',
                'sin',
                'ceiling',
                'cos',
                'roots',
                'integral',
                'derivative',
                'defint',
                'sqrt',
                'eig',
                'cov',
                'deig',
                'dcov',
                'float',
                'floor',
                'product',
                'root',
                'round',
                'sum',
                'test',
                'unit',
            ];
            const primetab = (function () {
                const primes = [2];
                let i = 3;
                while (primes.length < MAXPRIMETAB) {
                    let j = 0;
                    const ceil = Math.sqrt(i);
                    while (j < primes.length && primes[j] <= ceil) {
                        if (i % primes[j] === 0) {
                            j = -1;
                            break;
                        }
                        j++;
                    }
                    if (j !== -1) {
                        primes.push(i);
                    }
                    i += 2;
                }
                primes[MAXPRIMETAB] = 0;
                return primes;
            })();
            const TRANSPOSE_CHAR_CODE = 7488;
            /**
             * Middle or Center Dot. 183 = 0xB7
             */
            const MIDDLE_DOT_CHAR_CODE = 183;
            const MIDDLE_DOT_STRING = String.fromCharCode(MIDDLE_DOT_CHAR_CODE);
            function MSIGN(p) {
                if (p.isZero()) {
                    return 0;
                }
                if (p.isPositive()) {
                    return 1;
                }
                return -1;
            }
            /**
             * p.equals(n)
             */
            function MEQUAL(p, n) {
                return p.equals(n);
            }

            // there are around a dozen different unicodes that
            /**
             * Converts the various representations of middle dots embedded in text to a canonical MIDDLE_DOT_STRING.
             * @param text Contains the embedded middle dots in various forms.
             */
            function normalize_unicode_dots(text) {
                let str = text;
                str = str.replace(new RegExp(String.fromCharCode(8901), 'g'), MIDDLE_DOT_STRING);
                str = str.replace(new RegExp(String.fromCharCode(8226), 'g'), MIDDLE_DOT_STRING);
                str = str.replace(new RegExp(String.fromCharCode(12539), 'g'), MIDDLE_DOT_STRING);
                str = str.replace(new RegExp(String.fromCharCode(55296), 'g'), MIDDLE_DOT_STRING);
                str = str.replace(new RegExp(String.fromCharCode(65381), 'g'), MIDDLE_DOT_STRING);
                return str;
            }

            const TYPEOF_ERR = 'Err';

            var _Err_cause;
            /**
             * An Err is synonymous with undefined.
             * undefined means that the types are correct but the expression is not meaningful because of the values.
             * An error that may be used as a return value. This MUST not be thrown.
             * Err may be considered to be synonymous with undefined.
             */
            class Err extends Atom {
                constructor(cause, pos, end) {
                    super(TYPEOF_ERR, pos, end);
                    _Err_cause.set(this, void 0);
                    __classPrivateFieldSet(this, _Err_cause, cause, "f");
                }
                get cause() {
                    return __classPrivateFieldGet(this, _Err_cause, "f");
                }
                equals(other) {
                    if (this === other) {
                        return true;
                    }
                    if (other instanceof Err) {
                        return this.equalsErr(other);
                    }
                    else {
                        return false;
                    }
                }
                equalsErr(other) {
                    return this.cause.equals(other.cause);
                }
                toString() {
                    return `${TYPEOF_ERR}(${__classPrivateFieldGet(this, _Err_cause, "f").toString()})`;
                }
                toInfixString() {
                    throw new Error();
                }
                toListString() {
                    throw new Error();
                }
            }
            _Err_cause = new WeakMap();

            function is_err(p) {
                return p instanceof Err;
            }

            const KIND_NIL = 0;
            const KIND_CONS = 1;
            const KIND_ATOM = 2;
            const HASH_BLADE = 'Blade';
            const HASH_BOO = 'Boo';
            const HASH_ERR = TYPEOF_ERR;
            const HASH_FLT = 'Flt';
            const HASH_HYP = 'Hyp';
            const HASH_IMU = 'Imu';
            const HASH_RAT = 'Rat';
            const HASH_STR = 'Str';
            const HASH_SYM = 'Sym';
            const HASH_TENSOR = 'Tensor';
            const HASH_UOM = 'Uom';
            const HASH_ANY = 'U';
            const HASH_NIL = 'Nil';
            function hash_binop_atom_atom(opr, lhs, rhs) {
                return `(${opr.key()} ${lhs} ${rhs})`;
            }
            function hash_binop_atom_cons(opr, lhs, rhs) {
                return `(${opr.key()} ${lhs} (${rhs.key()}))`;
            }
            function hash_binop_cons_atom(opr, lhs, rhs) {
                return `(${opr.key()} (${lhs.key()}) ${rhs})`;
            }
            function hash_binop_cons_cons(opr, lhs, rhs) {
                return `(${opr.key()} (${lhs.key()}) (${rhs.key()}))`;
            }
            function hash_unaop_atom(opr, arg) {
                return `(${opr.key()} ${arg})`;
            }
            /**
             * '(' opr '(' arg ')' ')'
             */
            function hash_unaop_cons(opr, arg) {
                return `(${opr.key()} (${arg.key()}))`;
            }
            /**
             * '(' opr ')'
             */
            function hash_nonop_cons(opr) {
                return `(${opr.key()})`;
            }
            function hash_info(expr) {
                const protos = [];
                const info = hash_info_at_level(expr, 0);
                protos.push(compress(info));
                switch (info.kind) {
                    case KIND_CONS: {
                        if (info.parts.length === 3) {
                            protos.push(compress({ kind: KIND_CONS, parts: [info.parts[0], info.parts[1], HASH_ANY] }));
                            protos.push(compress({ kind: KIND_CONS, parts: [info.parts[0], HASH_ANY, info.parts[2]] }));
                            protos.push(compress({ kind: KIND_CONS, parts: [info.parts[0], HASH_ANY, HASH_ANY] }));
                            protos.push(compress({ kind: KIND_CONS, parts: [info.parts[0]] }));
                        }
                        if (info.parts.length === 2) {
                            protos.push(compress({ kind: KIND_CONS, parts: [info.parts[0], HASH_ANY] }));
                            protos.push(compress({ kind: KIND_CONS, parts: [info.parts[0]] }));
                        }
                        break;
                    }
                }
                return protos;
            }
            function compress(info) {
                switch (info.kind) {
                    case KIND_CONS: {
                        return `(${info.parts.join(' ')})`;
                    }
                    case KIND_ATOM: {
                        return info.parts[0];
                    }
                    default: {
                        return HASH_NIL;
                    }
                }
            }
            function hash_info_at_level(expr, level) {
                if (is_cons(expr)) {
                    if (level === 0) {
                        if (expr.length === 3) {
                            const opr = expr.opr;
                            const lhs = expr.lhs;
                            const rhs = expr.rhs;
                            return { kind: KIND_CONS, parts: [hash_arg(opr), compress(hash_info_at_level(lhs, level + 1)), compress(hash_info_at_level(rhs, level + 1))] };
                        }
                        if (expr.length === 2) {
                            const opr = expr.opr;
                            const arg = expr.arg;
                            return { kind: KIND_CONS, parts: [hash_arg(opr), compress(hash_info_at_level(arg, level + 1))] };
                        }
                        if (is_sym(expr.head)) {
                            return { kind: KIND_CONS, parts: [hash_arg(expr.head)] };
                        }
                        else if (is_rat$1(expr.head)) {
                            return { kind: KIND_CONS, parts: [hash_arg(expr.head)] };
                        }
                        else {
                            throw new Error(`${expr}`);
                        }
                    }
                    else {
                        return { kind: KIND_CONS, parts: [hash_arg(expr.opr)] };
                    }
                }
                if (is_sym(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_SYM] };
                }
                if (is_rat$1(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_RAT] };
                }
                if (is_blade$1(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_BLADE] };
                }
                if (is_imu(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_IMU] };
                }
                if (is_tensor(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_TENSOR] };
                }
                if (is_uom$1(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_UOM] };
                }
                if (is_flt$1(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_FLT] };
                }
                if (is_nil(expr)) {
                    return { kind: KIND_NIL, parts: [HASH_NIL] };
                }
                if (is_str$1(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_STR] };
                }
                if (is_boo(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_BOO] };
                }
                if (is_hyp(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_HYP] };
                }
                if (is_err(expr)) {
                    return { kind: KIND_ATOM, parts: [HASH_ERR] };
                }
                throw new Error(`hash_string(${expr})`);
            }
            /**
             * Note: This is starting to look a lot like the hash_from_match function, except in that case it is a pattern.
             */
            function hash_arg(arg) {
                if (is_sym(arg)) {
                    // For a symbol, what distinguishes it is the text of the symbol.
                    return arg.key();
                }
                else if (is_rat$1(arg)) {
                    // We know that this is 'Rat' and is the same as the hash.
                    return arg.name;
                }
                else {
                    throw new Error(`hash_arg(arg=${arg})`);
                }
            }

            /**
             * A poor-mans way of implementing an OperatorBuilder is to take an existing Extension
             * and wrap it. That's what this class does. Use it for existing extensions, migrating
             * to a first-class implementation of OperatorBuilder.
             */
            class ExtensionOperatorBuilder {
                /**
                 *
                 * @param extensionProvider A function that takes an extension environment and produces an Extension.
                 */
                constructor(extensionProvider) {
                    this.extensionProvider = extensionProvider;
                    // Nothing to see here.
                }
                create($) {
                    return new ExtensionOperator(this.extensionProvider($), $);
                }
            }
            /**
             * In general, we delegate to a method on the Extension with the same name and with an additional
             * $: ExtensionEnv parameter. Anything different is a code smell.
             */
            class ExtensionOperator {
                constructor(extension, $) {
                    this.extension = extension;
                    this.$ = $;
                    // Nothing going on here because this is a crude adaption of the Extension.
                    // This would be a good place to cache symbols that will be needed later.
                }
                get key() {
                    return this.extension.key;
                }
                get hash() {
                    return this.extension.hash;
                }
                get name() {
                    return this.extension.name;
                }
                get phases() {
                    return this.extension.phases;
                }
                get dependencies() {
                    return this.extension.dependencies;
                }
                isImag(expr) {
                    return this.extension.isImag(expr, this.$);
                }
                isKind(expr) {
                    return this.extension.isKind(expr, this.$);
                }
                isMinusOne(expr) {
                    return this.extension.isMinusOne(expr, this.$);
                }
                isOne(expr) {
                    return this.extension.isOne(expr, this.$);
                }
                isReal(expr) {
                    return this.extension.isReal(expr, this.$);
                }
                isScalar(expr) {
                    return this.extension.isScalar(expr, this.$);
                }
                isZero(expr) {
                    return this.extension.isZero(expr, this.$);
                }
                valueOf(expr) {
                    return this.extension.transform(expr, this.$)[1];
                }
                subst(expr, oldExpr, newExpr) {
                    return this.extension.subst(expr, oldExpr, newExpr, this.$);
                }
                toInfixString(expr) {
                    return this.extension.toInfixString(expr, this.$);
                }
                toLatexString(expr) {
                    return this.extension.toLatexString(expr, this.$);
                }
                toListString(expr) {
                    return this.extension.toListString(expr, this.$);
                }
                evaluate(expr, argList) {
                    return this.extension.evaluate(expr, argList, this.$);
                }
                transform(expr) {
                    return this.extension.transform(expr, this.$);
                }
            }

            function is_rat(p) {
                return p instanceof Rat;
            }
            class RatExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                    // Nothing to see here.
                }
                get key() {
                    return one.name;
                }
                get hash() {
                    return HASH_RAT;
                }
                get name() {
                    return 'RatExtension';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isKind(arg, $) {
                    // console.lg(`RatExtension.isKind for ${arg.toString()}`);
                    // We must be prepared to handle singleton lists containing a single rat.
                    if (is_cons(arg) && is_singleton(arg)) {
                        return this.isKind(arg.head, $);
                    }
                    return arg instanceof Rat;
                }
                isMinusOne(arg) {
                    return arg.isMinusOne();
                }
                isOne(arg) {
                    return arg.isOne();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                isZero(expr) {
                    return expr.isZero();
                }
                subst(expr, oldExpr, newExpr) {
                    if (is_rat(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                toInfixString(rat) {
                    return rat.toInfixString();
                }
                toLatexString(rat) {
                    return rat.toInfixString();
                }
                toListString(rat) {
                    return rat.toListString();
                }
                evaluate(rat, argList) {
                    if (is_cons(rat)) {
                        throw new Error(`The expr is really a Cons! ${rat}`);
                    }
                    return this.transform(cons(rat, argList));
                }
                transform(expr) {
                    if (expr instanceof Rat) {
                        // console.lg(`RatExtension.transform ${expr}`);
                        if (this.$.getNativeDirective(Directive.evaluatingAsFloat)) {
                            return [TFLAG_DIFF, create_flt(expr.toNumber())];
                        }
                        else {
                            return [TFLAG_HALT, expr];
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
                valueOf(expr) {
                    return this.transform(expr)[1];
                }
            }
            const rat_extension = new ExtensionOperatorBuilder(function ($) {
                return new RatExtension($);
            });

            /**
             * Use this exclusively for failures of the system due programming errors.
             */
            class SystemError extends Error {
                /**
                 * Constructs a SystemError using the message. The stack will be logged to the console.
                 */
                constructor(message) {
                    super(message);
                    this.name = 'SystemError';
                    // eslint-disable-next-line no-console
                    console.warn(message, new Error().stack);
                }
            }

            function assert_sym(expr) {
                if (is_sym(expr)) {
                    return expr;
                }
                else {
                    // Don't need anything fancy here because this is an assertion for dev eyes only.
                    throw new SystemError(`expr => ${expr}`);
                }
            }

            function assert_token_code(actual, expect) {
                if (actual === expect) {
                    return actual;
                }
                else {
                    throw new SystemError();
                }
            }

            /**
             * Creates a clone of the first symbol using the scanner information from the second symbol.
             * @param sym The symbol to be cloned.
             * @param info The symbol providing the scanner information.
             */
            function clone_symbol_using_info(sym, info) {
                return sym.clone(info.pos, info.end);
            }

            const next_code = function (startCode) {
                let nextCode = startCode;
                return function (text) {
                    return { text, code: nextCode++ };
                };
            }(1001);
            const T_INT = next_code('Int');
            const T_FLT = next_code('Flt');
            const T_SYM = next_code('Sym');
            const T_FUNCTION = next_code('Function');
            const T_MINUS = next_code('-');
            const T_NewLine = next_code('NewLine');
            const T_PLUS = next_code('+');
            const T_STR = next_code('Str');
            const T_GTEQ = next_code('>=');
            const T_GTGT = next_code('>>');
            const T_LTEQ = next_code('<=');
            const T_LTLT = next_code('<<');
            const T_LT = next_code('<');
            const T_GT = next_code('>');
            const AsteriskToken = next_code('*');
            const T_FWDSLASH = next_code('/');
            const T_LPAR = next_code('(');
            const T_RPAR = next_code(')');
            const T_MIDDLE_DOT = next_code('·');
            const T_EQ_EQ = next_code('==');
            const T_NTEQ = next_code('!=');
            const T_COLON = next_code(':');
            const T_COLON_EQ = next_code(':=');
            const T_EQ = next_code('=');
            const T_ASTRX_ASTRX = next_code('**');
            const CaretToken = next_code('^');
            const T_VBAR = next_code('|');
            const T_END = next_code('End');
            const T_COMMA = next_code(',');
            const T_LSQB = next_code('[');
            const T_RSQB = next_code(']');

            class FltTokenParser {
                parse(token, pos, end) {
                    const d = parseFloat(token);
                    return new Flt(d, pos, end);
                }
            }

            class IntTokenParser {
                parse(token, pos, end) {
                    // TODO: Make use of pos and end
                    const sign = token[0];
                    if (sign === '+') {
                        const numerator = BigIntegerExports(token.substring(1));
                        return new Rat(numerator, BigIntegerExports.one, pos, end);
                    }
                    if (sign === '-') {
                        const numerator = BigIntegerExports(token.substring(1));
                        return new Rat(numerator, BigIntegerExports.one, pos, end).neg();
                    }
                    const numerator = BigIntegerExports(token);
                    return new Rat(numerator, BigIntegerExports.one, pos, end);
                }
            }

            class StrTokenParser {
                parse(token, pos, end) {
                    // We remove the delimiters. Not very sophisticated, I know.
                    // TODO: Parsing of string with embedded and varying delimiters.
                    const parsedText = token.substring(1, token.length - 1);
                    return new Str$1(parsedText, pos, end);
                }
            }

            class SymTokenParser {
                parse(token, pos, end) {
                    return create_sym(token, pos, end);
                }
            }

            /**
             * if
             */
            create_sym('if');
            /**
             * nil() => NIL
             */
            create_sym('nil');
            /**
             * false
             */
            create_sym('false');
            /**
             * true
             */
            create_sym('true');
            /**
             * undefined
             */
            create_sym('undefined');
            /**
             * ':='
             */
            const LANG_COLON_EQ = create_sym(':=');

            /**
             *
             */
            function is_digit(str) {
                if (str == null) {
                    return false;
                }
                return /^\d+$/.test(str);
            }

            function consume_num(stream, handler) {
                if (is_digit(stream.curr) || stream.curr === '.') {
                    while (is_digit(stream.curr)) {
                        stream.consumeChars(1);
                    }
                    if (stream.curr === '.') {
                        stream.consumeChars(1);
                        while (is_digit(stream.curr)) {
                            stream.consumeChars(1);
                        }
                        if (stream.currEquals('e') && (stream.next === '+' || stream.next === '-' || is_digit(stream.next))) {
                            stream.consumeChars(2);
                            while (is_digit(stream.curr)) {
                                stream.consumeChars(1);
                            }
                        }
                        handler.flt();
                        return true;
                    }
                    else {
                        handler.int();
                        return true;
                    }
                }
                return false;
            }

            /**
             * A ... Z or a ... z
             */
            function is_alphabetic(str) {
                if (str == null) {
                    return false;
                }
                // console.lg(`is_alphabetic(str = ${JSON.stringify(str)}) length is ${str.length}`);
                // Check for non-alphabetic characters and space
                return str.search(/[^A-Za-z]/) === -1;
            }

            function is_alphabetic_or_underscore(str) {
                if (str == null) {
                    return false;
                }
                // Check for non-alphabetic characters and space
                return str.search(/[^A-Za-z_]/) === -1;
            }
            function is_alphanumeric_or_underscore(str) {
                if (str == null) {
                    return false;
                }
                // console.lg(`is_alphabetic_or_underscore(str = ${JSON.stringify(str)}) length is ${str.length}`);
                return is_alphabetic_or_underscore(str) || is_digit(str);
            }

            // s is a string here anyways
            function is_space(s) {
                if (s == null) {
                    return false;
                }
                return (s === ' ' ||
                    s === '\t' ||
                    s === '\n' ||
                    s === '\v' ||
                    s === '\f' ||
                    s === '\r');
            }

            let TokenError$1 = class TokenError extends Error {
                constructor(message, pos, end) {
                    super(`${message} in range [${pos}, ${end}]`);
                }
            };

            var _InputState_token;
            const scanConfig = {
                fltParser: new FltTokenParser(),
                intParser: new IntTokenParser(),
                strParser: new StrTokenParser(),
                symParser: new SymTokenParser(),
                // The lexicon should ONLY contain operators that are "hard-coded" into the scanner.
                // All other functions should be excluded. This conversion is a convenience for the
                // consumer by having normalized operators rather than syntax dependency.
                // Note that MATH_OUTER and MATH_POW depend upon the scanner version.
                // version 1.x : '^' is exponentiation, '**' is not defined.
                // version 2.x : '^' is outer product, '**' is exponentiation.
                lexicon: {
                    '+': native_sym(Native.add),
                    '-': native_sym(Native.subtract),
                    '*': native_sym(Native.multiply),
                    '/': native_sym(Native.divide),
                    '^': native_sym(Native.outer),
                    '|': native_sym(Native.inner),
                    '>>': native_sym(Native.rco),
                    '<<': native_sym(Native.lco),
                    '**': native_sym(Native.pow),
                    '<=': native_sym(Native.test_le),
                    '<': native_sym(Native.test_lt),
                    '>=': native_sym(Native.test_ge),
                    '>': native_sym(Native.test_gt),
                    '!=': native_sym(Native.test_ne),
                    '==': native_sym(Native.test_eq),
                    ':=': LANG_COLON_EQ,
                    '=': ASSIGN,
                    'abs': native_sym(Native.abs),
                    'cos': native_sym(Native.cos),
                    'exp': native_sym(Native.exp),
                    'iscomplex': native_sym(Native.is_complex),
                    'isreal': native_sym(Native.is_real),
                    'sin': native_sym(Native.sin),
                },
                meta: {
                    'a': METAA,
                    'b': METAB,
                    'x': METAX
                },
                parse_time_simplifications: true
            };
            class InputState {
                /**
                 * @param sourceText The text that will be used for the scan.
                 * @param end The zero-based starting position in the text.
                 */
                constructor(sourceText, end = 0) {
                    this.sourceText = sourceText;
                    /**
                     * The token is a string when it contains single character operators.
                     * Tokens or Operators with multiple characters are combined into a number captured in a T_* constant. e.g. T_
                     */
                    _InputState_token.set(this, void 0);
                    this.meta_mode = false;
                    /**
                     * Use '^' or '**' for exponentiation.
                     */
                    this.useCaretForExponentiation = false;
                    /**
                     *
                     */
                    this.explicitAssocAdd = false;
                    /**
                     *
                     */
                    this.explicitAssocMul = false;
                    __classPrivateFieldSet(this, _InputState_token, { txt: '', pos: 0, end: end }, "f");
                    this.newLine = false;
                    this.input_str = 0;
                    this.lastFoundSymbol = null;
                    this.symbolsRightOfAssignment = [];
                    this.symbolsLeftOfAssignment = [];
                    this.isSymbolLeftOfAssignment = null;
                    this.scanningParameters = [];
                    this.functionInvokationsScanningStack = [];
                    this.skipRootVariableToBeSolved = false;
                    this.assignmentFound = null;
                }
                get code() {
                    const code = __classPrivateFieldGet(this, _InputState_token, "f").code;
                    if (code) {
                        return code;
                    }
                    else {
                        throw new Error();
                    }
                }
                peek(n) {
                    return this.sourceText.slice(__classPrivateFieldGet(this, _InputState_token, "f").end, __classPrivateFieldGet(this, _InputState_token, "f").end + n);
                }
                /**
                 * Returns a new InputState n characters to the right of the this input state.
                 */
                read(n) {
                    return new InputState(this.sourceText, __classPrivateFieldGet(this, _InputState_token, "f").end + n);
                }
                get done() {
                    return __classPrivateFieldGet(this, _InputState_token, "f").end === this.sourceText.length;
                }
                get text() {
                    return __classPrivateFieldGet(this, _InputState_token, "f").txt;
                }
                get pos() {
                    return __classPrivateFieldGet(this, _InputState_token, "f").pos;
                }
                get end() {
                    return __classPrivateFieldGet(this, _InputState_token, "f").end;
                }
                get scanned() {
                    // console.lg(`pos: ${this.token.pos}`);
                    // console.lg(`end: ${this.token.end}`);
                    // console.lg(`inp: ${this.input_str}`);
                    return __classPrivateFieldGet(this, _InputState_token, "f").pos - this.input_str;
                }
                /**
                 * The character at token.end
                 */
                get curr() {
                    return this.sourceText[__classPrivateFieldGet(this, _InputState_token, "f").end];
                }
                /**
                 * The character at token.end + 1
                 */
                get next() {
                    return this.sourceText[__classPrivateFieldGet(this, _InputState_token, "f").end + 1];
                }
                advance() {
                    // console.lg(`ScanState.advance(from = ${JSON.stringify(this.token)})`);
                    this.newLine = false;
                    // eslint-disable-next-line no-constant-condition
                    while (true) {
                        this.get_token();
                        if (__classPrivateFieldGet(this, _InputState_token, "f").code === T_NewLine) {
                            this.newLine = true;
                        }
                        else {
                            break;
                        }
                    }
                    // console.lg(`InputState.advance(token = ${JSON.stringify(this.#token)})`);
                }
                consumeChars(n) {
                    __classPrivateFieldGet(this, _InputState_token, "f").end += n;
                }
                currEquals(thing) {
                    return this.curr === thing;
                }
                expect(code) {
                    if (this.code === code) {
                        return { pos: this.pos, end: this.end };
                    }
                    else {
                        this.scan_error(`${code.text} expected`);
                    }
                }
                tokenToFlt() {
                    return scanConfig.fltParser.parse(__classPrivateFieldGet(this, _InputState_token, "f").txt, __classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                }
                tokenToInt() {
                    return scanConfig.intParser.parse(__classPrivateFieldGet(this, _InputState_token, "f").txt, __classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                }
                tokenToStr() {
                    return scanConfig.strParser.parse(__classPrivateFieldGet(this, _InputState_token, "f").txt, __classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                }
                tokenToSym() {
                    // TODO: This stuff seems like it could go into a parser, but we would need the meta_mode.
                    // Maybe we use two different symbol parsers?
                    const key = __classPrivateFieldGet(this, _InputState_token, "f").txt;
                    if (this.meta_mode && typeof __classPrivateFieldGet(this, _InputState_token, "f").txt == 'string') {
                        const metaKey = scanConfig.meta[key];
                        if (metaKey) {
                            return metaKey;
                        }
                    }
                    if (scanConfig.lexicon[key]) {
                        return scanConfig.lexicon[key].clone(__classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                    }
                    else {
                        return create_sym(key, __classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                    }
                }
                /**
                 * Sets the (private) token variable to the next token.
                 * Skips whitespace.
                 * Eats numbers giving T_DOUBLE (scientific notation) or T_INTEGER (otherwise).
                 * Eats symbols giving T_SYMBOL or T_FUNCTION if Lpar detected.
                 * Eats (double) quoted strings giving T_STRING.
                 * Eats comments giving T_NEWLINE.
                 * Combines multi-character operators as follows:
                 * ':=' T_COLON_EQ
                 * '==' T_EQ_EQ
                 * '!=' T_BANG_EQ
                 * '<=' T_LTEQ
                 * '>=' T_GTEQ
                 * '**' or "**" T_STAR_STAR
                 */
                get_token() {
                    // eslint-disable-next-line no-console
                    // console.lg(`get_token(start = ${JSON.stringify(this.#token)})`);
                    // skip spaces
                    while (is_space(this.curr)) {
                        if (this.curr === '\n' || this.curr === '\r') {
                            __classPrivateFieldGet(this, _InputState_token, "f").code = T_NewLine;
                            __classPrivateFieldGet(this, _InputState_token, "f").end++;
                            return;
                        }
                        __classPrivateFieldGet(this, _InputState_token, "f").end++;
                    }
                    __classPrivateFieldGet(this, _InputState_token, "f").pos = __classPrivateFieldGet(this, _InputState_token, "f").end;
                    // end of source text?
                    if (__classPrivateFieldGet(this, _InputState_token, "f").end === this.sourceText.length) {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = '';
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_END;
                        return;
                    }
                    if (consume_num(this, {
                        flt: () => {
                            __classPrivateFieldGet(this, _InputState_token, "f").code = T_FLT;
                            this.update_token_text(__classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                        },
                        int: () => {
                            __classPrivateFieldGet(this, _InputState_token, "f").code = T_INT;
                            this.update_token_text(__classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                        }
                    })) {
                        return;
                    }
                    /*
                    if (is_digit(this.curr) || this.curr === '.') {
                        while (is_digit(this.curr)) {
                            this.#token.end++;
                        }
                        if (this.curr === '.') {
                            this.#token.end++;
                            while (is_digit(this.curr)) {
                                this.#token.end++;
                            }
                            if (this.currEquals('e') && (this.next === '+' || this.next === '-' || is_digit(this.next))) {
                                this.#token.end += 2;
                                while (is_digit(this.curr)) {
                                    this.#token.end++;
                                }
                            }
                            this.#token.code = T_FLT;
                        }
                        else {
                            this.#token.code = T_INT;
                        }
                        this.update_token_text(this.#token.pos, this.#token.end);
                        return;
                    }
                    */
                    // symbol?
                    if (is_alphabetic(this.curr)) {
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_SYM;
                        __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        while (is_alphanumeric_or_underscore(this.curr)) {
                            __classPrivateFieldGet(this, _InputState_token, "f").code = T_SYM;
                            __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        }
                        this.update_token_text(__classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                        return;
                    }
                    // string ?
                    // TODO: Handle strings containing embedded double quotes
                    if (this.curr === '"') {
                        __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        while (this.curr !== '"') {
                            //if (scan_str == scanned.length || scanned[scan_str] == '\n' || scanned[scan_str] == '\r')
                            if (__classPrivateFieldGet(this, _InputState_token, "f").end === this.sourceText.length - 1) {
                                __classPrivateFieldGet(this, _InputState_token, "f").end++;
                                this.scan_error('runaway string');
                                // FIXME...
                                __classPrivateFieldGet(this, _InputState_token, "f").end--;
                            }
                            __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        }
                        __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_STR;
                        // Notice that the token.buf contains the entire un-parsed string.
                        this.update_token_text(__classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                        return;
                    }
                    // comment?
                    if (this.curr === '#' || (this.curr === '-' && this.next === '-')) {
                        while (this.curr && !this.currEquals('\n') && !this.currEquals('\r')) {
                            __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        }
                        if (this.curr) {
                            __classPrivateFieldGet(this, _InputState_token, "f").end++;
                        }
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_NewLine;
                        return;
                    }
                    switch (this.curr) {
                        case '*': {
                            switch (this.next) {
                                case '*': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_ASTRX_ASTRX;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '**';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '*';
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = AsteriskToken;
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case ':': {
                            switch (this.next) {
                                case '=': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_COLON_EQ;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = ':=';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_COLON;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = ':';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case '=': {
                            switch (this.next) {
                                case '=': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_EQ_EQ;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '==';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_EQ;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '=';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case '>': {
                            switch (this.next) {
                                case '=': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_GTEQ;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '>=';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                case '>': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_GTGT;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '>>';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_GT;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '>';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case '<': {
                            switch (this.next) {
                                case '=': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_LTEQ;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '<=';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                case '<': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_LTLT;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '<<';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_LT;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '<';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case '!': {
                            switch (this.next) {
                                case '=': {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_NTEQ;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '!=';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 2;
                                    return;
                                }
                            }
                            break;
                        }
                        case '(': {
                            switch (this.next) {
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_LPAR;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '(';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case ')': {
                            switch (this.next) {
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_RPAR;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = ')';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case ',': {
                            switch (this.next) {
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_COMMA;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = ',';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case '[': {
                            switch (this.next) {
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_LSQB;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = '[';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                        case ']': {
                            switch (this.next) {
                                default: {
                                    __classPrivateFieldGet(this, _InputState_token, "f").code = T_RSQB;
                                    __classPrivateFieldGet(this, _InputState_token, "f").txt = ']';
                                    __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                                    return;
                                }
                            }
                        }
                    }
                    if (this.curr === '+') {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = this.curr;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_PLUS;
                        __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                        return;
                    }
                    if (this.curr === '-') {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = this.curr;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_MINUS;
                        __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                        return;
                    }
                    if (this.curr === '^') {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = this.curr;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = CaretToken;
                        __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                        return;
                    }
                    if (this.curr === '|') {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = this.curr;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_VBAR;
                        __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                        return;
                    }
                    if (this.curr === '/') {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = this.curr;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_FWDSLASH;
                        __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                        return;
                    }
                    if (this.curr === '·') {
                        __classPrivateFieldGet(this, _InputState_token, "f").txt = this.curr;
                        __classPrivateFieldGet(this, _InputState_token, "f").code = T_MIDDLE_DOT;
                        __classPrivateFieldGet(this, _InputState_token, "f").end += 1;
                        return;
                    }
                    // single char token. What did we miss?
                    __classPrivateFieldGet(this, _InputState_token, "f").txt = this.sourceText[__classPrivateFieldGet(this, _InputState_token, "f").end++];
                    throw new Error(`text = ${__classPrivateFieldGet(this, _InputState_token, "f").txt}`);
                }
                /**
                 * Updates the token buffer string to be the substring defined by pos and end.
                 * TODO: In version 1.x there could be a problem with embedded string delimiters.
                 * @param pos The end position of the token.
                 * @param end The start position of the token.
                 */
                update_token_text(pos, end) {
                    __classPrivateFieldGet(this, _InputState_token, "f").txt = this.sourceText.substring(pos, end);
                    // console.lg(`update_token_buf(pos => ${pos}, end => ${end}), token.buf => ${JSON.stringify(token.buf)}`);
                }
                scan_error(errmsg) {
                    // console.lg(`scan_error ${JSON.stringify(micro(state))} ${errmsg})`);
                    defs.errorMessage = '';
                    // try not to put question mark on orphan line
                    while (this.input_str !== __classPrivateFieldGet(this, _InputState_token, "f").end) {
                        if ((this.sourceText[this.input_str] === '\n' || this.sourceText[this.input_str] === '\r') && (this.input_str + 1 === __classPrivateFieldGet(this, _InputState_token, "f").end)) {
                            break;
                        }
                        defs.errorMessage += this.sourceText[this.input_str++];
                    }
                    defs.errorMessage += ' ? ';
                    while (this.sourceText[this.input_str] && this.sourceText[this.input_str] !== '\n' && this.sourceText[this.input_str] !== '\r') {
                        defs.errorMessage += this.sourceText[this.input_str++];
                    }
                    defs.errorMessage += '\n';
                    throw new TokenError$1(errmsg, __classPrivateFieldGet(this, _InputState_token, "f").pos, __classPrivateFieldGet(this, _InputState_token, "f").end);
                }
                tokenCharCode() {
                    const mtoken = this.munge(__classPrivateFieldGet(this, _InputState_token, "f"));
                    if (typeof mtoken == 'string') {
                        return mtoken.charCodeAt(0);
                    }
                    return undefined;
                }
                /**
                 * Temporary function until all token texts are recognized and codified.
                 */
                munge(token) {
                    const token_code = token.code;
                    if (typeof token_code === 'object' && typeof token_code.code === 'number') {
                        return token_code.code;
                    }
                    else {
                        return token.txt;
                    }
                }
                get parse_time_simplifications() {
                    return scanConfig.parse_time_simplifications;
                }
            }
            _InputState_token = new WeakMap();

            /**
             * Constructs (divide 1 expr) without any further evaluation.
             */
            function one_divided_by(expr) {
                if (is_rat$1(expr)) {
                    return expr.inv();
                }
                else if (is_flt$1(expr)) {
                    return expr.inv();
                }
                else {
                    return items_to_cons$1(MATH_POW$2.clone(expr.pos, expr.end), expr, negOne);
                }
            }

            function scanner_negate(expr) {
                if (is_rat$1(expr)) {
                    return expr.neg();
                }
                else if (is_flt$1(expr)) {
                    return expr.neg();
                }
                else {
                    // The ordering of -1 and expr is not important, but this order will likely reduce downstream processing.
                    return items_to_cons$1(MATH_MUL$3.clone(expr.pos, expr.end), negOne, expr);
                }
            }

            /**
             * Scans the input string, s, leaving the expression on the stack.
             * Returns zero when there is nothing left to scan.
             * @param sourceText The input string.
             * @returns The number of characters scanned.
             */
            function scan(sourceText, options) {
                // console.lg(`scan(sourceText = ${JSON.stringify(sourceText)})`);
                const state = new InputState(sourceText);
                state.lastFoundSymbol = null;
                state.symbolsRightOfAssignment = [];
                state.symbolsLeftOfAssignment = [];
                state.isSymbolLeftOfAssignment = true;
                state.scanningParameters = [];
                state.functionInvokationsScanningStack = [''];
                state.assignmentFound = false;
                state.useCaretForExponentiation = options.useCaretForExponentiation;
                state.explicitAssocAdd = options.explicitAssocAdd;
                state.explicitAssocMul = options.explicitAssocMul;
                state.advance();
                if (state.code === T_END) {
                    return [0, nil];
                }
                const expr = scan_stmt(state);
                if (!state.assignmentFound) {
                    defs.symbolsInExpressionsWithoutAssignments = defs.symbolsInExpressionsWithoutAssignments.concat(state.symbolsLeftOfAssignment);
                }
                return [state.scanned, expr];
            }
            function scan_meta(sourceText) {
                const state = new InputState(sourceText);
                state.meta_mode = true;
                state.advance();
                if (state.code === T_END) {
                    return nil;
                }
                return scan_stmt(state);
            }
            /**
             * ':='
             */
            function is_quote_assign(code) {
                switch (code) {
                    case T_COLON_EQ: {
                        return true;
                    }
                    default: {
                        return false;
                    }
                }
            }
            /**
             * '='
             */
            function is_assign(code) {
                switch (code) {
                    case T_EQ: {
                        return true;
                    }
                    default: {
                        return false;
                    }
                }
            }
            /**
             * ':=' | '='
             */
            function is_stmt(code) {
                // console.lg("is_stmt", code);
                return is_quote_assign(code) || is_assign(code);
            }
            function scan_stmt(state) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`scan_stmt => ${retval} @ ${description}`);
                    return retval;
                };
                let result = scan_relational_expr(state);
                if (is_stmt(state.code)) {
                    const symbolLeft = state.lastFoundSymbol;
                    state.assignmentFound = true;
                    state.isSymbolLeftOfAssignment = false;
                    // Keep the scanning information for the operator so that we can add it to the tree.
                    const { pos, end } = state.tokenToSym();
                    const was_quote_assign = is_quote_assign(state.code);
                    state.advance();
                    let rhs = scan_relational_expr(state);
                    // if it's a := then add a quote
                    if (was_quote_assign) {
                        rhs = items_to_cons$1(QUOTE.clone(pos, end), rhs);
                    }
                    result = items_to_cons$1(ASSIGN.clone(pos, end), result, rhs);
                    state.isSymbolLeftOfAssignment = true;
                    if (defs.codeGen) {
                        // in case of re-assignment, the symbol on the
                        // left will also be in the set of the symbols
                        // on the right. In that case just remove it from
                        // the symbols on the right.
                        if (symbolLeft) {
                            const i = state.symbolsRightOfAssignment.indexOf(symbolLeft);
                            if (i !== -1) {
                                state.symbolsRightOfAssignment.splice(i, 1);
                                defs.symbolsHavingReassignments.push(symbolLeft);
                            }
                        }
                        // print out the immediate dependencies
                        // eslint-disable-next-line no-console
                        // console.lg(`locally, ${symbolLeftOfAssignment} depends on: `);
                        // for (const i of Array.from(symbolsRightOfAssignment)) {
                        // eslint-disable-next-line no-console
                        // console.lg(`  ${i}`);
                        // }
                        // ok add the local dependencies to the existing
                        // dependencies of this left-value symbol
                        // create the exiting dependencies list if it doesn't exist
                        if (symbolLeft) {
                            if (defs.symbolsDependencies[symbolLeft] == null) {
                                defs.symbolsDependencies[symbolLeft] = [];
                            }
                            const existingDependencies = defs.symbolsDependencies[symbolLeft];
                            // copy over the new dependencies to the existing
                            // dependencies avoiding repetitions
                            for (const i of Array.from(state.symbolsRightOfAssignment)) {
                                if (existingDependencies.indexOf(i) === -1) {
                                    existingDependencies.push(i);
                                }
                            }
                        }
                        state.symbolsRightOfAssignment = [];
                    }
                }
                return hook(result);
            }
            /**
             * '==' | '!=' | '<=' | '>=' | '<' | '>'
             */
            function is_relational(code) {
                switch (code) {
                    case T_EQ_EQ:
                    case T_NTEQ:
                    case T_LTEQ:
                    case T_GTEQ:
                    case T_LT:
                    case T_GT: {
                        return true;
                    }
                    default: {
                        return false;
                    }
                }
            }
            /**
             * relational ::= add [REL add]?
             */
            function scan_relational_expr(state) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`scan_relational => ${retval} @ ${description}`);
                    return retval;
                };
                const result = scan_additive_expr(state);
                if (is_relational(state.code)) {
                    const opr = state.tokenToSym();
                    state.advance();
                    const rhs = scan_additive_expr(state);
                    return hook(items_to_cons$1(opr, result, rhs));
                }
                return hook(result);
            }
            /**
             * !newLine && ('+' || '-')
             */
            function is_additive(code, newLine) {
                // console.lg(`is_additive_expression(state = ${JSON.stringify(micro(state))})`);
                if (!newLine) {
                    switch (code) {
                        case T_PLUS:
                        case T_MINUS: {
                            return true;
                        }
                        default: {
                            return false;
                        }
                    }
                }
                else {
                    return false;
                }
            }
            function scan_additive_expr(state) {
                if (state.explicitAssocAdd) {
                    return scan_additive_expr_explicit(state);
                }
                else {
                    return scan_additive_expr_implicit(state);
                }
            }
            /**
             *
             */
            function scan_additive_expr_implicit(state) {
                // TODO: We could cache the symbol.
                const terms = [native_sym(Native.add)];
                switch (state.code) {
                    case T_PLUS:
                        state.advance();
                        terms.push(scan_multiplicative_expr(state));
                        break;
                    case T_MINUS:
                        state.advance();
                        terms.push(negate(scan_multiplicative_expr(state)));
                        break;
                    default:
                        terms.push(scan_multiplicative_expr(state));
                }
                while (state.newLine === false && (state.code === T_PLUS || state.code === T_MINUS)) {
                    if (state.code === T_PLUS) {
                        state.advance();
                        terms.push(scan_multiplicative_expr(state));
                    }
                    else {
                        state.advance();
                        terms.push(negate(scan_multiplicative_expr(state)));
                    }
                }
                if (terms.length === 2) {
                    return terms[1];
                }
                return items_to_cons$1(...terms);
            }
            function negate(expr) {
                if (is_num(expr)) {
                    return expr.neg();
                }
                else {
                    return items_to_cons$1(MATH_MUL$3, expr, negOne);
                }
            }
            function scan_additive_expr_explicit(state) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`scan_additive => ${retval} @ ${description}`);
                    return retval;
                };
                let result = scan_multiplicative_expr(state);
                while (is_additive(state.code, state.newLine)) {
                    switch (state.code) {
                        case T_PLUS: {
                            const opr = clone_symbol_using_info(native_sym(Native.add), state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scan_multiplicative_expr(state));
                            break;
                        }
                        default: {
                            // TODO: Remove this negate code and handle it in the engine.
                            // Make sure to also add test for a-b-c = (a-b)-c
                            assert_token_code(state.code, T_MINUS);
                            const opr = clone_symbol_using_info(native_sym(Native.add), state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scanner_negate(scan_multiplicative_expr(state)));
                            break;
                        }
                    }
                }
                return hook(result);
            }
            /**
             * '*' | '/' | '(' | 'Sym' | 'Function' | 'Int' | 'Flt' | 'Str'
             */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function is_multiplicative(code, newLine) {
                switch (code) {
                    case AsteriskToken:
                    case T_FWDSLASH: {
                        return true;
                    }
                    // TOOD: Not sure if this belongs here anymore.
                    // Probably used for juxtaposition as multiplication (implicit multiplication).
                    // case T_LPAR:
                    // case T_SYM:
                    // case T_FUNCTION:
                    // case T_INT:
                    // case T_FLT:
                    /*
                    case T_STR: {
                        if (newLine) {
                            return false;
                            // implicit multiplication can't cross line
                            // throw new Error("end <<<< pos");
                            // state.end = state.pos; // better error display
                            // return false;
                        }
                        else {
                            return true;
                        }
                    }
                    */
                }
                return false;
            }
            function scan_multiplicative_expr(state) {
                if (state.explicitAssocMul) {
                    return scan_multiplicative_expr_explicit(state);
                }
                else {
                    return scan_multiplicative_expr_implicit(state);
                }
            }
            /**
             *
             */
            function scan_multiplicative_expr_implicit(state) {
                const results = [scan_outer_expr(state)];
                /*
                if (parse_time_simplifications) {
                    simplify_1_in_products(results);
                }
                */
                while (is_multiplicative(state.code, state.newLine)) {
                    if (state.code === AsteriskToken) {
                        state.advance();
                        results.push(scan_outer_expr(state));
                    }
                    else if (state.code === T_FWDSLASH) {
                        // in case of 1/... then
                        // we scanned the 1, we get rid
                        // of it because otherwise it becomes
                        // an extra factor that wasn't there and
                        // things like
                        // 1/(2*a) become 1*(1/(2*a))
                        simplify_1_in_products(results);
                        state.advance();
                        results.push(one_divided_by(scan_outer_expr(state)));
                    }
                    /*
                    else if (tokenCharCode() === dotprod_unicode) {
                        state.advance();
                        results.push(items_to_cons(symbol(INNER), results.pop(), scan_factor()));
                    }
                    */
                    else {
                        results.push(scan_outer_expr(state));
                    }
                    /*
                    if (parse_time_simplifications) {
                        multiply_consecutive_constants(results);
                        simplify_1_in_products(results);
                    }
                    */
                }
                if (results.length === 0) {
                    return one;
                }
                else if (results.length == 1) {
                    return results[0];
                }
                return items_to_cons$1(MATH_MUL$3, ...results);
            }
            function simplify_1_in_products(factors) {
                if (factors.length > 0) {
                    const factor = factors[factors.length - 1];
                    if (is_rat(factor) && factor.isOne()) {
                        factors.pop();
                    }
                }
            }
            /**
             * Corresponds to scan_term
             */
            function scan_multiplicative_expr_explicit(state) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`scan_multiplicative => ${retval} @ ${description}`);
                    return retval;
                };
                let result = scan_outer_expr(state);
                while (is_multiplicative(state.code, state.newLine)) {
                    switch (state.code) {
                        case AsteriskToken: {
                            const opr = clone_symbol_using_info(MATH_MUL$3, state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scan_outer_expr(state));
                            break;
                        }
                        case T_FWDSLASH: {
                            // TODO: For now we leave this canonicalization in the scanner.
                            // But I think it belongs in the transformations.
                            // console.lg("result", JSON.stringify(result));
                            if (is_rat(result) && result.isOne()) {
                                state.advance();
                                result = one_divided_by(scan_outer_expr(state));
                            }
                            else {
                                const mulOp = clone_symbol_using_info(MATH_MUL$3, state.tokenToSym());
                                state.advance();
                                result = items_to_cons$1(mulOp, result, one_divided_by(scan_outer_expr(state)));
                            }
                            break;
                        }
                        default: {
                            throw new Error(`${JSON.stringify(state)}`);
                            // result = makeList(opr, result, scan_outer(state));
                            // factors.push(scan_outer(state));
                        }
                    }
                }
                return hook(result);
            }
            /**
             * ! newline && '^'
             */
            function is_outer$2(code, newline_flag, useCaretForExponentiation) {
                if (!newline_flag) {
                    if (code === CaretToken) {
                        if (useCaretForExponentiation) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                }
                return false;
            }
            function scan_outer_expr(state) {
                let result = scan_inner_expr(state);
                while (is_outer$2(state.code, state.newLine, state.useCaretForExponentiation)) {
                    const opr = clone_symbol_using_info(MATH_OUTER, state.tokenToSym());
                    state.advance();
                    result = items_to_cons$1(opr, result, scan_inner_expr(state));
                }
                return result;
            }
            /**
             * ! newline && ('<<' || '>>' || Vbar || 'middle-dot')
             */
            function is_inner_or_contraction(code, newline_flag) {
                return !newline_flag && (code === T_LTLT || code === T_GTGT || code === T_VBAR || code === T_MIDDLE_DOT);
            }
            function scan_inner_expr(state) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`results (INNER) => ${retval} @ ${description}`);
                    return retval;
                };
                let result = scan_power_expr(state);
                while (is_inner_or_contraction(state.code, state.newLine)) {
                    switch (state.code) {
                        case T_LTLT: {
                            const opr = clone_symbol_using_info(MATH_LCO, state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scan_power_expr(state));
                            break;
                        }
                        case T_GTGT: {
                            const opr = clone_symbol_using_info(MATH_RCO, state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scan_power_expr(state));
                            break;
                        }
                        case T_VBAR: {
                            const opr = clone_symbol_using_info(MATH_INNER, state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scan_power_expr(state));
                            break;
                        }
                        default: {
                            state.expect(T_MIDDLE_DOT);
                            const opr = clone_symbol_using_info(MATH_INNER, state.tokenToSym());
                            state.advance();
                            result = items_to_cons$1(opr, result, scan_power_expr(state));
                            break;
                        }
                    }
                }
                return hook(result);
            }
            function is_power$1(code, newLine, useCaretForExponentiation) {
                // console.lg(`is_power ${JSON.stringify(code)} useCaret: ${useCaretForExponentiation}`);
                if (newLine) {
                    return false;
                }
                if (useCaretForExponentiation) {
                    return code === CaretToken;
                }
                else {
                    return code === T_ASTRX_ASTRX;
                }
            }
            function scan_power_expr(state) {
                // Using a stack because exponentiation is right-associative.
                // We'll push the operands as well in order to retain scanning location information.
                const stack = [];
                stack.push(scan_unary_expr(state));
                while (is_power$1(state.code, state.newLine, state.useCaretForExponentiation)) {
                    stack.push(state.tokenToSym());
                    state.advance();
                    stack.push(scan_unary_expr(state));
                }
                while (stack.length > 0) {
                    const rhs = stack.pop();
                    if (stack.length > 0) {
                        const opr = assert_sym(stack.pop());
                        const lhs = stack.pop();
                        stack.push(items_to_cons$1(clone_symbol_using_info(MATH_POW$2, opr), lhs, rhs));
                    }
                    else {
                        return rhs;
                    }
                }
                throw new Error();
            }
            function scan_unary_expr(state) {
                const code = state.code;
                switch (code) {
                    case T_PLUS: {
                        state.advance();
                        return scan_unary_expr(state);
                    }
                    case T_MINUS: {
                        state.advance();
                        return scanner_negate(scan_unary_expr(state));
                    }
                    default: {
                        return scan_grouping_expr(state);
                    }
                }
            }
            function scan_grouping_expr(state) {
                const code = state.code;
                if (code === T_LPAR) {
                    return scan_grouping(state);
                }
                else {
                    return scan_factor(state);
                }
            }
            /**
             *
             */
            function scan_first_factor(state) {
                const code = state.code;
                // TODO: Convert this to a switch.
                if (code === T_LPAR) {
                    return [false, scan_grouping(state)];
                }
                else if (code === T_SYM) {
                    // TODO: This code should probablt be merged into scan_symbol.
                    if (state.text === 'true') {
                        const value = new Boo(true, state.pos, state.end);
                        state.advance();
                        return [false, value];
                    }
                    else if (state.text === 'false') {
                        const value = new Boo(false, state.pos, state.end);
                        state.advance();
                        return [false, value];
                    }
                    else {
                        return [false, scan_symbol(state)];
                    }
                }
                else if (code === T_FUNCTION) {
                    return [false, scan_function_call_with_function_name(state)];
                }
                else if (code === T_LSQB) {
                    return [false, scan_tensor(state)];
                }
                else if (code === T_INT) {
                    return [true, scan_int(state)];
                }
                else if (code === T_FLT) {
                    return [true, scan_flt(state)];
                }
                else if (code === T_STR) {
                    return [false, scan_string(state)];
                }
                else {
                    // We were probably expecting something.
                    // console.lg(`code=${JSON.stringify(code)}`);
                    state.scan_error(`Unexpected token ${JSON.stringify(code.text)}`);
                }
            }
            function scan_flt(state) {
                const flt = state.tokenToFlt();
                state.advance();
                return flt;
            }
            function scan_int(state) {
                const int = state.tokenToInt();
                state.advance();
                return int;
            }
            function scan_string(state) {
                const str = state.tokenToStr();
                state.advance();
                return str;
            }
            function scan_factor(state) {
                const ff = scan_first_factor(state);
                const ff_is_num = ff[0];
                let result = ff[1];
                // after the main initial part of the factor that
                // we just scanned above,
                // we can get an arbitrary number of appendages
                // of the form ...[...](...)...
                // If the main part is not a number, then these are all, respectively,
                //  - index references (as opposed to tensor definition) and
                //  - function calls without an explicit function name
                //    (instead of subexpressions or parameters of function
                //    definitions or function calls with an explicit function
                //    name), respectively
                while (state.code === T_LSQB || (state.code === T_LPAR && !state.newLine && !ff_is_num)) {
                    if (state.code === T_LSQB) {
                        result = scan_index(result, state);
                    }
                    else if (state.code === T_LPAR) {
                        // console.lg "( as function call without function name "
                        result = scan_function_call_without_function_name(result, state);
                    }
                }
                while (state.text === '!') {
                    state.advance();
                    result = items_to_cons$1(FACTORIAL, result);
                }
                // in theory we could already count the
                // number of transposes and simplify them
                // away, but it's not that clean to have
                // multiple places where that happens, and
                // the parser is not the place.
                while (state.tokenCharCode() === TRANSPOSE_CHAR_CODE) {
                    state.advance();
                    result = items_to_cons$1(TRANSPOSE, result);
                }
                return result;
            }
            function scan_index(indexable, state) {
                state.expect(T_LSQB);
                state.advance();
                const items = [MATH_COMPONENT, indexable];
                if (state.code !== T_RSQB) {
                    items.push(scan_additive_expr(state));
                    while (state.code === T_COMMA) {
                        state.advance();
                        items.push(scan_additive_expr(state));
                    }
                }
                state.expect(T_RSQB);
                state.advance();
                return items_to_cons$1(...items);
            }
            function addSymbolRightOfAssignment(state, theSymbol) {
                if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 &&
                    state.symbolsRightOfAssignment.indexOf(theSymbol) === -1 &&
                    state.symbolsRightOfAssignment.indexOf("'" + theSymbol) === -1 &&
                    !state.skipRootVariableToBeSolved) {
                    // console.lg(`... adding symbol: ${theSymbol} to the set of the symbols right of assignment`);
                    let prefixVar = '';
                    for (let i = 1; i < state.functionInvokationsScanningStack.length; i++) {
                        if (state.functionInvokationsScanningStack[i] !== '') {
                            prefixVar += state.functionInvokationsScanningStack[i] + '_' + i + '_';
                        }
                    }
                    theSymbol = prefixVar + theSymbol;
                    state.symbolsRightOfAssignment.push(theSymbol);
                }
            }
            function addSymbolLeftOfAssignment(state, theSymbol) {
                if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 &&
                    state.symbolsLeftOfAssignment.indexOf(theSymbol) === -1 &&
                    state.symbolsLeftOfAssignment.indexOf("'" + theSymbol) === -1 &&
                    !state.skipRootVariableToBeSolved) {
                    // console.lg(`... adding symbol: ${theSymbol} to the set of the symbols left of assignment`);
                    let prefixVar = '';
                    for (let i = 1; i < state.functionInvokationsScanningStack.length; i++) {
                        if (state.functionInvokationsScanningStack[i] !== '') {
                            prefixVar += state.functionInvokationsScanningStack[i] + '_' + i + '_';
                        }
                    }
                    theSymbol = prefixVar + theSymbol;
                    state.symbolsLeftOfAssignment.push(theSymbol);
                }
            }
            function scan_symbol(state) {
                // console.lg("scan_symbol()");
                state.expect(T_SYM);
                const sym = state.tokenToSym();
                // The text should be the same as  
                // const text = sym.text;
                if (state.scanningParameters.length === 0) {
                    // TODO: Why don't we just store the actual symbol here?
                    state.lastFoundSymbol = state.text;
                    if (state.isSymbolLeftOfAssignment) {
                        addSymbolLeftOfAssignment(state, state.text);
                    }
                }
                else {
                    if (state.isSymbolLeftOfAssignment) {
                        addSymbolRightOfAssignment(state, "'" + state.text);
                    }
                }
                // if we were looking at the right part of an assignment while we
                // found the symbol, then add it to the "symbolsRightOfAssignment"
                // set (we check for duplications)
                if (!state.isSymbolLeftOfAssignment) {
                    addSymbolRightOfAssignment(state, state.text);
                }
                state.advance();
                return sym;
            }
            function is_special_function(name) {
                switch (name) {
                    case 'defint':
                    case 'for':
                    case 'product':
                    case 'roots':
                    case 'sum': {
                        return true;
                    }
                    default: {
                        return false;
                    }
                }
            }
            function scan_function_call_with_function_name(state) {
                state.expect(T_FUNCTION);
                let n = 1; // the parameter number as we scan parameters
                const p = state.tokenToSym();
                const fcall = [p];
                const functionName = state.text;
                if (is_special_function(functionName)) {
                    state.functionInvokationsScanningStack.push(state.text);
                }
                state.lastFoundSymbol = state.text;
                if (!state.isSymbolLeftOfAssignment) {
                    addSymbolRightOfAssignment(state, state.text);
                }
                state.advance(); // open parens
                state.advance(); // 1st parameter
                state.scanningParameters.push(true);
                try {
                    if (state.code !== T_RPAR) {
                        fcall.push(scan_stmt(state));
                        n++;
                        while (state.code === T_COMMA) {
                            state.advance();
                            // roots' disappearing variable, if there, is the second one
                            if (n === 2 && state.functionInvokationsScanningStack[state.functionInvokationsScanningStack.length - 1].indexOf('roots') !== -1) {
                                state.symbolsRightOfAssignment = state.symbolsRightOfAssignment.filter((x) => !new RegExp('roots_' +
                                    (state.functionInvokationsScanningStack.length - 1) +
                                    '_' +
                                    state.text).test(x));
                                state.skipRootVariableToBeSolved = true;
                            }
                            // sums' disappearing variable, is alsways the second one
                            if (n === 2 && state.functionInvokationsScanningStack[state.functionInvokationsScanningStack.length - 1].indexOf('sum') !== -1) {
                                state.symbolsRightOfAssignment = state.symbolsRightOfAssignment.filter((x) => !new RegExp('sum_' +
                                    (state.functionInvokationsScanningStack.length - 1) +
                                    '_' +
                                    state.text).test(x));
                                state.skipRootVariableToBeSolved = true;
                            }
                            // product's disappearing variable, is alsways the second one
                            if (n === 2 && state.functionInvokationsScanningStack[state.functionInvokationsScanningStack.length - 1].indexOf('product') !== -1) {
                                state.symbolsRightOfAssignment = state.symbolsRightOfAssignment.filter((x) => !new RegExp('product_' +
                                    (state.functionInvokationsScanningStack.length - 1) +
                                    '_' +
                                    state.text).test(x));
                                state.skipRootVariableToBeSolved = true;
                            }
                            // for's disappearing variable, is alsways the second one
                            if (n === 2 && state.functionInvokationsScanningStack[state.functionInvokationsScanningStack.length - 1].indexOf('for') !== -1) {
                                state.symbolsRightOfAssignment = state.symbolsRightOfAssignment.filter((x) => !new RegExp('for_' +
                                    (state.functionInvokationsScanningStack.length - 1) +
                                    '_' +
                                    state.text).test(x));
                                state.skipRootVariableToBeSolved = true;
                            }
                            // defint's disappearing variables can be in positions 2,5,8...
                            if (state.functionInvokationsScanningStack[state.functionInvokationsScanningStack.length - 1].indexOf('defint') !== -1 && (n === 2 || (n > 2 && (n - 2) % 3 === 0))) {
                                state.symbolsRightOfAssignment = state.symbolsRightOfAssignment.filter((x) => !new RegExp('defint_' +
                                    (state.functionInvokationsScanningStack.length - 1) +
                                    '_' +
                                    state.text).test(x));
                                state.skipRootVariableToBeSolved = true;
                            }
                            fcall.push(scan_stmt(state));
                            state.skipRootVariableToBeSolved = false;
                            n++;
                        }
                        // todo refactor this, there are two copies
                        // this catches the case where the "roots" variable is not specified
                        if (n === 2 &&
                            state.functionInvokationsScanningStack[state.functionInvokationsScanningStack.length - 1].indexOf('roots') !== -1) {
                            state.symbolsRightOfAssignment = state.symbolsRightOfAssignment.filter((x) => !new RegExp('roots_' + (state.functionInvokationsScanningStack.length - 1) + '_' + 'x').test(x));
                        }
                    }
                }
                finally {
                    state.scanningParameters.pop();
                }
                for (let i = 0; i <= state.symbolsRightOfAssignment.length; i++) {
                    if (state.symbolsRightOfAssignment[i] != null) {
                        if (functionName === 'roots') {
                            state.symbolsRightOfAssignment[i] = state.symbolsRightOfAssignment[i].replace(new RegExp('roots_' + (state.functionInvokationsScanningStack.length - 1) + '_'), '');
                        }
                        if (functionName === 'defint') {
                            state.symbolsRightOfAssignment[i] = state.symbolsRightOfAssignment[i].replace(new RegExp('defint_' + (state.functionInvokationsScanningStack.length - 1) + '_'), '');
                        }
                        if (functionName === 'sum') {
                            state.symbolsRightOfAssignment[i] = state.symbolsRightOfAssignment[i].replace(new RegExp('sum_' + (state.functionInvokationsScanningStack.length - 1) + '_'), '');
                        }
                        if (functionName === 'product') {
                            state.symbolsRightOfAssignment[i] = state.symbolsRightOfAssignment[i].replace(new RegExp('product_' + (state.functionInvokationsScanningStack.length - 1) + '_'), '');
                        }
                        if (functionName === 'for') {
                            state.symbolsRightOfAssignment[i] = state.symbolsRightOfAssignment[i].replace(new RegExp('for_' + (state.functionInvokationsScanningStack.length - 1) + '_'), '');
                        }
                    }
                }
                state.expect(T_RPAR);
                state.advance();
                if (is_special_function(functionName)) {
                    state.functionInvokationsScanningStack.pop();
                }
                if (PATTERN.equals(create_sym(functionName))) {
                    defs.patternHasBeenFound = true;
                }
                // console.lg('-- scan_function_call_with_function_name end');
                return items_to_cons$1(...fcall);
            }
            function scan_function_call_without_function_name(lhs, state) {
                state.expect(T_LPAR);
                // const func = makeList(EVAL, lhs); // original code added an EVAL. Don't know why.
                const func = lhs;
                const fcall = [func];
                assert_token_code(state.code, T_LPAR);
                state.advance(); // left paren
                state.scanningParameters.push(true);
                try {
                    if (state.code !== T_RPAR) {
                        fcall.push(scan_stmt(state));
                        while (state.code === T_COMMA) {
                            state.advance();
                            fcall.push(scan_stmt(state));
                        }
                    }
                }
                finally {
                    state.scanningParameters.pop();
                }
                state.expect(T_RPAR);
                state.advance();
                return items_to_cons$1(...fcall);
            }
            /**
             * An expression that is enclosed in parentheses.
             */
            function scan_grouping(state) {
                state.expect(T_LPAR);
                state.advance();
                const result = scan_stmt(state);
                state.expect(T_RPAR);
                state.advance();
                return result;
            }
            function scan_tensor(state) {
                state.expect(T_LSQB);
                state.advance();
                const element = scan_stmt(state);
                const elements = [element];
                while (state.code === T_COMMA) {
                    state.advance();
                    elements.push(scan_stmt(state));
                }
                const M = create_tensor(elements);
                state.expect(T_RSQB);
                state.advance();
                return M;
            }

            function config_from_options$1(options) {
                if (options) {
                    return {
                        useCaretForExponentiation: !!options.useCaretForExponentiation,
                        explicitAssocAdd: !!options.explicitAssocAdd,
                        explicitAssocMul: !!options.explicitAssocMul
                    };
                }
                else {
                    return {
                        useCaretForExponentiation: false,
                        explicitAssocAdd: false,
                        explicitAssocMul: false
                    };
                }
            }
            /**
             * Each line of a multiline source text creates a tree in the array of trees.
             * @param fileName The name of the file containing the sourceText.
             * @param sourceText The source text. May contain embedded newline characters.
             * @param options Determine how the parsing behaves.
             */
            function eigenmath_parse(fileName, sourceText, options) {
                // console.lg(`scan(sourceText = ${JSON.stringify(sourceText)})`);
                const config = config_from_options$1(options);
                const normalizedScript = normalize_unicode_dots(sourceText);
                let scanned = 0;
                let tree;
                let index_of_part_remaining_to_be_parsed = 0;
                const trees = [];
                const errors = [];
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    // while we can keep scanning commands out of the
                    // passed input AND we can execute them...
                    try {
                        defs.errorMessage = '';
                        // TODO: Will the scan ever not return zero?
                        [scanned, tree] = scan(normalizedScript.substring(index_of_part_remaining_to_be_parsed), {
                            useCaretForExponentiation: config.useCaretForExponentiation,
                            explicitAssocAdd: config.explicitAssocAdd,
                            explicitAssocMul: config.explicitAssocMul
                        });
                        if (scanned > 0) {
                            trees.push(tree);
                        }
                    }
                    catch (error) {
                        if (error instanceof Error) {
                            // We should be returning user errors rather than throwing them.
                            // Then the only errors being thrown should be SystemError, which we don't want to catch.
                            // eslint-disable-next-line no-console
                            errors.push(error);
                        }
                        else {
                            errors.push(new Error(`${error}`));
                        }
                        hard_reset();
                        break;
                    }
                    if (scanned === 0) {
                        break;
                    }
                    if (scanned === sourceText.length) {
                        break;
                    }
                    index_of_part_remaining_to_be_parsed += scanned;
                }
                return { trees, errors };
            }

            /**
             * exp(x) = (expt e x)
             */
            const MATH_EXP = native_sym(Native.exp);

            // import * as _ from "../deps/underscore-1.10.2-esm.js"
            const Chars = {};
            class Char {
                constructor(value) {
                    this.value = value;
                }
                static get(c) {
                    //if (typeof (c) != "string") {
                    //    throw new Bug("Char.get: " + inspect(c) + " is not a string");
                    // }
                    if (Chars[c] === undefined)
                        return new Str$1(c);
                    else
                        return Chars[c];
                }
            }
            //
            // Char
            //
            /*
            const Chars = {};

            const Char = Class.create({
              initialize: function(c){
                Chars[ this.value = c ] = this;
              },
              to_write: function(){
                switch(this.value){
                  case '\n': return "#\\newline";
                  case ' ':  return "#\\space";
                  case '\t': return "#\\tab";
                  default:   return "#\\"+this.value;
                }
              },
              inspect: function(){
                return this.to_write();
              }
            });

            Char.get = function(c) {
              if(typeof(c) != "string") {
                throw new Bug("Char.get: " + inspect(c) + " is not a string");
              }
              if( Chars[c] === undefined )
                return new Char(c);
              else
                return Chars[c];
            };

            export default Char;
            */

            class CommentMarker {
                constructor() {
                    this.name = "CommentMarker";
                    this.meta = 0;
                }
                contains(needle) {
                    return needle instanceof CommentMarker;
                }
                equals(other) {
                    return other instanceof CommentMarker;
                }
                isCons() {
                    return false;
                }
                isNil() {
                    return false;
                }
                reset(meta) {
                    this.meta = meta;
                }
            }

            class EOS {
                constructor() {
                    this.name = "EOS";
                    this.meta = 0;
                }
                contains(needle) {
                    return needle instanceof EOS;
                }
                equals(other) {
                    return other instanceof EOS;
                }
                isCons() {
                    return false;
                }
                isNil() {
                    return false;
                }
                reset(meta) {
                    this.meta = meta;
                }
            }

            /**
             * The parser requires a mutable for of Cons.
             */
            class Pair {
                constructor(car, cdr) {
                    this.car = car;
                    this.cdr = cdr;
                    this.name = "Pair";
                    this.meta = 0;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                contains(needle) {
                    throw new Error("Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                equals(other) {
                    throw new Error("Method not implemented.");
                }
                isCons() {
                    throw new Error("Method not implemented.");
                }
                isNil() {
                    throw new Error("Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                reset(meta) {
                    throw new Error("Method not implemented.");
                }
                toString() {
                    return `Pair(${this.car} ${this.cdr})`;
                }
            }

            var _NumBuilder_num, _Parser_instances, _Parser_tokenIdx, _Parser_tokens, _Parser_consumeObject, _Parser_consumeList, _Parser_consumeAtom, _Parser_consumeVector, _Parser_consumeObjectsInSexpComment;
            const endOfString = new EOS();
            const sexpCommentMarker = new CommentMarker();
            class CharStreamOnString {
                constructor(chars) {
                    this.chars = chars;
                    this.pos = 0;
                }
                get curr() {
                    return this.chars[this.pos];
                }
                get next() {
                    return this.chars[this.pos + 1];
                }
                consumeChars(n) {
                    this.pos += n;
                }
                currEquals(ch) {
                    return this.curr === ch;
                }
            }
            class NumBuilder {
                constructor(chars) {
                    this.chars = chars;
                    _NumBuilder_num.set(this, void 0);
                }
                get num() {
                    if (__classPrivateFieldGet(this, _NumBuilder_num, "f")) {
                        return __classPrivateFieldGet(this, _NumBuilder_num, "f");
                    }
                    else {
                        throw new Error();
                    }
                }
                flt() {
                    __classPrivateFieldSet(this, _NumBuilder_num, new FltTokenParser().parse(this.chars, 0, 0), "f");
                }
                int() {
                    __classPrivateFieldSet(this, _NumBuilder_num, new IntTokenParser().parse(this.chars, 0, 0), "f");
                }
            }
            _NumBuilder_num = new WeakMap();
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function scheme_parse(fileName, sourceText, options) {
                const parser = new Parser$1(sourceText, options);
                const trees = [];
                let done = false;
                while (!done) {
                    const expr = parser.value();
                    if (expr === endOfString) {
                        done = true;
                    }
                    else {
                        trees.push(expr);
                    }
                }
                return { trees, errors: [] };
            }
            let Parser$1 = class Parser {
                constructor(sourceText, options) {
                    this.options = options;
                    _Parser_instances.add(this);
                    _Parser_tokenIdx.set(this, 0);
                    _Parser_tokens.set(this, []);
                    __classPrivateFieldSet(this, _Parser_tokens, tokenize(sourceText), "f");
                }
                value() {
                    return pairs_to_cons(__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this));
                }
            };
            _Parser_tokenIdx = new WeakMap(), _Parser_tokens = new WeakMap(), _Parser_instances = new WeakSet(), _Parser_consumeObject = function _Parser_consumeObject() {
                let r = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeAtom).call(this);
                if (r !== sexpCommentMarker) {
                    return r;
                }
                r = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this);
                if (r === endOfString)
                    throw new Error("Readable object not found after S expression comment.");
                r = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this);
                return r;
            }, _Parser_consumeList = function _Parser_consumeList(t) {
                var _a, _b;
                let list = nil;
                let prev = list;
                while (__classPrivateFieldGet(this, _Parser_tokenIdx, "f") < __classPrivateFieldGet(this, _Parser_tokens, "f").length) {
                    __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObjectsInSexpComment).call(this, "Input stream terminated unexpectedly (in list).");
                    if (__classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] === ')' || __classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] === ']' || __classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] === '}') {
                        __classPrivateFieldSet(this, _Parser_tokenIdx, (_a = __classPrivateFieldGet(this, _Parser_tokenIdx, "f"), _a++, _a), "f");
                        break;
                    }
                    if (__classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] === '.') {
                        __classPrivateFieldSet(this, _Parser_tokenIdx, (_b = __classPrivateFieldGet(this, _Parser_tokenIdx, "f"), _b++, _b), "f");
                        const o = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this);
                        if (o !== endOfString && list !== nil) {
                            prev.cdr = o;
                        }
                    }
                    else {
                        const cur = new Pair(__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this), nil);
                        if (list === nil) {
                            list = cur;
                        }
                        else {
                            prev.cdr = cur;
                        }
                        prev = cur;
                    }
                }
                return list;
            }, _Parser_consumeAtom = function _Parser_consumeAtom() {
                var _a, _b;
                if (__classPrivateFieldGet(this, _Parser_tokenIdx, "f") >= __classPrivateFieldGet(this, _Parser_tokens, "f").length) {
                    return endOfString;
                }
                const t = __classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldSet(this, _Parser_tokenIdx, (_b = __classPrivateFieldGet(this, _Parser_tokenIdx, "f"), _a = _b++, _b), "f"), _a];
                // if( t == ')' ) return null;
                if (t == '#;') {
                    return sexpCommentMarker;
                }
                const s = t == "'" ? 'quote' :
                    t == "`" ? 'quasiquote' :
                        t == "," ? 'unquote' :
                            t == ",@" ? 'unquote-splicing' : false;
                if (s || t == '(' || t == '#(' || t == '[' || t == '#[' || t == '{' || t == '#{') {
                    if (s) {
                        return new Pair(sym_from_lexeme(s, this.options), new Pair(__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this), nil));
                    }
                    else {
                        if (t == '(' || t == '[' || t == '{') {
                            return __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeList).call(this, t);
                        }
                        else {
                            return __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeVector).call(this, t);
                        }
                    }
                }
                else {
                    switch (t) {
                        case "+inf.0": return new Flt(Infinity);
                        case "-inf.0": return new Flt(-Infinity);
                        case "+nan.0": return new Flt(NaN);
                    }
                    if (/^#x[0-9a-z]+$/i.test(t)) { // #x... Hex
                        return create_int(new Number('0x' + t.substring(2, t.length)).valueOf());
                    }
                    else if (/^#d[0-9.]+$/i.test(t)) { // #d... Decimal
                        return create_flt(new Number(t.substring(2, t.length)).valueOf());
                    }
                    else {
                        const stream = new CharStreamOnString(t);
                        const builder = new NumBuilder(t);
                        if (consume_num(stream, builder)) {
                            return builder.num;
                        }
                    }
                    if (t == '#f' || t == '#F') {
                        return Boo.valueOf(false);
                    }
                    else if (t == '#t' || t == '#T') {
                        return Boo.valueOf(true);
                    }
                    else if (t.toLowerCase() == '#\\newline') {
                        return Char.get('\n');
                    }
                    else if (t.toLowerCase() == '#\\space') {
                        return Char.get(' ');
                    }
                    else if (t.toLowerCase() == '#\\tab') {
                        return Char.get('\t');
                    }
                    else if (/^#\\.$/.test(t)) {
                        return Char.get(t.charAt(2));
                    }
                    else if (/^#\\x[a-zA-Z0-9]+$/.test(t)) {
                        const scalar = parseInt(t.slice(3), 16);
                        // R6RS 11.11 (surrogate codepoints)
                        if (scalar >= 0xD800 && scalar <= 0xDFFF) {
                            throw new Error("Character in Unicode excluded range.");
                        }
                        // ECMA-262 4.3.16 -- Basically, strings are sequences of 16-bit
                        // unsigned integers, so anything greater than 0xFFFF won't fit.
                        // NOTE: This violates R6RS which requires the full Unicode range!
                        else if (scalar > 0xFFFF) {
                            throw new Error("Character literal out of range.");
                        }
                        else {
                            return Char.get(String.fromCharCode(scalar));
                        }
                    }
                    else if (/^"(\\(.|$)|[^"\\])*"?$/.test(t)) {
                        const s = t.replace(/(\r?\n|\\n)/g, "\n").replace(/^"|\\(.|$)|"$/g, function ($0, $1) {
                            return $1 ? $1 : '';
                        });
                        return new Str$1(s);
                    }
                    else {
                        return sym_from_lexeme(t, this.options);
                    }
                }
            }, _Parser_consumeVector = function _Parser_consumeVector(t) {
                var _a;
                const items = [];
                while (__classPrivateFieldGet(this, _Parser_tokenIdx, "f") < __classPrivateFieldGet(this, _Parser_tokens, "f").length) {
                    __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObjectsInSexpComment).call(this, "Input stream terminated unexpectedly(in vector)");
                    if (__classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] == ')' || __classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] == ']' || __classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] == '}') {
                        __classPrivateFieldSet(this, _Parser_tokenIdx, (_a = __classPrivateFieldGet(this, _Parser_tokenIdx, "f"), _a++, _a), "f");
                        break;
                    }
                    items[items.length] = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this);
                }
                return items_to_cons$1(...items);
            }, _Parser_consumeObjectsInSexpComment = function _Parser_consumeObjectsInSexpComment(err_msg) {
                var _a;
                while (__classPrivateFieldGet(this, _Parser_tokens, "f")[__classPrivateFieldGet(this, _Parser_tokenIdx, "f")] == '#;') {
                    __classPrivateFieldSet(this, _Parser_tokenIdx, (_a = __classPrivateFieldGet(this, _Parser_tokenIdx, "f"), _a++, _a), "f");
                    if ((__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_consumeObject).call(this) == endOfString) || (__classPrivateFieldGet(this, _Parser_tokenIdx, "f") >= __classPrivateFieldGet(this, _Parser_tokens, "f").length))
                        throw new Error(err_msg);
                }
            };
            function pairs_to_cons(expr) {
                if (expr instanceof Pair) {
                    const car = pairs_to_cons(expr.car);
                    const cdr = pairs_to_cons(expr.cdr);
                    return cons(car, cdr);
                }
                else {
                    return expr;
                }
            }
            function tokenize(txt) {
                const tokens = [];
                let oldTxt = null;
                let in_srfi_30_comment = 0;
                while (txt != "" && oldTxt != txt) {
                    oldTxt = txt;
                    txt = txt.replace(/^\s*(;[^\r\n]*(\r|\n|$)|#;|#\||#\\[^\w]|#?(\(|\[|{)|\)|\]|}|'|`|,@|,|\+inf\.0|-inf\.0|\+nan\.0|"(\\(.|$)|[^"\\])*("|$)|[^\s()[\]{}]+)/, function ($0, $1) {
                        const t = $1;
                        if (t == "#|") {
                            in_srfi_30_comment++;
                            return "";
                        }
                        else if (in_srfi_30_comment > 0) {
                            if (/(.*\|#)/.test(t)) {
                                in_srfi_30_comment--;
                                if (in_srfi_30_comment < 0) {
                                    throw new Error("Found an extra comment terminator: `|#'");
                                }
                                // Push back the rest substring to input stream.
                                return t.substring(RegExp.$1.length, t.length);
                            }
                            else {
                                return "";
                            }
                        }
                        else {
                            if (t.charAt(0) != ';') {
                                tokens[tokens.length] = t;
                            }
                            return "";
                        }
                    });
                }
                return tokens;
            }
            function sym_from_lexeme(lexeme, options) {
                // console.lg("sym_from_lexeme", JSON.stringify(lexeme), JSON.stringify(options, null, 2));
                if (options) {
                    if (options.lexicon) {
                        // console.lg(Object.keys(options.lexicon));
                        if (options.lexicon[lexeme]) {
                            return options.lexicon[lexeme];
                        }
                        else {
                            return create_sym(lexeme);
                        }
                    }
                    else {
                        return create_sym(lexeme);
                    }
                }
                else {
                    return create_sym(lexeme);
                }
            }

            /**
             * We're looking for something that is truthy, not just true.
             */
            function assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }
            function fail(message) {
                assert(false, message);
            }
            /**
             * Returns true if the specified value is a string.
             * @param {*} val Variable to test.
             * @return {boolean} Whether variable is a string.
             */
            function isString(val) {
                return typeof val === 'string';
            }
            /**
             * Returns true if the specified value is a number.
             * @param {*} val Variable to test.
             * @return {boolean} Whether variable is a number.
             */
            function isNumber(val) {
                return typeof val === 'number';
            }

            /**
             * Returns the number of children in the specified node.
             * Returns n.children.length
             */
            function NCH(n) {
                assert(n !== undefined);
                if (Array.isArray(n.children)) {
                    return n.children.length;
                }
                else {
                    return 0;
                }
            }
            function CHILD(n, i) {
                assert(i !== undefined && i >= 0);
                return CHILDREN(n)[i];
            }
            function FIND(n, type) {
                assert(type !== undefined);
                const children = CHILDREN(n);
                const N = children.length;
                for (let i = 0; i < N; i++) {
                    const child = children[i];
                    if (child.type === type) {
                        return i;
                    }
                }
                return -1;
            }
            function CHILDREN(n) {
                assert(n !== undefined);
                if (n.children) {
                    return n.children;
                }
                else {
                    throw new Error("node does not have any children");
                }
            }
            /**
             * Convenience function to return the index of the last element in an array.
             * @param xs The array.
             * @returns The length of the array minus 1.
             */
            function IDXLAST(xs) {
                return xs.length - 1;
            }

            /**
             * Symbolic constants for various Python Language tokens.
             */
            var Tokens;
            (function (Tokens) {
                Tokens[Tokens["T_ENDMARKER"] = 0] = "T_ENDMARKER";
                Tokens[Tokens["T_NAME"] = 1] = "T_NAME";
                Tokens[Tokens["T_NUMBER"] = 2] = "T_NUMBER";
                Tokens[Tokens["T_STRING"] = 3] = "T_STRING";
                Tokens[Tokens["T_NEWLINE"] = 4] = "T_NEWLINE";
                Tokens[Tokens["T_INDENT"] = 5] = "T_INDENT";
                Tokens[Tokens["T_DEDENT"] = 6] = "T_DEDENT";
                Tokens[Tokens["T_LPAR"] = 7] = "T_LPAR";
                Tokens[Tokens["T_RPAR"] = 8] = "T_RPAR";
                Tokens[Tokens["T_LSQB"] = 9] = "T_LSQB";
                Tokens[Tokens["T_RSQB"] = 10] = "T_RSQB";
                Tokens[Tokens["T_COLON"] = 11] = "T_COLON";
                Tokens[Tokens["T_COMMA"] = 12] = "T_COMMA";
                Tokens[Tokens["T_SEMI"] = 13] = "T_SEMI";
                Tokens[Tokens["T_PLUS"] = 14] = "T_PLUS";
                Tokens[Tokens["T_MINUS"] = 15] = "T_MINUS";
                Tokens[Tokens["T_STAR"] = 16] = "T_STAR";
                Tokens[Tokens["T_SLASH"] = 17] = "T_SLASH";
                Tokens[Tokens["T_VBAR"] = 18] = "T_VBAR";
                Tokens[Tokens["T_AMPER"] = 19] = "T_AMPER";
                Tokens[Tokens["T_LESS"] = 20] = "T_LESS";
                Tokens[Tokens["T_GREATER"] = 21] = "T_GREATER";
                Tokens[Tokens["T_EQUAL"] = 22] = "T_EQUAL";
                Tokens[Tokens["T_DOT"] = 23] = "T_DOT";
                Tokens[Tokens["T_PERCENT"] = 24] = "T_PERCENT";
                Tokens[Tokens["T_BACKQUOTE"] = 25] = "T_BACKQUOTE";
                Tokens[Tokens["T_LBRACE"] = 26] = "T_LBRACE";
                Tokens[Tokens["T_RBRACE"] = 27] = "T_RBRACE";
                Tokens[Tokens["T_EQEQUAL"] = 28] = "T_EQEQUAL";
                Tokens[Tokens["T_NOTEQUAL"] = 29] = "T_NOTEQUAL";
                Tokens[Tokens["T_LESSEQUAL"] = 30] = "T_LESSEQUAL";
                Tokens[Tokens["T_GREATEREQUAL"] = 31] = "T_GREATEREQUAL";
                Tokens[Tokens["T_TILDE"] = 32] = "T_TILDE";
                /**
                 * '^'
                 */
                Tokens[Tokens["T_CIRCUMFLEX"] = 33] = "T_CIRCUMFLEX";
                Tokens[Tokens["T_LEFTSHIFT"] = 34] = "T_LEFTSHIFT";
                Tokens[Tokens["T_RIGHTSHIFT"] = 35] = "T_RIGHTSHIFT";
                Tokens[Tokens["T_DOUBLESTAR"] = 36] = "T_DOUBLESTAR";
                Tokens[Tokens["T_PLUSEQUAL"] = 37] = "T_PLUSEQUAL";
                Tokens[Tokens["T_MINEQUAL"] = 38] = "T_MINEQUAL";
                Tokens[Tokens["T_STAREQUAL"] = 39] = "T_STAREQUAL";
                Tokens[Tokens["T_SLASHEQUAL"] = 40] = "T_SLASHEQUAL";
                Tokens[Tokens["T_PERCENTEQUAL"] = 41] = "T_PERCENTEQUAL";
                Tokens[Tokens["T_AMPEREQUAL"] = 42] = "T_AMPEREQUAL";
                Tokens[Tokens["T_VBAREQUAL"] = 43] = "T_VBAREQUAL";
                Tokens[Tokens["T_CIRCUMFLEXEQUAL"] = 44] = "T_CIRCUMFLEXEQUAL";
                Tokens[Tokens["T_LEFTSHIFTEQUAL"] = 45] = "T_LEFTSHIFTEQUAL";
                Tokens[Tokens["T_RIGHTSHIFTEQUAL"] = 46] = "T_RIGHTSHIFTEQUAL";
                Tokens[Tokens["T_DOUBLESTAREQUAL"] = 47] = "T_DOUBLESTAREQUAL";
                Tokens[Tokens["T_DOUBLESLASH"] = 48] = "T_DOUBLESLASH";
                Tokens[Tokens["T_DOUBLESLASHEQUAL"] = 49] = "T_DOUBLESLASHEQUAL";
                Tokens[Tokens["T_AT"] = 50] = "T_AT";
                Tokens[Tokens["T_ATEQUAL"] = 51] = "T_ATEQUAL";
                Tokens[Tokens["T_OP"] = 52] = "T_OP";
                Tokens[Tokens["T_COMMENT"] = 53] = "T_COMMENT";
                Tokens[Tokens["T_NL"] = 54] = "T_NL";
                Tokens[Tokens["T_RARROW"] = 55] = "T_RARROW";
                Tokens[Tokens["T_AWAIT"] = 56] = "T_AWAIT";
                Tokens[Tokens["T_ASYNC"] = 57] = "T_ASYNC";
                Tokens[Tokens["T_ERRORTOKEN"] = 58] = "T_ERRORTOKEN";
                Tokens[Tokens["T_N_TOKENS"] = 59] = "T_N_TOKENS";
                Tokens[Tokens["T_NT_OFFSET"] = 256] = "T_NT_OFFSET";
            })(Tokens || (Tokens = {}));

            // DO NOT MODIFY. File automatically generated by pgen/parser/main.py
            /**
             * Mapping from operator textual symbols to token symbolic constants.
             */
            const OpMap = {
                "(": Tokens.T_LPAR,
                ")": Tokens.T_RPAR,
                "[": Tokens.T_LSQB,
                "]": Tokens.T_RSQB,
                ":": Tokens.T_COLON,
                ",": Tokens.T_COMMA,
                ";": Tokens.T_SEMI,
                "+": Tokens.T_PLUS,
                "-": Tokens.T_MINUS,
                "*": Tokens.T_STAR,
                "/": Tokens.T_SLASH,
                "|": Tokens.T_VBAR,
                "&": Tokens.T_AMPER,
                "<": Tokens.T_LESS,
                ">": Tokens.T_GREATER,
                "=": Tokens.T_EQUAL,
                ".": Tokens.T_DOT,
                "%": Tokens.T_PERCENT,
                "`": Tokens.T_BACKQUOTE,
                "{": Tokens.T_LBRACE,
                "}": Tokens.T_RBRACE,
                "@": Tokens.T_AT,
                "==": Tokens.T_EQEQUAL,
                "!=": Tokens.T_NOTEQUAL,
                "<>": Tokens.T_NOTEQUAL,
                "<=": Tokens.T_LESSEQUAL,
                ">=": Tokens.T_GREATEREQUAL,
                "~": Tokens.T_TILDE,
                "^": Tokens.T_CIRCUMFLEX,
                "<<": Tokens.T_LEFTSHIFT,
                ">>": Tokens.T_RIGHTSHIFT,
                "**": Tokens.T_DOUBLESTAR,
                "+=": Tokens.T_PLUSEQUAL,
                "-=": Tokens.T_MINEQUAL,
                "*=": Tokens.T_STAREQUAL,
                "/=": Tokens.T_SLASHEQUAL,
                "%=": Tokens.T_PERCENTEQUAL,
                "&=": Tokens.T_AMPEREQUAL,
                "|=": Tokens.T_VBAREQUAL,
                "^=": Tokens.T_CIRCUMFLEXEQUAL,
                "<<=": Tokens.T_LEFTSHIFTEQUAL,
                ">>=": Tokens.T_RIGHTSHIFTEQUAL,
                "**=": Tokens.T_DOUBLESTAREQUAL,
                "//": Tokens.T_DOUBLESLASH,
                "//=": Tokens.T_DOUBLESLASHEQUAL,
                "->": Tokens.T_RARROW
            };
            /**
             * An Arc is a pair, represented in an array, consisting a label and a to-state.
             */
            const ARC_SYMBOL_LABEL = 0;
            const ARC_TO_STATE = 1;
            /**
             *
             */
            const IDX_DFABT_DFA = 0;
            const IDX_DFABT_BEGIN_TOKENS = 1;
            /**
             *
             */
            const ParseTables = {
                sym: { AndExpr: 257,
                    ArithmeticExpr: 258,
                    AtomExpr: 259,
                    BitwiseAndExpr: 260,
                    BitwiseOrExpr: 261,
                    BitwiseXorExpr: 262,
                    ComparisonExpr: 263,
                    ExprList: 264,
                    ExprStmt: 265,
                    GeometricExpr: 266,
                    GlobalStmt: 267,
                    IfExpr: 268,
                    ImportList: 269,
                    ImportSpecifier: 270,
                    LambdaExpr: 271,
                    ModuleSpecifier: 272,
                    NonLocalStmt: 273,
                    NotExpr: 274,
                    OrExpr: 275,
                    PowerExpr: 276,
                    ShiftExpr: 277,
                    UnaryExpr: 278,
                    YieldExpr: 279,
                    annasign: 280,
                    arglist: 281,
                    argument: 282,
                    assert_stmt: 283,
                    augassign: 284,
                    break_stmt: 285,
                    classdef: 286,
                    comp_op: 287,
                    compound_stmt: 288,
                    continue_stmt: 289,
                    decorated: 290,
                    decorator: 291,
                    decorators: 292,
                    del_stmt: 293,
                    dictmaker: 294,
                    dotted_as_name: 295,
                    dotted_as_names: 296,
                    dotted_name: 297,
                    encoding_decl: 298,
                    eval_input: 299,
                    except_clause: 300,
                    exec_stmt: 301,
                    file_input: 302,
                    flow_stmt: 303,
                    for_stmt: 304,
                    fpdef: 305,
                    fplist: 306,
                    funcdef: 307,
                    gen_for: 308,
                    gen_if: 309,
                    gen_iter: 310,
                    if_stmt: 311,
                    import_from: 312,
                    import_name: 313,
                    import_stmt: 314,
                    list_for: 315,
                    list_if: 316,
                    list_iter: 317,
                    listmaker: 318,
                    old_LambdaExpr: 319,
                    old_test: 320,
                    parameters: 321,
                    pass_stmt: 322,
                    print_stmt: 323,
                    raise_stmt: 324,
                    return_stmt: 325,
                    simple_stmt: 326,
                    single_input: 256,
                    sliceop: 327,
                    small_stmt: 328,
                    stmt: 329,
                    subscript: 330,
                    subscriptlist: 331,
                    suite: 332,
                    testlist: 333,
                    testlist1: 334,
                    testlist_gexp: 335,
                    testlist_safe: 336,
                    trailer: 337,
                    try_stmt: 338,
                    varargslist: 339,
                    while_stmt: 340,
                    with_stmt: 341,
                    with_var: 342,
                    yield_stmt: 343 },
                number2symbol: { 256: 'single_input',
                    257: 'AndExpr',
                    258: 'ArithmeticExpr',
                    259: 'AtomExpr',
                    260: 'BitwiseAndExpr',
                    261: 'BitwiseOrExpr',
                    262: 'BitwiseXorExpr',
                    263: 'ComparisonExpr',
                    264: 'ExprList',
                    265: 'ExprStmt',
                    266: 'GeometricExpr',
                    267: 'GlobalStmt',
                    268: 'IfExpr',
                    269: 'ImportList',
                    270: 'ImportSpecifier',
                    271: 'LambdaExpr',
                    272: 'ModuleSpecifier',
                    273: 'NonLocalStmt',
                    274: 'NotExpr',
                    275: 'OrExpr',
                    276: 'PowerExpr',
                    277: 'ShiftExpr',
                    278: 'UnaryExpr',
                    279: 'YieldExpr',
                    280: 'annasign',
                    281: 'arglist',
                    282: 'argument',
                    283: 'assert_stmt',
                    284: 'augassign',
                    285: 'break_stmt',
                    286: 'classdef',
                    287: 'comp_op',
                    288: 'compound_stmt',
                    289: 'continue_stmt',
                    290: 'decorated',
                    291: 'decorator',
                    292: 'decorators',
                    293: 'del_stmt',
                    294: 'dictmaker',
                    295: 'dotted_as_name',
                    296: 'dotted_as_names',
                    297: 'dotted_name',
                    298: 'encoding_decl',
                    299: 'eval_input',
                    300: 'except_clause',
                    301: 'exec_stmt',
                    302: 'file_input',
                    303: 'flow_stmt',
                    304: 'for_stmt',
                    305: 'fpdef',
                    306: 'fplist',
                    307: 'funcdef',
                    308: 'gen_for',
                    309: 'gen_if',
                    310: 'gen_iter',
                    311: 'if_stmt',
                    312: 'import_from',
                    313: 'import_name',
                    314: 'import_stmt',
                    315: 'list_for',
                    316: 'list_if',
                    317: 'list_iter',
                    318: 'listmaker',
                    319: 'old_LambdaExpr',
                    320: 'old_test',
                    321: 'parameters',
                    322: 'pass_stmt',
                    323: 'print_stmt',
                    324: 'raise_stmt',
                    325: 'return_stmt',
                    326: 'simple_stmt',
                    327: 'sliceop',
                    328: 'small_stmt',
                    329: 'stmt',
                    330: 'subscript',
                    331: 'subscriptlist',
                    332: 'suite',
                    333: 'testlist',
                    334: 'testlist1',
                    335: 'testlist_gexp',
                    336: 'testlist_safe',
                    337: 'trailer',
                    338: 'try_stmt',
                    339: 'varargslist',
                    340: 'while_stmt',
                    341: 'with_stmt',
                    342: 'with_var',
                    343: 'yield_stmt' },
                dfas: { 256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[1, 1]]],
                        { 1: 1,
                            4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            16: 1,
                            17: 1,
                            18: 1,
                            19: 1,
                            20: 1,
                            21: 1,
                            22: 1,
                            23: 1,
                            24: 1,
                            25: 1,
                            26: 1,
                            27: 1,
                            28: 1,
                            29: 1,
                            30: 1,
                            31: 1,
                            32: 1,
                            33: 1,
                            34: 1,
                            35: 1,
                            36: 1,
                            37: 1 }],
                    257: [[[[38, 1]], [[39, 0], [0, 1]]],
                        { 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    258: [[[[40, 1]], [[5, 0], [6, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    259: [[[[8, 1], [9, 2], [10, 3], [11, 4], [12, 5], [13, 5], [14, 6]],
                            [[41, 7], [42, 7], [43, 5]],
                            [[44, 8], [45, 5]],
                            [[46, 9], [47, 5]],
                            [[48, 10]],
                            [[0, 5]],
                            [[14, 6], [0, 6]],
                            [[43, 5]],
                            [[45, 5]],
                            [[47, 5]],
                            [[11, 5]]],
                        { 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    260: [[[[49, 1]], [[50, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    261: [[[[51, 1]], [[52, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    262: [[[[53, 1]], [[54, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    263: [[[[55, 1]], [[56, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    264: [[[[55, 1]], [[57, 2], [0, 1]], [[55, 1], [0, 2]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    265: [[[[58, 1]],
                            [[59, 2], [60, 3], [61, 4], [0, 1]],
                            [[0, 2]],
                            [[41, 2], [58, 2]],
                            [[41, 5], [58, 5]],
                            [[61, 4], [0, 5]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    266: [[[[62, 1]], [[63, 0], [64, 0], [65, 0], [66, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    267: [[[[26, 1]], [[12, 2]], [[57, 1], [0, 2]]], { 26: 1 }],
                    268: [[[[67, 1], [68, 2]],
                            [[30, 3], [0, 1]],
                            [[0, 2]],
                            [[67, 4]],
                            [[69, 5]],
                            [[70, 2]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    269: [[[[71, 1]], [[57, 2], [0, 1]], [[71, 1], [0, 2]]], { 12: 1 }],
                    270: [[[[12, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]], { 12: 1 }],
                    271: [[[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[70, 4]], [[0, 4]]],
                        { 15: 1 }],
                    272: [[[[14, 1]], [[0, 1]]], { 14: 1 }],
                    273: [[[[27, 1]], [[12, 2]], [[57, 1], [0, 2]]], { 27: 1 }],
                    274: [[[[4, 1], [75, 2]], [[38, 2]], [[0, 2]]],
                        { 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    275: [[[[76, 1]], [[77, 0], [0, 1]]],
                        { 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    276: [[[[78, 1]], [[79, 1], [80, 2], [0, 1]], [[49, 3]], [[0, 3]]],
                        { 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    277: [[[[81, 1]], [[82, 0], [83, 0], [0, 1]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    278: [[[[5, 1], [6, 1], [7, 1], [84, 2]], [[49, 2]], [[0, 2]]],
                        { 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1 }],
                    279: [[[[23, 1]], [[58, 2], [0, 1]], [[0, 2]]], { 23: 1 }],
                    280: [[[[74, 1]], [[70, 2]], [[61, 3], [0, 2]], [[70, 4]], [[0, 4]]], { 74: 1 }],
                    281: [[[[85, 1], [63, 2], [80, 3]],
                            [[57, 4], [0, 1]],
                            [[70, 5]],
                            [[70, 6]],
                            [[85, 1], [63, 2], [80, 3], [0, 4]],
                            [[57, 7], [0, 5]],
                            [[0, 6]],
                            [[85, 5], [80, 3]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            63: 1,
                            80: 1 }],
                    282: [[[[70, 1]], [[86, 2], [61, 3], [0, 1]], [[0, 2]], [[70, 2]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    283: [[[[29, 1]], [[70, 2]], [[57, 3], [0, 2]], [[70, 4]], [[0, 4]]], { 29: 1 }],
                    284: [[[[87, 1],
                                [88, 1],
                                [89, 1],
                                [90, 1],
                                [91, 1],
                                [92, 1],
                                [93, 1],
                                [94, 1],
                                [95, 1],
                                [96, 1],
                                [97, 1],
                                [98, 1]],
                            [[0, 1]]],
                        { 87: 1,
                            88: 1,
                            89: 1,
                            90: 1,
                            91: 1,
                            92: 1,
                            93: 1,
                            94: 1,
                            95: 1,
                            96: 1,
                            97: 1,
                            98: 1 }],
                    285: [[[[19, 1]], [[0, 1]]], { 19: 1 }],
                    286: [[[[36, 1]],
                            [[12, 2]],
                            [[8, 3], [74, 4]],
                            [[58, 5], [43, 6]],
                            [[99, 7]],
                            [[43, 6]],
                            [[74, 4]],
                            [[0, 7]]],
                        { 36: 1 }],
                    287: [[[[100, 1],
                                [101, 1],
                                [102, 1],
                                [103, 1],
                                [104, 1],
                                [105, 1],
                                [105, 1],
                                [106, 1],
                                [4, 2],
                                [107, 3]],
                            [[0, 1]],
                            [[106, 1]],
                            [[4, 1], [0, 3]]],
                        { 4: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1, 105: 1, 106: 1, 107: 1 }],
                    288: [[[[108, 1],
                                [109, 1],
                                [110, 1],
                                [111, 1],
                                [112, 1],
                                [113, 1],
                                [114, 1],
                                [115, 1]],
                            [[0, 1]]],
                        { 30: 1, 31: 1, 32: 1, 33: 1, 34: 1, 35: 1, 36: 1, 37: 1 }],
                    289: [[[[20, 1]], [[0, 1]]], { 20: 1 }],
                    290: [[[[116, 1]], [[114, 2], [113, 2]], [[0, 2]]], { 37: 1 }],
                    291: [[[[37, 1]],
                            [[117, 2]],
                            [[8, 3], [1, 4]],
                            [[118, 5], [43, 6]],
                            [[0, 4]],
                            [[43, 6]],
                            [[1, 4]]],
                        { 37: 1 }],
                    292: [[[[119, 1]], [[119, 1], [0, 1]]], { 37: 1 }],
                    293: [[[[17, 1]], [[120, 2]], [[0, 2]]], { 17: 1 }],
                    294: [[[[70, 1]], [[74, 2]], [[70, 3]], [[57, 4], [0, 3]], [[70, 1], [0, 4]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    295: [[[[117, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]], { 12: 1 }],
                    296: [[[[121, 1]], [[57, 0], [0, 1]]], { 12: 1 }],
                    297: [[[[12, 1]], [[122, 0], [0, 1]]], { 12: 1 }],
                    298: [[[[12, 1]], [[0, 1]]], { 12: 1 }],
                    299: [[[[58, 1]], [[1, 1], [123, 2]], [[0, 2]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    300: [[[[124, 1]],
                            [[70, 2], [0, 1]],
                            [[72, 3], [57, 3], [0, 2]],
                            [[70, 4]],
                            [[0, 4]]],
                        { 124: 1 }],
                    301: [[[[28, 1]],
                            [[55, 2]],
                            [[106, 3], [0, 2]],
                            [[70, 4]],
                            [[57, 5], [0, 4]],
                            [[70, 6]],
                            [[0, 6]]],
                        { 28: 1 }],
                    302: [[[[1, 0], [125, 0], [123, 1]], [[0, 1]]],
                        { 1: 1,
                            4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            16: 1,
                            17: 1,
                            18: 1,
                            19: 1,
                            20: 1,
                            21: 1,
                            22: 1,
                            23: 1,
                            24: 1,
                            25: 1,
                            26: 1,
                            27: 1,
                            28: 1,
                            29: 1,
                            30: 1,
                            31: 1,
                            32: 1,
                            33: 1,
                            34: 1,
                            35: 1,
                            36: 1,
                            37: 1,
                            123: 1 }],
                    303: [[[[126, 1], [127, 1], [128, 1], [129, 1], [130, 1]], [[0, 1]]],
                        { 19: 1, 20: 1, 21: 1, 22: 1, 23: 1 }],
                    304: [[[[32, 1]],
                            [[120, 2]],
                            [[106, 3]],
                            [[58, 4]],
                            [[74, 5]],
                            [[99, 6]],
                            [[69, 7], [0, 6]],
                            [[74, 8]],
                            [[99, 9]],
                            [[0, 9]]],
                        { 32: 1 }],
                    305: [[[[12, 1], [8, 2]],
                            [[74, 3], [0, 1]],
                            [[131, 4]],
                            [[70, 5]],
                            [[43, 5]],
                            [[0, 5]]],
                        { 8: 1, 12: 1 }],
                    306: [[[[132, 1]], [[57, 2], [0, 1]], [[132, 1], [0, 2]]], { 8: 1, 12: 1 }],
                    307: [[[[35, 1]],
                            [[12, 2]],
                            [[133, 3]],
                            [[134, 4], [74, 5]],
                            [[70, 6]],
                            [[99, 7]],
                            [[74, 5]],
                            [[0, 7]]],
                        { 35: 1 }],
                    308: [[[[32, 1]],
                            [[120, 2]],
                            [[106, 3]],
                            [[67, 4]],
                            [[135, 5], [0, 4]],
                            [[0, 5]]],
                        { 32: 1 }],
                    309: [[[[30, 1]], [[136, 2]], [[135, 3], [0, 2]], [[0, 3]]], { 30: 1 }],
                    310: [[[[86, 1], [137, 1]], [[0, 1]]], { 30: 1, 32: 1 }],
                    311: [[[[30, 1]],
                            [[70, 2]],
                            [[74, 3]],
                            [[99, 4]],
                            [[138, 1], [69, 5], [0, 4]],
                            [[74, 6]],
                            [[99, 7]],
                            [[0, 7]]],
                        { 30: 1 }],
                    312: [[[[25, 1]],
                            [[139, 2]],
                            [[24, 3]],
                            [[63, 4], [8, 5], [140, 4]],
                            [[0, 4]],
                            [[140, 6]],
                            [[43, 4]]],
                        { 25: 1 }],
                    313: [[[[24, 1]], [[141, 2]], [[0, 2]]], { 24: 1 }],
                    314: [[[[142, 1], [143, 1]], [[0, 1]]], { 24: 1, 25: 1 }],
                    315: [[[[32, 1]],
                            [[120, 2]],
                            [[106, 3]],
                            [[144, 4]],
                            [[145, 5], [0, 4]],
                            [[0, 5]]],
                        { 32: 1 }],
                    316: [[[[30, 1]], [[136, 2]], [[145, 3], [0, 2]], [[0, 3]]], { 30: 1 }],
                    317: [[[[146, 1], [147, 1]], [[0, 1]]], { 30: 1, 32: 1 }],
                    318: [[[[70, 1]],
                            [[146, 2], [57, 3], [0, 1]],
                            [[0, 2]],
                            [[70, 4], [0, 3]],
                            [[57, 3], [0, 4]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    319: [[[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[136, 4]], [[0, 4]]],
                        { 15: 1 }],
                    320: [[[[67, 1], [148, 1]], [[0, 1]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    321: [[[[8, 1]], [[73, 2], [43, 3]], [[43, 3]], [[0, 3]]], { 8: 1 }],
                    322: [[[[18, 1]], [[0, 1]]], { 18: 1 }],
                    323: [[[[16, 1]],
                            [[70, 2], [83, 3], [0, 1]],
                            [[57, 4], [0, 2]],
                            [[70, 5]],
                            [[70, 2], [0, 4]],
                            [[57, 6], [0, 5]],
                            [[70, 7]],
                            [[57, 8], [0, 7]],
                            [[70, 7], [0, 8]]],
                        { 16: 1 }],
                    324: [[[[22, 1]],
                            [[70, 2], [0, 1]],
                            [[57, 3], [0, 2]],
                            [[70, 4]],
                            [[57, 5], [0, 4]],
                            [[70, 6]],
                            [[0, 6]]],
                        { 22: 1 }],
                    325: [[[[21, 1]], [[58, 2], [0, 1]], [[0, 2]]], { 21: 1 }],
                    326: [[[[149, 1]], [[150, 2], [1, 3]], [[149, 1], [1, 3]], [[0, 3]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            16: 1,
                            17: 1,
                            18: 1,
                            19: 1,
                            20: 1,
                            21: 1,
                            22: 1,
                            23: 1,
                            24: 1,
                            25: 1,
                            26: 1,
                            27: 1,
                            28: 1,
                            29: 1 }],
                    327: [[[[74, 1]], [[70, 2], [0, 1]], [[0, 2]]], { 74: 1 }],
                    328: [[[[151, 1],
                                [152, 1],
                                [153, 1],
                                [154, 1],
                                [155, 1],
                                [156, 1],
                                [157, 1],
                                [158, 1],
                                [159, 1],
                                [160, 1]],
                            [[0, 1]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            16: 1,
                            17: 1,
                            18: 1,
                            19: 1,
                            20: 1,
                            21: 1,
                            22: 1,
                            23: 1,
                            24: 1,
                            25: 1,
                            26: 1,
                            27: 1,
                            28: 1,
                            29: 1 }],
                    329: [[[[2, 1], [3, 1]], [[0, 1]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            16: 1,
                            17: 1,
                            18: 1,
                            19: 1,
                            20: 1,
                            21: 1,
                            22: 1,
                            23: 1,
                            24: 1,
                            25: 1,
                            26: 1,
                            27: 1,
                            28: 1,
                            29: 1,
                            30: 1,
                            31: 1,
                            32: 1,
                            33: 1,
                            34: 1,
                            35: 1,
                            36: 1,
                            37: 1 }],
                    330: [[[[122, 1], [70, 2], [74, 3]],
                            [[122, 4]],
                            [[74, 3], [0, 2]],
                            [[70, 5], [161, 6], [0, 3]],
                            [[122, 6]],
                            [[161, 6], [0, 5]],
                            [[0, 6]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            74: 1,
                            122: 1 }],
                    331: [[[[162, 1]], [[57, 2], [0, 1]], [[162, 1], [0, 2]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            74: 1,
                            122: 1 }],
                    332: [[[[2, 1], [1, 2]],
                            [[0, 1]],
                            [[163, 3]],
                            [[125, 4]],
                            [[125, 4], [164, 1]]],
                        { 1: 1,
                            4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1,
                            16: 1,
                            17: 1,
                            18: 1,
                            19: 1,
                            20: 1,
                            21: 1,
                            22: 1,
                            23: 1,
                            24: 1,
                            25: 1,
                            26: 1,
                            27: 1,
                            28: 1,
                            29: 1 }],
                    333: [[[[70, 1]], [[57, 2], [0, 1]], [[70, 1], [0, 2]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    334: [[[[70, 1]], [[57, 0], [0, 1]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    335: [[[[70, 1]],
                            [[86, 2], [57, 3], [0, 1]],
                            [[0, 2]],
                            [[70, 4], [0, 3]],
                            [[57, 3], [0, 4]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    336: [[[[136, 1]],
                            [[57, 2], [0, 1]],
                            [[136, 3]],
                            [[57, 4], [0, 3]],
                            [[136, 3], [0, 4]]],
                        { 4: 1,
                            5: 1,
                            6: 1,
                            7: 1,
                            8: 1,
                            9: 1,
                            10: 1,
                            11: 1,
                            12: 1,
                            13: 1,
                            14: 1,
                            15: 1 }],
                    337: [[[[8, 1], [9, 2], [122, 3]],
                            [[118, 4], [43, 5]],
                            [[165, 6]],
                            [[12, 5]],
                            [[43, 5]],
                            [[0, 5]],
                            [[45, 5]]],
                        { 8: 1, 9: 1, 122: 1 }],
                    338: [[[[33, 1]],
                            [[74, 2]],
                            [[99, 3]],
                            [[166, 4], [167, 5]],
                            [[74, 6]],
                            [[74, 7]],
                            [[99, 8]],
                            [[99, 9]],
                            [[166, 4], [69, 10], [167, 5], [0, 8]],
                            [[0, 9]],
                            [[74, 11]],
                            [[99, 12]],
                            [[167, 5], [0, 12]]],
                        { 33: 1 }],
                    339: [[[[132, 1], [63, 2], [80, 3]],
                            [[61, 4], [57, 5], [0, 1]],
                            [[12, 6]],
                            [[12, 7]],
                            [[70, 8]],
                            [[132, 1], [63, 2], [80, 3], [0, 5]],
                            [[57, 9], [0, 6]],
                            [[0, 7]],
                            [[57, 5], [0, 8]],
                            [[80, 3]]],
                        { 8: 1, 12: 1, 63: 1, 80: 1 }],
                    340: [[[[31, 1]],
                            [[70, 2]],
                            [[74, 3]],
                            [[99, 4]],
                            [[69, 5], [0, 4]],
                            [[74, 6]],
                            [[99, 7]],
                            [[0, 7]]],
                        { 31: 1 }],
                    341: [[[[34, 1]],
                            [[70, 2]],
                            [[168, 3], [74, 4]],
                            [[74, 4]],
                            [[99, 5]],
                            [[0, 5]]],
                        { 34: 1 }],
                    342: [[[[72, 1]], [[55, 2]], [[0, 2]]], { 72: 1 }],
                    343: [[[[41, 1]], [[0, 1]]], { 23: 1 }] },
                states: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[1, 1]]],
                    [[[38, 1]], [[39, 0], [0, 1]]],
                    [[[40, 1]], [[5, 0], [6, 0], [0, 1]]],
                    [[[8, 1], [9, 2], [10, 3], [11, 4], [12, 5], [13, 5], [14, 6]],
                        [[41, 7], [42, 7], [43, 5]],
                        [[44, 8], [45, 5]],
                        [[46, 9], [47, 5]],
                        [[48, 10]],
                        [[0, 5]],
                        [[14, 6], [0, 6]],
                        [[43, 5]],
                        [[45, 5]],
                        [[47, 5]],
                        [[11, 5]]],
                    [[[49, 1]], [[50, 0], [0, 1]]],
                    [[[51, 1]], [[52, 0], [0, 1]]],
                    [[[53, 1]], [[54, 0], [0, 1]]],
                    [[[55, 1]], [[56, 0], [0, 1]]],
                    [[[55, 1]], [[57, 2], [0, 1]], [[55, 1], [0, 2]]],
                    [[[58, 1]],
                        [[59, 2], [60, 3], [61, 4], [0, 1]],
                        [[0, 2]],
                        [[41, 2], [58, 2]],
                        [[41, 5], [58, 5]],
                        [[61, 4], [0, 5]]],
                    [[[62, 1]], [[63, 0], [64, 0], [65, 0], [66, 0], [0, 1]]],
                    [[[26, 1]], [[12, 2]], [[57, 1], [0, 2]]],
                    [[[67, 1], [68, 2]],
                        [[30, 3], [0, 1]],
                        [[0, 2]],
                        [[67, 4]],
                        [[69, 5]],
                        [[70, 2]]],
                    [[[71, 1]], [[57, 2], [0, 1]], [[71, 1], [0, 2]]],
                    [[[12, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]],
                    [[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[70, 4]], [[0, 4]]],
                    [[[14, 1]], [[0, 1]]],
                    [[[27, 1]], [[12, 2]], [[57, 1], [0, 2]]],
                    [[[4, 1], [75, 2]], [[38, 2]], [[0, 2]]],
                    [[[76, 1]], [[77, 0], [0, 1]]],
                    [[[78, 1]], [[79, 1], [80, 2], [0, 1]], [[49, 3]], [[0, 3]]],
                    [[[81, 1]], [[82, 0], [83, 0], [0, 1]]],
                    [[[5, 1], [6, 1], [7, 1], [84, 2]], [[49, 2]], [[0, 2]]],
                    [[[23, 1]], [[58, 2], [0, 1]], [[0, 2]]],
                    [[[74, 1]], [[70, 2]], [[61, 3], [0, 2]], [[70, 4]], [[0, 4]]],
                    [[[85, 1], [63, 2], [80, 3]],
                        [[57, 4], [0, 1]],
                        [[70, 5]],
                        [[70, 6]],
                        [[85, 1], [63, 2], [80, 3], [0, 4]],
                        [[57, 7], [0, 5]],
                        [[0, 6]],
                        [[85, 5], [80, 3]]],
                    [[[70, 1]], [[86, 2], [61, 3], [0, 1]], [[0, 2]], [[70, 2]]],
                    [[[29, 1]], [[70, 2]], [[57, 3], [0, 2]], [[70, 4]], [[0, 4]]],
                    [[[87, 1],
                            [88, 1],
                            [89, 1],
                            [90, 1],
                            [91, 1],
                            [92, 1],
                            [93, 1],
                            [94, 1],
                            [95, 1],
                            [96, 1],
                            [97, 1],
                            [98, 1]],
                        [[0, 1]]],
                    [[[19, 1]], [[0, 1]]],
                    [[[36, 1]],
                        [[12, 2]],
                        [[8, 3], [74, 4]],
                        [[58, 5], [43, 6]],
                        [[99, 7]],
                        [[43, 6]],
                        [[74, 4]],
                        [[0, 7]]],
                    [[[100, 1],
                            [101, 1],
                            [102, 1],
                            [103, 1],
                            [104, 1],
                            [105, 1],
                            [105, 1],
                            [106, 1],
                            [4, 2],
                            [107, 3]],
                        [[0, 1]],
                        [[106, 1]],
                        [[4, 1], [0, 3]]],
                    [[[108, 1],
                            [109, 1],
                            [110, 1],
                            [111, 1],
                            [112, 1],
                            [113, 1],
                            [114, 1],
                            [115, 1]],
                        [[0, 1]]],
                    [[[20, 1]], [[0, 1]]],
                    [[[116, 1]], [[114, 2], [113, 2]], [[0, 2]]],
                    [[[37, 1]],
                        [[117, 2]],
                        [[8, 3], [1, 4]],
                        [[118, 5], [43, 6]],
                        [[0, 4]],
                        [[43, 6]],
                        [[1, 4]]],
                    [[[119, 1]], [[119, 1], [0, 1]]],
                    [[[17, 1]], [[120, 2]], [[0, 2]]],
                    [[[70, 1]], [[74, 2]], [[70, 3]], [[57, 4], [0, 3]], [[70, 1], [0, 4]]],
                    [[[117, 1]], [[72, 2], [0, 1]], [[12, 3]], [[0, 3]]],
                    [[[121, 1]], [[57, 0], [0, 1]]],
                    [[[12, 1]], [[122, 0], [0, 1]]],
                    [[[12, 1]], [[0, 1]]],
                    [[[58, 1]], [[1, 1], [123, 2]], [[0, 2]]],
                    [[[124, 1]],
                        [[70, 2], [0, 1]],
                        [[72, 3], [57, 3], [0, 2]],
                        [[70, 4]],
                        [[0, 4]]],
                    [[[28, 1]],
                        [[55, 2]],
                        [[106, 3], [0, 2]],
                        [[70, 4]],
                        [[57, 5], [0, 4]],
                        [[70, 6]],
                        [[0, 6]]],
                    [[[1, 0], [125, 0], [123, 1]], [[0, 1]]],
                    [[[126, 1], [127, 1], [128, 1], [129, 1], [130, 1]], [[0, 1]]],
                    [[[32, 1]],
                        [[120, 2]],
                        [[106, 3]],
                        [[58, 4]],
                        [[74, 5]],
                        [[99, 6]],
                        [[69, 7], [0, 6]],
                        [[74, 8]],
                        [[99, 9]],
                        [[0, 9]]],
                    [[[12, 1], [8, 2]],
                        [[74, 3], [0, 1]],
                        [[131, 4]],
                        [[70, 5]],
                        [[43, 5]],
                        [[0, 5]]],
                    [[[132, 1]], [[57, 2], [0, 1]], [[132, 1], [0, 2]]],
                    [[[35, 1]],
                        [[12, 2]],
                        [[133, 3]],
                        [[134, 4], [74, 5]],
                        [[70, 6]],
                        [[99, 7]],
                        [[74, 5]],
                        [[0, 7]]],
                    [[[32, 1]], [[120, 2]], [[106, 3]], [[67, 4]], [[135, 5], [0, 4]], [[0, 5]]],
                    [[[30, 1]], [[136, 2]], [[135, 3], [0, 2]], [[0, 3]]],
                    [[[86, 1], [137, 1]], [[0, 1]]],
                    [[[30, 1]],
                        [[70, 2]],
                        [[74, 3]],
                        [[99, 4]],
                        [[138, 1], [69, 5], [0, 4]],
                        [[74, 6]],
                        [[99, 7]],
                        [[0, 7]]],
                    [[[25, 1]],
                        [[139, 2]],
                        [[24, 3]],
                        [[63, 4], [8, 5], [140, 4]],
                        [[0, 4]],
                        [[140, 6]],
                        [[43, 4]]],
                    [[[24, 1]], [[141, 2]], [[0, 2]]],
                    [[[142, 1], [143, 1]], [[0, 1]]],
                    [[[32, 1]], [[120, 2]], [[106, 3]], [[144, 4]], [[145, 5], [0, 4]], [[0, 5]]],
                    [[[30, 1]], [[136, 2]], [[145, 3], [0, 2]], [[0, 3]]],
                    [[[146, 1], [147, 1]], [[0, 1]]],
                    [[[70, 1]],
                        [[146, 2], [57, 3], [0, 1]],
                        [[0, 2]],
                        [[70, 4], [0, 3]],
                        [[57, 3], [0, 4]]],
                    [[[15, 1]], [[73, 2], [74, 3]], [[74, 3]], [[136, 4]], [[0, 4]]],
                    [[[67, 1], [148, 1]], [[0, 1]]],
                    [[[8, 1]], [[73, 2], [43, 3]], [[43, 3]], [[0, 3]]],
                    [[[18, 1]], [[0, 1]]],
                    [[[16, 1]],
                        [[70, 2], [83, 3], [0, 1]],
                        [[57, 4], [0, 2]],
                        [[70, 5]],
                        [[70, 2], [0, 4]],
                        [[57, 6], [0, 5]],
                        [[70, 7]],
                        [[57, 8], [0, 7]],
                        [[70, 7], [0, 8]]],
                    [[[22, 1]],
                        [[70, 2], [0, 1]],
                        [[57, 3], [0, 2]],
                        [[70, 4]],
                        [[57, 5], [0, 4]],
                        [[70, 6]],
                        [[0, 6]]],
                    [[[21, 1]], [[58, 2], [0, 1]], [[0, 2]]],
                    [[[149, 1]], [[150, 2], [1, 3]], [[149, 1], [1, 3]], [[0, 3]]],
                    [[[74, 1]], [[70, 2], [0, 1]], [[0, 2]]],
                    [[[151, 1],
                            [152, 1],
                            [153, 1],
                            [154, 1],
                            [155, 1],
                            [156, 1],
                            [157, 1],
                            [158, 1],
                            [159, 1],
                            [160, 1]],
                        [[0, 1]]],
                    [[[2, 1], [3, 1]], [[0, 1]]],
                    [[[122, 1], [70, 2], [74, 3]],
                        [[122, 4]],
                        [[74, 3], [0, 2]],
                        [[70, 5], [161, 6], [0, 3]],
                        [[122, 6]],
                        [[161, 6], [0, 5]],
                        [[0, 6]]],
                    [[[162, 1]], [[57, 2], [0, 1]], [[162, 1], [0, 2]]],
                    [[[2, 1], [1, 2]], [[0, 1]], [[163, 3]], [[125, 4]], [[125, 4], [164, 1]]],
                    [[[70, 1]], [[57, 2], [0, 1]], [[70, 1], [0, 2]]],
                    [[[70, 1]], [[57, 0], [0, 1]]],
                    [[[70, 1]],
                        [[86, 2], [57, 3], [0, 1]],
                        [[0, 2]],
                        [[70, 4], [0, 3]],
                        [[57, 3], [0, 4]]],
                    [[[136, 1]],
                        [[57, 2], [0, 1]],
                        [[136, 3]],
                        [[57, 4], [0, 3]],
                        [[136, 3], [0, 4]]],
                    [[[8, 1], [9, 2], [122, 3]],
                        [[118, 4], [43, 5]],
                        [[165, 6]],
                        [[12, 5]],
                        [[43, 5]],
                        [[0, 5]],
                        [[45, 5]]],
                    [[[33, 1]],
                        [[74, 2]],
                        [[99, 3]],
                        [[166, 4], [167, 5]],
                        [[74, 6]],
                        [[74, 7]],
                        [[99, 8]],
                        [[99, 9]],
                        [[166, 4], [69, 10], [167, 5], [0, 8]],
                        [[0, 9]],
                        [[74, 11]],
                        [[99, 12]],
                        [[167, 5], [0, 12]]],
                    [[[132, 1], [63, 2], [80, 3]],
                        [[61, 4], [57, 5], [0, 1]],
                        [[12, 6]],
                        [[12, 7]],
                        [[70, 8]],
                        [[132, 1], [63, 2], [80, 3], [0, 5]],
                        [[57, 9], [0, 6]],
                        [[0, 7]],
                        [[57, 5], [0, 8]],
                        [[80, 3]]],
                    [[[31, 1]],
                        [[70, 2]],
                        [[74, 3]],
                        [[99, 4]],
                        [[69, 5], [0, 4]],
                        [[74, 6]],
                        [[99, 7]],
                        [[0, 7]]],
                    [[[34, 1]], [[70, 2]], [[168, 3], [74, 4]], [[74, 4]], [[99, 5]], [[0, 5]]],
                    [[[72, 1]], [[55, 2]], [[0, 2]]],
                    [[[41, 1]], [[0, 1]]]],
                labels: [[0, 'EMPTY'],
                    [4, null],
                    [326, null],
                    [288, null],
                    [1, 'not'],
                    [14, null],
                    [15, null],
                    [32, null],
                    [7, null],
                    [9, null],
                    [26, null],
                    [25, null],
                    [1, null],
                    [2, null],
                    [3, null],
                    [1, 'lambda'],
                    [1, 'print'],
                    [1, 'del'],
                    [1, 'pass'],
                    [1, 'break'],
                    [1, 'continue'],
                    [1, 'return'],
                    [1, 'raise'],
                    [1, 'yield'],
                    [1, 'import'],
                    [1, 'from'],
                    [1, 'global'],
                    [1, 'nonlocal'],
                    [1, 'exec'],
                    [1, 'assert'],
                    [1, 'if'],
                    [1, 'while'],
                    [1, 'for'],
                    [1, 'try'],
                    [1, 'with'],
                    [1, 'def'],
                    [1, 'class'],
                    [50, null],
                    [274, null],
                    [1, 'and'],
                    [266, null],
                    [279, null],
                    [335, null],
                    [8, null],
                    [318, null],
                    [10, null],
                    [294, null],
                    [27, null],
                    [334, null],
                    [278, null],
                    [19, null],
                    [262, null],
                    [18, null],
                    [260, null],
                    [33, null],
                    [258, null],
                    [287, null],
                    [12, null],
                    [333, null],
                    [280, null],
                    [284, null],
                    [22, null],
                    [277, null],
                    [16, null],
                    [17, null],
                    [24, null],
                    [48, null],
                    [275, null],
                    [271, null],
                    [1, 'else'],
                    [268, null],
                    [270, null],
                    [1, 'as'],
                    [339, null],
                    [11, null],
                    [263, null],
                    [257, null],
                    [1, 'or'],
                    [259, null],
                    [337, null],
                    [36, null],
                    [261, null],
                    [34, null],
                    [35, null],
                    [276, null],
                    [282, null],
                    [308, null],
                    [37, null],
                    [38, null],
                    [39, null],
                    [40, null],
                    [41, null],
                    [42, null],
                    [43, null],
                    [44, null],
                    [45, null],
                    [46, null],
                    [47, null],
                    [49, null],
                    [332, null],
                    [20, null],
                    [21, null],
                    [28, null],
                    [31, null],
                    [30, null],
                    [29, null],
                    [1, 'in'],
                    [1, 'is'],
                    [311, null],
                    [340, null],
                    [304, null],
                    [338, null],
                    [341, null],
                    [307, null],
                    [286, null],
                    [290, null],
                    [292, null],
                    [297, null],
                    [281, null],
                    [291, null],
                    [264, null],
                    [295, null],
                    [23, null],
                    [0, null],
                    [1, 'except'],
                    [329, null],
                    [285, null],
                    [289, null],
                    [325, null],
                    [324, null],
                    [343, null],
                    [306, null],
                    [305, null],
                    [321, null],
                    [55, null],
                    [310, null],
                    [320, null],
                    [309, null],
                    [1, 'elif'],
                    [272, null],
                    [269, null],
                    [296, null],
                    [313, null],
                    [312, null],
                    [336, null],
                    [317, null],
                    [315, null],
                    [316, null],
                    [319, null],
                    [328, null],
                    [13, null],
                    [265, null],
                    [323, null],
                    [293, null],
                    [322, null],
                    [303, null],
                    [314, null],
                    [267, null],
                    [273, null],
                    [301, null],
                    [283, null],
                    [327, null],
                    [330, null],
                    [5, null],
                    [6, null],
                    [331, null],
                    [300, null],
                    [1, 'finally'],
                    [342, null]],
                keywords: { 'and': 39,
                    'as': 72,
                    'assert': 29,
                    'break': 19,
                    'class': 36,
                    'continue': 20,
                    'def': 35,
                    'del': 17,
                    'elif': 138,
                    'else': 69,
                    'except': 124,
                    'exec': 28,
                    'finally': 167,
                    'for': 32,
                    'from': 25,
                    'global': 26,
                    'if': 30,
                    'import': 24,
                    'in': 106,
                    'is': 107,
                    'lambda': 15,
                    'nonlocal': 27,
                    'not': 4,
                    'or': 77,
                    'pass': 18,
                    'print': 16,
                    'raise': 22,
                    'return': 21,
                    'try': 33,
                    'while': 31,
                    'with': 34,
                    'yield': 23 },
                tokens: { 0: 123,
                    1: 12,
                    2: 13,
                    3: 14,
                    4: 1,
                    5: 163,
                    6: 164,
                    7: 8,
                    8: 43,
                    9: 9,
                    10: 45,
                    11: 74,
                    12: 57,
                    13: 150,
                    14: 5,
                    15: 6,
                    16: 63,
                    17: 64,
                    18: 52,
                    19: 50,
                    20: 100,
                    21: 101,
                    22: 61,
                    23: 122,
                    24: 65,
                    25: 11,
                    26: 10,
                    27: 47,
                    28: 102,
                    29: 105,
                    30: 104,
                    31: 103,
                    32: 7,
                    33: 54,
                    34: 82,
                    35: 83,
                    36: 80,
                    37: 87,
                    38: 88,
                    39: 89,
                    40: 90,
                    41: 91,
                    42: 92,
                    43: 93,
                    44: 94,
                    45: 95,
                    46: 96,
                    47: 97,
                    48: 66,
                    49: 98,
                    50: 37,
                    55: 134 },
                start: 256
            };
            // Nothing more to see here.

            /**
             * Decodes of the tokens.
             * A mapping from the token number (symbol) to its human-readable name.
             */
            const tokenNames = {};
            tokenNames[Tokens.T_AMPER] = 'T_AMPER';
            tokenNames[Tokens.T_AMPEREQUAL] = 'T_AMPEREQUAL';
            tokenNames[Tokens.T_AT] = 'T_AT';
            tokenNames[Tokens.T_BACKQUOTE] = 'T_BACKQUOTE';
            tokenNames[Tokens.T_CIRCUMFLEX] = 'T_CIRCUMFLEX';
            tokenNames[Tokens.T_CIRCUMFLEXEQUAL] = 'T_CIRCUMFLEXEQUAL';
            tokenNames[Tokens.T_COLON] = 'T_COLON';
            tokenNames[Tokens.T_COMMA] = 'T_COMMA';
            tokenNames[Tokens.T_COMMENT] = 'T_COMMENT';
            tokenNames[Tokens.T_DEDENT] = 'T_DEDENT';
            tokenNames[Tokens.T_DOT] = 'T_DOT';
            tokenNames[Tokens.T_DOUBLESLASH] = 'T_DOUBLESLASH';
            tokenNames[Tokens.T_DOUBLESLASHEQUAL] = 'T_DOUBLESLASHEQUAL';
            tokenNames[Tokens.T_DOUBLESTAR] = 'T_DOUBLESTAR';
            tokenNames[Tokens.T_DOUBLESTAREQUAL] = 'T_DOUBLESTAREQUAL';
            tokenNames[Tokens.T_ENDMARKER] = 'T_ENDMARKER';
            tokenNames[Tokens.T_EQEQUAL] = 'T_EQEQUAL';
            tokenNames[Tokens.T_EQUAL] = 'T_EQUAL';
            tokenNames[Tokens.T_ERRORTOKEN] = 'T_ERRORTOKEN';
            tokenNames[Tokens.T_GREATER] = 'T_GREATER';
            tokenNames[Tokens.T_GREATEREQUAL] = 'T_GREATEREQUAL';
            tokenNames[Tokens.T_INDENT] = 'T_INDENT';
            tokenNames[Tokens.T_LBRACE] = 'T_LBRACE';
            tokenNames[Tokens.T_LEFTSHIFT] = 'T_LEFTSHIFT';
            tokenNames[Tokens.T_LEFTSHIFTEQUAL] = 'T_LEFTSHIFTEQUAL';
            tokenNames[Tokens.T_LESS] = 'T_LESS';
            tokenNames[Tokens.T_LESSEQUAL] = 'T_LESSEQUAL';
            tokenNames[Tokens.T_LPAR] = 'T_LPAR';
            tokenNames[Tokens.T_LSQB] = 'T_LSQB';
            tokenNames[Tokens.T_MINEQUAL] = 'T_MINEQUAL';
            tokenNames[Tokens.T_MINUS] = 'T_MINUS';
            tokenNames[Tokens.T_N_TOKENS] = 'T_N_TOKENS';
            tokenNames[Tokens.T_NAME] = 'T_NAME';
            tokenNames[Tokens.T_NEWLINE] = 'T_NEWLINE';
            tokenNames[Tokens.T_NL] = 'T_NL';
            tokenNames[Tokens.T_NOTEQUAL] = 'T_NOTEQUAL';
            tokenNames[Tokens.T_NT_OFFSET] = 'T_NT_OFFSET';
            tokenNames[Tokens.T_NUMBER] = 'T_NUMBER';
            tokenNames[Tokens.T_OP] = 'T_OP';
            tokenNames[Tokens.T_PERCENT] = 'T_PERCENT';
            tokenNames[Tokens.T_PERCENTEQUAL] = 'T_PERCENTEQUAL';
            tokenNames[Tokens.T_PLUS] = 'T_PLUS';
            tokenNames[Tokens.T_PLUSEQUAL] = 'T_PLUSEQUAL';
            tokenNames[Tokens.T_RARROW] = 'T_RARROW';
            tokenNames[Tokens.T_RBRACE] = 'T_RBRACE';
            tokenNames[Tokens.T_RIGHTSHIFT] = 'T_RIGHTSHIFT';
            tokenNames[Tokens.T_RPAR] = 'T_RPAR';
            tokenNames[Tokens.T_RSQB] = 'T_RSQB';
            tokenNames[Tokens.T_SEMI] = 'T_SEMI';
            tokenNames[Tokens.T_SLASH] = 'T_SLASH';
            tokenNames[Tokens.T_SLASHEQUAL] = 'T_SLASHEQUAL';
            tokenNames[Tokens.T_STAR] = 'T_STAR';
            tokenNames[Tokens.T_STAREQUAL] = 'T_STAREQUAL';
            tokenNames[Tokens.T_STRING] = 'T_STRING';
            tokenNames[Tokens.T_TILDE] = 'T_TILDE';
            tokenNames[Tokens.T_VBAR] = 'T_VBAR';
            tokenNames[Tokens.T_VBAREQUAL] = 'T_VBAREQUAL';

            function grammarName(type) {
                const tokenName = tokenNames[type];
                if (tokenName) {
                    return tokenName;
                }
                else {
                    return ParseTables.number2symbol[type];
                }
            }

            /**
             * A token error is exclusively used to indicate EOF situations.
             */
            class TokenError extends Error {
                /**
                 * @param message
                 * @param lineNumber
                 * @param columnNumber
                 */
                constructor(message, lineNumber, columnNumber) {
                    super(message);
                    this.lineNumber = lineNumber;
                    this.columnNumber = columnNumber;
                    assert(isNumber(lineNumber), "lineNumber must be a number");
                    assert(isNumber(columnNumber), "columnNumber must be a number");
                }
            }

            // Cache a few tokens for performance.
            const T_COMMENT$1 = Tokens.T_COMMENT;
            const T_DEDENT = Tokens.T_DEDENT;
            const T_ENDMARKER$1 = Tokens.T_ENDMARKER;
            const T_ERRORTOKEN = Tokens.T_ERRORTOKEN;
            const T_INDENT = Tokens.T_INDENT;
            const T_NAME$1 = Tokens.T_NAME;
            const T_NEWLINE = Tokens.T_NEWLINE;
            const T_NL$1 = Tokens.T_NL;
            const T_NUMBER = Tokens.T_NUMBER;
            const T_OP$1 = Tokens.T_OP;
            const T_STRING = Tokens.T_STRING;
            /* we have to use string and ctor to be able to build patterns up. + on /.../
                * does something strange. */
            // const Whitespace = "[ \\f\\t]*";
            const Comment_ = "#[^\\r\\n]*";
            const MultiComment_ = "'{3}[^]*'{3}";
            const Ident = "[a-zA-Z_]\\w*";
            const Binnumber = '0[bB][01]*';
            const Hexnumber = '0[xX][\\da-fA-F]*[lL]?';
            const Octnumber = '0[oO]?[0-7]*[lL]?';
            const Decnumber = '[1-9]\\d*[lL]?';
            const Intnumber = group$1(Binnumber, Hexnumber, Octnumber, Decnumber);
            const Exponent = "[eE][-+]?\\d+";
            const Pointfloat = group$1("\\d+\\.\\d*", "\\.\\d+") + maybe(Exponent);
            const Expfloat = '\\d+' + Exponent;
            const Floatnumber = group$1(Pointfloat, Expfloat);
            const Imagnumber = group$1("\\d+[jJ]", Floatnumber + "[jJ]");
            const Number_ = group$1(Imagnumber, Floatnumber, Intnumber);
            // tail end of ' string
            const Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'";
            // tail end of " string
            const Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
            // tail end of ''' string
            const Single3 = "[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
            // tail end of """ string
            const Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
            const Triple = group$1("[ubUB]?[rR]?'''", '[ubUB]?[rR]?"""');
            // const String_ = group("[uU]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
            // Because of leftmost-then-longest match semantics, be sure to put the
            // longest operators first (e.g., if = came before ==, == would get
            // recognized as two instances of =).
            const Operator = group$1("\\*\\*=?", ">>=?", "<<=?", "<>", "!=", "//=?", "->", "[+\\-*/%&|^=<>]=?", "~");
            const Bracket = '[\\][(){}]';
            const Special = group$1('\\r?\\n', '[:;.,`@]');
            const Funny = group$1(Operator, Bracket, Special);
            const ContStr = group$1("[uUbB]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" +
                group$1("'", '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' +
                group$1('"', '\\\\\\r?\\n'));
            const PseudoExtras = group$1('\\\\\\r?\\n', Comment_, Triple, MultiComment_);
            // Need to prefix with "^" as we only want to match what's next
            const PseudoToken = "^" + group$1(PseudoExtras, Number_, Funny, ContStr, Ident);
            const pseudoprog = new RegExp(PseudoToken);
            const single3prog = new RegExp(Single3, "g");
            const double3prog = new RegExp(Double3, "g");
            const endprogs = {
                "'": new RegExp(Single, "g"), '"': new RegExp(Double_, "g"),
                "'''": single3prog, '"""': double3prog,
                "r'''": single3prog, 'r"""': double3prog,
                "u'''": single3prog, 'u"""': double3prog,
                "b'''": single3prog, 'b"""': double3prog,
                "ur'''": single3prog, 'ur"""': double3prog,
                "br'''": single3prog, 'br"""': double3prog,
                "R'''": single3prog, 'R"""': double3prog,
                "U'''": single3prog, 'U"""': double3prog,
                "B'''": single3prog, 'B"""': double3prog,
                "uR'''": single3prog, 'uR"""': double3prog,
                "Ur'''": single3prog, 'Ur"""': double3prog,
                "UR'''": single3prog, 'UR"""': double3prog,
                "bR'''": single3prog, 'bR"""': double3prog,
                "Br'''": single3prog, 'Br"""': double3prog,
                "BR'''": single3prog, 'BR"""': double3prog,
                'r': null, 'R': null,
                'u': null, 'U': null,
                'b': null, 'B': null
            };
            const triple_quoted = {
                "'''": true, '"""': true,
                "r'''": true, 'r"""': true, "R'''": true, 'R"""': true,
                "u'''": true, 'u"""': true, "U'''": true, 'U"""': true,
                "b'''": true, 'b"""': true, "B'''": true, 'B"""': true,
                "ur'''": true, 'ur"""': true, "Ur'''": true, 'Ur"""': true,
                "uR'''": true, 'uR"""': true, "UR'''": true, 'UR"""': true,
                "br'''": true, 'br"""': true, "Br'''": true, 'Br"""': true,
                "bR'''": true, 'bR"""': true, "BR'''": true, 'BR"""': true
            };
            const single_quoted = {
                "'": true, '"': true,
                "r'": true, 'r"': true, "R'": true, 'R"': true,
                "u'": true, 'u"': true, "U'": true, 'U"': true,
                "b'": true, 'b"': true, "B'": true, 'B"': true,
                "ur'": true, 'ur"': true, "Ur'": true, 'Ur"': true,
                "uR'": true, 'uR"': true, "UR'": true, 'UR"': true,
                "br'": true, 'br"': true, "Br'": true, 'Br"': true,
                "bR'": true, 'bR"': true, "BR'": true, 'BR"': true
            };
            const tabsize = 8;
            const NAMECHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
            const NUMCHARS = '0123456789';
            /**
             * The index of the line in the LineColumn array.
             */
            const LINE = 0;
            /**
             * The index of the column in the LineColumn array.
             */
            const COLUMN = 1;
            const Done = 'done';
            const Failed = 'failed';
            /**
             * This is a port of tokenize.py by Ka-Ping Yee.
             *
             * each call to readline should return one line of input as a string, or
             * undefined if it's finished.
             *
             * callback is called for each token with 5 args:
             * 1. the token type
             * 2. the token string
             * 3. [ start_row, start_col ]
             * 4. [ end_row, end_col ]
             * 5. logical line where the token was found, including continuation lines
             *
             * callback can return true to abort.
             */
            class Tokenizer {
                /**
                 *
                 */
                constructor(interactive, callback) {
                    this.callback = callback;
                    /**
                     * Cache of the beginning of a token.
                     * This will change by token so consumers must copy the values out.
                     */
                    this.begin = [-1, -1];
                    /**
                     * Cache of the end of a token.
                     * This will change by token so consumers must copy the values out.
                     */
                    this.end = [-1, -1];
                    /**
                     * The line number. This must be copied into the begin[LINE] and end[LINE] properties.
                     */
                    this.lnum = 0;
                    this.parenlev = 0;
                    this.strstart = [-1, -1];
                    this.callback = callback;
                    this.continued = false;
                    this.contstr = '';
                    this.needcont = false;
                    this.contline = undefined;
                    this.indents = [0];
                    this.endprog = /.*/;
                    this.interactive = interactive;
                    this.doneFunc = function doneOrFailed() {
                        const begin = this.begin;
                        const end = this.end;
                        begin[LINE] = end[LINE] = this.lnum;
                        begin[COLUMN] = end[COLUMN] = 0;
                        const N = this.indents.length;
                        for (let i = 1; i < N; ++i) {
                            if (callback(T_DEDENT, '', begin, end, '')) {
                                return Done;
                            }
                        }
                        if (callback(T_ENDMARKER$1, '', begin, end, '')) {
                            return Done;
                        }
                        return Failed;
                    };
                }
                /**
                 * @param line
                 * @return 'done' or 'failed' or true?
                 */
                generateTokens(line) {
                    let endmatch;
                    let column;
                    let endIndex;
                    if (!line) {
                        line = '';
                    }
                    this.lnum += 1;
                    let pos = 0;
                    let max = line.length;
                    /**
                     * Local variable for performance and brevity.
                     */
                    const callback = this.callback;
                    const begin = this.begin;
                    begin[LINE] = this.lnum;
                    const end = this.end;
                    end[LINE] = this.lnum;
                    if (this.contstr.length > 0) {
                        if (!line) {
                            throw new TokenError("EOF in multi-line string", this.strstart[LINE], this.strstart[COLUMN]);
                        }
                        this.endprog.lastIndex = 0;
                        endmatch = this.endprog.test(line);
                        if (endmatch) {
                            pos = endIndex = this.endprog.lastIndex;
                            end[COLUMN] = endIndex;
                            if (callback(T_STRING, this.contstr + line.substring(0, endIndex), this.strstart, end, this.contline + line)) {
                                return Done;
                            }
                            this.contstr = '';
                            this.needcont = false;
                            this.contline = undefined;
                        }
                        else if (this.needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
                            // Either contline is a string or the callback must allow undefined.
                            assert(typeof this.contline === 'string');
                            end[COLUMN] = line.length;
                            if (callback(T_ERRORTOKEN, this.contstr + line, this.strstart, end, this.contline)) {
                                return Done;
                            }
                            this.contstr = '';
                            this.contline = undefined;
                            return false;
                        }
                        else {
                            this.contstr += line;
                            this.contline = this.contline + line;
                            return false;
                        }
                    }
                    else if (this.parenlev === 0 && !this.continued) {
                        if (!line)
                            return this.doneFunc();
                        column = 0;
                        while (pos < max) {
                            const ch = line.charAt(pos);
                            if (ch === ' ') {
                                column += 1;
                            }
                            else if (ch === '\t') {
                                column = (column / tabsize + 1) * tabsize;
                            }
                            else if (ch === '\f') {
                                column = 0;
                            }
                            else {
                                break;
                            }
                            pos = pos + 1;
                        }
                        if (pos === max)
                            return this.doneFunc();
                        if ("#\r\n".indexOf(line.charAt(pos)) !== -1) {
                            if (line.charAt(pos) === '#') {
                                const comment_token = rstrip(line.substring(pos), '\r\n');
                                const nl_pos = pos + comment_token.length;
                                begin[COLUMN] = pos;
                                end[COLUMN] = nl_pos;
                                if (callback(T_COMMENT$1, comment_token, begin, end, line)) {
                                    return Done;
                                }
                                begin[COLUMN] = nl_pos;
                                end[COLUMN] = line.length;
                                if (callback(T_NL$1, line.substring(nl_pos), begin, end, line)) {
                                    return Done;
                                }
                                return false;
                            }
                            else {
                                begin[COLUMN] = pos;
                                end[COLUMN] = line.length;
                                if (callback(T_NL$1, line.substring(pos), begin, end, line)) {
                                    return Done;
                                }
                                if (!this.interactive)
                                    return false;
                            }
                        }
                        if ("'''".indexOf(line.charAt(pos)) !== -1) {
                            if (line.charAt(pos) === "'") {
                                const comment_token = line.substring(pos);
                                const nl_pos = pos + comment_token.length;
                                begin[COLUMN] = pos;
                                end[COLUMN] = nl_pos;
                                if (callback(T_COMMENT$1, comment_token, begin, end, line)) {
                                    return Done;
                                }
                                begin[COLUMN] = nl_pos;
                                end[COLUMN] = line.length;
                                if (callback(T_NL$1, line.substring(nl_pos), begin, end, line)) {
                                    return Done;
                                }
                                return false;
                            }
                            else {
                                begin[COLUMN] = pos;
                                end[COLUMN] = line.length;
                                if (callback(T_NL$1, line.substring(pos), begin, end, line)) {
                                    return Done;
                                }
                                if (!this.interactive)
                                    return false;
                            }
                        }
                        if (column > this.indents[this.indents.length - 1]) {
                            this.indents.push(column);
                            begin[COLUMN] = 0;
                            end[COLUMN] = pos;
                            if (callback(T_INDENT, line.substring(0, pos), begin, end, line)) {
                                return Done;
                            }
                        }
                        while (column < this.indents[this.indents.length - 1]) {
                            if (!contains(this.indents, column)) {
                                begin[COLUMN] = 0;
                                end[COLUMN] = pos;
                                throw indentationError("unindent does not match any outer indentation level", begin, end);
                            }
                            this.indents.splice(this.indents.length - 1, 1);
                            begin[COLUMN] = pos;
                            end[COLUMN] = pos;
                            if (callback(T_DEDENT, '', begin, end, line)) {
                                return Done;
                            }
                        }
                    }
                    else {
                        if (!line) {
                            throw new TokenError("EOF in multi-line statement", this.lnum, 0);
                        }
                        this.continued = false;
                    }
                    while (pos < max) {
                        // js regexes don't return any info about matches, other than the
                        // content. we'd like to put a \w+ before pseudomatch, but then we
                        // can't get any data
                        let capos = line.charAt(pos);
                        while (capos === ' ' || capos === '\f' || capos === '\t') {
                            pos += 1;
                            capos = line.charAt(pos);
                        }
                        pseudoprog.lastIndex = 0;
                        const pseudomatch = pseudoprog.exec(line.substring(pos));
                        if (pseudomatch) {
                            const startIndex = pos;
                            endIndex = startIndex + pseudomatch[1].length;
                            begin[COLUMN] = startIndex;
                            end[COLUMN] = endIndex;
                            pos = endIndex;
                            const token = line.substring(startIndex, endIndex);
                            const initial = line.charAt(startIndex);
                            if (NUMCHARS.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {
                                if (callback(T_NUMBER, token, begin, end, line)) {
                                    return Done;
                                }
                            }
                            else if (initial === '\r' || initial === '\n') {
                                let newl = T_NEWLINE;
                                if (this.parenlev > 0)
                                    newl = T_NL$1;
                                if (callback(newl, token, begin, end, line)) {
                                    return Done;
                                }
                            }
                            else if (initial === '#' || initial === "'''") {
                                if (callback(T_COMMENT$1, token, begin, end, line)) {
                                    return Done;
                                }
                            }
                            else if (triple_quoted.hasOwnProperty(token)) {
                                this.endprog = endprogs[token];
                                this.endprog.lastIndex = 0;
                                endmatch = this.endprog.test(line.substring(pos));
                                if (endmatch) {
                                    pos = this.endprog.lastIndex + pos;
                                    const token = line.substring(startIndex, pos);
                                    end[COLUMN] = pos;
                                    if (callback(T_STRING, token, begin, end, line)) {
                                        return Done;
                                    }
                                }
                                else {
                                    this.strstart[LINE] = this.lnum;
                                    this.strstart[COLUMN] = startIndex;
                                    this.contstr = line.substring(startIndex);
                                    this.contline = line;
                                    return false;
                                }
                            }
                            else if (single_quoted.hasOwnProperty(initial) ||
                                single_quoted.hasOwnProperty(token.substring(0, 2)) ||
                                single_quoted.hasOwnProperty(token.substring(0, 3))) {
                                if (token[token.length - 1] === '\n') {
                                    this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];
                                    assert(this.endprog instanceof RegExp);
                                    this.contstr = line.substring(startIndex);
                                    this.needcont = true;
                                    this.contline = line;
                                    return false;
                                }
                                else {
                                    if (callback(T_STRING, token, begin, end, line)) {
                                        return Done;
                                    }
                                }
                            }
                            else if (NAMECHARS.indexOf(initial) !== -1) {
                                if (callback(T_NAME$1, token, begin, end, line)) {
                                    return Done;
                                }
                            }
                            else if (initial === '\\') {
                                end[COLUMN] = pos;
                                if (callback(T_NL$1, token, begin, end, line)) {
                                    return Done;
                                }
                                this.continued = true;
                            }
                            else {
                                if ('([{'.indexOf(initial) !== -1) {
                                    this.parenlev += 1;
                                }
                                else if (')]}'.indexOf(initial) !== -1) {
                                    this.parenlev -= 1;
                                }
                                if (callback(T_OP$1, token, begin, end, line)) {
                                    return Done;
                                }
                            }
                        }
                        else {
                            begin[COLUMN] = pos;
                            end[COLUMN] = pos + 1;
                            if (callback(T_ERRORTOKEN, line.charAt(pos), begin, end, line)) {
                                return Done;
                            }
                            pos += 1;
                        }
                    }
                    return false;
                }
            }
            function group$1(x, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                const args = Array.prototype.slice.call(arguments);
                return '(' + args.join('|') + ')';
            }
            function maybe(x) { return group$1.apply(null, arguments) + "?"; }
            function contains(a, obj) {
                let i = a.length;
                while (i--) {
                    if (a[i] === obj) {
                        return true;
                    }
                }
                return false;
            }
            function rstrip(input, what) {
                let i;
                for (i = input.length; i > 0; --i) {
                    if (what.indexOf(input.charAt(i - 1)) === -1)
                        break;
                }
                return input.substring(0, i);
            }
            /**
             * @param message
             * @param begin
             * @param end
             * @param {string|undefined} text
             */
            function indentationError(message, begin, end, text) {
                assert(Array.isArray(begin), "begin must be an Array");
                assert(Array.isArray(end), "end must be an Array");
                const e = new SyntaxError(message /*, fileName*/);
                e.name = "IndentationError";
                if (begin) {
                    e['lineNumber'] = begin[LINE];
                    e['columnNumber'] = begin[COLUMN];
                }
                return e;
            }

            class Position {
                /**
                 *
                 */
                constructor(line, column) {
                    this.line = line;
                    this.column = column;
                }
                /**
                 * 0-based row number.
                 */
                get row() {
                    return this.line - 1;
                }
                toString() {
                    return `[${this.line}, ${this.column}]`;
                }
            }
            /*
            export interface Position {
                row: number;
                column: number;
            }
            */
            /**
             *
             */
            class ParseError extends SyntaxError {
                constructor(message) {
                    super(message);
                    this.name = 'ParseError';
                }
            }
            /**
             * Indicates that the parser could not transition from its current state to another state because of the token received.
             */
            class UnexpectedTokenError extends ParseError {
                /**
                 * @param tokenName The name of the token.
                 * @param begin The position of the beginning of the token.
                 * @param end The position of the ending of the token.
                 */
                constructor(tokenName, begin, end) {
                    super(`Unexpected ${tokenName} at ${JSON.stringify([begin[0], begin[1] + 1])}`);
                    this.tokenName = tokenName;
                    this.name = 'UnexpectedTokenError';
                    if (Array.isArray(begin)) {
                        this.begin = new Position(begin[0], begin[1]);
                    }
                    if (Array.isArray(end)) {
                        this.end = new Position(end[0], end[1]);
                    }
                }
            }
            /**
             * @param message
             * @param begin
             * @param end
             */
            function parseError(message, begin, end) {
                const e = new ParseError(message);
                // Copying from begin and end is important because they change for each token.
                // Notice that the Line is 1-based, but that row is 0-based.
                // Both column and Column are 0-based.
                if (Array.isArray(begin)) {
                    e.begin = new Position(begin[0], begin[1]);
                }
                if (Array.isArray(end)) {
                    e.end = new Position(end[0], end[1]);
                }
                return e;
            }

            class Range {
                /**
                 *
                 */
                constructor(begin, end) {
                    assert(begin, "begin must be defined");
                    assert(end, "end must be defined");
                    this.begin = begin;
                    this.end = end;
                }
                toString() {
                    return `${this.begin} to ${this.end}`;
                }
            }

            /**
             * Prepare the source text into lines to feed to the `generateTokens` method of the tokenizer.
             * The source text is split using the newline, '\n', character.
             * @param sourceText The source text.
             * @returns The source text split into lines with the newline character retained.
             */
            function splitSourceTextIntoLines(sourceText) {
                const lines = [];
                // Why do we normalize the sourceText in this manner?
                if (sourceText.substr(IDXLAST(sourceText), 1) !== "\n") {
                    sourceText += "\n";
                }
                // Splitting this way will create a final line that is the zero-length string.
                const pieces = sourceText.split("\n");
                const N = pieces.length;
                for (let i = 0; i < N; ++i) {
                    // We're adding back newline characters for all but the last line.
                    const line = pieces[i] + ((i === IDXLAST(pieces)) ? "" : "\n");
                    lines.push(line);
                }
                return lines;
            }

            // Dereference certain tokens for performance.
            const T_COMMENT = Tokens.T_COMMENT;
            const T_ENDMARKER = Tokens.T_ENDMARKER;
            const T_NAME = Tokens.T_NAME;
            const T_NL = Tokens.T_NL;
            const T_NT_OFFSET = Tokens.T_NT_OFFSET;
            const T_OP = Tokens.T_OP;
            // TODO: The parser does not report whitespace nodes.
            // It would be nice if there were an ignoreWhitespace option.
            /**
             * Low level parser to a concrete syntax tree, derived from cpython's lib2to3.
             */
            class Parser {
                /**
                 *
                 */
                constructor(grammar) {
                    this.stack = [];
                    this.used_names = {};
                    this.grammar = grammar;
                }
                /**
                 * Pushes an element onto the stack of the type specified in the start parameter.
                 * @param start Usually ParseTables.sym.file_input or eval_input or single_input. Default is the grammar.start passed in the constructor.
                 */
                setup(start) {
                    start = start || this.grammar.start;
                    const newnode = {
                        type: start,
                        range: null,
                        value: null,
                        children: []
                    };
                    const stackentry = {
                        dfa: this.grammar.dfas[start][IDX_DFABT_DFA],
                        beginTokens: this.grammar.dfas[start][IDX_DFABT_BEGIN_TOKENS],
                        stateId: 0,
                        node: newnode
                    };
                    this.stack.push(stackentry);
                }
                /**
                 * Add a token; return true if we're done.
                 * @param type
                 * @param value
                 * @param context [start, end, line]
                 */
                addtoken(type, value, begin, end, line) {
                    /**
                     * The symbol for the token being added.
                     */
                    const tokenSymbol = this.classify(type, value, begin, end, line);
                    /**
                     * Local variable for performance.
                     */
                    const stack = this.stack;
                    // More local variables for performance.
                    const g = this.grammar;
                    const dfas = g.dfas;
                    const labels = g.labels;
                    // This code is very performance sensitive.
                    OUTERWHILE: while (true) {
                        let stackTop = stack[stack.length - 1];
                        let dfa = stackTop.dfa;
                        // This is not being used. Why?
                        // let first = tp.dfa[DFA_SECOND];
                        const arcs = dfa[stackTop.stateId];
                        // look for a to-state with this label
                        for (const arc of arcs) {
                            const arcSymbol = arc[ARC_SYMBOL_LABEL];
                            const newState = arc[ARC_TO_STATE];
                            const t = labels[arcSymbol][0];
                            // const v = labels[arcSymbol][1];
                            // console.lg(`t => ${t}, v => ${v}`);
                            if (tokenSymbol === arcSymbol) {
                                this.shiftToken(type, value, newState, begin, end, line);
                                // pop while we are in an accept-only state
                                let stateId = newState;
                                /**
                                 * Temporary variable to save a few CPU cycles.
                                 */
                                let statesOfState = dfa[stateId];
                                while (statesOfState.length === 1 && statesOfState[0][ARC_SYMBOL_LABEL] === 0 && statesOfState[0][ARC_TO_STATE] === stateId) {
                                    this.popNonTerminal();
                                    // Much of the time we won't be done so cache the stack length.
                                    const stackLength = stack.length;
                                    if (stackLength === 0) {
                                        // done!
                                        return true;
                                    }
                                    else {
                                        stackTop = stack[stackLength - 1];
                                        stateId = stackTop.stateId;
                                        dfa = stackTop.dfa;
                                        // first = stackTop.beginTokens;
                                        // first = top.dfa[1];
                                        statesOfState = dfa[stateId];
                                    }
                                }
                                // done with this token
                                return false;
                            }
                            else if (isNonTerminal(t)) {
                                const dfabt = dfas[t];
                                const dfa = dfabt[IDX_DFABT_DFA];
                                const beginTokens = dfabt[IDX_DFABT_BEGIN_TOKENS];
                                if (beginTokens.hasOwnProperty(tokenSymbol)) {
                                    this.pushNonTerminal(t, dfa, beginTokens, newState, begin, end, line);
                                    continue OUTERWHILE;
                                }
                            }
                        }
                        // We've exhaused all the arcs for the for the state.
                        if (existsTransition(arcs, [T_ENDMARKER, stackTop.stateId])) {
                            // an accepting state, pop it and try something else
                            this.popNonTerminal();
                            if (stack.length === 0) {
                                throw parseError("too much input");
                            }
                        }
                        else {
                            const tokenName = grammarName(stackTop.stateId);
                            throw new UnexpectedTokenError(tokenName, begin, end);
                        }
                    }
                }
                /**
                 * Turn a token into a symbol (something that labels an arc in the DFA).
                 * The context is only used for error reporting.
                 * @param type
                 * @param value
                 * @param context [begin, end, line]
                 */
                classify(type, value, begin, end, line) {
                    // Assertion commented out for efficiency.
                    assertTerminal(type);
                    const g = this.grammar;
                    if (type === T_NAME) {
                        this.used_names[value] = true;
                        const keywordToSymbol = g.keywords;
                        if (keywordToSymbol.hasOwnProperty(value)) {
                            const ilabel = keywordToSymbol[value];
                            // assert(typeof ilabel === 'number', "How can it not be?");
                            return ilabel;
                        }
                    }
                    const tokenToSymbol = g.tokens;
                    let ilabel;
                    if (tokenToSymbol.hasOwnProperty(type)) {
                        ilabel = tokenToSymbol[type];
                    }
                    if (!ilabel) {
                        // console.lg(`ilabel = ${ilabel}, type = ${type}, value = ${value}, begin = ${JSON.stringify(begin)}, end = ${JSON.stringify(end)}`);
                        throw parseError("bad token", begin, end);
                    }
                    return ilabel;
                }
                /**
                 * Shifting a token (terminal).
                 * 1. A new node is created representing the token.
                 * 2. The new node is added as a child to the topmost node on the stack.
                 * 3. The state of the topmost element on the stack is updated to be the new state.
                 */
                shiftToken(type, value, newState, begin, end, line) {
                    // assertTerminal(type);
                    // Local variable for efficiency.
                    const stack = this.stack;
                    /**
                     * The topmost element in the stack is affected by shifting a token.
                     */
                    const stackTop = stack[stack.length - 1];
                    const node = stackTop.node;
                    const newnode = {
                        type: type,
                        value: value,
                        range: new Range(new Position(begin[0], begin[1]), new Position(end[0], end[1])),
                        children: null
                    };
                    if (newnode && node.children) {
                        node.children.push(newnode);
                    }
                    stackTop.stateId = newState;
                }
                /**
                 * Push a non-terminal symbol onto the stack as a new node.
                 * 1. Update the state of the topmost element on the stack to be newState.
                 * 2. Push a new element onto the stack corresponding to the symbol.
                 * The new stack elements uses the newDfa and has state 0.
                 */
                pushNonTerminal(type, dfa, beginTokens, newState, begin, end, line) {
                    // Based on how this function is called, there is really no need for this assertion.
                    // Retain it for now while it is not the performance bottleneck.
                    // assertNonTerminal(type);
                    // Local variable for efficiency.
                    const stack = this.stack;
                    const stackTop = stack[stack.length - 1];
                    stackTop.stateId = newState;
                    const beginPos = begin ? new Position(begin[0], begin[1]) : null;
                    const endPos = end ? new Position(end[0], end[1]) : null;
                    const newnode = { type, value: null, range: new Range(beginPos, endPos), children: [] };
                    // TODO: Is there a symbolic constant for the zero state?
                    stack.push({ dfa, beginTokens, stateId: 0, node: newnode });
                }
                /**
                 * Pop a nonterminal.
                 * Popping an element from the stack causes the node to be added to the children of the new top element.
                 * The exception is when the stack becomes empty, in which case the node becomes the root node.
                 */
                popNonTerminal() {
                    // Local variable for efficiency.
                    const stack = this.stack;
                    const poppedElement = stack.pop();
                    if (poppedElement) {
                        const poppedNode = poppedElement.node;
                        // Remove this assertion only when it becomes a performance issue.
                        // assertNonTerminal(poppedNode.type);
                        if (poppedNode) {
                            /**
                             * The length of the stack following the pop operation.
                             */
                            const N = stack.length;
                            if (N !== 0) {
                                const node = stack[N - 1].node;
                                const children = node.children;
                                if (children) {
                                    children.push(poppedNode);
                                }
                            }
                            else {
                                // If the length of the stack following the pop is zero then the popped element becomes the root node.
                                this.rootNode = poppedNode;
                                poppedNode.used_names = this.used_names;
                            }
                        }
                    }
                }
            }
            /**
             * FIXME: This is O(N). Can we do better?
             * Finds the specified
             * @param a An array of arrays where each element is an array of two integers.
             * @param obj An array containing two integers.
             */
            function existsTransition(arcs, obj) {
                let i = arcs.length;
                while (i--) {
                    const arc = arcs[i];
                    if (arc[ARC_SYMBOL_LABEL] === obj[ARC_SYMBOL_LABEL] && arc[ARC_TO_STATE] === obj[ARC_TO_STATE]) {
                        return true;
                    }
                }
                return false;
            }
            /**
             * Constructs a Parser for interactive input.
             * Returns a function that should be called with a single line as input as they are entered.
             * The function will return false until the input is complete, when it will return the rootnode of the parse.
             *
             * @param style root of parse tree (optional)
             */
            function makeParser(sourceKind) {
                if (sourceKind === undefined)
                    sourceKind = SourceKind.File;
                const p = new Parser(ParseTables);
                // TODO: Can we do this over the symbolic constants?
                switch (sourceKind) {
                    case SourceKind.File: {
                        p.setup(ParseTables.sym.file_input);
                        break;
                    }
                    case SourceKind.Eval: {
                        p.setup(ParseTables.sym.eval_input);
                        break;
                    }
                    case SourceKind.Single: {
                        p.setup(ParseTables.sym.single_input);
                        break;
                    }
                    default: {
                        throw new Error("SourceKind must be one of File, Eval, or Single.");
                    }
                }
                // let prefix = "";
                const tokenizer = new Tokenizer(sourceKind === SourceKind.Single, function tokenizerCallback(type, value, start, end, line) {
                    start[0];
                    start[1];
                    if (type === T_COMMENT || type === T_NL) {
                        // prefix += value;
                        end[0];
                        end[1];
                        if (value[value.length - 1] === "\n") ;
                        return undefined;
                    }
                    if (type === T_OP) {
                        type = OpMap[value];
                    }
                    // FIXME: We're creating an array object here for every token.
                    if (p.addtoken(type, value, start, end, line)) {
                        return true;
                    }
                    return undefined;
                });
                return function (line) {
                    const ret = tokenizer.generateTokens(line);
                    if (ret) {
                        if (ret !== "done") {
                            throw parseError("incomplete input");
                        }
                        return p.rootNode;
                    }
                    return false;
                };
            }
            /**
             * Determines the starting point in the grammar for parsing the source.
             */
            var SourceKind;
            (function (SourceKind) {
                /**
                 * Suitable for a module.
                 */
                SourceKind[SourceKind["File"] = 0] = "File";
                /**
                 * Suitable for execution.
                 */
                SourceKind[SourceKind["Eval"] = 1] = "Eval";
                /**
                 * Suitable for a REPL.
                 */
                SourceKind[SourceKind["Single"] = 2] = "Single";
            })(SourceKind || (SourceKind = {}));
            /**
             * Parses the sourceText into a Concrete Syntax Tree (the Parse Tree representation).
             * @param sourceText The source text
             * @param sourceKind The source kind (Default is File).
             * @returns
             */
            function parse(sourceText, sourceKind = SourceKind.File) {
                const parser = makeParser(sourceKind);
                const lines = splitSourceTextIntoLines(sourceText);
                // FIXME: Mixing the types this way is awkward for the consumer.
                let ret = false;
                for (const line of lines) {
                    ret = parser(line);
                }
                return ret;
            }
            /**
             * Concrete Syntax Tree
             */
            function cstDump(parseTree) {
                function parseTreeDump(n, indent) {
                    let ret = "";
                    if (isNonTerminal(n.type)) {
                        ret += indent + ParseTables.number2symbol[n.type] + "\n";
                        if (n.children) {
                            for (let i = 0; i < n.children.length; ++i) {
                                ret += parseTreeDump(n.children[i], "  " + indent);
                            }
                        }
                    }
                    else {
                        ret += indent + tokenNames[n.type] + ": " + n.value + "\n";
                    }
                    return ret;
                }
                return parseTreeDump(parseTree, "");
            }
            /**
             * Terminal symbols hsould be less than T_NT_OFFSET.
             * NT_OFFSET means non-terminal offset.
             */
            function assertTerminal(type) {
                assert(type < T_NT_OFFSET, "terminal symbols should be less than T_NT_OFFSET");
            }
            /*
            function assertNonTerminal(type: number): void {
                assert(isNonTerminal(type), "non terminal symbols should be greater than or equal to T_NT_OFFSET");
            }
            */
            function isNonTerminal(type) {
                return type >= T_NT_OFFSET;
            }

            /**
             * @param s
             */
            function floatAST(s) {
                const thing = {
                    text: s,
                    value: parseFloat(s),
                    isFloat: function () { return true; },
                    isInt: function () { return false; },
                    isLong: function () { return false; },
                    toString: function () { return s; }
                };
                return thing;
            }
            /**
             * @param n
             */
            function intAST(n) {
                const thing = {
                    value: n,
                    isFloat: function () { return false; },
                    isInt: function () { return true; },
                    isLong: function () { return false; },
                    toString: function () { return '' + n; }
                };
                return thing;
            }
            /**
             * @param {string} s
             */
            function longAST(s, radix) {
                const thing = {
                    text: s,
                    radix: radix,
                    isFloat: function () { return false; },
                    isInt: function () { return false; },
                    isLong: function () { return true; },
                    toString: function () { return s; }
                };
                return thing;
            }

            class Load {
            }
            class Store {
            }
            class Del {
            }
            class AugLoad {
            }
            class AugStore {
            }
            class Param {
            }
            /**
             * Logical AND (&&)
             */
            class And {
            }
            /**
             * Logical OR (||)
             */
            class Or {
            }
            /**
             * Addition (+)
             */
            class Add {
            }
            /**
             * Subtraction (-)
             */
            class Sub {
            }
            /**
             * Multiplication (*)
             */
            class Mult {
            }
            /**
             * Division (/)
             */
            class Div {
            }
            /**
             * Remainder (%)
             */
            class Mod {
            }
            /**
             * Exponentiation '**'
             */
            class Pow {
            }
            /**
             * Bitwise Left Shift (<<)
             */
            class LShift {
            }
            /**
             * Bitwise Right Shift (>>)
             */
            class RShift {
            }
            /**
             * Bitwise OR (|)
             */
            class BitOr {
            }
            /**
             * Bitwise XOR (^)
             */
            class BitXor {
            }
            /**
             * Bitwise AND (&)
             */
            class BitAnd {
            }
            /**
             * (//)
             */
            class FloorDiv {
            }
            /**
             * Bitwise NOT (~)
             */
            class Invert {
            }
            /**
             * Logical NOT (not)
             */
            class Not {
            }
            /**
             * Unary Plus (+)
             */
            class UAdd {
            }
            /**
             * Unary Minus (-)
             */
            class USub {
            }
            class Eq {
            }
            class NotEq {
            }
            class Lt {
            }
            class LtE {
            }
            class Gt {
            }
            class GtE {
            }
            class Is {
            }
            class IsNot {
            }
            class In {
            }
            class NotIn {
            }
            class RangeAnnotated {
                constructor(value, range) {
                    this.value = value;
                    this.range = range;
                    assert(typeof value !== 'undefined', "value must be defined.");
                }
            }
            class Expression {
                constructor() {
                    // Do noting yet.
                }
                accept(visitor) {
                    // accept must be implemented by derived classes.
                    throw new Error(`"Expression.accept" is not implemented. this=${JSON.stringify(this, null, 2)}`);
                }
            }
            class Statement {
                accept(visitor) {
                    // accept must be implemented by derived classes.
                    throw new Error(`"Statement.accept" is not implemented.`);
                }
            }
            class IterationStatement extends Statement {
            }
            class Module {
                constructor(body) {
                    this.body = body;
                }
                accept(visitor) {
                    visitor.module(this);
                }
            }
            class FunctionDef extends Statement {
                constructor(name, args, body, returnType, decorator_list, range) {
                    super();
                    this.range = range;
                    this.name = name;
                    this.args = args;
                    this.body = body;
                    this.decorator_list = decorator_list;
                    this.returnType = returnType;
                }
                accept(visitor) {
                    visitor.functionDef(this);
                }
            }
            class FunctionParamDef {
                constructor(name, type) {
                    this.name = name;
                    if (type) {
                        this.type = type;
                    }
                    else {
                        this.type = null;
                    }
                }
            }
            class ClassDef extends Statement {
                constructor(name, bases, body, decorator_list, range) {
                    super();
                    this.range = range;
                    this.name = name;
                    this.bases = bases;
                    this.body = body;
                    this.decorator_list = decorator_list;
                }
                accept(visitor) {
                    visitor.classDef(this);
                }
            }
            class ReturnStatement extends Statement {
                constructor(value, range) {
                    super();
                    this.range = range;
                    this.value = value;
                }
                accept(visitor) {
                    visitor.returnStatement(this);
                }
            }
            class DeleteStatement extends Statement {
                constructor(targets, range) {
                    super();
                    this.range = range;
                    this.targets = targets;
                }
            }
            class Assign extends Statement {
                constructor(targets, value, range, eqRange, type) {
                    super();
                    this.range = range;
                    this.eqRange = eqRange;
                    this.targets = targets;
                    this.value = value;
                    if (type) {
                        this.type = type;
                    }
                }
                accept(visitor) {
                    visitor.assign(this);
                }
            }
            class AugAssign extends Statement {
                constructor(target, op, value, range) {
                    super();
                    this.range = range;
                    this.target = target;
                    this.op = op;
                    this.value = value;
                }
            }
            class AnnAssign extends Statement {
                constructor(type, target, range) {
                    super();
                    this.range = range;
                    this.value = type;
                    this.target = target;
                }
                accept(visitor) {
                    visitor.annAssign(this);
                }
            }
            class Print extends Statement {
                constructor(dest, values, nl, range) {
                    super();
                    this.range = range;
                    this.dest = dest;
                    this.values = values;
                    this.nl = nl;
                }
                accept(visitor) {
                    visitor.print(this);
                }
            }
            class ForStatement extends Statement {
                constructor(target, iter, body, orelse, range) {
                    super();
                    this.range = range;
                    this.target = target;
                    this.iter = iter;
                    this.body = body;
                    this.orelse = orelse;
                }
                accept(visitor) {
                    visitor.forStatement(this);
                }
            }
            class WhileStatement extends IterationStatement {
                constructor(test, body, orelse, range) {
                    super();
                    this.range = range;
                    this.test = test;
                    this.body = body;
                    this.orelse = orelse;
                }
            }
            class IfStatement extends Statement {
                constructor(test, consequent, alternate, range) {
                    super();
                    this.range = range;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                }
                accept(visitor) {
                    visitor.ifStatement(this);
                }
            }
            class WithStatement extends Statement {
                constructor(context_expr, optional_vars, body, range) {
                    super();
                    this.range = range;
                    this.context_expr = context_expr;
                    this.optional_vars = optional_vars;
                    this.body = body;
                }
            }
            class Raise extends Statement {
                constructor(type, inst, tback, range) {
                    super();
                    this.range = range;
                    this.type = type;
                    this.inst = inst;
                    this.tback = tback;
                }
            }
            class TryExcept extends Statement {
                constructor(body, handlers, orelse, range) {
                    super();
                    this.range = range;
                    this.body = body;
                    this.handlers = handlers;
                    this.orelse = orelse;
                }
            }
            class TryFinally extends Statement {
                constructor(body, finalbody, range) {
                    super();
                    this.range = range;
                    this.body = body;
                    this.finalbody = finalbody;
                }
            }
            class Assert extends Statement {
                constructor(test, msg, range) {
                    super();
                    this.range = range;
                    this.test = test;
                    this.msg = msg;
                }
            }
            class ImportStatement extends Statement {
                constructor(names, range) {
                    super();
                    this.range = range;
                    this.names = names;
                }
            }
            class ImportFrom extends Statement {
                constructor(module, names, level, range) {
                    super();
                    this.range = range;
                    assert(typeof module.value === 'string', "module must be a string.");
                    assert(Array.isArray(names), "names must be an Array.");
                    this.module = module;
                    this.names = names;
                    this.level = level;
                }
                accept(visitor) {
                    visitor.importFrom(this);
                }
            }
            class Exec extends Statement {
                constructor(body, globals, locals, range) {
                    super();
                    this.range = range;
                    this.body = body;
                    this.globals = globals;
                    this.locals = locals;
                }
            }
            class Global extends Statement {
                constructor(names, range) {
                    super();
                    this.range = range;
                    this.names = names;
                }
            }
            class NonLocal extends Statement {
                constructor(names, range) {
                    super();
                    this.range = range;
                    this.names = names;
                }
            }
            class ExpressionStatement extends Statement {
                constructor(value, range) {
                    super();
                    this.range = range;
                    this.value = value;
                }
                accept(visitor) {
                    visitor.expressionStatement(this);
                }
            }
            class Pass extends Statement {
                constructor(range) {
                    super();
                    this.range = range;
                }
            }
            class BreakStatement extends Statement {
                constructor(range) {
                    super();
                    this.range = range;
                }
            }
            class ContinueStatement extends Statement {
                constructor(range) {
                    super();
                    this.range = range;
                }
            }
            class BoolOp extends Expression {
                constructor(op, values, range) {
                    super();
                    this.range = range;
                    this.op = op;
                    this.values = values;
                }
            }
            class BinOp extends Expression {
                constructor(lhs, ops, rhs, range) {
                    super();
                    this.range = range;
                    this.lhs = lhs;
                    this.op = ops.op;
                    this.opRange = ops.range;
                    this.rhs = rhs;
                }
                accept(visitor) {
                    visitor.binOp(this);
                }
            }
            class UnaryOp extends Expression {
                constructor(op, operand, range) {
                    super();
                    this.op = op;
                    this.operand = operand;
                    this.range = range;
                    assert(op === UAdd || op === USub || op === Invert || op === Not, "op must be defined.");
                    assert(!!operand, "operand must be defined");
                }
                accept(visitor) {
                    visitor.unaryOp(this);
                }
            }
            let Lambda$1 = class Lambda extends Expression {
                constructor(args, body, range) {
                    super();
                    this.range = range;
                    this.args = args;
                    this.body = body;
                }
            };
            class IfExp extends Expression {
                constructor(test, body, orelse, range) {
                    super();
                    this.range = range;
                    this.test = test;
                    this.body = body;
                    this.orelse = orelse;
                }
            }
            class Dict extends Expression {
                constructor(keys, values, range) {
                    super();
                    this.range = range;
                    this.keys = keys;
                    this.values = values;
                }
                accept(visitor) {
                    visitor.dict(this);
                }
            }
            class ListComp extends Expression {
                constructor(elt, generators, range) {
                    super();
                    this.range = range;
                    this.elt = elt;
                    this.generators = generators;
                }
            }
            class GeneratorExp extends Expression {
                constructor(elt, generators, range) {
                    super();
                    this.range = range;
                    this.elt = elt;
                    this.generators = generators;
                }
            }
            class Yield extends Expression {
                constructor(value, range) {
                    super();
                    this.range = range;
                    this.value = value;
                }
            }
            class Compare extends Expression {
                constructor(left, ops, comparators, range) {
                    super();
                    this.range = range;
                    this.left = left;
                    for (const op of ops) {
                        switch (op) {
                            case Eq: {
                                break;
                            }
                            case NotEq: {
                                break;
                            }
                            case Gt: {
                                break;
                            }
                            case GtE: {
                                break;
                            }
                            case Lt: {
                                break;
                            }
                            case LtE: {
                                break;
                            }
                            case In: {
                                break;
                            }
                            case NotIn: {
                                break;
                            }
                            case Is: {
                                break;
                            }
                            case IsNot: {
                                break;
                            }
                            default: {
                                throw new Error(`ops must only contain CompareOperator(s) but contains ${op}`);
                            }
                        }
                    }
                    this.ops = ops;
                    this.comparators = comparators;
                }
                accept(visitor) {
                    visitor.compareExpression(this);
                }
            }
            class Call extends Expression {
                constructor(func, args, keywords, starargs, kwargs) {
                    super();
                    this.func = func;
                    this.args = args;
                    this.keywords = keywords;
                    this.starargs = starargs;
                    this.kwargs = kwargs;
                }
                accept(visitor) {
                    visitor.callExpression(this);
                }
            }
            class Num extends Expression {
                constructor(n) {
                    super();
                    this.n = n;
                }
                accept(visitor) {
                    visitor.num(this);
                }
            }
            class Str extends Expression {
                constructor(s) {
                    super();
                    this.s = s;
                }
                accept(visitor) {
                    visitor.str(this);
                }
            }
            class Attribute extends Expression {
                constructor(value, attr, ctx, range) {
                    super();
                    this.range = range;
                    this.value = value;
                    this.attr = attr;
                    this.ctx = ctx;
                }
                accept(visitor) {
                    visitor.attribute(this);
                }
            }
            class Subscript extends Expression {
                constructor(value, slice, ctx, range) {
                    super();
                    this.range = range;
                    this.value = value;
                    this.slice = slice;
                    this.ctx = ctx;
                }
                accept(visitor) {
                    visitor.subscript(this);
                }
            }
            class Name extends Expression {
                constructor(id, ctx) {
                    super();
                    this.id = id;
                    this.ctx = ctx;
                }
                accept(visitor) {
                    visitor.name(this);
                }
            }
            class List extends Expression {
                constructor(elts, ctx, range) {
                    super();
                    this.range = range;
                    this.elts = elts;
                    this.ctx = ctx;
                }
                accept(visitor) {
                    visitor.list(this);
                }
            }
            class Tuple extends Expression {
                constructor(elts, ctx, range) {
                    super();
                    this.range = range;
                    this.elts = elts;
                    this.ctx = ctx;
                }
            }
            class Ellipsis {
                constructor() {
                    // Do nothing yet.
                }
            }
            class Slice {
                constructor(lower, upper, step) {
                    this.lower = lower;
                    this.upper = upper;
                    this.step = step;
                }
            }
            class ExtSlice {
                constructor(dims) {
                    this.dims = dims;
                }
            }
            class Index {
                constructor(value) {
                    this.value = value;
                }
            }
            class Comprehension {
                constructor(target, iter, ifs, range) {
                    this.range = range;
                    this.target = target;
                    this.iter = iter;
                    this.ifs = ifs;
                }
            }
            class ExceptHandler {
                constructor(type, name, body, range) {
                    this.range = range;
                    this.type = type;
                    this.name = name;
                    this.body = body;
                }
            }
            class Arguments {
                constructor(args, vararg, kwarg, defaults) {
                    this.args = args;
                    this.vararg = vararg;
                    this.kwarg = kwarg;
                    this.defaults = defaults;
                }
            }
            class Keyword {
                constructor(arg, value) {
                    this.arg = arg;
                    this.value = value;
                }
            }
            class Alias {
                constructor(name, asname) {
                    assert(typeof name.value === 'string');
                    assert(typeof asname === 'string' || asname === null);
                    this.name = name;
                    this.asname = asname;
                }
                toString() {
                    return `${this.name.value} as ${this.asname}`;
                }
            }
            Module.prototype['_astname'] = 'Module';
            Module.prototype['_fields'] = [
                'body', function (n) { return n.body; }
            ];
            Expression.prototype['_astname'] = 'Expression';
            Expression.prototype['_fields'] = [
                'body', function (n) {
                    // TOD: Expression is abstract so we should not be here?
                    return void 0;
                }
            ];
            FunctionDef.prototype['_astname'] = 'FunctionDef';
            FunctionDef.prototype['_fields'] = [
                'name', function (n) { return n.name.value; },
                'args', function (n) { return n.args; },
                'body', function (n) { return n.body; },
                'returnType', function (n) { return n.returnType; },
                'decorator_list', function (n) { return n.decorator_list; }
            ];
            ClassDef.prototype['_astname'] = 'ClassDef';
            ClassDef.prototype['_fields'] = [
                'name', function (n) { return n.name.value; },
                'bases', function (n) { return n.bases; },
                'body', function (n) { return n.body; },
                'decorator_list', function (n) { return n.decorator_list; }
            ];
            ReturnStatement.prototype['_astname'] = 'ReturnStatement';
            ReturnStatement.prototype['_fields'] = [
                'value', function (n) { return n.value; }
            ];
            DeleteStatement.prototype['_astname'] = 'DeleteStatement';
            DeleteStatement.prototype['_fields'] = [
                'targets', function (n) { return n.targets; }
            ];
            Assign.prototype['_astname'] = 'Assign';
            Assign.prototype['_fields'] = [
                'targets', function (n) { return n.targets; },
                'value', function (n) { return n.value; }
            ];
            AugAssign.prototype['_astname'] = 'AugAssign';
            AugAssign.prototype['_fields'] = [
                'target', function (n) { return n.target; },
                'op', function (n) { return n.op; },
                'value', function (n) { return n.value; }
            ];
            AnnAssign.prototype['_astname'] = 'AnnAssign';
            AnnAssign.prototype['_fields'] = [
                'target', function (n) { return n.target; },
                'type', function (n) { return n.value; }
            ];
            Print.prototype['_astname'] = 'Print';
            Print.prototype['_fields'] = [
                'dest', function (n) { return n.dest; },
                'values', function (n) { return n.values; },
                'nl', function (n) { return n.nl; }
            ];
            ForStatement.prototype['_astname'] = 'ForStatement';
            ForStatement.prototype['_fields'] = [
                'target', function (n) { return n.target; },
                'iter', function (n) { return n.iter; },
                'body', function (n) { return n.body; },
                'orelse', function (n) { return n.orelse; }
            ];
            WhileStatement.prototype['_astname'] = 'WhileStatement';
            WhileStatement.prototype['_fields'] = [
                'test', function (n) { return n.test; },
                'body', function (n) { return n.body; },
                'orelse', function (n) { return n.orelse; }
            ];
            IfStatement.prototype['_astname'] = 'IfStatement';
            IfStatement.prototype['_fields'] = [
                'test', function (n) { return n.test; },
                'consequent', function (n) { return n.consequent; },
                'alternate', function (n) { return n.alternate; }
            ];
            WithStatement.prototype['_astname'] = 'WithStatement';
            WithStatement.prototype['_fields'] = [
                'context_expr', function (n) { return n.context_expr; },
                'optional_vars', function (n) { return n.optional_vars; },
                'body', function (n) { return n.body; }
            ];
            Raise.prototype['_astname'] = 'Raise';
            Raise.prototype['_fields'] = [
                'type', function (n) { return n.type; },
                'inst', function (n) { return n.inst; },
                'tback', function (n) { return n.tback; }
            ];
            TryExcept.prototype['_astname'] = 'TryExcept';
            TryExcept.prototype['_fields'] = [
                'body', function (n) { return n.body; },
                'handlers', function (n) { return n.handlers; },
                'orelse', function (n) { return n.orelse; }
            ];
            TryFinally.prototype['_astname'] = 'TryFinally';
            TryFinally.prototype['_fields'] = [
                'body', function (n) { return n.body; },
                'finalbody', function (n) { return n.finalbody; }
            ];
            Assert.prototype['_astname'] = 'Assert';
            Assert.prototype['_fields'] = [
                'test', function (n) { return n.test; },
                'msg', function (n) { return n.msg; }
            ];
            ImportStatement.prototype['_astname'] = 'Import';
            ImportStatement.prototype['_fields'] = [
                'names', function (n) { return n.names; }
            ];
            ImportFrom.prototype['_astname'] = 'ImportFrom';
            ImportFrom.prototype['_fields'] = [
                'module', function (n) { return n.module.value; },
                'names', function (n) { return n.names; },
                'level', function (n) { return n.level; }
            ];
            Exec.prototype['_astname'] = 'Exec';
            Exec.prototype['_fields'] = [
                'body', function (n) { return n.body; },
                'globals', function (n) { return n.globals; },
                'locals', function (n) { return n.locals; }
            ];
            Global.prototype['_astname'] = 'Global';
            Global.prototype['_fields'] = [
                'names', function (n) { return n.names; }
            ];
            NonLocal.prototype['_astname'] = 'NonLocal';
            NonLocal.prototype['_fields'] = [
                'names', function (n) { return n.names; }
            ];
            ExpressionStatement.prototype['_astname'] = 'ExpressionStatement';
            ExpressionStatement.prototype['_fields'] = [
                'value', function (n) { return n.value; }
            ];
            Pass.prototype['_astname'] = 'Pass';
            Pass.prototype['_fields'] = [];
            BreakStatement.prototype['_astname'] = 'BreakStatement';
            BreakStatement.prototype['_fields'] = [];
            ContinueStatement.prototype['_astname'] = 'ContinueStatement';
            ContinueStatement.prototype['_fields'] = [];
            BoolOp.prototype['_astname'] = 'BoolOp';
            BoolOp.prototype['_fields'] = [
                'op', function (n) { return n.op; },
                'values', function (n) { return n.values; }
            ];
            BinOp.prototype['_astname'] = 'BinOp';
            BinOp.prototype['_fields'] = [
                'lhs', function (n) { return n.lhs; },
                'op', function (n) { return n.op; },
                'rhs', function (n) { return n.rhs; }
            ];
            UnaryOp.prototype['_astname'] = 'UnaryOp';
            UnaryOp.prototype['_fields'] = [
                'op', function (n) { return n.op; },
                'operand', function (n) { return n.operand; }
            ];
            Lambda$1.prototype['_astname'] = 'Lambda';
            Lambda$1.prototype['_fields'] = [
                'args', function (n) { return n.args; },
                'body', function (n) { return n.body; }
            ];
            IfExp.prototype['_astname'] = 'IfExp';
            IfExp.prototype['_fields'] = [
                'test', function (n) { return n.test; },
                'body', function (n) { return n.body; },
                'orelse', function (n) { return n.orelse; }
            ];
            Dict.prototype['_astname'] = 'Dict';
            Dict.prototype['_fields'] = [
                'keys', function (n) { return n.keys; },
                'values', function (n) { return n.values; }
            ];
            ListComp.prototype['_astname'] = 'ListComp';
            ListComp.prototype['_fields'] = [
                'elt', function (n) { return n.elt; },
                'generators', function (n) { return n.generators; }
            ];
            GeneratorExp.prototype['_astname'] = 'GeneratorExp';
            GeneratorExp.prototype['_fields'] = [
                'elt', function (n) { return n.elt; },
                'generators', function (n) { return n.generators; }
            ];
            Yield.prototype['_astname'] = 'Yield';
            Yield.prototype['_fields'] = [
                'value', function (n) { return n.value; }
            ];
            Compare.prototype['_astname'] = 'Compare';
            Compare.prototype['_fields'] = [
                'left', function (n) { return n.left; },
                'ops', function (n) { return n.ops; },
                'comparators', function (n) { return n.comparators; }
            ];
            Call.prototype['_astname'] = 'Call';
            Call.prototype['_fields'] = [
                'func', function (n) { return n.func; },
                'args', function (n) { return n.args; },
                'keywords', function (n) { return n.keywords; },
                'starargs', function (n) { return n.starargs; },
                'kwargs', function (n) { return n.kwargs; }
            ];
            Num.prototype['_astname'] = 'Num';
            Num.prototype['_fields'] = [
                'n', function (n) { return n.n.value; }
            ];
            Str.prototype['_astname'] = 'Str';
            Str.prototype['_fields'] = [
                's', function (n) { return n.s.value; }
            ];
            Attribute.prototype['_astname'] = 'Attribute';
            Attribute.prototype['_fields'] = [
                'value', function (n) { return n.value; },
                'attr', function (n) { return n.attr.value; },
                'ctx', function (n) { return n.ctx; }
            ];
            Subscript.prototype['_astname'] = 'Subscript';
            Subscript.prototype['_fields'] = [
                'value', function (n) { return n.value; },
                'slice', function (n) { return n.slice; },
                'ctx', function (n) { return n.ctx; }
            ];
            Name.prototype['_astname'] = 'Name';
            Name.prototype['_fields'] = [
                'id', function (n) { return n.id.value; },
                'ctx', function (n) { return n.ctx; }
            ];
            List.prototype['_astname'] = 'List';
            List.prototype['_fields'] = [
                'elts', function (n) { return n.elts; },
                'ctx', function (n) { return n.ctx; }
            ];
            Tuple.prototype['_astname'] = 'Tuple';
            Tuple.prototype['_fields'] = [
                'elts', function (n) { return n.elts; },
                'ctx', function (n) { return n.ctx; }
            ];
            Load.prototype['_astname'] = 'Load';
            Load.prototype['_isenum'] = true;
            Store.prototype['_astname'] = 'Store';
            Store.prototype['_isenum'] = true;
            Del.prototype['_astname'] = 'Del';
            Del.prototype['_isenum'] = true;
            AugLoad.prototype['_astname'] = 'AugLoad';
            AugLoad.prototype['_isenum'] = true;
            AugStore.prototype['_astname'] = 'AugStore';
            AugStore.prototype['_isenum'] = true;
            Param.prototype['_astname'] = 'Param';
            Param.prototype['_isenum'] = true;
            Ellipsis.prototype['_astname'] = 'Ellipsis';
            Ellipsis.prototype['_fields'] = [];
            Slice.prototype['_astname'] = 'Slice';
            Slice.prototype['_fields'] = [
                'lower', function (n) { return n.lower; },
                'upper', function (n) { return n.upper; },
                'step', function (n) { return n.step; }
            ];
            ExtSlice.prototype['_astname'] = 'ExtSlice';
            ExtSlice.prototype['_fields'] = [
                'dims', function (n) { return n.dims; }
            ];
            Index.prototype['_astname'] = 'Index';
            Index.prototype['_fields'] = [
                'value', function (n) { return n.value; }
            ];
            And.prototype['_astname'] = 'And';
            And.prototype['_isenum'] = true;
            Or.prototype['_astname'] = 'Or';
            Or.prototype['_isenum'] = true;
            Add.prototype['_astname'] = 'Add';
            Add.prototype['_isenum'] = true;
            Sub.prototype['_astname'] = 'Sub';
            Sub.prototype['_isenum'] = true;
            Mult.prototype['_astname'] = 'Mult';
            Mult.prototype['_isenum'] = true;
            Div.prototype['_astname'] = 'Div';
            Div.prototype['_isenum'] = true;
            Mod.prototype['_astname'] = 'Mod';
            Mod.prototype['_isenum'] = true;
            Pow.prototype['_astname'] = 'Pow';
            Pow.prototype['_isenum'] = true;
            LShift.prototype['_astname'] = 'LShift';
            LShift.prototype['_isenum'] = true;
            RShift.prototype['_astname'] = 'RShift';
            RShift.prototype['_isenum'] = true;
            BitOr.prototype['_astname'] = 'BitOr';
            BitOr.prototype['_isenum'] = true;
            BitXor.prototype['_astname'] = 'BitXor';
            BitXor.prototype['_isenum'] = true;
            BitAnd.prototype['_astname'] = 'BitAnd';
            BitAnd.prototype['_isenum'] = true;
            FloorDiv.prototype['_astname'] = 'FloorDiv';
            FloorDiv.prototype['_isenum'] = true;
            Invert.prototype['_astname'] = 'Invert';
            Invert.prototype['_isenum'] = true;
            Not.prototype['_astname'] = 'Not';
            Not.prototype['_isenum'] = true;
            UAdd.prototype['_astname'] = 'UAdd';
            UAdd.prototype['_isenum'] = true;
            USub.prototype['_astname'] = 'USub';
            USub.prototype['_isenum'] = true;
            Eq.prototype['_astname'] = 'Eq';
            Eq.prototype['_isenum'] = true;
            NotEq.prototype['_astname'] = 'NotEq';
            NotEq.prototype['_isenum'] = true;
            Lt.prototype['_astname'] = 'Lt';
            Lt.prototype['_isenum'] = true;
            LtE.prototype['_astname'] = 'LtE';
            LtE.prototype['_isenum'] = true;
            Gt.prototype['_astname'] = 'Gt';
            Gt.prototype['_isenum'] = true;
            GtE.prototype['_astname'] = 'GtE';
            GtE.prototype['_isenum'] = true;
            Is.prototype['_astname'] = 'Is';
            Is.prototype['_isenum'] = true;
            IsNot.prototype['_astname'] = 'IsNot';
            IsNot.prototype['_isenum'] = true;
            In.prototype['_astname'] = 'In';
            In.prototype['_isenum'] = true;
            NotIn.prototype['_astname'] = 'NotIn';
            NotIn.prototype['_isenum'] = true;
            Comprehension.prototype['_astname'] = 'Comprehension';
            Comprehension.prototype['_fields'] = [
                'target', function (n) { return n.target; },
                'iter', function (n) { return n.iter; },
                'ifs', function (n) { return n.ifs; }
            ];
            ExceptHandler.prototype['_astname'] = 'ExceptHandler';
            ExceptHandler.prototype['_fields'] = [
                'type', function (n) { return n.type; },
                'name', function (n) { return n.name; },
                'body', function (n) { return n.body; }
            ];
            Arguments.prototype['_astname'] = 'Arguments';
            Arguments.prototype['_fields'] = [
                'args', function (n) { return n.args; },
                'vararg', function (n) { return n.vararg; },
                'kwarg', function (n) { return n.kwarg; },
                'defaults', function (n) { return n.defaults; }
            ];
            Keyword.prototype['_astname'] = 'Keyword';
            Keyword.prototype['_fields'] = [
                'arg', function (n) { return n.arg.value; },
                'value', function (n) { return n.value; }
            ];
            FunctionParamDef.prototype['_astname'] = 'FunctionParamDef';
            FunctionParamDef.prototype['_fields'] = [
                'name', function (n) { return n.name; },
                'type', function (n) { return n.type; }
            ];
            Alias.prototype['_astname'] = 'Alias';
            Alias.prototype['_fields'] = [
                'name', function (n) { return n.name.value; },
                'asname', function (n) { return n.asname; }
            ];

            //
            // This is pretty much a straight port of ast.c from CPython 2.6.5.
            //
            // The previous version was easier to work with and more JS-ish, but having a
            // somewhat different ast structure than cpython makes testing more difficult.
            //
            // This way, we can use a dump from the ast module on any arbitrary python
            // code and know that we're the same up to ast level, at least.
            //
            const SYM = ParseTables.sym;
            /**
             *
             */
            const LONG_THRESHOLD = Math.pow(2, 53);
            /**
             * FIXME: Consolidate with parseError in parser.
             */
            function syntaxError(message, range) {
                assert(isString(message), "message must be a string");
                assert(isNumber(range.begin.line), "lineNumber must be a number");
                const e = new SyntaxError(message /*, fileName*/);
                e['lineNumber'] = range.begin.line;
                return e;
            }
            class Compiling {
                constructor(encoding) {
                    this.c_encoding = encoding;
                }
            }
            /**
             * Asserts that the type of the node is that specified.
             */
            function REQ(n, type) {
                // Avoid the cost of building the message string when there is no issue.
                if (n.type !== type) {
                    fail(`node must have type ${type} = ${grammarName(type)}, but was ${n.type} = ${grammarName(n.type)}.`);
                }
            }
            /**
             * Nothing more than assertion that the argument is a string.
             */
            function strobj(s) {
                // Avoid the cost of building the message string when there is no issue.
                if (typeof s !== 'string') {
                    fail("expecting string, got " + (typeof s));
                }
                // This previously constructed the runtime representation.
                // That may have had an string intern side effect?
                return s;
            }
            function numStmts(n) {
                switch (n.type) {
                    case SYM.single_input:
                        if (CHILD(n, 0).type === Tokens.T_NEWLINE)
                            return 0;
                        else
                            return numStmts(CHILD(n, 0));
                    case SYM.file_input:
                        let cnt = 0;
                        for (let i = 0; i < NCH(n); ++i) {
                            const ch = CHILD(n, i);
                            if (ch.type === SYM.stmt) {
                                cnt += numStmts(ch);
                            }
                        }
                        return cnt;
                    case SYM.stmt:
                        return numStmts(CHILD(n, 0));
                    case SYM.compound_stmt:
                        return 1;
                    case SYM.simple_stmt:
                        return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s
                    case SYM.suite:
                        if (NCH(n) === 1)
                            return numStmts(CHILD(n, 0));
                        else {
                            let cnt = 0;
                            for (let i = 2; i < NCH(n) - 1; ++i) {
                                cnt += numStmts(CHILD(n, i));
                            }
                            return cnt;
                        }
                    default: {
                        throw new Error("Non-statement found");
                    }
                }
            }
            function forbiddenCheck(c, n, x, range) {
                if (x === "None")
                    throw syntaxError("assignment to None", range);
                if (x === "True" || x === "False")
                    throw syntaxError("assignment to True or False is forbidden", range);
            }
            /**
             * Set the context ctx for e, recursively traversing e.
             *
             * Only sets context for expr kinds that can appear in assignment context as
             * per the asdl file.
             */
            function setContext(c, e, ctx, n) {
                assert(ctx !== AugStore && ctx !== AugLoad);
                let s = null;
                let exprName = null;
                if (e instanceof Attribute) {
                    if (ctx === Store)
                        forbiddenCheck(c, n, e.attr.value, n.range);
                    e.ctx = ctx;
                }
                else if (e instanceof Name) {
                    if (ctx === Store)
                        forbiddenCheck(c, n, /*e.attr*/ void 0, n.range);
                    e.ctx = ctx;
                }
                else if (e instanceof Subscript) {
                    e.ctx = ctx;
                }
                else if (e instanceof List) {
                    e.ctx = ctx;
                    s = e.elts;
                }
                else if (e instanceof Tuple) {
                    if (e.elts.length === 0) {
                        throw syntaxError("can't assign to ()", n.range);
                    }
                    e.ctx = ctx;
                    s = e.elts;
                }
                else if (e instanceof Lambda$1) {
                    exprName = "lambda";
                }
                else if (e instanceof Call) {
                    exprName = "function call";
                }
                else if (e instanceof BoolOp) {
                    exprName = "operator";
                }
                else {
                    switch (e.constructor) {
                        case BoolOp:
                        case BinOp:
                        case UnaryOp:
                            exprName = "operator";
                            break;
                        case GeneratorExp:
                            exprName = "generator expression";
                            break;
                        case Yield:
                            exprName = "yield expression";
                            break;
                        case ListComp:
                            exprName = "list comprehension";
                            break;
                        case Dict:
                        case Num:
                        case Str:
                            exprName = "literal";
                            break;
                        case Compare:
                            exprName = "comparison expression";
                            break;
                        case IfExp:
                            exprName = "conditional expression";
                            break;
                        default: {
                            throw new Error("unhandled expression in assignment");
                        }
                    }
                }
                if (exprName) {
                    throw syntaxError("can't " + (ctx === Store ? "assign to" : "delete") + " " + exprName, n.range);
                }
                if (s) {
                    for (const e of s) {
                        setContext(c, e, ctx, n);
                    }
                }
            }
            /**
             * Contains a map from a token identifier to an operator class.
             * Missing: JavaScript Bitwise Unsigned Right Shift (>>>)
             * Missing: "Relational" operators... Less Than, LessThan Or Equal WHY?
             * Missing: "Equality" Operators. WHY?
             */
            const operatorMap = {};
            (function () {
                // Exponentiation
                operatorMap[Tokens.T_DOUBLESTAR] = Pow;
                // Multiplication
                operatorMap[Tokens.T_STAR] = Mult;
                // Division
                operatorMap[Tokens.T_SLASH] = Div;
                // Remainder
                operatorMap[Tokens.T_PERCENT] = Mod;
                // Addition
                operatorMap[Tokens.T_PLUS] = Add;
                // Subtraction
                operatorMap[Tokens.T_MINUS] = Sub;
                // Bitwise Left Shift
                operatorMap[Tokens.T_LEFTSHIFT] = LShift;
                // Bitwise Right Shift
                operatorMap[Tokens.T_RIGHTSHIFT] = RShift;
                // Bitwise AND (&)
                operatorMap[Tokens.T_AMPER] = BitAnd;
                // Bitwise XOR (^)
                operatorMap[Tokens.T_CIRCUMFLEX] = BitXor;
                // Bitwise OR (|)
                operatorMap[Tokens.T_VBAR] = BitOr;
                // Python FloorDiv
                operatorMap[Tokens.T_DOUBLESLASH] = FloorDiv;
            }());
            /**
             * Creates the structure for describing an operator and its range.
             * Looks up the operator class in the operatorMap.
             * Use the range from the concrete syntax tree node.
             *
             * @param n The node in the concrete syntax tree.
             */
            function getOperator(n) {
                assert(operatorMap[n.type] !== undefined, `${n.type}`);
                return { op: operatorMap[n.type], range: n.range };
            }
            function astForCompOp(c, n) {
                // comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is' |'is' 'not'
                REQ(n, SYM.comp_op);
                if (NCH(n) === 1) {
                    n = CHILD(n, 0);
                    switch (n.type) {
                        case Tokens.T_LESS: return Lt;
                        case Tokens.T_GREATER: return Gt;
                        case Tokens.T_EQEQUAL: return Eq;
                        case Tokens.T_LESSEQUAL: return LtE;
                        case Tokens.T_GREATEREQUAL: return GtE;
                        case Tokens.T_NOTEQUAL: return NotEq;
                        case Tokens.T_NAME:
                            if (n.value === "in")
                                return In;
                            if (n.value === "is")
                                return Is;
                    }
                }
                else if (NCH(n) === 2) {
                    if (CHILD(n, 0).type === Tokens.T_NAME) {
                        if (CHILD(n, 1).value === "in")
                            return NotIn;
                        if (CHILD(n, 0).value === "is")
                            return IsNot;
                    }
                }
                throw new Error("invalid comp_op");
            }
            function seqForTestlist(c, n) {
                /* testlist: test (',' test)* [','] */
                assert(n.type === SYM.testlist ||
                    n.type === SYM.listmaker ||
                    n.type === SYM.testlist_gexp ||
                    n.type === SYM.testlist_safe ||
                    n.type === SYM.testlist1);
                const seq = [];
                for (let i = 0; i < NCH(n); i += 2) {
                    assert(CHILD(n, i).type === SYM.IfExpr || CHILD(n, i).type === SYM.old_test);
                    seq[i / 2] = astForExpr(c, CHILD(n, i));
                }
                return seq;
            }
            function astForSuite(c, n) {
                /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
                REQ(n, SYM.suite);
                const seq = [];
                let pos = 0;
                let ch;
                if (CHILD(n, 0).type === SYM.simple_stmt) {
                    n = CHILD(n, 0);
                    /* simple_stmt always ends with an NEWLINE and may have a trailing
                        * SEMI. */
                    let end = NCH(n) - 1;
                    if (CHILD(n, end - 1).type === Tokens.T_SEMI) {
                        end -= 1;
                    }
                    // by 2 to skip
                    for (let i = 0; i < end; i += 2) {
                        seq[pos++] = astForStmt(c, CHILD(n, i));
                    }
                }
                else {
                    for (let i = 2; i < NCH(n) - 1; ++i) {
                        ch = CHILD(n, i);
                        REQ(ch, SYM.stmt);
                        let num = numStmts(ch);
                        if (num === 1) {
                            // small_stmt or compound_stmt w/ only 1 child
                            seq[pos++] = astForStmt(c, ch);
                        }
                        else {
                            ch = CHILD(ch, 0);
                            REQ(ch, SYM.simple_stmt);
                            for (let j = 0; j < NCH(ch); j += 2) {
                                if (NCH(CHILD(ch, j)) === 0) {
                                    assert(j + 1 === NCH(ch));
                                    break;
                                }
                                seq[pos++] = astForStmt(c, CHILD(ch, j));
                            }
                        }
                    }
                }
                assert(pos === numStmts(n));
                return seq;
            }
            function astForExceptClause(c, exc, body) {
                /* except_clause: 'except' [test [(',' | 'as') test]] */
                REQ(exc, SYM.except_clause);
                REQ(body, SYM.suite);
                if (NCH(exc) === 1) {
                    return new ExceptHandler(null, null, astForSuite(c, body), exc.range);
                }
                else if (NCH(exc) === 2)
                    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.range);
                else if (NCH(exc) === 4) {
                    const e = astForExpr(c, CHILD(exc, 3));
                    setContext(c, e, Store, CHILD(exc, 3));
                    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.range);
                }
                else {
                    throw new Error("wrong number of children for except clause");
                }
            }
            function astForTryStmt(c, n) {
                const nc = NCH(n);
                let nexcept = (nc - 3) / 3;
                let orelse = [];
                let finally_ = null;
                REQ(n, SYM.try_stmt);
                let body = astForSuite(c, CHILD(n, 2));
                if (CHILD(n, nc - 3).type === Tokens.T_NAME) {
                    if (CHILD(n, nc - 3).value === "finally") {
                        if (nc >= 9 && CHILD(n, nc - 6).type === Tokens.T_NAME) {
                            /* we can assume it's an "else",
                                because nc >= 9 for try-else-finally and
                                it would otherwise have a type of except_clause */
                            orelse = astForSuite(c, CHILD(n, nc - 4));
                            nexcept--;
                        }
                        finally_ = astForSuite(c, CHILD(n, nc - 1));
                        nexcept--;
                    }
                    else {
                        /* we can assume it's an "else",
                            otherwise it would have a type of except_clause */
                        orelse = astForSuite(c, CHILD(n, nc - 1));
                        nexcept--;
                    }
                }
                else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
                    throw syntaxError("malformed 'try' statement", n.range);
                }
                if (nexcept > 0) {
                    const handlers = [];
                    for (let i = 0; i < nexcept; ++i) {
                        handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
                    }
                    const exceptSt = new TryExcept(body, handlers, orelse, n.range);
                    if (!finally_)
                        return exceptSt;
                    /* if a 'finally' is present too, we nest the TryExcept within a
                        TryFinally to emulate try ... except ... finally */
                    body = [exceptSt];
                }
                assert(finally_ !== null);
                return new TryFinally(body, finally_, n.range);
            }
            function astForDottedName(c, n) {
                REQ(n, SYM.dotted_name);
                const child = CHILD(n, 0);
                let id = new RangeAnnotated(child.value, child.range);
                let e = new Name(id, Load);
                for (let i = 2; i < NCH(n); i += 2) {
                    const child = CHILD(n, i);
                    id = new RangeAnnotated(child.value, child.range);
                    e = new Attribute(e, id, Load, n.range);
                }
                return e;
            }
            function astForDecorator(c, n) {
                /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
                REQ(n, SYM.decorator);
                REQ(CHILD(n, 0), Tokens.T_AT);
                REQ(CHILD(n, NCH(n) - 1), Tokens.T_NEWLINE);
                const nameExpr = astForDottedName(c, CHILD(n, 1));
                if (NCH(n) === 3) // no args
                    return nameExpr;
                else if (NCH(n) === 5) // call with no args
                    return new Call(nameExpr, [], [], null, null);
                else
                    return astForCall(c, CHILD(n, 3), nameExpr);
            }
            function astForDecorators(c, n) {
                REQ(n, SYM.decorators);
                const decoratorSeq = [];
                for (let i = 0; i < NCH(n); ++i) {
                    decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
                }
                return decoratorSeq;
            }
            function astForDecorated(c, n) {
                REQ(n, SYM.decorated);
                const decoratorSeq = astForDecorators(c, CHILD(n, 0));
                assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);
                let thing = null;
                if (CHILD(n, 1).type === SYM.funcdef) {
                    thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);
                }
                else if (CHILD(n, 1).type === SYM.classdef) {
                    thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);
                }
                else {
                    throw new Error("astForDecorated");
                }
                return thing;
            }
            function astForWithVar(c, n) {
                REQ(n, SYM.with_var);
                return astForExpr(c, CHILD(n, 1));
            }
            function astForWithStmt(c, n) {
                /* with_stmt: 'with' test [ with_var ] ':' suite */
                let suiteIndex = 3; // skip with, test, :
                assert(n.type === SYM.with_stmt);
                const contextExpr = astForExpr(c, CHILD(n, 1));
                let optionalVars;
                if (CHILD(n, 2).type === SYM.with_var) {
                    optionalVars = astForWithVar(c, CHILD(n, 2));
                    setContext(c, optionalVars, Store, n);
                    suiteIndex = 4;
                }
                return new WithStatement(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.range);
            }
            function astForExecStmt(c, n) {
                let globals = null;
                let locals = null;
                const nchildren = NCH(n);
                assert(nchildren === 2 || nchildren === 4 || nchildren === 6);
                /* exec_stmt: 'exec' expr ['in' test [',' test]] */
                REQ(n, SYM.exec_stmt);
                const expr1 = astForExpr(c, CHILD(n, 1));
                if (nchildren >= 4) {
                    globals = astForExpr(c, CHILD(n, 3));
                }
                if (nchildren === 6) {
                    locals = astForExpr(c, CHILD(n, 5));
                }
                return new Exec(expr1, globals, locals, n.range);
            }
            function astForIfStmt(c, n) {
                /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
                    ['else' ':' suite]
                */
                REQ(n, SYM.if_stmt);
                if (NCH(n) === 4)
                    return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.range);
                const s = CHILD(n, 4).value;
                const decider = s.charAt(2); // elSe or elIf
                if (decider === 's') {
                    return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.range);
                }
                else if (decider === 'i') {
                    let nElif = NCH(n) - 4;
                    let hasElse = false;
                    let orelse = [];
                    /* must reference the child nElif+1 since 'else' token is third, not
                        * fourth child from the end. */
                    if (CHILD(n, nElif + 1).type === Tokens.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === 's') {
                        hasElse = true;
                        nElif -= 3;
                    }
                    nElif /= 4;
                    if (hasElse) {
                        orelse = [
                            new IfStatement(astForExpr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).range)
                        ];
                        nElif--;
                    }
                    for (let i = 0; i < nElif; ++i) {
                        const off = 5 + (nElif - i - 1) * 4;
                        orelse = [
                            new IfStatement(astForExpr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).range)
                        ];
                    }
                    return new IfStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.range);
                }
                throw new Error("unexpected token in 'if' statement");
            }
            function astForExprlist(c, n, context) {
                REQ(n, SYM.ExprList);
                const seq = [];
                for (let i = 0; i < NCH(n); i += 2) {
                    const e = astForExpr(c, CHILD(n, i));
                    seq[i / 2] = e;
                    if (context)
                        setContext(c, e, context, CHILD(n, i));
                }
                return seq;
            }
            function astForDelStmt(c, n) {
                REQ(n, SYM.del_stmt);
                return new DeleteStatement(astForExprlist(c, CHILD(n, 1), Del), n.range);
            }
            function astForGlobalStmt(c, n) {
                REQ(n, SYM.GlobalStmt);
                const s = [];
                for (let i = 1; i < NCH(n); i += 2) {
                    s[(i - 1) / 2] = strobj(CHILD(n, i).value);
                }
                return new Global(s, n.range);
            }
            function astForNonLocalStmt(c, n) {
                REQ(n, SYM.NonLocalStmt);
                const s = [];
                for (let i = 1; i < NCH(n); i += 2) {
                    s[(i - 1) / 2] = strobj(CHILD(n, i).value);
                }
                return new NonLocal(s, n.range);
            }
            function astForAssertStmt(c, n) {
                /* assert_stmt: 'assert' test [',' test] */
                REQ(n, SYM.assert_stmt);
                if (NCH(n) === 2) {
                    return new Assert(astForExpr(c, CHILD(n, 1)), null, n.range);
                }
                else if (NCH(n) === 4) {
                    return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.range);
                }
                throw new Error("improper number of parts to assert stmt");
            }
            function aliasForImportName(c, n) {
                /*
                    ImportSpecifier: NAME ['as' NAME]
                    dotted_as_name: dotted_name ['as' NAME]
                    dotted_name: NAME ('.' NAME)*
                */
                loop: while (true) {
                    switch (n.type) {
                        case SYM.ImportSpecifier: {
                            let str = null;
                            const nameNode = CHILD(n, 0);
                            const name = strobj(nameNode.value);
                            const nameRange = nameNode.range;
                            if (NCH(n) === 3) {
                                str = CHILD(n, 2).value;
                            }
                            return new Alias(new RangeAnnotated(name, nameRange), str == null ? null : strobj(str));
                        }
                        case SYM.dotted_as_name:
                            if (NCH(n) === 1) {
                                n = CHILD(n, 0);
                                continue loop;
                            }
                            else {
                                const a = aliasForImportName(c, CHILD(n, 0));
                                assert(!a.asname);
                                a.asname = strobj(CHILD(n, 2).value);
                                return a;
                            }
                        case SYM.dotted_name:
                            if (NCH(n) === 1) {
                                const nameNode = CHILD(n, 0);
                                const name = strobj(nameNode.value);
                                const nameRange = nameNode.range;
                                return new Alias(new RangeAnnotated(name, nameRange), null);
                            }
                            else {
                                // create a string of the form a.b.c
                                let str = '';
                                for (let i = 0; i < NCH(n); i += 2) {
                                    str += CHILD(n, i).value + ".";
                                }
                                return new Alias(new RangeAnnotated(str.substr(0, str.length - 1), null), null);
                            }
                        case Tokens.T_STAR: {
                            return new Alias(new RangeAnnotated("*", n.range), null);
                        }
                        case Tokens.T_NAME: {
                            // Temporary.
                            return new Alias(new RangeAnnotated(n.value, n.range), null);
                        }
                        default: {
                            throw syntaxError(`unexpected import name ${grammarName(n.type)}`, n.range);
                        }
                    }
                }
            }
            function parseModuleSpecifier(c, moduleSpecifierNode) {
                REQ(moduleSpecifierNode, SYM.ModuleSpecifier);
                const N = NCH(moduleSpecifierNode);
                let ret = "";
                let range;
                for (let i = 0; i < N; ++i) {
                    const child = CHILD(moduleSpecifierNode, i);
                    ret = ret + parsestr(c, child.value);
                    range = child.range;
                }
                return { value: ret, range };
            }
            function astForImportStmt(c, importStatementNode) {
                REQ(importStatementNode, SYM.import_stmt);
                let nameOrFrom = CHILD(importStatementNode, 0);
                if (nameOrFrom.type === SYM.import_name) {
                    const n = CHILD(nameOrFrom, 1);
                    REQ(n, SYM.dotted_as_names);
                    const aliases = [];
                    for (let i = 0; i < NCH(n); i += 2) {
                        aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
                    }
                    return new ImportStatement(aliases, importStatementNode.range);
                }
                else if (nameOrFrom.type === SYM.import_from) {
                    // let mod: Alias = null;
                    let moduleSpec;
                    let ndots = 0;
                    let nchildren;
                    let idx;
                    for (idx = 1; idx < NCH(nameOrFrom); ++idx) {
                        const child = CHILD(nameOrFrom, idx);
                        const childType = child.type;
                        if (childType === SYM.dotted_name) {
                            // This should be dead code since we support ECMAScript 2015 modules.
                            throw syntaxError(`unknown import statement ${grammarName(childType)}.`, child.range);
                            // mod = aliasForImportName(c, child);
                            // idx++;
                            // break;
                        }
                        else if (childType === SYM.ModuleSpecifier) {
                            moduleSpec = parseModuleSpecifier(c, child);
                            break;
                        }
                        else if (childType !== Tokens.T_DOT) {
                            // Let's be more specific...
                            throw syntaxError(`unknown import statement ${grammarName(childType)}.`, child.range);
                            // break;
                        }
                        ndots++;
                    }
                    ++idx; // skip the import keyword
                    let n = nameOrFrom;
                    switch (CHILD(nameOrFrom, idx).type) {
                        case Tokens.T_STAR: {
                            // from ... import
                            n = CHILD(nameOrFrom, idx);
                            nchildren = 1;
                            break;
                        }
                        case Tokens.T_LPAR: {
                            // from ... import (x, y, z)
                            n = CHILD(n, idx + 1);
                            nchildren = NCH(n);
                            break;
                        }
                        case SYM.ImportList: {
                            // from ... import x, y, z
                            n = CHILD(n, idx);
                            nchildren = NCH(n);
                            if (nchildren % 2 === 0) {
                                throw syntaxError("trailing comma not allowed without surrounding parentheses", n.range);
                            }
                        }
                    }
                    const aliases = [];
                    if (n.type === Tokens.T_STAR) {
                        aliases[0] = aliasForImportName(c, n);
                    }
                    else {
                        REQ(n, SYM.import_from);
                        const importListNode = CHILD(n, FIND(n, SYM.ImportList));
                        astForImportList(c, importListNode, aliases);
                    }
                    // moduleName = mod ? mod.name : moduleName;
                    assert(typeof moduleSpec.value === 'string');
                    return new ImportFrom(new RangeAnnotated(moduleSpec.value, moduleSpec.range), aliases, ndots, importStatementNode.range);
                }
                else {
                    throw syntaxError(`unknown import statement ${grammarName(nameOrFrom.type)}.`, nameOrFrom.range);
                }
            }
            function astForImportList(c, importListNode, aliases) {
                REQ(importListNode, SYM.ImportList);
                const N = NCH(importListNode);
                for (let i = 0; i < N; i++) {
                    const child = CHILD(importListNode, i);
                    if (child.type === SYM.ImportSpecifier) {
                        aliases.push(aliasForImportName(c, child));
                    }
                }
            }
            function astForTestlistGexp(c, n) {
                assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
                if (NCH(n) > 1 && CHILD(n, 1).type === SYM.gen_for)
                    return astForGenexp(c, n);
                return astForTestlist(c, n);
            }
            function astForListcomp(c, n) {
                function countListFors(c, n) {
                    let nfors = 0;
                    let ch = CHILD(n, 1);
                    count_list_for: while (true) {
                        nfors++;
                        REQ(ch, SYM.list_for);
                        if (NCH(ch) === 5)
                            ch = CHILD(ch, 4);
                        else
                            return nfors;
                        count_list_iter: while (true) {
                            REQ(ch, SYM.list_iter);
                            ch = CHILD(ch, 0);
                            if (ch.type === SYM.list_for)
                                continue count_list_for;
                            else if (ch.type === SYM.list_if) {
                                if (NCH(ch) === 3) {
                                    ch = CHILD(ch, 2);
                                    continue count_list_iter;
                                }
                                else
                                    return nfors;
                            }
                            break;
                        }
                        // FIXME: What does a break at the end of a function do?
                        break;
                    }
                    throw new Error("TODO: Should this be returning void 0?");
                }
                function countListIfs(c, n) {
                    let nifs = 0;
                    while (true) {
                        REQ(n, SYM.list_iter);
                        if (CHILD(n, 0).type === SYM.list_for)
                            return nifs;
                        n = CHILD(n, 0);
                        REQ(n, SYM.list_if);
                        nifs++;
                        if (NCH(n) === 2)
                            return nifs;
                        n = CHILD(n, 2);
                    }
                }
                REQ(n, SYM.listmaker);
                assert(NCH(n) > 1);
                const elt = astForExpr(c, CHILD(n, 0));
                const nfors = countListFors(c, n);
                const listcomps = [];
                let ch = CHILD(n, 1);
                for (let i = 0; i < nfors; ++i) {
                    REQ(ch, SYM.list_for);
                    const forch = CHILD(ch, 1);
                    const t = astForExprlist(c, forch, Store);
                    const expression = astForTestlist(c, CHILD(ch, 3));
                    let lc;
                    if (NCH(forch) === 1)
                        lc = new Comprehension(t[0], expression, []);
                    else
                        lc = new Comprehension(new Tuple(t, Store, ch.range), expression, []);
                    if (NCH(ch) === 5) {
                        ch = CHILD(ch, 4);
                        const nifs = countListIfs(c, ch);
                        const ifs = [];
                        for (let j = 0; j < nifs; ++j) {
                            REQ(ch, SYM.list_iter);
                            ch = CHILD(ch, 0);
                            REQ(ch, SYM.list_if);
                            ifs[j] = astForExpr(c, CHILD(ch, 1));
                            if (NCH(ch) === 3)
                                ch = CHILD(ch, 2);
                        }
                        if (ch.type === SYM.list_iter)
                            ch = CHILD(ch, 0);
                        lc.ifs = ifs;
                    }
                    listcomps[i] = lc;
                }
                return new ListComp(elt, listcomps, n.range);
            }
            function astForUnaryExpr(c, n) {
                if (CHILD(n, 0).type === Tokens.T_MINUS && NCH(n) === 2) {
                    const pfactor = CHILD(n, 1);
                    if (pfactor.type === SYM.UnaryExpr && NCH(pfactor) === 1) {
                        const ppower = CHILD(pfactor, 0);
                        if (ppower.type === SYM.PowerExpr && NCH(ppower) === 1) {
                            const patom = CHILD(ppower, 0);
                            if (patom.type === SYM.AtomExpr) {
                                const pnum = CHILD(patom, 0);
                                if (pnum.type === Tokens.T_NUMBER) {
                                    pnum.value = "-" + pnum.value;
                                    return astForAtomExpr(c, patom);
                                }
                            }
                        }
                    }
                }
                const expression = astForExpr(c, CHILD(n, 1));
                switch (CHILD(n, 0).type) {
                    case Tokens.T_PLUS: return new UnaryOp(UAdd, expression, n.range);
                    case Tokens.T_MINUS: return new UnaryOp(USub, expression, n.range);
                    case Tokens.T_TILDE: return new UnaryOp(Invert, expression, n.range);
                }
                throw new Error("unhandled UnaryExpr");
            }
            function astForForStmt(c, n) {
                let seq = [];
                REQ(n, SYM.for_stmt);
                if (NCH(n) === 9) {
                    seq = astForSuite(c, CHILD(n, 8));
                }
                const nodeTarget = CHILD(n, 1);
                const _target = astForExprlist(c, nodeTarget, Store);
                let target;
                if (NCH(nodeTarget) === 1)
                    target = _target[0];
                else
                    target = new Tuple(_target, Store, n.range);
                return new ForStatement(target, astForTestlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.range);
            }
            function astForCall(c, n, func) {
                /*
                    arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
                            | '**' test)
                    argument: [test '='] test [gen_for]        # Really [keyword '='] test
                */
                REQ(n, SYM.arglist);
                let nargs = 0;
                let nkeywords = 0;
                let ngens = 0;
                for (let i = 0; i < NCH(n); ++i) {
                    const ch = CHILD(n, i);
                    if (ch.type === SYM.argument) {
                        if (NCH(ch) === 1)
                            nargs++;
                        else if (CHILD(ch, 1).type === SYM.gen_for)
                            ngens++;
                        else
                            nkeywords++;
                    }
                }
                if (ngens > 1 || (ngens && (nargs || nkeywords)))
                    throw syntaxError("Generator expression must be parenthesized if not sole argument", n.range);
                if (nargs + nkeywords + ngens > 255)
                    throw syntaxError("more than 255 arguments", n.range);
                const args = [];
                const keywords = [];
                nargs = 0;
                nkeywords = 0;
                let vararg = null;
                let kwarg = null;
                for (let i = 0; i < NCH(n); ++i) {
                    const ch = CHILD(n, i);
                    if (ch.type === SYM.argument) {
                        if (NCH(ch) === 1) {
                            if (nkeywords)
                                throw syntaxError("non-keyword arg after keyword arg", n.range);
                            if (vararg)
                                throw syntaxError("only named arguments may follow *expression", n.range);
                            args[nargs++] = astForExpr(c, CHILD(ch, 0));
                        }
                        else if (CHILD(ch, 1).type === SYM.gen_for)
                            args[nargs++] = astForGenexp(c, ch);
                        else {
                            const e = astForExpr(c, CHILD(ch, 0));
                            if (e.constructor === Lambda$1) {
                                throw syntaxError("lambda cannot contain assignment", n.range);
                            }
                            else if (e.constructor !== Name) {
                                throw syntaxError("keyword can't be an expression", n.range);
                            }
                            // TODO: Why does TypeScript think that the type is never?
                            const key = e.id;
                            forbiddenCheck(c, CHILD(ch, 0), key.value, n.range);
                            for (let k = 0; k < nkeywords; ++k) {
                                const tmp = keywords[k].arg.value;
                                if (tmp === key.value)
                                    throw syntaxError("keyword argument repeated", n.range);
                            }
                            keywords[nkeywords++] = new Keyword(key, astForExpr(c, CHILD(ch, 2)));
                        }
                    }
                    else if (ch.type === Tokens.T_STAR)
                        vararg = astForExpr(c, CHILD(n, ++i));
                    else if (ch.type === Tokens.T_DOUBLESTAR)
                        kwarg = astForExpr(c, CHILD(n, ++i));
                }
                // Convert keywords to a Dict, which is one arg
                const keywordDict = keywordsToDict(keywords);
                if (keywordDict.keys.length !== 0) {
                    args.push(keywordDict);
                }
                return new Call(func, args, [], vararg, kwarg);
            }
            function keywordsToDict(keywords) {
                let keys = [];
                let values = [];
                for (const keyword of keywords) {
                    values.push(keyword.value);
                    keys.push(new Name(new RangeAnnotated(keyword.arg.value, keyword.arg.range), Load));
                }
                return new Dict(keys, values);
            }
            function astForTrailer(c, node, leftExpr) {
                /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
                    subscriptlist: subscript (',' subscript)* [',']
                    subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
                    */
                const n = node;
                const childZero = CHILD(n, 0);
                const childOne = CHILD(n, 1);
                const childTwo = CHILD(n, 2);
                REQ(n, SYM.trailer);
                if (childZero.type === Tokens.T_LPAR) {
                    if (NCH(n) === 2) {
                        return new Call(leftExpr, [], [], null, null);
                    }
                    else {
                        return astForCall(c, childOne, leftExpr);
                    }
                }
                else if (childZero.type === Tokens.T_DOT) {
                    return new Attribute(leftExpr, new RangeAnnotated(childOne.value, childOne.range), Load, n.range);
                }
                else {
                    REQ(childZero, Tokens.T_LSQB);
                    REQ(childTwo, Tokens.T_RSQB);
                    const n = childOne;
                    if (NCH(n) === 1)
                        return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.range);
                    else {
                        /* The grammar is ambiguous here. The ambiguity is resolved
                            by treating the sequence as a tuple literal if there are
                            no slice features.
                        */
                        let simple = true;
                        const slices = [];
                        for (let j = 0; j < NCH(n); j += 2) {
                            const slc = astForSlice(c, CHILD(n, j));
                            if (slc.constructor !== Index) {
                                simple = false;
                            }
                            slices[j / 2] = slc;
                        }
                        if (!simple) {
                            return new Subscript(leftExpr, new ExtSlice(slices), Load, n.range);
                        }
                        const elts = [];
                        for (let j = 0; j < slices.length; ++j) {
                            let slc = slices[j];
                            if (slc instanceof Index) {
                                assert(slc.value !== null && slc.value !== undefined);
                                elts[j] = slc.value;
                            }
                            else {
                                assert(slc instanceof Index);
                            }
                        }
                        const tuple = new Tuple(elts, Load, n.range);
                        return new Subscript(leftExpr, new Index(tuple), Load, n.range);
                    }
                }
            }
            function astForFlowStmt(c, n) {
                REQ(n, SYM.flow_stmt);
                const ch = CHILD(n, 0);
                switch (ch.type) {
                    case SYM.break_stmt: return new BreakStatement(n.range);
                    case SYM.continue_stmt: return new ContinueStatement(n.range);
                    case SYM.yield_stmt:
                        return new ExpressionStatement(astForExpr(c, CHILD(ch, 0)), n.range);
                    case SYM.return_stmt:
                        if (NCH(ch) === 1)
                            return new ReturnStatement(null, n.range);
                        else
                            return new ReturnStatement(astForTestlist(c, CHILD(ch, 1)), n.range);
                    case SYM.raise_stmt: {
                        if (NCH(ch) === 1)
                            return new Raise(null, null, null, n.range);
                        else if (NCH(ch) === 2)
                            return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.range);
                        else if (NCH(ch) === 4)
                            return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), null, n.range);
                        else if (NCH(ch) === 6)
                            return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), astForExpr(c, CHILD(ch, 5)), n.range);
                        else {
                            throw new Error("unhandled flow statement");
                        }
                    }
                    default: {
                        throw new Error("unexpected flow_stmt");
                    }
                }
            }
            function astForArguments(c, n) {
                /* parameters: '(' [varargslist] ')'
                    varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]
                        | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']
                */
                let ch;
                let vararg = null;
                let kwarg = null;
                if (n.type === SYM.parameters) {
                    if (NCH(n) === 2) // () as arglist
                        return new Arguments([], null, null, []);
                    n = CHILD(n, 1); // n is a varargslist here on out
                }
                REQ(n, SYM.varargslist);
                const args = [];
                const defaults = [];
                /* fpdef: NAME [':' IfExpr] | '(' fplist ')'
                    fplist: fpdef (',' fpdef)* [',']
                */
                let foundDefault = false;
                let i = 0;
                let j = 0; // index for defaults
                let k = 0; // index for args
                // loop through the children of the varargslist
                while (i < NCH(n)) {
                    ch = CHILD(n, i);
                    switch (ch.type) {
                        // If it is a fpdef - act here
                        case SYM.fpdef:
                            let complexArgs = 0;
                            let parenthesized = false;
                            handle_fpdef: while (true) {
                                if (i + 1 < NCH(n) && CHILD(n, i + 1).type === Tokens.T_EQUAL) {
                                    defaults[j++] = astForExpr(c, CHILD(n, i + 2));
                                    i += 2;
                                    foundDefault = true;
                                }
                                else if (foundDefault) {
                                    /* def f((x)=4): pass should raise an error.
                                        def f((x, (y))): pass will just incur the tuple unpacking warning. */
                                    if (parenthesized && !complexArgs)
                                        throw syntaxError("parenthesized arg with default", n.range);
                                    throw syntaxError("non-default argument follows default argument", n.range);
                                }
                                // For unpacking a tuple
                                if (NCH(ch) === 3 && ch.children[2].type === Tokens.T_RPAR) {
                                    ch = CHILD(ch, 1);
                                    // def foo((x)): is not complex, special case.
                                    if (NCH(ch) !== 1) {
                                        throw syntaxError("tuple parameter unpacking has been removed", n.range);
                                    }
                                    else {
                                        /* def foo((x)): setup for checking NAME below. */
                                        /* Loop because there can be many parens and tuple
                                            unpacking mixed in. */
                                        parenthesized = true;
                                        ch = CHILD(ch, 0);
                                        assert(ch.type === SYM.fpdef);
                                        continue handle_fpdef;
                                    }
                                }
                                // childzero here is possibly the 'NAME' in fpdef: NAME [':' IfExpr]
                                const childZero = CHILD(ch, 0);
                                if (childZero.type === Tokens.T_NAME) {
                                    forbiddenCheck(c, n, childZero.value, n.range);
                                    const id = new RangeAnnotated(childZero.value, childZero.range);
                                    /**
                                     * Setting the type of the param here, will be third child of fpdef if it exists
                                     * If it doesn't exist then set the type as null and have typescript attempt to infer it later
                                     */
                                    const paramTypeNode = CHILD(ch, 2);
                                    if (paramTypeNode) {
                                        let paramTypeExpr = astForExpr(c, paramTypeNode);
                                        args[k++] = new FunctionParamDef(new Name(id, Param), paramTypeExpr);
                                    }
                                    else {
                                        args[k++] = new FunctionParamDef(new Name(id, Param));
                                    }
                                }
                                i += 2;
                                if (parenthesized)
                                    throw syntaxError("parenthesized argument names are invalid", n.range);
                                break;
                            }
                            break;
                        case Tokens.T_STAR:
                            forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.range);
                            vararg = strobj(CHILD(n, i + 1).value);
                            i += 3;
                            break;
                        case Tokens.T_DOUBLESTAR:
                            forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.range);
                            kwarg = strobj(CHILD(n, i + 1).value);
                            i += 3;
                            break;
                        default: {
                            throw new Error("unexpected node in varargslist");
                        }
                    }
                }
                return new Arguments(args, vararg, kwarg, defaults);
            }
            function astForFuncdef(c, n, decoratorSeq) {
                /**
                 * funcdef: ['export'] def' NAME parameters ['->' IfExpr] ':' suite
                 */
                REQ(n, SYM.funcdef);
                const numberOfChildren = NCH(n);
                let ch1;
                let name;
                let args;
                // Name and args are 1 node further if 'export' exists
                if (numberOfChildren !== 8 && numberOfChildren !== 6) {
                    ch1 = CHILD(n, 1);
                    name = strobj(ch1.value);
                    forbiddenCheck(c, ch1, name, n.range);
                    args = astForArguments(c, CHILD(n, 2));
                }
                else {
                    ch1 = CHILD(n, 2);
                    name = strobj(ch1.value);
                    forbiddenCheck(c, ch1, name, n.range);
                    args = astForArguments(c, CHILD(n, 3));
                }
                // suite is either 4, 6 or 7, depending on whether functype exists
                let body;
                let returnType;
                // Neither Export nor FuncType exist
                if (numberOfChildren === 5) {
                    body = astForSuite(c, CHILD(n, 4));
                    returnType = null;
                }
                // Only Export exists
                else if (numberOfChildren === 6) {
                    body = astForSuite(c, CHILD(n, 5));
                    returnType = null;
                }
                // Only FuncType exists
                else if (numberOfChildren === 7) {
                    returnType = astForExpr(c, CHILD(n, 4));
                    body = astForSuite(c, CHILD(n, 6));
                }
                // Export AND FuncType exist
                else if (numberOfChildren === 8) {
                    returnType = astForExpr(c, CHILD(n, 5));
                    body = astForSuite(c, CHILD(n, 7));
                }
                else {
                    fail(`Was expecting 5, 7 or 8 children, received ${numberOfChildren} children`);
                }
                return new FunctionDef(new RangeAnnotated(name, ch1.range), args, body, returnType, decoratorSeq, n.range);
            }
            function astForClassBases(c, n) {
                const numberOfChildren = NCH(n);
                assert(numberOfChildren > 0);
                REQ(n, SYM.testlist);
                if (numberOfChildren === 1) {
                    return [astForExpr(c, CHILD(n, 0))];
                }
                return seqForTestlist(c, n);
            }
            function astForClassdef(c, node, decoratorSeq) {
                /**
                 * ['export'] 'class' NAME ['(' [testlist] ')'] ':' suite
                 */
                const n = node;
                const numberOfChildren = NCH(n);
                REQ(n, SYM.classdef);
                let nameNode;
                let className;
                let nameRange;
                if (numberOfChildren !== 5 && numberOfChildren !== 8) {
                    if (numberOfChildren !== 7 || CHILD(n, 4).type !== Tokens.T_RPAR) {
                        nameNode = CHILD(n, 1);
                        forbiddenCheck(c, n, nameNode.value, n.range);
                        className = strobj(nameNode.value);
                        nameRange = nameNode.range;
                    }
                }
                else {
                    nameNode = CHILD(n, 2);
                    forbiddenCheck(c, n, nameNode.value, n.range);
                    className = strobj(nameNode.value);
                    nameRange = nameNode.range;
                }
                // If grammar looks like 'class NAME : suite'
                if (numberOfChildren === 4) {
                    return new ClassDef(new RangeAnnotated(className, nameRange), [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.range);
                }
                // If grammar looks like 'export class NAME '(' ')' : suite'
                if (numberOfChildren === 7 && CHILD(n, 3).type !== Tokens.T_RPAR) ;
                const c3 = CHILD(n, 3);
                // If grammar looks like 'class NAME '(' ')' : suite'
                if (c3.type === Tokens.T_RPAR) {
                    return new ClassDef(new RangeAnnotated(className, nameRange), [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.range);
                }
                // Otherwise grammar looks like 'class NAME '(' testlist ')' : suite'
                // ClassBases are 'testlist'
                const bases = astForClassBases(c, c3);
                const s = astForSuite(c, CHILD(n, 6));
                return new ClassDef(new RangeAnnotated(className, nameRange), bases, s, decoratorSeq, n.range);
            }
            function astForLambdef(c, n) {
                let args;
                let expression;
                if (NCH(n) === 3) {
                    args = new Arguments([], null, null, []);
                    expression = astForExpr(c, CHILD(n, 2));
                }
                else {
                    args = astForArguments(c, CHILD(n, 1));
                    expression = astForExpr(c, CHILD(n, 3));
                }
                return new Lambda$1(args, expression, n.range);
            }
            function astForGenexp(c, n) {
                /* testlist_gexp: test ( gen_for | (',' test)* [','] )
                    argument: [test '='] test [gen_for]       # Really [keyword '='] test */
                assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
                assert(NCH(n) > 1);
                function countGenFors(c, n) {
                    let nfors = 0;
                    let ch = CHILD(n, 1);
                    count_gen_for: while (true) {
                        nfors++;
                        REQ(ch, SYM.gen_for);
                        if (NCH(ch) === 5)
                            ch = CHILD(ch, 4);
                        else
                            return nfors;
                        count_gen_iter: while (true) {
                            REQ(ch, SYM.gen_iter);
                            ch = CHILD(ch, 0);
                            if (ch.type === SYM.gen_for)
                                continue count_gen_for;
                            else if (ch.type === SYM.gen_if) {
                                if (NCH(ch) === 3) {
                                    ch = CHILD(ch, 2);
                                    continue count_gen_iter;
                                }
                                else
                                    return nfors;
                            }
                            break;
                        }
                        break;
                    }
                    throw new Error("logic error in countGenFors");
                }
                function countGenIfs(c, n) {
                    let nifs = 0;
                    while (true) {
                        REQ(n, SYM.gen_iter);
                        if (CHILD(n, 0).type === SYM.gen_for)
                            return nifs;
                        n = CHILD(n, 0);
                        REQ(n, SYM.gen_if);
                        nifs++;
                        if (NCH(n) === 2)
                            return nifs;
                        n = CHILD(n, 2);
                    }
                }
                const elt = astForExpr(c, CHILD(n, 0));
                const nfors = countGenFors(c, n);
                const genexps = [];
                let ch = CHILD(n, 1);
                for (let i = 0; i < nfors; ++i) {
                    REQ(ch, SYM.gen_for);
                    const forch = CHILD(ch, 1);
                    const t = astForExprlist(c, forch, Store);
                    let expression = astForExpr(c, CHILD(ch, 3));
                    let ge;
                    if (NCH(forch) === 1)
                        ge = new Comprehension(t[0], expression, []);
                    else
                        ge = new Comprehension(new Tuple(t, Store, ch.range), expression, []);
                    if (NCH(ch) === 5) {
                        ch = CHILD(ch, 4);
                        const nifs = countGenIfs(c, ch);
                        const ifs = [];
                        for (let j = 0; j < nifs; ++j) {
                            REQ(ch, SYM.gen_iter);
                            ch = CHILD(ch, 0);
                            REQ(ch, SYM.gen_if);
                            expression = astForExpr(c, CHILD(ch, 1));
                            ifs[j] = expression;
                            if (NCH(ch) === 3)
                                ch = CHILD(ch, 2);
                        }
                        if (ch.type === SYM.gen_iter)
                            ch = CHILD(ch, 0);
                        ge.ifs = ifs;
                    }
                    genexps[i] = ge;
                }
                return new GeneratorExp(elt, genexps, n.range);
            }
            function astForWhileStmt(c, n) {
                /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
                REQ(n, SYM.while_stmt);
                if (NCH(n) === 4)
                    return new WhileStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.range);
                else if (NCH(n) === 7)
                    return new WhileStatement(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.range);
                throw new Error("wrong number of tokens for 'while' stmt");
            }
            function astForAugassign(c, n) {
                REQ(n, SYM.augassign);
                n = CHILD(n, 0);
                switch (n.value.charAt(0)) {
                    case '+': return Add;
                    case '-': return Sub;
                    case '/': {
                        if (n.value.charAt(1) === '/') {
                            return FloorDiv;
                        }
                        else {
                            return Div;
                        }
                    }
                    case '%': return Mod;
                    case '<': return LShift;
                    case '>': return RShift;
                    case '&': return BitAnd;
                    case '^': return BitXor;
                    case '|': return BitOr;
                    case '*': {
                        if (n.value.charAt(1) === '*') {
                            return Pow;
                        }
                        else {
                            return Mult;
                        }
                    }
                    default: {
                        throw new Error("invalid augassign");
                    }
                }
            }
            function astForBinop(c, n) {
                /* Must account for a sequence of expressions.
                    How should A op B op C by represented?
                    BinOp(BinOp(A, op, B), op, C).
                */
                let result = new BinOp(astForExpr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), astForExpr(c, CHILD(n, 2)), n.range);
                const nops = (NCH(n) - 1) / 2;
                for (let i = 1; i < nops; ++i) {
                    const nextOper = CHILD(n, i * 2 + 1);
                    const tmp = astForExpr(c, CHILD(n, i * 2 + 2));
                    result = new BinOp(result, getOperator(nextOper), tmp, nextOper.range);
                }
                return result;
            }
            function astForTestlist(c, n) {
                /* testlist_gexp: test (',' test)* [','] */
                /* testlist: test (',' test)* [','] */
                /* testlist_safe: test (',' test)+ [','] */
                /* testlist1: test (',' test)* */
                assert(NCH(n) > 0);
                if (n.type === SYM.testlist_gexp) {
                    if (NCH(n) > 1) {
                        assert(CHILD(n, 1).type !== SYM.gen_for);
                    }
                }
                else {
                    assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
                }
                if (NCH(n) === 1) {
                    return astForExpr(c, CHILD(n, 0));
                }
                else {
                    return new Tuple(seqForTestlist(c, n), Load, n.range);
                }
            }
            function astForExprStmt(c, node) {
                // Prevent assignment.
                const n = node;
                REQ(n, SYM.ExprStmt);
                if (NCH(n) === 1) {
                    return new ExpressionStatement(astForTestlist(c, CHILD(n, 0)), n.range);
                }
                else if (CHILD(n, 1).type === SYM.augassign) {
                    let ch = CHILD(n, 0);
                    const expr1 = astForTestlist(c, ch);
                    switch (expr1.constructor) {
                        case GeneratorExp: throw syntaxError("augmented assignment to generator expression not possible", n.range);
                        case Yield: throw syntaxError("augmented assignment to yield expression not possible", n.range);
                        case Name: {
                            const varName = expr1.id;
                            forbiddenCheck(c, ch, varName.value, n.range);
                            break;
                        }
                        case Attribute:
                        case Subscript:
                            break;
                        default:
                            throw syntaxError("illegal expression for augmented assignment", n.range);
                    }
                    setContext(c, expr1, Store, ch);
                    ch = CHILD(n, 2);
                    let expr2;
                    if (ch.type === SYM.testlist) {
                        expr2 = astForTestlist(c, ch);
                    }
                    else
                        expr2 = astForExpr(c, ch);
                    return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.range);
                }
                else if (CHILD(n, 1).type === SYM.annasign) {
                    // annasign
                    // ':' 'IfExpr' ['=' 'IfExpr]
                    const ch = CHILD(n, 0);
                    const annasignChild = CHILD(n, 1);
                    const type = astForExpr(c, CHILD(annasignChild, 1));
                    const eq = CHILD(annasignChild, 2); // Equals sign
                    if (eq) {
                        REQ(eq, Tokens.T_EQUAL);
                        const variable = [astForTestlist(c, ch)]; // variable is the first node (before the annasign)
                        const valueNode = CHILD(annasignChild, 3);
                        let value;
                        if (valueNode.type === SYM.testlist) {
                            value = astForTestlist(c, valueNode);
                        }
                        else {
                            value = astForExpr(c, valueNode);
                        }
                        return new Assign(variable, value, n.range, eq.range, type);
                    }
                    else {
                        return new AnnAssign(type, astForTestlist(c, ch), n.range);
                    }
                }
                else {
                    // normal assignment
                    const eq = CHILD(n, 1);
                    REQ(eq, Tokens.T_EQUAL);
                    const targets = [];
                    const N = NCH(n);
                    for (let i = 0; i < N - 2; i += 2) {
                        const ch = CHILD(n, i);
                        if (ch.type === SYM.YieldExpr)
                            throw syntaxError("assignment to yield expression not possible", n.range);
                        const e = astForTestlist(c, ch);
                        setContext(c, e, Store, CHILD(n, i));
                        targets[i / 2] = e;
                    }
                    const value = CHILD(n, N - 1);
                    let expression;
                    if (value.type === SYM.testlist)
                        expression = astForTestlist(c, value);
                    else
                        expression = astForExpr(c, value);
                    return new Assign(targets, expression, n.range, eq.range);
                }
            }
            function astForIfexpr(c, n) {
                assert(NCH(n) === 5);
                return new IfExp(astForExpr(c, CHILD(n, 2)), astForExpr(c, CHILD(n, 0)), astForExpr(c, CHILD(n, 4)), n.range);
            }
            // escape() was deprecated in JavaScript 1.5. Use encodeURI or encodeURIComponent instead.
            function escape(s) {
                return encodeURIComponent(s);
            }
            /**
             * s is a python-style string literal, including quote characters and u/r/b
             * prefixes. Returns decoded string object.
             */
            function parsestr(c, s) {
                // const encodeUtf8 = function(s) { return unescape(encodeURIComponent(s)); };
                const decodeUtf8 = function (s) { return decodeURIComponent(escape(s)); };
                const decodeEscape = function (s, quote) {
                    const len = s.length;
                    let ret = '';
                    for (let i = 0; i < len; ++i) {
                        let c = s.charAt(i);
                        if (c === '\\') {
                            ++i;
                            c = s.charAt(i);
                            if (c === 'n')
                                ret += "\n";
                            else if (c === '\\')
                                ret += "\\";
                            else if (c === 't')
                                ret += "\t";
                            else if (c === 'r')
                                ret += "\r";
                            else if (c === 'b')
                                ret += "\b";
                            else if (c === 'f')
                                ret += "\f";
                            else if (c === 'v')
                                ret += "\v";
                            else if (c === '0')
                                ret += "\0";
                            else if (c === '"')
                                ret += '"';
                            else if (c === '\'')
                                ret += '\'';
                            else if (c === '\n') /* escaped newline, join lines */ ;
                            else if (c === 'x') {
                                const d0 = s.charAt(++i);
                                const d1 = s.charAt(++i);
                                ret += String.fromCharCode(parseInt(d0 + d1, 16));
                            }
                            else if (c === 'u' || c === 'U') {
                                const d0 = s.charAt(++i);
                                const d1 = s.charAt(++i);
                                const d2 = s.charAt(++i);
                                const d3 = s.charAt(++i);
                                ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));
                            }
                            else {
                                // Leave it alone
                                ret += "\\" + c;
                            }
                        }
                        else {
                            ret += c;
                        }
                    }
                    return ret;
                };
                let quote = s.charAt(0);
                let rawmode = false;
                if (quote === 'u' || quote === 'U') {
                    s = s.substr(1);
                    quote = s.charAt(0);
                }
                else if (quote === 'r' || quote === 'R') {
                    s = s.substr(1);
                    quote = s.charAt(0);
                    rawmode = true;
                }
                assert(quote !== 'b' && quote !== 'B', "todo; haven't done b'' strings yet");
                assert(quote === "'" || quote === '"' && s.charAt(s.length - 1) === quote);
                s = s.substr(1, s.length - 2);
                if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
                    assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
                    s = s.substr(2, s.length - 4);
                }
                if (rawmode || s.indexOf('\\') === -1) {
                    return strobj(decodeUtf8(s));
                }
                return strobj(decodeEscape(s));
            }
            /**
             *
             */
            function parsestrplus(c, n) {
                REQ(CHILD(n, 0), Tokens.T_STRING);
                let ret = "";
                for (let i = 0; i < NCH(n); ++i) {
                    const child = CHILD(n, i);
                    try {
                        ret = ret + parsestr(c, child.value);
                    }
                    catch (x) {
                        throw syntaxError("invalid string (possibly contains a unicode character)", child.range);
                    }
                }
                return ret;
            }
            function parsenumber(c, s, range) {
                const endChar = s.charAt(s.length - 1);
                if (endChar === 'j' || endChar === 'J') {
                    throw syntaxError("complex numbers are currently unsupported", range);
                }
                if (s.indexOf('.') !== -1) {
                    return floatAST(s);
                }
                // Handle integers of various bases
                let tmp = s;
                let value;
                let radix = 10;
                let neg = false;
                if (s.charAt(0) === '-') {
                    tmp = s.substr(1);
                    neg = true;
                }
                if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X')) {
                    // Hex
                    tmp = tmp.substring(2);
                    value = parseInt(tmp, 16);
                    radix = 16;
                }
                else if ((s.indexOf('e') !== -1) || (s.indexOf('E') !== -1)) {
                    // Float with exponent (needed to make sure e/E wasn't hex first)
                    return floatAST(s);
                }
                else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B')) {
                    // Binary
                    tmp = tmp.substring(2);
                    value = parseInt(tmp, 2);
                    radix = 2;
                }
                else if (tmp.charAt(0) === '0') {
                    if (tmp === "0") {
                        // Zero
                        value = 0;
                    }
                    else {
                        // Octal (Leading zero, but not actually zero)
                        if (endChar === 'l' || endChar === 'L') {
                            return longAST(s.substr(0, s.length - 1), 8);
                        }
                        else {
                            radix = 8;
                            tmp = tmp.substring(1);
                            if ((tmp.charAt(0) === 'o') || (tmp.charAt(0) === 'O')) {
                                tmp = tmp.substring(1);
                            }
                            value = parseInt(tmp, 8);
                        }
                    }
                }
                else {
                    // Decimal
                    if (endChar === 'l' || endChar === 'L') {
                        return longAST(s.substr(0, s.length - 1), radix);
                    }
                    else {
                        value = parseInt(tmp, radix);
                    }
                }
                // Convert to long
                if (value > LONG_THRESHOLD && Math.floor(value) === value && (s.indexOf('e') === -1 && s.indexOf('E') === -1)) {
                    // TODO: Does radix zero make sense?
                    return longAST(s, 0);
                }
                if (endChar === 'l' || endChar === 'L') {
                    return longAST(s.substr(0, s.length - 1), radix);
                }
                else {
                    if (neg) {
                        return intAST(-value);
                    }
                    else {
                        return intAST(value);
                    }
                }
            }
            function astForSlice(c, node) {
                const n = node;
                REQ(n, SYM.subscript);
                let ch = CHILD(n, 0);
                let lower = null;
                let upper = null;
                let step = null;
                if (ch.type === Tokens.T_DOT) {
                    return new Ellipsis();
                }
                if (NCH(n) === 1 && ch.type === SYM.IfExpr) {
                    const value = astForExpr(c, ch);
                    return new Index(value);
                }
                if (ch.type === SYM.IfExpr) {
                    lower = astForExpr(c, ch);
                }
                if (ch.type === Tokens.T_COLON) {
                    if (NCH(n) > 1) {
                        const n2 = CHILD(n, 1);
                        if (n2.type === SYM.IfExpr)
                            upper = astForExpr(c, n2);
                    }
                }
                else if (NCH(n) > 2) {
                    const n2 = CHILD(n, 2);
                    if (n2.type === SYM.IfExpr) {
                        upper = astForExpr(c, n2);
                    }
                }
                ch = CHILD(n, NCH(n) - 1);
                if (ch.type === SYM.sliceop) {
                    if (NCH(ch) === 1) {
                        ch = CHILD(ch, 0);
                        step = new Name(new RangeAnnotated("None", null), Load);
                    }
                    else {
                        ch = CHILD(ch, 1);
                        if (ch.type === SYM.IfExpr)
                            step = astForExpr(c, ch);
                    }
                }
                return new Slice(lower, upper, step);
            }
            function astForAtomExpr(c, n) {
                const c0 = CHILD(n, 0);
                switch (c0.type) {
                    case Tokens.T_NAME:
                        // All names start in Load context, but may be changed later
                        return new Name(new RangeAnnotated(c0.value, c0.range), Load);
                    case Tokens.T_STRING: {
                        // FIXME: Owing to the way that Python allows string concatenation, this is imprecise.
                        return new Str(new RangeAnnotated(parsestrplus(c, n), n.range));
                    }
                    case Tokens.T_NUMBER: {
                        return new Num(new RangeAnnotated(parsenumber(c, c0.value, c0.range), n.range));
                    }
                    case Tokens.T_LPAR: { // various uses for parens
                        const c1 = CHILD(n, 1);
                        if (c1.type === Tokens.T_RPAR) {
                            return new Tuple([], Load, n.range);
                        }
                        if (c1.type === SYM.YieldExpr) {
                            return astForExpr(c, c1);
                        }
                        if (NCH(c1) > 1 && CHILD(c1, 1).type === SYM.gen_for) {
                            return astForGenexp(c, c1);
                        }
                        return astForTestlistGexp(c, c1);
                    }
                    case Tokens.T_LSQB: { // list or listcomp
                        const c1 = CHILD(n, 1);
                        if (c1.type === Tokens.T_RSQB)
                            return new List([], Load, n.range);
                        REQ(c1, SYM.listmaker);
                        if (NCH(c1) === 1 || CHILD(c1, 1).type === Tokens.T_COMMA)
                            return new List(seqForTestlist(c, c1), Load, n.range);
                        else
                            return astForListcomp(c, c1);
                    }
                    case Tokens.T_LBRACE: {
                        /* dictmaker: test ':' test (',' test ':' test)* [','] */
                        const c1 = CHILD(n, 1);
                        const N = NCH(c1);
                        // var size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case
                        const keys = [];
                        const values = [];
                        for (let i = 0; i < N; i += 4) {
                            keys[i / 4] = astForExpr(c, CHILD(c1, i));
                            values[i / 4] = astForExpr(c, CHILD(c1, i + 2));
                        }
                        return new Dict(keys, values, n.range);
                    }
                    case Tokens.T_BACKQUOTE: {
                        throw syntaxError("backquote not supported, use repr()", n.range);
                    }
                    default: {
                        throw new Error(`unhandled atom '${grammarName(c0.type)}'`);
                    }
                }
            }
            /**
             * PowerExpr: AtomExpr trailer* ['**' UnaryExpr]
             */
            function astForPowerExpr(c, node) {
                const n = node;
                REQ(n, SYM.PowerExpr);
                const N = NCH(n);
                const NminusOne = N - 1;
                let lhs = astForAtomExpr(c, CHILD(n, 0));
                // If there is only one child then we have an AtomExpr with no trailer.
                if (N === 1)
                    return lhs;
                for (let i = 1; i < N; ++i) {
                    const ch = CHILD(n, i);
                    if (ch.type !== SYM.trailer) {
                        break;
                    }
                    lhs = astForTrailer(c, ch, lhs);
                }
                if (CHILD(n, NminusOne).type === SYM.UnaryExpr) {
                    const rhs = astForExpr(c, CHILD(n, NminusOne));
                    return new BinOp(lhs, getOperator(CHILD(n, N - 2)), rhs, n.range);
                }
                else {
                    return lhs;
                }
            }
            function astForExpr(c, n) {
                LOOP: while (true) {
                    switch (n.type) {
                        case SYM.IfExpr:
                        case SYM.old_test:
                            if (CHILD(n, 0).type === SYM.LambdaExpr || CHILD(n, 0).type === SYM.old_LambdaExpr)
                                return astForLambdef(c, CHILD(n, 0));
                            else if (NCH(n) > 1)
                                return astForIfexpr(c, n);
                        // fallthrough
                        case SYM.OrExpr:
                        case SYM.AndExpr:
                            if (NCH(n) === 1) {
                                n = CHILD(n, 0);
                                continue LOOP;
                            }
                            const seq = [];
                            for (let i = 0; i < NCH(n); i += 2) {
                                seq[i / 2] = astForExpr(c, CHILD(n, i));
                            }
                            if (CHILD(n, 1).value === "and") {
                                return new BoolOp(And, seq, n.range);
                            }
                            assert(CHILD(n, 1).value === "or");
                            return new BoolOp(Or, seq, n.range);
                        case SYM.NotExpr:
                            if (NCH(n) === 1) {
                                n = CHILD(n, 0);
                                continue LOOP;
                            }
                            else {
                                return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.range);
                            }
                        case SYM.ComparisonExpr:
                            if (NCH(n) === 1) {
                                n = CHILD(n, 0);
                                continue LOOP;
                            }
                            else {
                                const ops = [];
                                const cmps = [];
                                for (let i = 1; i < NCH(n); i += 2) {
                                    ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
                                    cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));
                                }
                                return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.range);
                            }
                        case SYM.ArithmeticExpr:
                        case SYM.GeometricExpr:
                        case SYM.ShiftExpr:
                        case SYM.BitwiseOrExpr:
                        case SYM.BitwiseXorExpr:
                        case SYM.BitwiseAndExpr:
                            if (NCH(n) === 1) {
                                n = CHILD(n, 0);
                                continue LOOP;
                            }
                            return astForBinop(c, n);
                        case SYM.YieldExpr:
                            let exp = null;
                            if (NCH(n) === 2) {
                                exp = astForTestlist(c, CHILD(n, 1));
                            }
                            return new Yield(exp, n.range);
                        case SYM.UnaryExpr:
                            if (NCH(n) === 1) {
                                n = CHILD(n, 0);
                                continue LOOP;
                            }
                            return astForUnaryExpr(c, n);
                        case SYM.PowerExpr:
                            return astForPowerExpr(c, n);
                        default: {
                            // TODO: Opportunity for structured Error here.
                            throw new Error(`unhandled expr: n.type: ${n.type}, n.value: ${n.value}, n.range= ${n.range}, dump=${cstDump(n)}`);
                        }
                    }
                }
            }
            function astForPrintStmt(c, n) {
                let start = 1;
                let dest = null;
                REQ(n, SYM.print_stmt);
                if (NCH(n) >= 2 && CHILD(n, 1).type === Tokens.T_RIGHTSHIFT) {
                    dest = astForExpr(c, CHILD(n, 2));
                    start = 4;
                }
                const seq = [];
                for (let i = start, j = 0; i < NCH(n); i += 2, ++j) {
                    seq[j] = astForExpr(c, CHILD(n, i));
                }
                const nl = (CHILD(n, NCH(n) - 1)).type === Tokens.T_COMMA ? false : true;
                return new Print(dest, seq, nl, n.range);
            }
            function astForStmt(c, n) {
                if (n.type === SYM.stmt) {
                    assert(NCH(n) === 1);
                    n = CHILD(n, 0);
                }
                if (n.type === SYM.simple_stmt) {
                    assert(numStmts(n) === 1);
                    n = CHILD(n, 0);
                }
                if (n.type === SYM.small_stmt) {
                    REQ(n, SYM.small_stmt);
                    n = CHILD(n, 0);
                    switch (n.type) {
                        case SYM.ExprStmt: return astForExprStmt(c, n);
                        case SYM.print_stmt: return astForPrintStmt(c, n);
                        case SYM.del_stmt: return astForDelStmt(c, n);
                        case SYM.pass_stmt: return new Pass(n.range);
                        case SYM.flow_stmt: return astForFlowStmt(c, n);
                        case SYM.import_stmt: return astForImportStmt(c, n);
                        case SYM.GlobalStmt: return astForGlobalStmt(c, n);
                        case SYM.NonLocalStmt: return astForNonLocalStmt(c, n);
                        case SYM.exec_stmt: return astForExecStmt(c, n);
                        case SYM.assert_stmt: return astForAssertStmt(c, n);
                        default: {
                            throw new Error("unhandled small_stmt");
                        }
                    }
                }
                else {
                    const ch = CHILD(n, 0);
                    REQ(n, SYM.compound_stmt);
                    switch (ch.type) {
                        case SYM.if_stmt: return astForIfStmt(c, ch);
                        case SYM.while_stmt: return astForWhileStmt(c, ch);
                        case SYM.for_stmt: return astForForStmt(c, ch);
                        case SYM.try_stmt: return astForTryStmt(c, ch);
                        case SYM.with_stmt: return astForWithStmt(c, ch);
                        case SYM.funcdef: return astForFuncdef(c, ch, []);
                        case SYM.classdef: return astForClassdef(c, ch, []);
                        case SYM.decorated: return astForDecorated(c, ch);
                        default: {
                            throw new Error("unhandled compound_stmt");
                        }
                    }
                }
            }
            /**
             * TODO: Documentation
             * @param n
             * @returns
             */
            function astFromParse(n) {
                const c = new Compiling("utf-8");
                const stmts = [];
                let k = 0;
                for (let i = 0; i < NCH(n) - 1; ++i) {
                    let ch = CHILD(n, i);
                    if (n.type === Tokens.T_NEWLINE)
                        continue;
                    REQ(ch, SYM.stmt);
                    const num = numStmts(ch);
                    if (num === 1) {
                        stmts[k++] = astForStmt(c, ch);
                    }
                    else {
                        ch = CHILD(ch, 0);
                        REQ(ch, SYM.simple_stmt);
                        for (let j = 0; j < num; ++j) {
                            stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
                        }
                    }
                }
                return stmts;
                /*
                switch (n.type) {
                    case SYM.file_input:
                    case SYM.eval_input: {
                        throw new Error("todo;");
                    }
                    case SYM.single_input: {
                        throw new Error("todo;");
                    }
                    default: {
                        throw new Error("todo;");
                    }
                }
                */
            }

            /* eslint-disable @typescript-eslint/no-unused-vars */
            class PythonVisitor {
                constructor() {
                    this.stack = [];
                }
                annAssign(annassign) {
                    throw new Error("Method not implemented.");
                }
                assign(assign) {
                    assign.targets.forEach((target) => {
                        target.accept(this);
                    });
                    assign.value.accept(this);
                    const rhs = this.stack.pop();
                    const lhs = this.stack.pop();
                    this.stack.push(items_to_cons$1(ASSIGN, lhs, rhs));
                }
                attribute(attribute) {
                    throw new Error("Method not implemented.");
                }
                binOp(be) {
                    be.lhs.accept(this);
                    be.rhs.accept(this);
                    const rhs = this.stack.pop();
                    const lhs = this.stack.pop();
                    switch (be.op) {
                        case Add: {
                            this.stack.push(items_to_cons$1(MATH_ADD$1, lhs, rhs));
                            break;
                        }
                        case Sub: {
                            this.stack.push(items_to_cons$1(MATH_SUB, lhs, rhs));
                            break;
                        }
                        case Mult: {
                            this.stack.push(items_to_cons$1(MATH_MUL$3, lhs, rhs));
                            break;
                        }
                        case Div: {
                            this.stack.push(items_to_cons$1(MATH_DIV, lhs, rhs));
                            break;
                        }
                        case Pow: {
                            this.stack.push(items_to_cons$1(MATH_POW$2, lhs, rhs));
                            break;
                        }
                        case BitXor: {
                            this.stack.push(items_to_cons$1(MATH_OUTER, lhs, rhs));
                            break;
                        }
                        case BitOr: {
                            this.stack.push(items_to_cons$1(MATH_INNER, lhs, rhs));
                            break;
                        }
                        case LShift: {
                            this.stack.push(items_to_cons$1(MATH_LCO, lhs, rhs));
                            break;
                        }
                        case RShift: {
                            this.stack.push(items_to_cons$1(MATH_RCO, lhs, rhs));
                            break;
                        }
                        default: {
                            throw new Error(JSON.stringify(be, null, 2));
                            // break;
                        }
                    }
                }
                callExpression(ce) {
                    const name = create_sym(ce.func.id?.value);
                    const args = [];
                    ce.args.forEach((arg) => {
                        arg.accept(this);
                        args.push(this.stack.pop());
                    });
                    this.stack.push(items_to_cons$1(name, ...args));
                }
                classDef(classDef) {
                    throw new Error("Method not implemented.");
                }
                compareExpression(ce) {
                    throw new Error("Method not implemented.");
                }
                dict(dict) {
                    throw new Error("Method not implemented.");
                }
                expressionStatement(es) {
                    es.value.accept(this);
                }
                functionDef(functionDef) {
                    const name = create_sym(functionDef.name.value);
                    const params = [];
                    functionDef.args.args.forEach((paramDef) => {
                        paramDef.name.accept(this);
                        params.push(this.stack.pop());
                    });
                    const stmts = [];
                    functionDef.body.forEach((stmt) => {
                        stmt.accept(this);
                        stmts.push(this.stack.pop());
                    });
                    const lambda = items_to_cons$1(create_sym('lambda'), items_to_cons$1(...params), ...stmts);
                    this.stack.push(items_to_cons$1(create_sym('define'), name, lambda));
                }
                ifStatement(ifs) {
                    throw new Error("Method not implemented.");
                }
                importFrom(importFrom) {
                    throw new Error("Method not implemented.");
                }
                list(list) {
                    const elements = [];
                    list.elts.forEach((elt) => {
                        elt.accept(this);
                        elements.push(this.stack.pop());
                    });
                    this.stack.push(create_tensor(elements));
                }
                module(module) {
                    module.body.forEach((stmt) => {
                        stmt.accept(this);
                    });
                }
                name(name) {
                    name.id.range;
                    name.id.value;
                    this.stack.push(create_sym(name.id.value));
                }
                num(num) {
                    const value = num.n.value;
                    const range = num.n.range;
                    // Ranges are given a s line and column, so we need a converter to get offset.
                    range.begin;
                    if (value.isInt()) {
                        this.stack.push(create_int(value.value));
                    }
                    else if (value.isFloat()) {
                        this.stack.push(new FltTokenParser().parse(value.text, 0, 0));
                    }
                    else if (value.isLong()) {
                        this.stack.push(new IntTokenParser().parse(value.text, 0, 0));
                    }
                    else {
                        throw new Error();
                    }
                }
                print(print) {
                    throw new Error("Method not implemented.");
                }
                returnStatement(rs) {
                    if (rs.value) {
                        rs.value.accept(this);
                    }
                    else {
                        this.stack.push(nil);
                    }
                }
                str(str) {
                    str.s.range;
                    const value = str.s.value;
                    this.stack.push(new Str$1(value, 0, 0));
                }
                subscript(se) {
                    se.value.accept(this);
                    const value = this.stack.pop();
                    if (se.slice instanceof Ellipsis) {
                        throw new Error();
                    }
                    if (se.slice instanceof Index) {
                        se.slice.value.accept(this);
                        const index = this.stack.pop();
                        this.stack.push(items_to_cons$1(MATH_COMPONENT, value, index));
                    }
                    if (se.slice instanceof Name) {
                        throw new Error();
                    }
                    if (se.slice instanceof Slice) {
                        throw new Error();
                    }
                }
                unaryOp(unaryExpr) {
                    throw new Error("Method not implemented.");
                }
                forStatement(fs) {
                    throw new Error("Method not implemented.");
                }
            }
            function python_parse(fileName, sourceText, options) {
                const node = parse(sourceText, SourceKind.File);
                if (typeof node === 'object') {
                    const stmts = astFromParse(node);
                    const mod = new Module(stmts);
                    const visitor = new PythonVisitor();
                    mod.accept(visitor);
                    const trees = [];
                    while (visitor.stack.length > 0) {
                        trees.push(visitor.stack.pop());
                    }
                    trees.reverse();
                    return { trees, errors: [] };
                }
                else {
                    throw new Error();
                }
            }

            var SyntaxKind; exports('SyntaxKind', SyntaxKind);
            (function (SyntaxKind) {
                /**
                 * Based on Algebrite, which was derived from Eigenmath.
                 */
                SyntaxKind[SyntaxKind["Native"] = 1] = "Native";
                /**
                 * Python Programming Language.
                 */
                SyntaxKind[SyntaxKind["Python"] = 2] = "Python";
                /**
                 * Scheme Programming Language, a dialect of Lisp.
                 */
                SyntaxKind[SyntaxKind["Scheme"] = 3] = "Scheme";
            })(SyntaxKind || (exports('SyntaxKind', SyntaxKind = {})));
            function human_readable_syntax_kind(syntaxKind) {
                switch (syntaxKind) {
                    case SyntaxKind.Native: return "Native";
                    case SyntaxKind.Python: return "Python";
                    case SyntaxKind.Scheme: return "Scheme";
                }
            }
            const syntaxKinds = exports('syntaxKinds', [SyntaxKind.Native, SyntaxKind.Python, SyntaxKind.Scheme]);
            function parse_expr(sourceText, options) {
                const { trees, errors } = parse_script("", sourceText, options);
                if (errors.length == 0) {
                    if (trees.length > 0) {
                        return trees[0];
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    throw errors[1];
                }
            }
            function parse_script(fileName, sourceText, options) {
                const syntaxKind = script_kind_from_options(options);
                switch (syntaxKind) {
                    case SyntaxKind.Native: {
                        return eigenmath_parse(fileName, sourceText, eigenmath_parse_options(options));
                    }
                    case SyntaxKind.Scheme: {
                        return scheme_parse(fileName, sourceText, scheme_parse_options(options));
                    }
                    case SyntaxKind.Python: {
                        return python_parse(fileName, sourceText, typhon_parse_options(options));
                    }
                    /*
                    case ScriptKind.JS:
                    case ScriptKind.TS: {
                        const tree = ts_parse(fileName, sourceText, ts_parse_options(options));
                        return { trees: [tree], errors: [] };
                    }
                    */
                    default: {
                        throw new Error(`options.syntaxKind ${syntaxKind} must be one of ${JSON.stringify(syntaxKinds.map(human_readable_syntax_kind).sort())}.`);
                    }
                }
            }
            function eigenmath_parse_options(options) {
                if (options) {
                    return {
                        explicitAssocAdd: options.explicitAssocAdd,
                        explicitAssocMul: options.explicitAssocMul,
                        useCaretForExponentiation: options.useCaretForExponentiation
                    };
                }
                else {
                    return {};
                }
            }
            function scheme_parse_options(options) {
                if (options) {
                    if (options.useCaretForExponentiation) {
                        throw new Error("useCaretForExponentiation is not supported by the Scheme parser");
                    }
                    return {
                        lexicon: {
                            '+': MATH_ADD$1,
                            '*': MATH_MUL$3,
                            'exp': MATH_EXP,
                            'expt': MATH_POW$2,
                            'quote': QUOTE,
                            'real?': PREDICATE_IS_REAL
                        },
                        explicitAssocAdd: options.explicitAssocAdd,
                        explicitAssocMul: options.explicitAssocMul,
                    };
                }
                else {
                    return scheme_parse_options({});
                }
            }
            function typhon_parse_options(options) {
                if (options) {
                    if (options.useCaretForExponentiation) {
                        throw new Error("useCaretForExponentiation is not supported by the Python parser");
                    }
                    return {
                        explicitAssocAdd: options.explicitAssocAdd,
                        explicitAssocMul: options.explicitAssocMul
                    };
                }
                else {
                    return {};
                }
            }
            function script_kind_from_options(options) {
                if (options) {
                    if (options.syntaxKind) {
                        return options.syntaxKind;
                    }
                    else {
                        return SyntaxKind.Native;
                    }
                }
                else {
                    return SyntaxKind.Native;
                }
            }

            function mmul(a, b) {
                return a.multiply(b);
            }
            function mdiv(a, b) {
                return a.divide(b);
            }
            function mmod(a, b) {
                return a.mod(b);
            }
            // return both quotient and remainder of a/b
            // we'd have this method as divmod(number)
            // but obviously doesn't change the passed parameters
            function mdivrem(a, b) {
                const toReturn = a.divmod(b);
                return [toReturn.quotient, toReturn.remainder];
            }

            // Bignum power
            function mpow(a, n) {
                return a.pow(n);
            }

            function in_safe_integer_range(a) {
                return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);
            }

            /**
             * is_rat(expr) && expr.isInteger
             */
            function is_rat_and_integer(expr) {
                return is_rat$1(expr) && expr.isInteger();
            }

            function nativeInt(p1) {
                let n = NaN;
                if (is_rat$1(p1)) {
                    if (is_rat_and_integer(p1) && in_safe_integer_range(p1.a)) {
                        n = p1.a.toJSNumber();
                    }
                }
                else if (is_flt$1(p1)) {
                    if (Math.floor(p1.d) === p1.d) {
                        n = p1.d;
                    }
                }
                return n;
            }

            //   _______
            //  |  | <- stack
            //  |  |
            //  |_______|
            //  |  | <- stack + tos
            //  |  |
            //  |  |
            //  |_______|
            //  |  | <- frame
            //  |_______|
            //      <- stack + TOS
            //
            //  The stack grows from low memory towards high memory. This is so that
            //  multiple expressions can be pushed on the stack and then accessed as an
            //  array.
            //
            //  The frame area holds local variables and grows from high memory towards
            //  low memory. The frame area makes local variables visible to the garIIIbage
            //  collector.
            /**
             * Push onto the stack.
             * @param expr The value to push onto the stack.
             */
            function stack_push(expr) {
                // console.lg(`push(${expr})`);
                if (typeof expr === 'undefined') {
                    throw new Error('expr must be defined.');
                }
                defs.stack[defs.tos++] = expr;
            }
            function stack_pop() {
                if (defs.tos === 0) {
                    throw new SystemError('stack underflow');
                }
                const popped = defs.stack[--defs.tos];
                defs.stack[defs.tos] = null;
                // No need to do any reference counting stuff if it is a symbol because the receiver
                // of the return value now owns the thing.
                // console.lg(`pop ${popped}`);
                return popped;
            }
            /**
             * Temporary function to push an array of items onto the stack.
             * Useful when migrating a function to returning a U[], but its
             * caller still needs the items on the stack
             *
             * WARNING!!! Destructive because the function producing the array is producing
             * a new array that will either be used as expected or pushed onto
             * the stack for compatibilty
             *
             * TODO: Delete when all functions are transitioned over to
             * normal arguments and outputs rather than using the stack
             *
             * Remaining Use: factorpoly.ts
             */
            function stack_push_items(items) {
                while (items.length > 0) {
                    stack_push(items.shift());
                }
            }
            /**
             * Returns the top of the program stack without actually popping it.
             */
            function stack_peek() {
                // All this casting is making me queasy.
                return defs.stack[defs.tos - 1];
            }
            /**
             * Create a list from n things on the stack.
             * The list will have the nested Cons structure.
             * The list will be NIL-terminated.
             * The lowest item on the stack will be the first in the list.
             * The highest item on the stack will be the last in the list.
             * The result is stored on the top of the stack.
             *
             * @param n is an integer.
             * @param $ the environment is required to provide the NIL symbol.
             */
            function stack_list(n) {
                stack_push(nil);
                for (let i = 0; i < n; i++) {
                    const arg2 = stack_pop();
                    const arg1 = stack_pop();
                    stack_push(cons(arg1, arg2));
                }
            }

            function mint(a) {
                return BigIntegerExports(a);
            }
            function makePositive(a) {
                if (a.isNegative()) {
                    return a.multiply(BigIntegerExports(-1));
                }
                return a;
            }
            function makeSignSameAs(a, b) {
                if (a.isPositive()) {
                    if (b.isNegative()) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                else {
                    // a is negative
                    if (b.isPositive()) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                return a;
            }
            function setSignTo(a, b) {
                if (a.isPositive()) {
                    if (b < 0) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                else {
                    // a is negative
                    if (b > 0) {
                        return a.multiply(BigIntegerExports(-1));
                    }
                }
                return a;
            }
            /**
             * TODO: Move to the NumExtension
             */
            function divide_numbers(lhs, rhs) {
                if (is_rat$1(lhs) && is_rat$1(rhs)) {
                    return lhs.div(rhs);
                }
                if (rhs.isZero()) {
                    throw new Error('divide by zero');
                }
                const a = is_flt$1(lhs) ? lhs.d : lhs.toNumber();
                const b = is_flt$1(rhs) ? rhs.d : rhs.toNumber();
                return create_flt(a / b);
            }
            function bignum_truncate(p1) {
                const a = mdiv(p1.a, p1.b);
                return new Rat(a, BigIntegerExports.one);
            }
            function mp_numerator(p1) {
                if (is_rat$1(p1)) {
                    return p1.numer();
                }
                else {
                    return one;
                }
            }
            function mp_denominator(p1) {
                if (is_rat$1(p1)) {
                    return p1.denom();
                }
                else {
                    return one;
                }
            }
            // expo is an integer
            function bignum_power_number(base, expo) {
                let a = mpow(base.a, Math.abs(expo));
                let b = mpow(base.b, Math.abs(expo));
                if (expo < 0) {
                    // swap a and b
                    const t = a;
                    a = b;
                    b = t;
                    a = makeSignSameAs(a, b);
                    b = setSignTo(b, 1);
                }
                return new Rat(a, b);
            }
            function rational(a, b) {
                // `as any as number` cast added because bigInt(number) and bigInt(bigInt.BigInteger)
                // are both accepted signatures, but bigInt(number|bigInt.BigInteger) is not
                return new Rat(BigIntegerExports(a), BigIntegerExports(b));
            }
            function nativeDouble(p1) {
                if (is_rat$1(p1)) {
                    return p1.toNumber();
                }
                else if (is_flt$1(p1)) {
                    return p1.toNumber();
                }
                else {
                    return 0;
                }
            }
            function rat_to_flt(n) {
                const d = n.toNumber();
                return create_flt(d);
            }
            //static unsigned int *__factorial(int)
            // n is an int
            function bignum_factorial(n) {
                return new Rat(__factorial(n), BigIntegerExports.one);
            }
            // n is an int
            function __factorial(n) {
                let a;
                // unsigned int *a, *b, *t
                if (n === 0 || n === 1) {
                    a = BigIntegerExports(1);
                    return a;
                }
                a = BigIntegerExports(2);
                let b = BigIntegerExports(0);
                if (3 <= n) {
                    for (let i = 3; i <= n; i++) {
                        b = BigIntegerExports(i);
                        a = mmul(a, b);
                    }
                }
                return a;
            }
            /*
            const mask = [
              0x00000001,
              0x00000002,
              0x00000004,
              0x00000008,
              0x00000010,
              0x00000020,
              0x00000040,
              0x00000080,
              0x00000100,
              0x00000200,
              0x00000400,
              0x00000800,
              0x00001000,
              0x00002000,
              0x00004000,
              0x00008000,
              0x00010000,
              0x00020000,
              0x00040000,
              0x00080000,
              0x00100000,
              0x00200000,
              0x00400000,
              0x00800000,
              0x01000000,
              0x02000000,
              0x04000000,
              0x08000000,
              0x10000000,
              0x20000000,
              0x40000000,
              0x80000000,
            ];
            */
            // unsigned int *x, unsigned int k
            /*
            function mp_clr_bit(x: bigInt.BigInteger, k: number) {
              console.lg('not implemented yet');
              breakpoint;
              return (x[k / 32] &= ~mask[k % 32]);
            }
            */

            function is_cons_opr_eq_sym(expr, name) {
                const opr = expr.car;
                if (is_sym(opr)) {
                    return opr.equalsSym(name);
                }
                else {
                    return false;
                }
            }

            function is_cons_opr_eq_add(expr) {
                return is_cons_opr_eq_sym(expr, MATH_ADD$1);
            }

            const ABS$4 = native_sym(Native.abs);
            function is_abs(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, ABS$4);
            }
            /**
             * is_cons && is_opr_eq(..., MATH_ADD)
             */
            function is_add(expr) {
                return is_cons(expr) && is_cons_opr_eq_add(expr);
            }
            function is_multiply(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_MUL$3);
            }
            function is_power(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_POW$2);
            }
            function is_factorial(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_FACTORIAL);
            }
            function is_outer$1(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_OUTER);
            }
            function is_lco(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_LCO);
            }
            function is_rco(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_RCO);
            }
            function is_inner_or_dot(expr) {
                if (is_cons(expr)) {
                    if (is_cons_opr_eq_sym(expr, MATH_INNER)) {
                        return true;
                    }
                    if (is_cons_opr_eq_sym(expr, DOT)) {
                        return true;
                    }
                    return false;
                }
                else {
                    return false;
                }
            }
            function is_transpose(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, TRANSPOSE);
            }
            function is_opr_eq_inv(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, INV$1);
            }
            /**
             * WARNING: This function is rather complicated and isn't exactly described by its name.
             */
            function is_num_or_tensor_or_identity_matrix(p) {
                // because of recursion, we consider a scalar to be
                // a tensor, so a numeric scalar will return true
                if (is_num(p) || SYMBOL_IDENTITY_MATRIX.equals(p)) {
                    return true;
                }
                if (is_tensor(p)) {
                    return p.everyElement(is_num_or_tensor_or_identity_matrix);
                }
                else {
                    return false;
                }
            }
            // TODO this is a bit of a shallow check, we should
            // check when we are passed an actual tensor and possibly
            // cache the test result.
            function is_identity_matrix(p) {
                return SYMBOL_IDENTITY_MATRIX.equals(p);
            }
            function is_sin(expr) {
                return is_cons(expr) && is_cons_opr_eq_sym(expr, MATH_SIN$1);
            }

            const E$1 = native_sym(Native.E);
            /**
             * @param expr The base found in e.g. (expt base exponent).
             */
            function is_base_of_natural_logarithm(expr) {
                if (is_sym(expr)) {
                    // console.lg("is_base_of_natural_logarithm", expr.toString());
                    return E$1.equals(expr);
                }
                else if (is_power(expr)) {
                    const base = expr.lhs;
                    const expo = expr.rhs;
                    if (is_num(expo) && expo.isOne()) {
                        return is_base_of_natural_logarithm(base);
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }

            function caar(p) {
                return car(car(p));
            }
            function cadr(p) {
                return car(cdr(p));
            }
            function cddr(p) {
                return cdr(cdr(p));
            }
            function caadr(p) {
                return car(car(cdr(p)));
            }
            function caddr(p) {
                return car(cdr(cdr(p)));
            }
            function cdadr(p) {
                return cdr(car(cdr(p)));
            }
            function cdddr(p) {
                return cdr(cdr(cdr(p)));
            }
            function cadadr(p) {
                return car(cdr(car(cdr(p))));
            }
            function cadddr(p) {
                return car(cdr(cdr(cdr(p))));
            }
            function caddddr(p) {
                return car(cdr(cdr(cdr(cdr(p)))));
            }

            function is_pi(expr) {
                if (is_sym(expr)) {
                    return MATH_PI$2.equalsSym(expr);
                }
                else {
                    return false;
                }
            }

            function Eval_float(expr, $) {
                // console.lg("Eval_float", render_as_infix(expr, $));
                // console.lg("Eval_float", render_as_sexpr(expr, $));
                $.pushNativeDirective(Directive.evaluatingAsFloat, true);
                try {
                    const A = cadr(expr);
                    // console.lg("A", render_as_infix(A, $), JSON.stringify(A));
                    if (is_base_of_natural_logarithm(A)) {
                        // console.lg("A is the base of natural logs.");
                    }
                    if (is_pi(A)) {
                        // console.lg("A is pi");
                    }
                    const B = $.valueOf(A);
                    // console.lg("B", render_as_infix(B, $));
                    const C = evaluate_as_float(B, $);
                    // console.lg("C", render_as_infix(C, $));
                    const D = $.valueOf(C);
                    // console.lg("D", render_as_infix(D, $));
                    return D;
                }
                finally {
                    $.popNativeDirective();
                }
            }
            /**
             * An interpretation of the "zz" is that the expression must be evaluated before it is processed and it will be evaluated after.
             * @param expr
             * @param $
             * @returns
             */
            function zzfloat(expr, $) {
                $.pushNativeDirective(Directive.evaluatingAsFloat, true);
                try {
                    return $.valueOf(evaluate_as_float($.valueOf(expr), $));
                }
                finally {
                    $.popNativeDirective();
                }
            }
            // zzfloat doesn't necessarily result in a double
            // , for example if there are variables. But
            // in many of the tests there should be indeed
            // a float, this line comes handy to highlight
            // when that doesn't happen for those tests.
            // checkFloatHasWorkedOutCompletely(defs.stack[defs.tos-1],$)
            /**
             * coercion of the expr to a Flt, Tensor<Flt> etc.
             */
            function evaluate_as_float(expr, $) {
                // console.lg(`yyfloat`, render_as_sexpr(expr, $));
                $.pushNativeDirective(Directive.evaluatingAsFloat, true);
                try {
                    return yyfloat_(expr, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            function yyfloat_(expr, $) {
                // console.lg(`yyfloat_`, $.toSExprString(expr));
                if (is_cons(expr)) {
                    return $.valueOf(items_to_cons$1(...expr.map(function (x) {
                        return yyfloat_(x, $);
                    })));
                }
                if (is_tensor(expr)) {
                    return expr.map(function (x) {
                        return yyfloat_(x, $);
                    });
                }
                if (is_rat$1(expr)) {
                    return rat_to_flt(expr);
                }
                if (is_pi(expr)) {
                    return piAsFlt;
                }
                if (is_base_of_natural_logarithm(expr)) {
                    return eAsFlt;
                }
                return expr;
            }

            /*
             Guesses a rational for each float in the passed expression
            */
            function Eval_approxratio(expr, $) {
                // Evaluating the expression gets it into canonical order.
                const arg = $.valueOf(expr.argList.head);
                // console.lg("Eval_approxratio", $.toInfixString(arg));
                return approxratio(arg, $);
            }
            function approxratio(expr, $) {
                // Notice that this function is recursive.
                // TODO: This can be made extensible using specialized operators.
                // But the recursion will need to allow for extensions.
                if (is_tensor(expr)) {
                    return expr.map(function (elem) {
                        return approxratio(elem, $);
                    });
                }
                if (is_flt$1(expr)) {
                    return approxratio_flt(expr, $);
                }
                if (is_cons(expr)) {
                    const head = expr.head;
                    const rest = expr.argList;
                    return cons(approxratio(head, $), approxratio(rest, $));
                }
                return expr;
            }
            function approxratio_flt(value, $) {
                // TypeScript establishes that the argument actually is a float, so we could simplify here.
                const supposedlyTheFloat = zzfloat(value, $);
                if (is_flt$1(supposedlyTheFloat)) {
                    const theFloat = supposedlyTheFloat.d;
                    const splitBeforeAndAfterDot = theFloat.toString().split('.');
                    if (splitBeforeAndAfterDot.length === 2) {
                        const numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
                        const precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
                        const theRatio = floatToRatioRoutine(theFloat, precision);
                        return rational(theRatio[0], theRatio[1]);
                    }
                    return create_int(theFloat);
                }
                // we didn't manage, just leave unexpressed
                return items_to_cons$1(APPROXRATIO, supposedlyTheFloat);
            }
            // original routine by John Kennedy, see
            // https://web.archive.org/web/20111027100847/http://homepage.smc.edu/kennedy_john/DEC2FRAC.PDF
            // courtesy of Michael Borcherds
            // who ported this to JavaScript under MIT licence
            // also see
            // https://github.com/geogebra/geogebra/blob/master/common/src/main/java/org/geogebra/common/kernel/algos/AlgoFractionText.java
            // potential other ways to do this:
            //   https://rosettacode.org/wiki/Convert_decimal_number_to_rational
            //   http://www.homeschoolmath.net/teaching/rational_numbers.php
            //   http://stackoverflow.com/questions/95727/how-to-convert-floats-to-human-readable-fractions
            function floatToRatioRoutine(decimal, AccuracyFactor) {
                if (isNaN(decimal)) {
                    return [0, 0];
                }
                // return 0/0
                if (decimal === Infinity) {
                    // 1/0
                    return [1, 0];
                }
                if (decimal === -Infinity) {
                    // -1/0
                    return [-1, 0];
                }
                const DecimalSign = decimal < 0.0 ? -1.0 : 1.0;
                decimal = Math.abs(decimal);
                if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {
                    // handles exact integers including 0
                    const FractionNumerator = decimal * DecimalSign;
                    const FractionDenominator = 1.0;
                    return [FractionNumerator, FractionDenominator];
                }
                if (decimal < 1.0e-19) {
                    // X = 0 already taken care of
                    const FractionNumerator = DecimalSign;
                    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                    const FractionDenominator = 9999999999999999999.0;
                    return [FractionNumerator, FractionDenominator];
                }
                if (decimal > 1.0e19) {
                    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                    const FractionNumerator = 9999999999999999999.0 * DecimalSign;
                    const FractionDenominator = 1.0;
                    return [FractionNumerator, FractionDenominator];
                }
                let Z = decimal;
                let PreviousDenominator = 0.0;
                let FractionDenominator = 1.0;
                let FractionNumerator = undefined;
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    Z = 1.0 / (Z - Math.floor(Z));
                    const temp = FractionDenominator;
                    FractionDenominator =
                        FractionDenominator * Math.floor(Z) + PreviousDenominator;
                    PreviousDenominator = temp;
                    FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);
                    // Rounding Function
                    if (!(Math.abs(decimal - FractionNumerator / FractionDenominator) >
                        AccuracyFactor) ||
                        Z === Math.floor(Z)) {
                        break;
                    }
                }
                FractionNumerator = DecimalSign * FractionNumerator;
                return [FractionNumerator, FractionDenominator];
            }
            /*
            export function testApprox() {
              for (const i of [2, 3, 5, 6, 7, 8, 10]) {
                for (const j of [2, 3, 5, 6, 7, 8, 10]) {
                  if (i === j) {
                    continue;
                  } // this is just 1
                  Console.log(`testapproxRadicals testing: 1 * sqrt( ${i} ) / ${j}`);
                  const value = Math.sqrt(i) / j;
                  const returned = approxRadicals(value);
                  const returnedValue =
                    (returned[2] * Math.sqrt(returned[3])) / returned[4];
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testapproxRadicals: 1 * sqrt( ${i} ) / ${j} . obtained: ${returned}`
                    );
                  }
                }
              }

              for (const i of [2, 3, 5, 6, 7, 8, 10]) {
                for (const j of [2, 3, 5, 6, 7, 8, 10]) {
                  if (i === j) {
                    continue;
                  } // this is just 1
                  Console.log(
                    `testapproxRadicals testing with 4 digits: 1 * sqrt( ${i} ) / ${j}`
                  );
                  const originalValue = Math.sqrt(i) / j;
                  const value = originalValue.toFixed(4);
                  const returned = approxRadicals(Number(value));
                  const returnedValue =
                    (returned[2] * Math.sqrt(returned[3])) / returned[4];
                  if (Math.abs(originalValue - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testapproxRadicals with 4 digits: 1 * sqrt( ${i} ) / ${j} . obtained: ${returned}`
                    );
                  }
                }
              }

              for (const i of [2, 3, 5, 6, 7, 8, 10]) {
                for (const j of [2, 3, 5, 6, 7, 8, 10]) {
                  if (i === j) {
                    continue;
                  } // this is just 1
                  Console.log(`testapproxRadicals testing: 1 * sqrt( ${i} / ${j} )`);
                  const value = Math.sqrt(i / j);
                  const returned = approxRadicals(value);
                  if (returned != null) {
                    const returnedValue =
                      returned[2] * Math.sqrt(returned[3] / returned[4]);
                    if (
                      returned[1] === approx_radicalOfRatio &&
                      Math.abs(value - returnedValue) > 1e-15
                    ) {
                      Console.log(
                        `fail testapproxRadicals: 1 * sqrt( ${i} / ${j} ) . obtained: ${returned}`
                      );
                    }
                  }
                }
              }

              for (const i of [1, 2, 3, 5, 6, 7, 8, 10]) {
                for (const j of [1, 2, 3, 5, 6, 7, 8, 10]) {
                  if (i === 1 && j === 1) {
                    continue;
                  }
                  Console.log(
                    `testapproxRadicals testing with 4 digits:: 1 * sqrt( ${i} / ${j} )`
                  );
                  const originalValue = Math.sqrt(i / j);
                  const value = originalValue.toFixed(4);
                  const returned = approxRadicals(Number(value));
                  const returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);
                  if (
                    returned[1] === approx_radicalOfRatio &&
                    Math.abs(originalValue - returnedValue) > 1e-15
                  ) {
                    Console.log(
                      `fail testapproxRadicals with 4 digits:: 1 * sqrt( ${i} / ${j} ) . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 5; i++) {
                for (let j = 1; j <= 5; j++) {
                  Console.log(`testApproxAll testing: 1 * log(${i} ) / ${j}`);
                  const value = Math.log(i) / j;
                  const returned = approxAll(value);
                  const returnedValue = (returned[2] * Math.log(returned[3])) / returned[4];
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll: 1 * log(${i} ) / ${j} . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 5; i++) {
                for (let j = 1; j <= 5; j++) {
                  Console.log(`testApproxAll testing with 4 digits: 1 * log(${i} ) / ${j}`);
                  const originalValue = Math.log(i) / j;
                  const value = originalValue.toFixed(4);
                  const returned = approxAll(Number(value));
                  const returnedValue = (returned[2] * Math.log(returned[3])) / returned[4];
                  if (Math.abs(originalValue - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll with 4 digits: 1 * log(${i} ) / ${j} . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 5; i++) {
                for (let j = 1; j <= 5; j++) {
                  Console.log(`testApproxAll testing: 1 * log(${i} / ${j} )}`);
                  const value = Math.log(i / j);
                  const returned = approxAll(value);
                  const returnedValue = returned[2] * Math.log(returned[3] / returned[4]);
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll: 1 * log(${i} / ${j} ) . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 5; i++) {
                for (let j = 1; j <= 5; j++) {
                  Console.log(`testApproxAll testing with 4 digits: 1 * log(${i} / ${j} )`);
                  const originalValue = Math.log(i / j);
                  const value = originalValue.toFixed(4);
                  const returned = approxAll(Number(value));
                  const returnedValue = returned[2] * Math.log(returned[3] / returned[4]);
                  if (Math.abs(originalValue - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll with 4 digits: 1 * log(${i} / ${j} ) . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 2; i++) {
                for (let j = 1; j <= 12; j++) {
                  Console.log(`testApproxAll testing: 1 * (e ^ ${i} ) / ${j}`);
                  const value = Math.pow(Math.E, i) / j;
                  const returned = approxAll(value);
                  const returnedValue =
                    (returned[2] * Math.pow(Math.E, returned[3])) / returned[4];
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll: 1 * (e ^ ${i} ) / ${j} . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 2; i++) {
                for (let j = 1; j <= 12; j++) {
                  Console.log(
                    `approxRationalsOfPowersOfE testing with 4 digits: 1 * (e ^ ${i} ) / ${j}`
                  );
                  const originalValue = Math.pow(Math.E, i) / j;
                  const value = originalValue.toFixed(4);
                  const returned = approxRationalsOfPowersOfE(Number(value));
                  const returnedValue =
                    (returned[2] * Math.pow(Math.E, returned[3])) / returned[4];
                  if (Math.abs(originalValue - returnedValue) > 1e-15) {
                    Console.log(
                      `fail approxRationalsOfPowersOfE with 4 digits: 1 * (e ^ ${i} ) / ${j} . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 2; i++) {
                for (let j = 1; j <= 12; j++) {
                  Console.log(`testApproxAll testing: 1 * pi ^ ${i} / ${j}`);
                  const value = Math.pow(Math.PI, i) / j;
                  const returned = approxAll(value);
                  const returnedValue =
                    (returned[2] * Math.pow(Math.PI, returned[3])) / returned[4];
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll: 1 * pi ^ ${i} / ${j} ) . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 2; i++) {
                for (let j = 1; j <= 12; j++) {
                  Console.log(
                    `approxRationalsOfPowersOfPI testing with 4 digits: 1 * pi ^ ${i} / ${j}`
                  );
                  const originalValue = Math.pow(Math.PI, i) / j;
                  const value = originalValue.toFixed(4);
                  const returned = approxRationalsOfPowersOfPI(Number(value));
                  const returnedValue =
                    (returned[2] * Math.pow(Math.PI, returned[3])) / returned[4];
                  if (Math.abs(originalValue - returnedValue) > 1e-15) {
                    Console.log(
                      `fail approxRationalsOfPowersOfPI with 4 digits: 1 * pi ^ ${i} / ${j} ) . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 4; i++) {
                for (let j = 1; j <= 4; j++) {
                  Console.log(`testApproxAll testing: 1 * sin( ${i}/${j} )}`);
                  const fraction = i / j;
                  const value = Math.sin(fraction);
                  const returned = approxAll(value);
                  const returnedFraction = returned[3] / returned[4];
                  const returnedValue = returned[2] * Math.sin(returnedFraction);
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail testApproxAll: 1 * sin( ${i}/${j} ) . obtained: ${returned}`
                    );
                  }
                }
              }

              // 5 digits create no problem
              for (let i = 1; i <= 4; i++) {
                for (let j = 1; j <= 4; j++) {
                  Console.log(`testApproxAll testing with 5 digits: 1 * sin( ${i}/${j} )`);
                  const fraction = i / j;
                  const originalValue = Math.sin(fraction);
                  const value = originalValue.toFixed(5);
                  const returned = approxAll(Number(value));
                  if (returned == null) {
                    Console.log(
                      `fail testApproxAll with 5 digits: 1 * sin( ${i}/${j} ) . obtained:  undefined `
                    );
                  }
                  const returnedFraction = returned[3] / returned[4];
                  const returnedValue = returned[2] * Math.sin(returnedFraction);
                  const error = Math.abs(originalValue - returnedValue);
                  if (error > 1e-14) {
                    Console.log(
                      `fail testApproxAll with 5 digits: 1 * sin( ${i}/${j} ) . obtained: ${returned} error: ${error}`
                    );
                  }
                }
              }

              // 4 digits create two collisions
              for (let i = 1; i <= 4; i++) {
                for (let j = 1; j <= 4; j++) {
                  Console.log(`testApproxAll testing with 4 digits: 1 * sin( ${i}/${j} )`);
                  const fraction = i / j;
                  const originalValue = Math.sin(fraction);
                  const value = originalValue.toFixed(4);
                  const returned = approxAll(Number(value));
                  if (returned == null) {
                    Console.log(
                      `fail testApproxAll with 4 digits: 1 * sin( ${i}/${j} ) . obtained:  undefined `
                    );
                  }
                  const returnedFraction = returned[3] / returned[4];
                  const returnedValue = returned[2] * Math.sin(returnedFraction);
                  const error = Math.abs(originalValue - returnedValue);
                  if (error > 1e-14) {
                    Console.log(
                      `fail testApproxAll with 4 digits: 1 * sin( ${i}/${j} ) . obtained: ${returned} error: ${error}`
                    );
                  }
                }
              }

              let value = 0;
              if (approxAll(value)[0] !== '0') {
                Console.log('fail testApproxAll: 0');
              }

              value = 0.0;
              if (approxAll(value)[0] !== '0') {
                Console.log('fail testApproxAll: 0.0');
              }

              value = 0.0;
              if (approxAll(value)[0] !== '0') {
                Console.log('fail testApproxAll: 0.00');
              }

              value = 0.0;
              if (approxAll(value)[0] !== '0') {
                Console.log('fail testApproxAll: 0.000');
              }

              value = 0.0;
              if (approxAll(value)[0] !== '0') {
                Console.log('fail testApproxAll: 0.0000');
              }

              value = 1;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1');
              }

              value = 1.0;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1.0');
              }

              value = 1.0;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1.00');
              }

              value = 1.0;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1.000');
              }

              value = 1.0;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1.0000');
              }

              value = 1.0;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1.00000');
              }

              value = Math.sqrt(2);
              if (approxAll(value)[0] !== '1 * sqrt( 2 ) / 1') {
                Console.log('fail testApproxAll: Math.sqrt(2)');
              }

              value = 1.41;
              if (approxAll(value)[0] !== '1 * sqrt( 2 ) / 1') {
                Console.log('fail testApproxAll: 1.41');
              }

              // if we narrow down to a particular family then we can get
              // an OK guess even with few digits, expecially for really "famous" numbers

              value = 1.4;
              if (approxRadicals(value)[0] !== '1 * sqrt( 2 ) / 1') {
                Console.log('fail approxRadicals: 1.4');
              }

              value = 0.6;
              if (approxLogs(value)[0] !== '1 * log( 2 ) / 1') {
                Console.log('fail approxLogs: 0.6');
              }

              value = 0.69;
              if (approxLogs(value)[0] !== '1 * log( 2 ) / 1') {
                Console.log('fail approxLogs: 0.69');
              }

              value = 0.7;
              if (approxLogs(value)[0] !== '1 * log( 2 ) / 1') {
                Console.log('fail approxLogs: 0.7');
              }

              value = 1.09;
              if (approxLogs(value)[0] !== '1 * log( 3 ) / 1') {
                Console.log('fail approxLogs: 1.09');
              }

              value = 1.09;
              if (approxAll(value)[0] !== '1 * log( 3 ) / 1') {
                Console.log('fail approxAll: 1.09');
              }

              value = 1.098;
              if (approxAll(value)[0] !== '1 * log( 3 ) / 1') {
                Console.log('fail approxAll: 1.098');
              }

              value = 1.1;
              if (approxAll(value)[0] !== '1 * log( 3 ) / 1') {
                Console.log('fail approxAll: 1.1');
              }

              value = 1.11;
              if (approxAll(value)[0] !== '1 * log( 3 ) / 1') {
                Console.log('fail approxAll: 1.11');
              }

              value = Math.sqrt(3);
              if (approxAll(value)[0] !== '1 * sqrt( 3 ) / 1') {
                Console.log('fail testApproxAll: Math.sqrt(3)');
              }

              value = 1.0;
              if (approxAll(value)[0] !== '1') {
                Console.log('fail testApproxAll: 1.0000');
              }

              value = 3.141592;
              if (approxAll(value)[0] !== '1 * (pi ^ 1 ) / 1 )') {
                Console.log('fail testApproxAll: 3.141592');
              }

              value = 31.41592;
              if (approxAll(value)[0] !== '10 * (pi ^ 1 ) / 1 )') {
                Console.log('fail testApproxAll: 31.41592');
              }

              value = 314.1592;
              if (approxAll(value)[0] !== '100 * (pi ^ 1 ) / 1 )') {
                Console.log('fail testApproxAll: 314.1592');
              }

              value = 31415926.53589793;
              if (approxAll(value)[0] !== '10000000 * (pi ^ 1 ) / 1 )') {
                Console.log('fail testApproxAll: 31415926.53589793');
              }

              value = Math.sqrt(2);
              if (approxTrigonometric(value)[0] !== '2 * sin( 1/4 * pi )') {
                Console.log('fail approxTrigonometric: Math.sqrt(2)');
              }

              value = Math.sqrt(3);
              if (approxTrigonometric(value)[0] !== '2 * sin( 1/3 * pi )') {
                Console.log('fail approxTrigonometric: Math.sqrt(3)');
              }

              value = (Math.sqrt(6) - Math.sqrt(2)) / 4;
              if (approxAll(value)[0] !== '1 * sin( 1/12 * pi )') {
                Console.log('fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4');
              }

              value = Math.sqrt(2 - Math.sqrt(2)) / 2;
              if (approxAll(value)[0] !== '1 * sin( 1/8 * pi )') {
                Console.log('fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2');
              }

              value = (Math.sqrt(6) + Math.sqrt(2)) / 4;
              if (approxAll(value)[0] !== '1 * sin( 5/12 * pi )') {
                Console.log('fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4');
              }

              value = Math.sqrt(2 + Math.sqrt(3)) / 2;
              if (approxAll(value)[0] !== '1 * sin( 5/12 * pi )') {
                Console.log('fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2');
              }

              value = (Math.sqrt(5) - 1) / 4;
              if (approxAll(value)[0] !== '1 * sin( 1/10 * pi )') {
                Console.log('fail testApproxAll: (Math.sqrt(5) - 1)/4');
              }

              value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;
              if (approxAll(value)[0] !== '1 * sin( 1/5 * pi )') {
                Console.log('fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4');
              }

              // this has a radical form but it's too long to write
              value = Math.sin(Math.PI / 7);
              if (approxAll(value)[0] !== '1 * sin( 1/7 * pi )') {
                Console.log('fail testApproxAll: Math.sin(Math.PI/7)');
              }

              // this has a radical form but it's too long to write
              value = Math.sin(Math.PI / 9);
              if (approxAll(value)[0] !== '1 * sin( 1/9 * pi )') {
                Console.log('fail testApproxAll: Math.sin(Math.PI/9)');
              }

              value = 1836.15267;
              if (approxRationalsOfPowersOfPI(value)[0] !== '6 * (pi ^ 5 ) / 1 )') {
                Console.log('fail approxRationalsOfPowersOfPI: 1836.15267');
              }

              for (let i = 1; i <= 13; i++) {
                for (let j = 1; j <= 13; j++) {
                  Console.log(`approxTrigonometric testing: 1 * sin( ${i}/${j} * pi )`);
                  const fraction = i / j;
                  value = Math.sin(Math.PI * fraction);
                  // we specifically search for sines of rational multiples of PI
                  // because too many of them would be picked up as simple
                  // rationals.
                  const returned = approxTrigonometric(value);
                  const returnedFraction = returned[3] / returned[4];
                  const returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);
                  if (Math.abs(value - returnedValue) > 1e-15) {
                    Console.log(
                      `fail approxTrigonometric: 1 * sin( ${i}/${j} * pi ) . obtained: ${returned}`
                    );
                  }
                }
              }

              for (let i = 1; i <= 13; i++) {
                for (let j = 1; j <= 13; j++) {
                  // with four digits, there are two collisions with the
                  // "simple fraction" argument hypotesis, which we prefer since
                  // it's a simpler expression, so let's skip those
                  // two tests
                  if ((i === 5 && j === 11) || (i === 6 && j === 11)) {
                    continue;
                  }

                  Console.log(
                    `approxTrigonometric testing with 4 digits: 1 * sin( ${i}/${j} * pi )`
                  );
                  const fraction = i / j;
                  const originalValue = Math.sin(Math.PI * fraction);
                  const value = originalValue.toFixed(4);
                  // we specifically search for sines of rational multiples of PI
                  // because too many of them would be picked up as simple
                  // rationals.
                  const returned = approxTrigonometric(Number(value));
                  const returnedFraction = returned[3] / returned[4];
                  const returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);
                  const error = Math.abs(originalValue - returnedValue);
                  if (error > 1e-14) {
                    Console.log(          `fail approxTrigonometric with 4 digits: 1 * sin( ${i}/${j} * pi ) . obtained: ${returned} error: ${error}`        );
                  }
                }
              }

              return Console.log('testApprox done');
            }
            */

            function bitCount(i) {
                // Note that unsigned shifting (>>>) is not required.
                i = i - ((i >> 1) & 0x55555555);
                i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
                i = (i + (i >> 4)) & 0x0F0F0F0F;
                i = i + (i >> 8);
                i = i + (i >> 16);
                return i & 0x0000003F;
            }

            /**
             * Compares blades according to the canonical representation.
             * This may not be the ordering that is desired for pretty printing.
             */
            function compare_blade_blade(lhs, rhs) {
                // This ordering produces the canonical ordering in the Bitmap Representation.
                // See GEOMETRIC ALGEBRA for Computer Science, p 512.
                // e.g.
                // 1, e1, e2, e1 ^ e2, e3, e1 ^ e3, e2 ^ e3, e1 ^ e2 ^ e3.
                // Indexing the Bitmap 1-based from the RHS, the ith bit indicates whether ei is present.
                // The Basis Blade is then the outer product of all blades present in order of increasing index.
                // e.g.
                // 101 is e1 ^ e3, 110 is e2 ^ e3, 111 is e1 ^ e2 ^ e3, 0 is 1 but we don't have the scalar blade in this implementation
                // because we keep the scaling out of the Vec. 
                const x = lhs.bitmap;
                const y = rhs.bitmap;
                if (x < y) {
                    return SIGN_LT;
                }
                if (x > y) {
                    return SIGN_GT;
                }
                return SIGN_EQ;
            }
            class BladeExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return 'Blade';
                }
                get hash() {
                    return HASH_BLADE;
                }
                get name() {
                    return 'BladeExtension';
                }
                get dependencies() {
                    return ['Blade'];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                isKind(arg) {
                    return is_blade$1(arg);
                }
                isMinusOne() {
                    // Blade cannot be one because scalars are excluded.
                    return false;
                }
                isOne() {
                    // Blade cannot be one because scalars are excluded.
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                isScalar(blade) {
                    return bitCount(blade.bitmap) === 0;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    // Blade cannot be zero because weight is implicity one.
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (is_blade$1(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                toInfixString(vec) {
                    return vec.toInfixString();
                }
                toLatexString(vec) {
                    return vec.toLatexString();
                }
                toListString(vec) {
                    return vec.toListString();
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    if (is_blade$1(expr)) {
                        return [TFLAG_HALT, expr];
                    }
                    return [TFLAG_NONE, expr];
                }
                valueOf(expr) {
                    return expr;
                }
            }
            const blade_extension = new ExtensionOperatorBuilder(function ($) {
                return new BladeExtension($);
            });

            function is_cons_opr_eq_mul(expr) {
                return is_cons_opr_eq_sym(expr, MATH_MUL$3);
            }

            function count_factors(expr, predicate) {
                if (is_cons_opr_eq_mul(expr)) {
                    return count_factors_recursive(expr.argList, predicate);
                }
                else {
                    return 0;
                }
            }
            function count_factors_recursive(argList, predicate) {
                if (is_nil(argList)) {
                    return 0;
                }
                else {
                    const arg = argList.car;
                    if (predicate(arg)) {
                        return 1 + count_factors_recursive(argList.argList, predicate);
                    }
                    else {
                        return count_factors_recursive(argList.argList, predicate);
                    }
                }
            }

            /**
             * Converts 0-ary and 1-ary multiplicative expressions to canonical form.
             *
             * 0-ary: (*)   => 1,
             *
             * 1-ary: (* x) => x,
             *
             * otherwise unchanged.
             */
            function canonicalize_mul(expr) {
                const L0 = expr;
                if (is_cons_opr_eq_mul(L0)) {
                    const L1 = L0.cdr;
                    if (is_nil(L1)) {
                        return one;
                    }
                    else if (is_nil(L1.cdr)) {
                        return L1.car;
                    }
                    else {
                        return L0;
                    }
                }
                else {
                    return L0;
                }
            }

            /**
             * expr = canonical_factor_num_lhs(expr) * canonical_factor_num_rhs(expr)
             */
            function canonical_factor_num_lhs(expr) {
                if (is_cons(expr)) {
                    const L0 = expr;
                    if (is_cons_opr_eq_mul(L0)) {
                        const L1 = L0.cdr;
                        if (is_nil(L1)) {
                            return one;
                        }
                        else {
                            const first = L1.car;
                            if (is_num(first)) {
                                return first;
                            }
                            else {
                                return one;
                            }
                        }
                    }
                    else {
                        return one;
                    }
                }
                else {
                    return one;
                }
            }
            /**
             * expr = canonical_factor_num_lhs(expr) * canonical_factor_num_rhs(expr)
             */
            function canonical_factor_num_rhs(expr) {
                if (is_cons(expr)) {
                    const L0 = expr;
                    if (is_cons_opr_eq_mul(L0)) {
                        const L1 = L0.cdr;
                        if (is_nil(L1)) {
                            return one;
                        }
                        else {
                            const first = L1.car;
                            if (is_num(first)) {
                                const L2 = L1.cdr;
                                return canonicalize_mul(cons(L0.opr, L2));
                            }
                            else {
                                return L0;
                            }
                        }
                    }
                    else {
                        return L0;
                    }
                }
                else {
                    return expr;
                }
            }

            /**
             * Removes factors from a (* f1 f2 f3) or atom that satisfy the predicate.
             * Essentialy returns an expression which is the original with factors removed.
             */
            function remove_factors(expr, predicate) {
                if (is_cons(expr)) {
                    if (is_cons_opr_eq_mul(expr)) {
                        return canonicalize_mul(cons(expr.opr, remove_factors_recursive(expr.argList, predicate)));
                    }
                    else {
                        return expr;
                    }
                }
                else {
                    if (predicate(expr)) {
                        return one;
                    }
                    else {
                        return expr;
                    }
                }
            }
            function remove_factors_recursive(argList, predicate) {
                if (is_nil(argList)) {
                    return argList;
                }
                else {
                    const arg = argList.car;
                    if (predicate(arg)) {
                        return remove_factors_recursive(argList.argList, predicate);
                    }
                    else {
                        return cons(arg, remove_factors_recursive(argList.argList, predicate));
                    }
                }
            }

            function strcmp(str1, str2) {
                if (str1 === str2) {
                    return 0;
                }
                else if (str1 > str2) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            function is_str(arg) {
                return arg instanceof Str$1;
            }
            class StrExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return emptyStr.name;
                }
                get hash() {
                    return HASH_STR;
                }
                get name() {
                    return 'StrExtension';
                }
                valueOf(str) {
                    return str;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                isKind(arg) {
                    return is_str(arg);
                }
                isMinusOne() {
                    return false;
                }
                isOne() {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                isZero() {
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (is_str(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                toInfixString(str) {
                    return str.toInfixString();
                }
                toLatexString(str) {
                    return str.toInfixString();
                }
                toListString(str) {
                    return str.toListString();
                }
                evaluate(str, argList) {
                    return this.transform(cons(str, argList));
                }
                transform(expr) {
                    if (is_str(expr)) {
                        return [TFLAG_HALT, expr];
                    }
                    return [TFLAG_NONE, expr];
                }
            }
            const str_extension = new ExtensionOperatorBuilder(function ($) {
                return new StrExtension($);
            });

            function number_to_floating_point_string(d, $) {
                // console.lg(`number_to_floating_point_string d=${d}`);
                // when generating code, print out
                // the standard JS Number printout
                let str;
                if (defs.codeGen || $.getNativeDirective(Directive.renderFloatAsEcmaScript)) {
                    return `${d}`;
                }
                if ($.is_zero($.getSymbolValue(FORCE_FIXED_PRINTOUT))) {
                    str = '' + d;
                    // manipulate the string so that it can be parsed by
                    // by ourselves (something like 1.23e-123 wouldn't cut it because
                    // that would be parsed as 1.23*e - 123)
                    if (defs.printMode === PRINTMODE_LATEX) {
                        // 1.0\mathrm{e}{-10} looks much better than the plain 1.0e-10
                        if (/\d*\.\d*e.*/gm.test(str)) {
                            str = str.replace(/e(.*)/gm, '\\mathrm{e}{$1}');
                        }
                        else {
                            // if there is no dot in the mantissa, add it so we see it's
                            // a double and not a perfect number
                            // e.g. 1e-10 becomes 1.0\mathrm{e}{-10}
                            str = str.replace(/(\d+)e(.*)/gm, '$1.0\\mathrm{e}{$2}');
                        }
                    }
                    else {
                        if (/\d*\.\d*e.*/gm.test(str)) {
                            str = str.replace(/e(.*)/gm, '*10^($1)');
                        }
                        else {
                            // if there is no dot in the mantissa, add it so we see it's
                            // a double and not a perfect number
                            // e.g. 1e-10 becomes 1.0e-10
                            str = str.replace(/(\d+)e(.*)/gm, '$1.0*10^($2)');
                        }
                    }
                }
                else {
                    // MAX_FIXED_PRINTOUT_DIGITS would be 6 if it were defined. If defined it would be a Rat or a Flt.
                    const txtMaxFixedPrintoutDigits = $.getSymbolValue(VARNAME_MAX_FIXED_PRINTOUT_DIGITS);
                    const maxFixedPrintoutDigits = nativeInt(is_nil(txtMaxFixedPrintoutDigits) ? create_int(DEFAULT_MAX_FIXED_PRINTOUT_DIGITS) : txtMaxFixedPrintoutDigits);
                    str = d.toFixed(maxFixedPrintoutDigits);
                    // remove any trailing zeroes after the dot
                    // see https://stackoverflow.com/questions/26299160/using-regex-how-do-i-remove-the-trailing-zeros-from-a-decimal-number
                    str = str.replace(/(\.\d*?[1-9])0+$/gm, '$1');
                    // in case there are only zeroes after the dot, removes the dot too
                    str = str.replace(/\.0+$/gm, '');
                    // we actually want to give a hint to user that
                    // it's a double, so add a trailing ".0" if there
                    // is no decimal point
                    if (str.indexOf('.') === -1) {
                        str += '.0';
                    }
                    if (parseFloat(str) !== d) {
                        str = d.toFixed(maxFixedPrintoutDigits) + '...';
                    }
                }
                return str;
            }

            function is_flt(p) {
                return p instanceof Flt;
            }
            class FltExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return oneAsFlt.name;
                }
                get name() {
                    return 'FltExtension';
                }
                get dependencies() {
                    return ['Flt'];
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    return [expr instanceof Flt ? TFLAG_HALT : TFLAG_NONE, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                isKind(arg) {
                    return is_flt(arg);
                }
                isMinusOne(arg) {
                    return arg.isMinusOne();
                }
                isOne(arg) {
                    return arg.isOne();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                isZero(arg) {
                    return arg.isZero();
                }
                subst(expr, oldExpr, newExpr) {
                    if (is_flt(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                toInfixString(atom, $) {
                    return number_to_floating_point_string(atom.d, $);
                }
                toLatexString(atom, $) {
                    return number_to_floating_point_string(atom.d, $);
                }
                toListString(atom, $) {
                    return number_to_floating_point_string(atom.d, $);
                }
                valueOf(expr) {
                    return expr;
                }
            }
            const flt_extension = new ExtensionOperatorBuilder(function ($) {
                return new FltExtension($);
            });

            function compare_num_num(lhs, rhs) {
                if (is_rat(lhs) && is_rat(rhs)) {
                    return lhs.compare(rhs);
                }
                const x = is_flt(lhs) ? lhs.toNumber() : lhs.toNumber();
                const y = is_flt(rhs) ? rhs.toNumber() : rhs.toNumber();
                if (x < y) {
                    return SIGN_LT;
                }
                if (x > y) {
                    return SIGN_GT;
                }
                return SIGN_EQ;
            }

            /**
             * The canonical function for comparing symbols.
             * This function ensures that MATH_PI will appear to the left of any other symbol.
             * It takes no account of whether the symbols should be treated as vectors.
             */
            function compare_sym_sym(lhs, rhs) {
                if (is_pi(lhs) && is_pi(rhs)) {
                    return SIGN_EQ;
                }
                else if (is_pi(lhs)) {
                    return SIGN_LT;
                }
                else if (is_pi(rhs)) {
                    return SIGN_GT;
                }
                else {
                    return lhs.compare(rhs);
                }
            }

            function compare_tensors(p1, p2, $) {
                if (p1.ndim < p2.ndim) {
                    return SIGN_LT;
                }
                if (p1.ndim > p2.ndim) {
                    return SIGN_GT;
                }
                const ndim = p1.ndim;
                for (let i = 0; i < ndim; i++) {
                    if (p1.dim(i) < p2.dim(i)) {
                        return SIGN_LT;
                    }
                    if (p1.dim(i) > p2.dim(i)) {
                        return SIGN_GT;
                    }
                }
                const nelem = p1.nelem;
                for (let i = 0; i < nelem; i++) {
                    switch (cmp_expr(p1.elem(i), p2.elem(i))) {
                        case SIGN_GT: {
                            return SIGN_GT;
                        }
                        case SIGN_LT: {
                            return SIGN_LT;
                        }
                        default: {
                            continue;
                        }
                    }
                }
                return SIGN_EQ;
            }

            /**
             * NIL, Num, Str, Sym, Tensor, Cons, Blade, Imu, Hyp, Uom
             */
            function cmp_expr(lhs, rhs, $) {
                // console.lg("ENTERING cmp_expr", "lhs", render_as_sexpr(lhs, $), "rhs", render_as_sexpr(rhs, $));
                let n = SIGN_EQ;
                if (lhs === rhs) {
                    return SIGN_EQ;
                }
                if (is_nil(lhs) && is_nil(rhs)) {
                    return SIGN_EQ;
                }
                if (is_nil(lhs)) {
                    return SIGN_LT;
                }
                if (is_nil(rhs)) {
                    return SIGN_GT;
                }
                if (is_num(lhs) && is_num(rhs)) {
                    return compare_num_num(lhs, rhs);
                }
                if (is_num(lhs)) {
                    return SIGN_LT;
                }
                if (is_num(rhs)) {
                    return SIGN_GT;
                }
                if (is_str$1(lhs) && is_str$1(rhs)) {
                    return strcmp(lhs.str, rhs.str);
                }
                if (is_str$1(lhs)) {
                    return SIGN_LT;
                }
                if (is_str$1(rhs)) {
                    return SIGN_GT;
                }
                if (is_sym(lhs) && is_sym(rhs)) {
                    return compare_sym_sym(lhs, rhs);
                }
                if (is_sym(lhs)) {
                    return SIGN_LT;
                }
                if (is_sym(rhs)) {
                    return SIGN_GT;
                }
                if (is_tensor(lhs) && is_tensor(rhs)) {
                    return compare_tensors(lhs, rhs);
                }
                if (is_tensor(lhs)) {
                    return SIGN_LT;
                }
                if (is_tensor(rhs)) {
                    return SIGN_GT;
                }
                if (is_uom$1(lhs) && is_uom$1(rhs)) {
                    return SIGN_EQ;
                }
                if (is_uom$1(lhs)) {
                    return SIGN_GT;
                }
                if (is_uom$1(rhs)) {
                    return SIGN_LT;
                }
                if (is_blade$1(lhs) && is_blade$1(rhs)) {
                    return compare_blade_blade(lhs, rhs);
                }
                if (is_blade$1(lhs)) {
                    return SIGN_GT;
                }
                if (is_blade$1(rhs)) {
                    return SIGN_LT;
                }
                if (is_imu(lhs) && is_imu(rhs)) {
                    return SIGN_EQ;
                }
                if (is_imu(lhs)) {
                    return SIGN_GT;
                }
                if (is_imu(rhs)) {
                    return SIGN_LT;
                }
                // recursion here
                while (is_cons(lhs) && is_cons(rhs)) {
                    n = cmp_expr(car(lhs), car(rhs));
                    if (n !== 0) {
                        return n;
                    }
                    lhs = cdr(lhs);
                    rhs = cdr(rhs);
                }
                if (is_cons(rhs)) {
                    return SIGN_LT;
                }
                if (is_cons(lhs)) {
                    return SIGN_GT;
                }
                return SIGN_EQ;
            }

            function contains_single_blade(expr) {
                if (is_blade$1(expr)) {
                    return true;
                }
                else if (is_cons(expr) && is_cons_opr_eq_mul(expr) && count_factors(expr, is_blade$1) === 1) {
                    return true;
                }
                else {
                    return false;
                }
            }

            const not_is_blade = (expr) => !is_blade$1(expr);

            function extract_single_blade(expr) {
                if (is_blade$1(expr)) {
                    return expr;
                }
                else if (is_cons(expr) && is_cons_opr_eq_mul(expr) && count_factors(expr, is_blade$1) === 1) {
                    const candidate = remove_factors(expr, not_is_blade);
                    if (is_blade$1(candidate)) {
                        return candidate;
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    throw new Error();
                }
            }

            class AddComparator {
                compare(lhs, rhs, $) {
                    const lhsR = canonical_factor_num_rhs(lhs);
                    const rhsR = canonical_factor_num_rhs(rhs);
                    switch (cmp_terms_core(lhsR, rhsR, $)) {
                        case SIGN_GT: {
                            return SIGN_GT;
                        }
                        case SIGN_LT: {
                            return SIGN_LT;
                        }
                        case SIGN_EQ: {
                            // If two terms, apart from numeric factors, are equal then it really does not matter too much
                            // how they are sorted because they are destined to be combined through addition.
                            // TODO: When tests are passing, try removing this code and returning SIGN_EQ.
                            // In other words do we ever have sums where adjacent terms differ only in numerical factors?
                            const lhsL = canonical_factor_num_lhs(lhs);
                            const rhsL = canonical_factor_num_lhs(rhs);
                            return compare_num_num(lhsL, rhsL);
                        }
                    }
                }
            }
            /**
             * @deprecated
             */
            function cmp_terms(lhs, rhs, $) {
                return $.compareFn(MATH_ADD$1)(lhs, rhs);
            }
            function cmp_terms_core(lhs, rhs, $) {
                // console.lg("ENTERING", "cmp_terms", "lhs", render_as_sexpr(lhs, $), "rhs", render_as_sexpr(rhs, $));
                // numbers can be combined
                if (lhs.equals(rhs)) {
                    return SIGN_EQ;
                }
                if (contains_single_blade(lhs) && contains_single_blade(rhs)) {
                    const bladeL = extract_single_blade(lhs);
                    const bladeR = extract_single_blade(rhs);
                    if (bladeL.equals(lhs) && bladeR.equals(rhs)) {
                        return compare_blade_blade(bladeL, bladeR);
                    }
                    else {
                        switch (cmp_terms(bladeL, bladeR, $)) {
                            case SIGN_GT: {
                                return SIGN_GT;
                            }
                            case SIGN_LT: {
                                return SIGN_LT;
                            }
                            default: {
                                return cmp_terms(remove_factors(lhs, is_blade$1), remove_factors(rhs, is_blade$1), $);
                            }
                        }
                    }
                }
                if (contains_single_blade(lhs)) {
                    return SIGN_GT;
                }
                if (contains_single_blade(rhs)) {
                    return SIGN_LT;
                }
                if (contains_single_imu(lhs) && contains_single_imu(rhs)) {
                    return cmp_terms(remove_factors(lhs, is_imu), remove_factors(rhs, is_imu), $);
                }
                // These probably belong in general expression comparision.
                if (contains_single_imu(lhs)) {
                    return SIGN_GT;
                }
                if (contains_single_imu(rhs)) {
                    return SIGN_LT;
                }
                if (is_num(lhs) && is_num(rhs)) {
                    return SIGN_EQ;
                }
                // congruent tensors can be combined
                if (is_tensor(lhs) && is_tensor(rhs)) {
                    if (lhs.ndim < rhs.ndim) {
                        return SIGN_LT;
                    }
                    if (lhs.ndim > rhs.ndim) {
                        return SIGN_GT;
                    }
                    const ndim = lhs.ndim;
                    for (let i = 0; i < ndim; i++) {
                        if (lhs.dim(i) < rhs.dim(i)) {
                            return SIGN_LT;
                        }
                        if (lhs.dim(i) > rhs.dim(i)) {
                            return SIGN_GT;
                        }
                    }
                    return SIGN_EQ;
                }
                const lhsPart = canonical_factor_num_rhs(lhs);
                const rhsPart = canonical_factor_num_rhs(rhs);
                // I'd still like to compare as terms, but that would be recursive if we don't have a termination condition.
                if (lhsPart.equals(lhs) && rhsPart.equals(rhs)) {
                    return cmp_expr(lhsPart, rhsPart);
                }
                else {
                    return cmp_terms(lhsPart, rhsPart, $);
                }
            }
            function contains_single_imu(expr) {
                if (is_imu(expr)) {
                    return true;
                }
                else if (is_cons(expr) && is_cons_opr_eq_mul(expr) && count_factors(expr, is_imu) === 1) {
                    return true;
                }
                else {
                    return false;
                }
            }

            class MulComparator {
                compare(lhs, rhs, $) {
                    // console.lg("ENTERING :", "compare *", "lhs", render_as_sexpr(lhs, $), "rhs", render_as_sexpr(rhs, $));
                    if (lhs === rhs || lhs.equals(rhs)) {
                        return SIGN_EQ;
                    }
                    /*
                    if (contains_single_blade(lhs) && contains_single_blade(rhs)) {
                        return SIGN_EQ;
                    }
                    */
                    if (lhs === rhs) {
                        return SIGN_EQ;
                    }
                    if (is_nil(lhs) && is_nil(rhs)) {
                        return SIGN_EQ;
                    }
                    if (is_nil(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_nil(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_num(lhs) && is_num(rhs)) {
                        return compare_num_num(lhs, rhs);
                    }
                    if (is_num(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_num(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_imu(lhs) && is_imu(rhs)) {
                        return SIGN_EQ;
                    }
                    if (is_imu(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_imu(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_str$1(lhs) && is_str$1(rhs)) {
                        return strcmp(lhs.str, rhs.str);
                    }
                    if (is_str$1(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_str$1(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_sym(lhs) && is_sym(rhs)) {
                        return compare_sym_sym(lhs, rhs);
                    }
                    if (is_sym(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_sym(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_tensor(lhs) && is_tensor(rhs)) {
                        return compare_tensors(lhs, rhs);
                    }
                    if (is_tensor(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_tensor(rhs)) {
                        return SIGN_GT;
                    }
                    while (is_cons(lhs) && is_cons(rhs)) {
                        const n = cmp_expr(car(lhs), car(rhs));
                        if (n !== SIGN_EQ) {
                            return n;
                        }
                        lhs = cdr(lhs);
                        rhs = cdr(rhs);
                    }
                    if (is_cons(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_cons(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_blade$1(lhs) && is_blade$1(rhs)) {
                        // In general, blades do not commute under multiplication.
                        return SIGN_EQ;
                    }
                    if (is_blade$1(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_blade$1(rhs)) {
                        return SIGN_GT;
                    }
                    if (is_uom$1(lhs) && is_uom$1(rhs)) {
                        return SIGN_EQ;
                    }
                    if (is_uom$1(lhs)) {
                        return SIGN_LT;
                    }
                    if (is_uom$1(rhs)) {
                        return SIGN_GT;
                    }
                    return SIGN_EQ;
                }
            }

            /*
              Clear all patterns
            */
            function clear_patterns() {
                defs.userSimplificationsInListForm = [];
                defs.userSimplificationsInStringForm = [];
            }

            /**
             * A bunch of strings that are scanned and evaluated, therby changing some bindings.
             * Concretely, the string "var = expr" becomes (set! var expr), where the expr has been evaluated.
             * This (set! var expr) is then evaluated and it becomes a binding of var to the expanded expression.
             */
            const defn_strings = [
                'e=exp(1)',
                'i=sqrt(-1)',
                'pi=tau(1)/2',
                'autoexpand=1',
                // TODO: Is setting this to zero really respected?
                // The converse is that variables may be complex.
                // We really need a better way to specify the types of symbols.
                'assumeRealVariables=1',
                // TODO: remove these and make sure it still works when these are not bound.
                'last=0',
                'trace=0',
                'forceFixedPrintout=1',
                `${VARNAME_MAX_FIXED_PRINTOUT_DIGITS}=${DEFAULT_MAX_FIXED_PRINTOUT_DIGITS}`,
                'printLeaveEAlone=1',
                'printLeaveXAlone=0',
            ];
            function execute_std_definitions($) {
                // console.lg('execute_std_definitions()');
                const originalCodeGen = defs.codeGen;
                defs.codeGen = false;
                try {
                    for (let i = 0; i < defn_strings.length; i++) {
                        const defn_string = defn_strings[i];
                        execute_definition(defn_string, $);
                    }
                }
                finally {
                    // restore the symbol dependencies as they were before.
                    defs.codeGen = originalCodeGen;
                }
            }
            function execute_definition(sourceText, $) {
                // console.lg(`execute_definition(${JSON.stringify(sourceText)})`);
                const originalCodeGen = defs.codeGen;
                defs.codeGen = false;
                try {
                    const [scanned, tree] = scan(sourceText, {
                        useCaretForExponentiation: $.getNativeDirective(Directive.useCaretForExponentiation),
                        explicitAssocAdd: false,
                        explicitAssocMul: false
                    });
                    try {
                        if (scanned > 0) {
                            // Evaluating the tree for the side-effect which is to establish a binding.
                            $.pushNativeDirective(Directive.expand, true);
                            try {
                                $.valueOf(tree);
                            }
                            finally {
                                $.popNativeDirective();
                            }
                        }
                    }
                    catch (e) {
                        if (e instanceof Error) {
                            throw new Error(`Unable to compute the value of definition ${JSON.stringify(sourceText)}. Cause: ${e.message}. Stack: ${e.stack}`);
                        }
                        else {
                            throw new Error(`Unable to compute the value of definition ${JSON.stringify(sourceText)}. Cause: ${e}`);
                        }
                    }
                }
                finally {
                    // restore the symbol dependencies as they were before.
                    defs.codeGen = originalCodeGen;
                }
            }

            function Eval_clearall($) {
                clear_patterns();
                $.clearBindings();
                // We need to redo these...
                execute_std_definitions($);
                return nil;
            }
            function Eval_clear(expr, $) {
                let argList = expr.argList;
                while (is_cons(argList)) {
                    const varName = car(argList);
                    if (is_sym(varName)) {
                        $.remove(varName);
                    }
                    else {
                        halt('symbol error');
                    }
                    argList = cdr(argList);
                }
                return nil;
            }

            // Guess which symbol to use for derivative, integral, etc.
            function guess(p) {
                if (p.contains(SYMBOL_X)) {
                    return SYMBOL_X;
                }
                else if (p.contains(SYMBOL_Y)) {
                    return SYMBOL_Y;
                }
                else if (p.contains(SYMBOL_Z)) {
                    return SYMBOL_Z;
                }
                else if (p.contains(SYMBOL_T)) {
                    return SYMBOL_T;
                }
                else if (p.contains(SYMBOL_S)) {
                    return SYMBOL_S;
                }
                else {
                    return SYMBOL_X;
                }
            }

            function length_of_cons_otherwise_zero(expr) {
                return is_cons(expr) ? [...expr].length : 0;
            }

            /**
             * The expression must be a Rat or Flt, otherwise the return value is false.
             * Returns true if expr < 0.
             * @param expr The expression being tested.
             */
            function is_negative_number(expr) {
                if (is_rat$1(expr)) {
                    return expr.isNegative();
                }
                else if (is_flt$1(expr)) {
                    return expr.isNegative();
                }
                else {
                    return false;
                }
            }

            //
            // TODO: In order not to torture our future selves, these should be documented and have coverage unit testing.
            // Maybe document the matching patterns?
            // Using block comments makes it possible to compose these with logical operators.
            //
            /**
             * The expression must be a Rat or Flt, otherwise the return value is false.
             * TODO: Interesting that this required expr > 0, when positive usually includes zero.
             * @param expr The expression being tested.
             */
            function is_num_and_gt_zero(expr) {
                if (is_rat$1(expr)) {
                    return MSIGN(expr.a) === 1;
                }
                else if (is_flt$1(expr)) {
                    return expr.d > 0.0;
                }
                else {
                    return false;
                }
            }
            function is_num_and_eq_two(p) {
                if (is_rat$1(p)) {
                    return MEQUAL(p.a, 2) && MEQUAL(p.b, 1);
                }
                else if (is_flt$1(p)) {
                    return p.d === 2.0;
                }
                else {
                    return false;
                }
            }
            /**
             *
             */
            function is_num_and_eq_minus_one(p) {
                if (is_num(p)) {
                    return p.isMinusOne();
                }
                else {
                    return false;
                }
            }
            /**
             *
             */
            function is_plus_or_minus_one(x, $) {
                return $.isOne(x) || is_num_and_eq_minus_one(x);
            }
            function is_integer_or_integer_float(p) {
                if (is_flt$1(p)) {
                    if (p.d === Math.round(p.d)) {
                        return true;
                    }
                    return false;
                }
                if (is_rat$1(p)) {
                    return p.isInteger();
                }
                return is_rat_and_integer(p);
            }
            function isnonnegativeinteger(p) {
                return is_rat$1(p) && MEQUAL(p.b, 1) && MSIGN(p.a) === 1;
            }
            function is_rat_and_positive_integer(p) {
                if (is_rat_and_integer(p)) {
                    return p.isPositiveInteger();
                }
                else {
                    return false;
                }
            }
            // --------------------------------------
            function isunivarpolyfactoredorexpandedform(p, x, $) {
                if (x == null) {
                    x = guess(p);
                }
                if (ispolyfactoredorexpandedform(p, x) && countTrue(p.contains(SYMBOL_X), p.contains(SYMBOL_Y), p.contains(SYMBOL_Z)) === 1) {
                    return x;
                }
                else {
                    return nil;
                }
            }
            function countTrue(...a) {
                // Number(true) = 1
                return a.reduce((count, x) => count + Number(x), 0);
            }
            // --------------------------------------
            // sometimes we want to check if we have a poly in our
            // hands, however it's in factored form and we don't
            // want to expand it.
            function ispolyfactoredorexpandedform(p, x, $) {
                return ispolyfactoredorexpandedform_factor(p, x);
            }
            function ispolyfactoredorexpandedform_factor(p, x, $) {
                if (is_multiply(p)) {
                    return p.tail().every((el) => {
                        const bool = ispolyfactoredorexpandedform_power(el, x);
                        return bool;
                    });
                }
                else {
                    return ispolyfactoredorexpandedform_power(p, x);
                }
            }
            function ispolyfactoredorexpandedform_power(p, x, $) {
                if (is_power(p)) {
                    return is_rat_and_positive_integer(caddr(p)) && is_poly_expanded_form_expr(cadr(p), x);
                }
                else {
                    return is_poly_expanded_form_expr(p, x);
                }
            }
            // --------------------------------------
            /**
             * Determines whether the expression, p, is a polynomial in the variable, x.
             *
             * @param p
             * @param x
             * @returns
             */
            function is_poly_expanded_form(p, x, $) {
                // console.lg(`is_poly_expanded_form ${print_expr(p, $)} ${x}`);
                if (p.contains(x)) {
                    return is_poly_expanded_form_expr(p, x);
                }
                else {
                    // If the expression does not contain the variable then it's a non-starter.
                    return false;
                }
            }
            function is_poly_expanded_form_expr(p, x, $) {
                // console.lg(`is_poly_expanded_form_expr ${print_expr(p, $)} ${x}`);
                if (is_add(p)) {
                    return p.tail().every((term) => is_poly_expanded_form_term(term, x));
                }
                else {
                    return is_poly_expanded_form_term(p, x);
                }
            }
            function is_poly_expanded_form_term(p, x, $) {
                // console.lg(`is_poly_expanded_form_term ${print_expr(p, $)} ${x}`);
                if (is_multiply(p)) {
                    return p.tail().every((factor) => is_poly_expanded_form_factor(factor, x));
                }
                else {
                    return is_poly_expanded_form_factor(p, x);
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function is_poly_expanded_form_factor(p, x, $) {
                // console.lg(`is_poly_expanded_form_factor ${print_expr(p, $)} ${x}`);
                if (p.equals(x)) {
                    return true;
                }
                if (is_power(p) && cadr(p).equals(x)) {
                    return is_rat_and_positive_integer(caddr(p));
                }
                if (p.contains(x)) {
                    return false;
                }
                else {
                    return true;
                }
            }
            function has_negative_rational_exponent(expr) {
                if (is_power(expr)) {
                    if (is_rat$1(car(cdr(cdr(expr))))) {
                        if (is_negative_number(car(cdr(expr)))) {
                            // (expt)
                            return true;
                        }
                    }
                }
                return false;
            }
            function isimaginarynumberdouble(p, $) {
                return ((is_multiply(p) &&
                    length_of_cons_otherwise_zero(p) === 3 &&
                    is_flt$1(cadr(p)) &&
                    has_negative_rational_exponent(caddr(p))) ||
                    $.equals(p, imu));
            }
            /**
             * (multiply Num i)
             */
            function is_imaginary_number(expr) {
                if (is_multiply(expr)) {
                    // (multiply a1 a2 a3 ...)
                    if (length_of_cons_otherwise_zero(expr) === 3) {
                        // (multiply x y)
                        if ((is_num(cadr(expr)) && caddr(expr).equals(imu))) {
                            // (multiply Num i)
                            return true;
                        }
                        if (expr.equals(imu)) {
                            // Probbaly dead code because i => (expt -1 1/2), which isn't a (multiply )
                            return true;
                        }
                        if (has_negative_rational_exponent(caddr(expr))) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function iscomplexnumberdouble(p, $) {
                return ((is_add(p) &&
                    length_of_cons_otherwise_zero(p) === 3 &&
                    is_flt$1(cadr(p)) &&
                    isimaginarynumberdouble(caddr(p), $)) ||
                    isimaginarynumberdouble(p, $));
            }
            /**
             * Determines whether expr is of the form (+ Num (something times i))
             * For this to work it is crucial that the complex number terms be arranged with
             * the real part on the left hand side. e.g. 1.0 + 2.0*i.
             * Notice that
             * @param expr
             * @param $
             * @returns
             */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function is_complex_number(expr, $) {
                // console.lg(`is_complex_number ${render_as_sexpr(expr, $)}`);
                if (is_add(expr)) {
                    // console.lg(`${$.toInfixString(expr)} is an add expression`);
                    const n = length_of_cons_otherwise_zero(expr);
                    // console.lg(`${$.toInfixString(expr)} n = ${n}`);
                    if (n === 3) {
                        const x = cadr(expr);
                        // console.lg(`${$.toInfixString(expr)} X = ${$.toInfixString(X)}`);
                        if (is_num(x)) {
                            if ((is_imaginary_number(caddr(expr))) || is_imaginary_number(expr)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            function iseveninteger(expr) {
                return is_rat_and_integer(expr) && expr.a.isEven();
            }
            function isNumberOneOverSomething(p) {
                return is_rat$1(p) && p.isFraction() && MEQUAL(p.a.abs(), 1);
            }
            /**
             * @deprecated Use is_rat(expr) && expr.isFraction()
             */
            function isfraction(p) {
                return is_rat$1(p) && p.isFraction();
            }
            // n an int
            /**
             * Returns true if the expr is the specified number.
             * TODO: This only handles Rat and Flt. Everything else returns false.
             * @param expr The expresson being tested.
             * @param n The value that the expression must match.
             */
            function equaln(expr, n) {
                if (expr !== null) {
                    if (is_rat$1(expr)) {
                        return MEQUAL(expr.a, n) && MEQUAL(expr.b, 1);
                    }
                    else if (is_flt$1(expr)) {
                        return expr.d === n;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            // a and b ints
            function is_num_and_equalq(expr, a, b) {
                if (is_rat$1(expr)) {
                    return expr.numer().isIntegerNumber(a) && expr.denom().isIntegerNumber(b);
                }
                else if (is_flt$1(expr)) {
                    return expr.d === a / b;
                }
                else {
                    return false;
                }
            }
            // p == 1/2 ?
            function is_num_and_equal_one_half(p) {
                return is_num_and_equalq(p, 1, 2);
            }
            // p == -1/2 ?
            function is_num_and_equal_minus_half(p) {
                return is_num_and_equalq(p, -1, 2);
            }
            // p == 1/sqrt(2) ?
            function isoneoversqrttwo(p) {
                return is_power(p) && equaln(cadr(p), 2) && is_num_and_equalq(caddr(p), -1, 2);
            }
            // p == -1/sqrt(2) ?
            function isminusoneoversqrttwo(p) {
                return (is_multiply(p) &&
                    equaln(cadr(p), -1) &&
                    isoneoversqrttwo(caddr(p)) &&
                    length_of_cons_otherwise_zero(p) === 3);
            }
            // Check if the value is sqrt(3)/2
            function isSqrtThreeOverTwo(p) {
                return (is_multiply(p) &&
                    is_num_and_equal_one_half(cadr(p)) &&
                    isSqrtThree(caddr(p)) &&
                    length_of_cons_otherwise_zero(p) === 3);
            }
            // Check if the value is -sqrt(3)/2
            function isMinusSqrtThreeOverTwo(p) {
                return (is_multiply(p) &&
                    is_num_and_equal_minus_half(cadr(p)) &&
                    isSqrtThree(caddr(p)) &&
                    length_of_cons_otherwise_zero(p) === 3);
            }
            // Check if value is sqrt(3)
            function isSqrtThree(p) {
                return is_power(p) && equaln(cadr(p), 3) && is_num_and_equal_one_half(caddr(p));
            }
            function contains_floating_values_or_floatf(expr) {
                // TODO: This probably needs to go into extension types as well. 
                if (is_flt$1(expr) || FLOAT.equals(expr)) {
                    return true;
                }
                if (is_cons(expr)) {
                    return [...expr].some(contains_floating_values_or_floatf);
                }
                return false;
            }

            /**
             *
             * @param nelem The total number of elements.
             * @param value The value to use for each element.
             */
            function create_tensor_elements(nelem, value) {
                const elems = new Array(nelem);
                for (let i = 0; i < nelem; i++) {
                    elems[i] = value;
                }
                return elems;
            }
            function create_tensor_elements_diagonal(n, diagValue, otherValue) {
                const elems = create_tensor_elements(n * n, otherValue);
                for (let i = 0; i < n; i++) {
                    elems[n * i + i] = diagValue;
                }
                return elems;
            }

            // n an integer
            /**
             * @deprecated until we decide whether to sort as terms or factors.
             * @param n
             * @param $
             */
            function sort_stack(n, $) {
                const h = defs.tos - n;
                const subsetOfStack = defs.stack.slice(h, h + n);
                subsetOfStack.sort(function (a, b) {
                    return cmp_terms(a, b, $);
                });
                defs.stack = defs.stack
                    .slice(0, h)
                    .concat(subsetOfStack)
                    .concat(defs.stack.slice(h + n));
            }

            function subtract(lhs, rhs, $) {
                const hook = function (retval) {
                    return retval;
                };
                const A = $.negate(rhs);
                const B = $.add(lhs, A);
                return hook(B);
            }

            /**
             * TODO: Exactly what kind of inverse is this?
             * @param expr
             * @param $
             * @returns
             */
            function inverse(expr, $) {
                const value = $.valueOf(expr);
                if (is_num(value)) {
                    return invert_number(value);
                }
                else {
                    return $.valueOf(items_to_cons$1(MATH_POW$2, value, negOne));
                }
            }
            /**
             *
             */
            function invert_number(num) {
                if (num.isZero()) {
                    // TODO: This error could/should be part of the inv() methods?
                    throw new Error('divide by zero');
                }
                if (is_flt$1(num)) {
                    return num.inv();
                }
                if (is_rat$1(num)) {
                    return num.inv();
                }
                throw new Error();
            }

            /**
             * Convenience function for dividing lhs by rhs.
             */
            function divide(lhs, rhs, $) {
                if (is_num(lhs) && is_num(rhs)) {
                    return divide_numbers(lhs, rhs);
                }
                else {
                    const inverse_rhs = inverse(rhs, $);
                    return $.multiply(lhs, inverse_rhs);
                }
            }
            function divide_expand(lhs, rhs, $) {
                $.pushNativeDirective(Directive.expand, true);
                try {
                    return divide(lhs, rhs, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }

            /**
             * Filter out terms in the polynomial f that contain x.
             * In other words, return only the constant part of f when x is the variable.
             * @param F The polynomial.
             * @param X The variable.
             */
            function filter(F, X, $) {
                return filter_main(F, X, $);
            }
            function filter_main(F, X, $) {
                if (is_add(F)) {
                    return filter_sum(F, X, $);
                }
                if (is_tensor(F)) {
                    return filter_tensor(F, X, $);
                }
                if (F.contains(X)) {
                    return zero;
                }
                return F;
            }
            function filter_sum(F, X, $) {
                return F.tail().reduce((a, b) => $.add(a, filter(b, X, $)), zero);
            }
            function filter_tensor(F, X, $) {
                return F.map((f) => filter(f, X, $));
            }

            function is_binop(expr) {
                return expr.length === 3;
            }

            function is_opr_2_any_any(name) {
                return function (expr) {
                    return is_cons_opr_eq_sym(expr, name) && is_binop(expr);
                };
            }

            function is_mul_2_any_any(expr) {
                return is_opr_2_any_any(MATH_MUL$3)(expr);
            }

            function subst(expr, oldExpr, newExpr, $) {
                if (expr.equals(oldExpr)) {
                    return newExpr;
                }
                if (is_cons(expr)) {
                    const car_expr = expr.car;
                    const cdr_expr = expr.cdr;
                    const replace_car = car_expr.contains(oldExpr);
                    const replace_cdr = cdr_expr.contains(oldExpr);
                    if (replace_car) {
                        const new_car = subst(car_expr, oldExpr, newExpr, $);
                        if (replace_cdr) {
                            const new_cdr = subst(cdr_expr, oldExpr, newExpr, $);
                            return cons(new_car, new_cdr);
                        }
                        else {
                            return cons(new_car, cdr_expr);
                        }
                    }
                    else {
                        if (replace_cdr) {
                            const new_cdr = subst(cdr_expr, oldExpr, newExpr, $);
                            return cons(car_expr, new_cdr);
                        }
                        else {
                            return expr;
                        }
                    }
                }
                else {
                    const op = $.operatorFor(expr);
                    return op.subst(expr, oldExpr, newExpr);
                }
            }

            /* coeff =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            p,x,n

            General description
            -------------------
            Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.

            */
            function Eval_coeff(p1, $) {
                const p = $.valueOf(cadr(p1));
                let x = $.valueOf(caddr(p1));
                let n = $.valueOf(cadddr(p1));
                if (nil.equals(n)) {
                    // only 2 args?
                    n = x;
                    x = SYMBOL_X;
                }
                // divide p by x^n, keep the constant term (the term not containing x)
                const x_pow_n = $.power(x, n);
                const p_div_x_pow_n = divide(p, x_pow_n, $);
                const k = filter(p_div_x_pow_n, x, $);
                return k;
            }
            //-----------------------------------------------------------------------------
            //
            //  Get polynomial coefficients
            //
            //  Input:  p(x) (the polynomial)
            //
            //          x (the variable)
            //
            //  Output:    Returns the array of coefficients:
            //
            //      [Coefficient of x^0, ..., Coefficient of x^(n-1)]
            //
            //-----------------------------------------------------------------------------
            /**
             * Used by bake, factorpoly, nroots, quotient, roots.
             * TODO: is it used by Eval_coeff?
             * @param expr
             * @param x
             * @param $
             * @returns
             */
            function coeff(expr, x, $) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    return retval;
                };
                const coefficients = [];
                let p = expr;
                // We get a coefficient from each iteration of the loop.
                const MAX_LOOPS = 10;
                let loops = 0;
                // TODO: Replace by recursive function?
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    // console.lg();
                    // console.lg(`P(${x}) => ${print_expr(p, $)}`);
                    // console.lg(`P(${x}) => ${print_list(p, $)}`);
                    const p0 = subst(p, x, zero, $);
                    const c = $.valueOf(p0);
                    // console.lg(`c = P(${x}=0) => ${print_expr(c, $)}`);
                    coefficients.push(c);
                    // console.lg(`subtracting ${print_list(c, $)} from ${print_list(p, $)}`);
                    // TODO: Optimization is if p == c then result is zero.
                    if (p.equals(c)) {
                        p = zero;
                    }
                    else {
                        p = $.valueOf(subtract(p, c, $));
                    }
                    // console.lg(`P(${x})-${print_expr(c, $)} = ${print_list(p, $)}`);
                    if (p.equals(zero)) {
                        // This appears to be the only way we get out of the loop.
                        return hook(coefficients);
                    }
                    // We should get the same result through division, although I would be concerned that
                    // x/x depends upon whether x is non-zero. In future, our analysis may reflect that by
                    // returning a conditioned expression. We may even try to do better than this by seeing if
                    // p has the factor x on the right (in some form or other).
                    // Certainly, this shortcut avoids a lot of computation of coefficients etc.
                    if (p.equals(x)) {
                        p = one;
                    }
                    else if (is_cons(p) && is_mul_2_any_any_and_rhs_equals(p, x)) {
                        p = p.lhs;
                    }
                    // TODO: Optimize for the case that p is (expt x n)
                    else {
                        // console.lg(`P(${x}) => ${print_expr(p, $)}`);
                        p = divide_expand(p, x, $);
                        // console.lg(`P(${x})/${x} => ${print_list(p, $)} (divide_expand)`);
                        p = $.valueOf(p);
                        // console.lg(`P(${x})/${x} => ${print_expr(p, $)} (after value-of)`);
                        // throw new Error("ENOUGH!");
                        // console.lg(`P(x)/x => ${p}`);
                    }
                    loops++;
                    if (loops > MAX_LOOPS) {
                        throw new Error("No making progress computing coefficients.");
                    }
                }
            }
            function is_mul_2_any_any_and_rhs_equals(expr, x) {
                if (is_mul_2_any_any(expr)) {
                    return expr.rhs.equals(x);
                }
                else {
                    return false;
                }
            }

            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function imag$2(z, $) {
                return items_to_cons$1(IMAG$h, z);
                /*
                // console.lg(`imag`, $.toInfixString(z));
                if (is_sym(z)) {
                    if ($.is_real(z)) {
                        return zero;
                    }
                    else {
                        return items_to_cons(IMAG, z);
                    }
                }
                // The use of the real() function is elegant but it introduces the risk of infinite recursion.
                const neg_imu = $.valueOf(items_to_cons(MATH_MUL, negOne, imu));
                // console.lg(`neg_imu`, $.toInfixString(neg_imu));
                const neg_imu_times_z = $.valueOf(items_to_cons(MATH_MUL, neg_imu, z));
                // console.lg(`neg_imu_times_z`, $.toInfixString(neg_imu_times_z));
                return real(neg_imu_times_z, $);
                */
            }

            /* conj =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            z

            General description
            -------------------
            Returns the complex conjugate of z.

            */
            // careful is you pass this one an expression with
            // i (instead of (-1)^(1/2)) then this doesn't work!
            function complex_conjugate(expr, $) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, where) {
                    // console.lg(`conj of ${$.toInfixString(z)} => ${$.toInfixString(retval)} (${where})`);
                    return retval;
                };
                // console.lg(`i => ${$.toInfixString(i)}`);
                const minus_i = $.negate(imu);
                // console.lg(`minus_i => ${$.toInfixString(minus_i)}`);
                // console.lg(`z => ${$.toInfixString(expr)}`);
                const z_star = subst(expr, imu, minus_i, $);
                // console.lg(`z_star => ${$.toInfixString(z_star)}`);
                return hook($.valueOf(z_star));
            }

            const EXP$6 = native_sym(Native.exp);
            const MATH_LOG$1 = native_sym(Native.log);
            const MATH_MUL$2 = native_sym(Native.multiply);
            const REAL$a = native_sym(Native.real);
            function compute_r_from_base_and_expo(base, expo, $) {
                // console.lg("compute_r_from_base_and_expo", $.toInfixString(base), $.toInfixString(expo));
                // console.lg("base", $.toInfixString(base));
                // console.lg("expo", $.toInfixString(expo));
                const log_base = $.valueOf(items_to_cons$1(MATH_LOG$1, base));
                // console.lg("log_base", $.toInfixString(log_base));
                const expo_times_log_base = $.valueOf(items_to_cons$1(MATH_MUL$2, expo, log_base));
                // console.lg("expo_times_log_base", $.toInfixString(expo_times_log_base));
                const real_expo_times_log_base = $.valueOf(items_to_cons$1(REAL$a, expo_times_log_base));
                // console.lg("real_expo_times_log_base", $.toInfixString(real_expo_times_log_base));
                const r = $.valueOf(items_to_cons$1(EXP$6, real_expo_times_log_base));
                // console.lg("r", $.toInfixString(r));
                return r;
            }

            const MATH_LOG = native_sym(Native.log);
            const MATH_MUL$1 = native_sym(Native.multiply);
            const IMAG$g = native_sym(Native.imag);
            function compute_theta_from_base_and_expo(base, expo, $) {
                const log_base = $.valueOf(items_to_cons$1(MATH_LOG, base));
                const expo_times_log_base = $.valueOf(items_to_cons$1(MATH_MUL$1, expo, log_base));
                const theta = $.valueOf(items_to_cons$1(IMAG$g, expo_times_log_base));
                return theta;
            }

            const MATH_ADD = native_sym(Native.add);
            const COS$2 = native_sym(Native.cos);
            const EXP$5 = native_sym(Native.exp);
            const IMAG$f = native_sym(Native.imag);
            const MATH_MUL = native_sym(Native.multiply);
            const MATH_POW$1 = native_sym(Native.pow);
            const REAL$9 = native_sym(Native.real);
            /**
             * Returns the real part of complex z
             * We assume the expr has already been evaluated.
             * @param expr
             * @param $
             * @returns
             */
            function real$2(expr, $) {
                // console.lg(`real`, $.toInfixString(expr));
                // console.lg("real", $.toSExprString(expr));
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, where) {
                    // console.lg(`HOOK: real part of ${$.toInfixString(expr)} is ${$.toInfixString(retval)} (${where})`);
                    return retval;
                };
                if ($.is_real(expr)) {
                    return hook(expr);
                }
                else if (is_rat$1(expr)) {
                    return expr;
                }
                else if (is_sym(expr)) {
                    const flag = $.getSymbolValue(ASSUME_REAL_VARIABLES);
                    if (is_rat$1(flag) && flag.isOne()) {
                        return expr;
                    }
                    else {
                        return items_to_cons$1(REAL$9, expr);
                    }
                }
                else if (is_add(expr)) {
                    // console.lg("is_add", $.toInfixString(expr));
                    const argList = expr.argList;
                    const A = argList.map(function (arg) {
                        return real$2(arg, $);
                    });
                    const sum = $.valueOf(cons(MATH_ADD, A));
                    // console.lg("real of", $.toInfixString(expr), "is", $.toInfixString(sum));
                    return hook(sum);
                }
                else if (is_power(expr)) {
                    const base = expr.lhs;
                    const expo = expr.rhs;
                    // console.lg("base", $.toInfixString(base));
                    // console.lg("expo", $.toInfixString(expo));
                    if (base.contains(imu)) {
                        if (is_rat$1(expo) && expo.isInteger() && expo.isNegative()) {
                            const conj_base = complex_conjugate(base, $);
                            const A = $.valueOf(items_to_cons$1(MATH_POW$1, base, expo.succ()));
                            const B = $.valueOf(conj_base);
                            const numer = $.valueOf(items_to_cons$1(MATH_MUL, A, B));
                            const denom = $.valueOf(items_to_cons$1(MATH_MUL, base, conj_base));
                            const C = divide(numer, denom, $);
                            return hook($.valueOf(items_to_cons$1(REAL$9, C)));
                        }
                        else {
                            throw new Error("Power");
                        }
                    }
                    else {
                        // The expression is in the form of a power.
                        // It is natural to then take a log: log(z) = log(base^expo)=>expo*log(base)
                        // Now let z = r * exp(i*theta). log(z) = log(r) + i * theta
                        // Hence log(r) + i * theta = expo*log(base)
                        // real(z) = r * cos(theta)
                        // log(r) = real(expo*log(base))
                        // r = exp(real(expo*log(base)))
                        // theta = imag(expo*log(base)) 
                        // console.lg("base", $.toInfixString(base));
                        // console.lg("expo", $.toInfixString(expo));
                        // console.lg("YIN");
                        const r = compute_r_from_base_and_expo(base, expo, $);
                        const theta = compute_theta_from_base_and_expo(base, expo, $);
                        const cos_theta = $.valueOf(items_to_cons$1(COS$2, theta));
                        const retval = $.valueOf(items_to_cons$1(MATH_MUL, r, cos_theta));
                        return hook(retval);
                    }
                }
                else if (is_multiply(expr)) {
                    // console.lg("Computing Re of a * expression...", $.toSExprString(expr));
                    const rs = []; // the real factors.
                    const cs = []; // the complex factors
                    [...expr.argList].forEach(function (factor) {
                        // console.lg("testing the arg:", $.toInfixString(arg));
                        if ($.is_real(factor)) {
                            // console.lg("arg is real:", $.toInfixString(arg));
                            rs.push(factor);
                        }
                        else {
                            // console.lg("arg is NOT real:", $.toInfixString(arg));
                            // console.lg("arg is NOT real:", $.toInfixString(arg));
                            // With no boolean response, we have to assume that the argument is not real valued.
                            // How do we make progress with the factors that are complex numbers?
                            if (is_sym(factor)) {
                                // console.lg("arg is Sym and possibly complex", $.toInfixString(arg));
                                const x = items_to_cons$1(REAL$9, factor);
                                const y = items_to_cons$1(IMAG$f, factor);
                                const iy = items_to_cons$1(MATH_MUL, imu, y);
                                const z = items_to_cons$1(MATH_ADD, x, iy);
                                // console.lg("Z=>", $.toInfixString(z));
                                cs.push(z);
                            }
                            else if (factor.equals(imu)) {
                                // console.lg("arg is imu", $.toInfixString(arg));
                                cs.push(factor);
                            }
                            else if (is_power(factor)) {
                                const base = factor.lhs;
                                const expo = factor.rhs;
                                if (is_rat$1(expo) && expo.isMinusOne()) {
                                    // Get the complex number out of the denominator.
                                    const z_star = $.conj(base);
                                    const denom = $.valueOf(items_to_cons$1(MATH_MUL, z_star, base));
                                    const one_over_denom = $.valueOf(items_to_cons$1(MATH_POW$1, denom, negOne));
                                    const z = $.multiply(z_star, one_over_denom);
                                    cs.push(z);
                                }
                                else {
                                    // console.lg("base", $.toInfixString(base));
                                    // console.lg("expo", $.toInfixString(expo));
                                    // console.lg("YAN");
                                    const r = compute_r_from_base_and_expo(base, expo, $);
                                    // console.lg("r", $.toInfixString(r));
                                    const theta = compute_theta_from_base_and_expo(base, expo, $);
                                    // console.lg("theta", $.toInfixString(theta));
                                    const i_times_theta = $.valueOf(items_to_cons$1(MATH_MUL, imu, theta));
                                    const cis_theta = $.valueOf(items_to_cons$1(EXP$5, i_times_theta));
                                    // console.lg("cis_theta", $.toInfixString(cis_theta));
                                    rs.push(r);
                                    cs.push(cis_theta);
                                }
                            }
                            else if (is_cons(factor) && is_sym(factor.opr)) {
                                cs.push(factor);
                            }
                            else {
                                // console.lg("WT...");
                                // Here we might encounter a function.
                                // So far we've handled math.pow.
                                // How to handle arbitrary functions. e.g. abs, sin, ...
                                throw new Error($.toSExprString(factor));
                            }
                        }
                    });
                    const A = multiply_factors$2(rs, $);
                    // console.lg("A", $.toInfixString(A));
                    const B = multiply_factors$2(cs, $);
                    // console.lg("B", $.toInfixString(B));
                    // console.lg("exp", $.toInfixString(expr));
                    const C = $.valueOf(items_to_cons$1(REAL$9, B));
                    // console.lg("C", $.toSExprString(C));
                    const D = $.valueOf(items_to_cons$1(MATH_MUL, A, C));
                    // console.lg("D", $.toSExprString(D));
                    // console.lg("real of", $.toInfixString(expr), "is", $.toInfixString(D));
                    return D;
                }
                else if (expr.equals(imu)) {
                    return zero;
                }
                /*
                // I'm not sure why this first step is necessary; it should not be.
                // const rect_z = rect(z, $);
                const conj_z = complex_conjugate(expr, $);
                // console.lg(`rect_z => ${$.toInfixString(rect_z)}`);
                // console.lg(`conj_z => ${$.toInfixString(conj_z)}`);
                const two_re = $.add(expr, conj_z);
                // console.lg(`2*x => ${$.toInfixString(two_re)}`);
                const re = divide(two_re, two, $);
                return hook(re, "");
                */
                return hook(expr);
            }
            function multiply_factors$2(factors, $) {
                if (factors.length > 1) {
                    return $.valueOf(items_to_cons$1(MATH_MUL, ...factors));
                }
                else if (factors.length === 1) {
                    return $.valueOf(factors[0]);
                }
                else {
                    return one;
                }
            }

            // find the roots of a polynomial numerically
            const NROOTS_YMAX = 101;
            const NROOTS_DELTA = 1.0e-6;
            const NROOTS_EPSILON = 1.0e-9;
            function NROOTS_ABS(z) {
                return Math.sqrt(z.r * z.r + z.i * z.i);
            }
            // random between -2 and 2
            // const theRandom = 0.0;
            function NROOTS_RANDOM() {
                //theRandom += 0.2
                //return theRandom
                return 4.0 * Math.random() - 2.0;
            }
            /**
             * A pair of numbers (r, i)
             */
            class NumericRootOfPolynomial {
                constructor() {
                    this.r = 0.0;
                    this.i = 0.0;
                }
            }
            const nroots_a = new NumericRootOfPolynomial();
            const nroots_b = new NumericRootOfPolynomial();
            const nroots_x = new NumericRootOfPolynomial();
            const nroots_y = new NumericRootOfPolynomial();
            const nroots_fa = new NumericRootOfPolynomial();
            const nroots_fb = new NumericRootOfPolynomial();
            const nroots_dx = new NumericRootOfPolynomial();
            const nroots_df = new NumericRootOfPolynomial();
            const nroots_c = [];
            for (let i = 0; i < NROOTS_YMAX; i++) {
                nroots_c[i] = new NumericRootOfPolynomial();
            }
            /**
             * nroots(p,x), where x is optional and may be guessed from p.
             * @param expr
             * @param $
             * @returns
             */
            function Eval_nroots(expr, $) {
                // console.lg("Eval_nroots", render_as_infix(expr, $));
                let X = $.valueOf(caddr(expr));
                let P = $.valueOf(cadr(expr));
                // console.lg("P", render_as_infix(P, $));
                // console.lg("X", render_as_infix(X, $));
                X = is_nil(X) ? guess(P) : X;
                // console.lg("P", render_as_infix(X, $));
                if (!is_poly_expanded_form(P, X)) {
                    halt(`nroots: Polynomial ${$.toInfixString(P)} in variable ${$.toInfixString(X)} must be in expanded form.`);
                }
                // mark the stack
                const h = defs.tos;
                // get the coefficients
                const coefficients = coeff(P, X, $);
                let n = coefficients.length;
                if (n > NROOTS_YMAX) {
                    halt('nroots: degree?');
                }
                // convert the coefficients to real and imaginary doubles
                for (let i = 0; i < n; i++) {
                    P = $.valueOf(evaluate_as_float(real$2(coefficients[i], $), $));
                    X = $.valueOf(evaluate_as_float(imag$2(coefficients[i]), $));
                    if (!is_flt$1(P) || !is_flt$1(X)) {
                        halt('nroots: coefficients?');
                    }
                    nroots_c[i].r = P.d;
                    nroots_c[i].i = X.d;
                }
                // n is the number of coefficients, n = deg(p) + 1
                monic(n);
                for (let k = n; k > 1; k--) {
                    findroot(k);
                    if (Math.abs(nroots_a.r) < NROOTS_DELTA) {
                        nroots_a.r = 0.0;
                    }
                    if (Math.abs(nroots_a.i) < NROOTS_DELTA) {
                        nroots_a.i = 0.0;
                    }
                    stack_push($.add(create_flt(nroots_a.r), $.multiply(create_flt(nroots_a.i), imu)));
                    NROOTS_divpoly(k);
                }
                // now make n equal to the number of roots
                n = defs.tos - h;
                if (n > 1) {
                    sort_stack(n, $);
                    const dims = [n];
                    const elems = defs.stack.slice(h, h + n);
                    move_top_of_stack(h);
                    stack_push(new Tensor(dims, elems));
                }
                const retval = stack_pop();
                return retval;
            }
            // divide the polynomial by its leading coefficient
            function monic(n) {
                nroots_y.r = nroots_c[n - 1].r;
                nroots_y.i = nroots_c[n - 1].i;
                const t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;
                for (let k = 0; k < n - 1; k++) {
                    nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;
                    nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;
                }
                nroots_c[n - 1].r = 1.0;
                nroots_c[n - 1].i = 0.0;
            }
            // uses the secant method
            function findroot(n) {
                if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {
                    nroots_a.r = 0.0;
                    nroots_a.i = 0.0;
                    return;
                }
                for (let j = 0; j < 100; j++) {
                    nroots_a.r = NROOTS_RANDOM();
                    nroots_a.i = NROOTS_RANDOM();
                    compute_fa(n);
                    nroots_b.r = nroots_a.r;
                    nroots_b.i = nroots_a.i;
                    nroots_fb.r = nroots_fa.r;
                    nroots_fb.i = nroots_fa.i;
                    nroots_a.r = NROOTS_RANDOM();
                    nroots_a.i = NROOTS_RANDOM();
                    for (let k = 0; k < 1000; k++) {
                        compute_fa(n);
                        const nrabs = NROOTS_ABS(nroots_fa);
                        if (nrabs < NROOTS_EPSILON) {
                            return;
                        }
                        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {
                            nroots_x.r = nroots_a.r;
                            nroots_x.i = nroots_a.i;
                            nroots_a.r = nroots_b.r;
                            nroots_a.i = nroots_b.i;
                            nroots_b.r = nroots_x.r;
                            nroots_b.i = nroots_x.i;
                            nroots_x.r = nroots_fa.r;
                            nroots_x.i = nroots_fa.i;
                            nroots_fa.r = nroots_fb.r;
                            nroots_fa.i = nroots_fb.i;
                            nroots_fb.r = nroots_x.r;
                            nroots_fb.i = nroots_x.i;
                        }
                        // dx = nroots_b - nroots_a
                        nroots_dx.r = nroots_b.r - nroots_a.r;
                        nroots_dx.i = nroots_b.i - nroots_a.i;
                        // df = fb - fa
                        nroots_df.r = nroots_fb.r - nroots_fa.r;
                        nroots_df.i = nroots_fb.i - nroots_fa.i;
                        // y = dx / df
                        const t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;
                        if (t === 0.0) {
                            break;
                        }
                        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;
                        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;
                        // a = b - y * fb
                        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);
                        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);
                    }
                }
                halt('nroots: convergence error');
            }
            function compute_fa(n) {
                // x = a
                nroots_x.r = nroots_a.r;
                nroots_x.i = nroots_a.i;
                // fa = c0 + c1 * x
                nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;
                nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;
                for (let k = 2; k < n; k++) {
                    // x = a * x
                    const t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;
                    nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;
                    nroots_x.r = t;
                    // fa += c[k] * x
                    nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;
                    nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r;
                }
            }
            // divide the polynomial by x - a
            function NROOTS_divpoly(n) {
                for (let k = n - 1; k > 0; k--) {
                    nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;
                    nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;
                }
                if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {
                    halt('nroots: residual error');
                }
                for (let k = 0; k < n - 1; k++) {
                    nroots_c[k].r = nroots_c[k + 1].r;
                    nroots_c[k].i = nroots_c[k + 1].i;
                }
            }

            /**
             * Extracts the operand at the specified zero-based position, where expr = (op0 op1 op2 ...).
             * cad(n)r foo = cad(n-1)r cdr foo and cad(0)r foo = car foo
             * @param expr A Cons expression for which the nth operand is sought.
             * @param n The zero-base operand index. MUST be an integer >= 0.
             */
            function cadnr(expr, n) {
                if (n > 0) {
                    const argList = expr.argList;
                    if (is_cons(argList)) {
                        return cadnr(argList, n - 1);
                    }
                    else {
                        return argList;
                    }
                }
                else {
                    return expr.car;
                }
            }

            function lt_num_num(lhs, rhs) {
                return compare_num_num(lhs, rhs) === SIGN_LT;
            }

            /**
             * exp(x) => (expt e x)
             */
            function exp$1(x, $) {
                return $.power(native_sym(Native.E), x);
            }

            function is_negative_term(p) {
                return is_negative_number(p) || (is_multiply(p) && is_negative_number(cadr(p)));
            }

            /**
             *
             */
            function is_negative(expr) {
                return (is_add(expr) && is_negative_term(cadr(expr))) || is_negative_term(expr);
            }

            /**
             * find stuff like (-1)^(something (but disregard
             * imaginary units which are in the form (-1)^(1/2))
             * @param p
             * @param p1
             * @param $
             * @returns
             */
            function has_clock_form(p, p1, $) {
                if (is_imu(p)) {
                    return false;
                }
                if (is_power(p) && !is_rat_and_integer(caddr(p1))) {
                    if (cadr(p).contains(imu)) {
                        // console.lg "found i^fraction " + p
                        return true;
                    }
                }
                if (is_power(p) && equaln(cadr(p), -1) && !is_rat_and_integer(caddr(p1))) {
                    // console.lg "found -1^fraction in " + p
                    return true;
                }
                if (is_tensor(p)) {
                    for (let i = 0; i < p.nelem; i++) {
                        if (has_clock_form(p.elem(i), p1)) {
                            return true;
                        }
                    }
                    return false;
                }
                if (is_cons(p)) {
                    return [...p].some((el) => has_clock_form(el, p1));
                }
                return false;
            }
            /**
             * find stuff like (e)^(i something)
             */
            function has_exp_form(expr, $) {
                if (is_cons(expr)) {
                    // (expt e (...))
                    if (is_power(expr)) {
                        const argList_expr = expr.cdr;
                        if (is_cons(argList_expr)) {
                            const base = argList_expr.car;
                            if (is_base_of_natural_logarithm(base)) {
                                const argList_argList_expr = argList_expr.argList;
                                if (is_cons(argList_argList_expr)) {
                                    const expo = argList_argList_expr.car;
                                    return expo.contains(imu);
                                }
                            }
                        }
                    }
                    // Look for same thing embedded in Cons.
                    return [...expr].some(function (x) {
                        return has_exp_form(x);
                    });
                }
                // Lok for elements of matrix that contain same thing.
                if (is_tensor(expr)) {
                    for (let i = 0; i < expr.nelem; i++) {
                        if (has_exp_form(expr.elem(i))) {
                            return true;
                        }
                    }
                    return false;
                }
                return false;
            }

            /**
             *
             */
            function items_to_cons(...items) {
                return items_to_cons$1(...items);
            }

            /**
             * Sorts an array of terms. Assumes that terms can commute under addition.
             * @param terms The unsorted array of terms. WARNING: This array may be reordered in future implementations.
             * @param $
             * @returns A new array containing the sorted factors.
             */
            function sort_terms(terms, $) {
                // We don't use the index yet but it could be used to make the sort stable (see corresponding factors code).
                const sortable = terms.map(function (value, index) {
                    return { value, index };
                });
                const compareFn = $.compareFn(MATH_ADD$1);
                sortable.sort(function (x, y) {
                    return compareFn(x.value, y.value);
                });
                const sorted = sortable.map(function (elem) {
                    return elem.value;
                });
                // console.lg(`sort_terms(${items_to_infix(terms, $)}) => ${items_to_infix(sorted, $)}`);
                return sorted;
            }

            function multiply_num_num(lhs, rhs) {
                if (is_rat$1(lhs)) {
                    if (is_rat$1(rhs)) {
                        return lhs.mul(rhs);
                    }
                    else {
                        const a = lhs.toNumber();
                        const b = rhs.d;
                        return create_flt(a * b);
                    }
                }
                else {
                    if (is_rat$1(rhs)) {
                        const a = lhs.d;
                        const b = rhs.toNumber();
                        return create_flt(a * b);
                    }
                    else {
                        return lhs.mul(rhs);
                    }
                }
            }

            function add_num_num(lhs, rhs) {
                if (is_rat$1(lhs)) {
                    if (is_rat$1(rhs)) {
                        return lhs.add(rhs);
                    }
                    else {
                        const a = lhs.toNumber();
                        const b = rhs.d;
                        return create_flt(a + b);
                    }
                }
                else {
                    if (is_rat$1(rhs)) {
                        const a = lhs.d;
                        const b = rhs.toNumber();
                        return create_flt(a + b);
                    }
                    else {
                        return lhs.add(rhs);
                    }
                }
            }

            function to_list_add_sort(terms, $) {
                const sorted = sort_terms(terms, $);
                return to_list_add(sorted, $);
            }
            /**
             * Compare adjacent terms in terms[] and combine if possible.
             * @param terms The terms to be combined and the output location.
             */
            function to_list_add(terms, $) {
                // console.lg(`to_list_add ${items_to_infix(terms, $)}`);
                let i = 0;
                let typedZero = zero;
                // The general idea is that we are going to take the terms in adjacent pairs
                // and try to combine them. If we can, we'll splice out the two terms and
                // replace them with a single term.
                while (i < terms.length - 1) {
                    const a = terms[i];
                    const b = terms[i + 1];
                    // TODO: Generalize here after understanding the issues for Tensor and Num
                    if (is_tensor(a) && is_tensor(b)) {
                        const sum = $.add(a, b);
                        // TODO: Why don't we handle zero like we do for Num below?
                        if (nil !== sum) {
                            // console.lg(`A. splice(${sum34})`);
                            terms.splice(i, 2, sum);
                            i--;
                        }
                        i++;
                        continue;
                    }
                    if (is_tensor(a) || is_tensor(b)) {
                        // TODO: I'm not sure why we give up here.
                        // Seems like we could try the simplification below.
                        i++;
                        continue;
                    }
                    if (is_num(a) && is_num(b)) {
                        const sum = add_num_num(a, b);
                        if ($.is_zero(sum)) {
                            // Ensure correct runtime type of the result by propagating the type correctly.
                            typedZero = multiply_num_num(typedZero, sum);
                            terms.splice(i, 2);
                        }
                        else {
                            terms.splice(i, 2, sum);
                        }
                        // TODO: This looks wierd compared to the matrix case. 
                        i--;
                        i++;
                        continue;
                    }
                    if (is_num(a) || is_num(b)) {
                        i++;
                        continue;
                    }
                    const decomp_a = decompose_multiply_num_times(a);
                    const is_list_s = decomp_a.denorm;
                    const lhs_a = decomp_a.lhs;
                    const rhs_a = decomp_a.rhs;
                    const decomp_b = decompose_multiply_num_times(b);
                    const lhs_b = decomp_b.lhs;
                    const rhs_b = decomp_b.rhs;
                    if (!$.equals(rhs_a, rhs_b)) {
                        // No common factor on right.
                        i++;
                        continue;
                    }
                    // If we are here then rhs_a = rhs_b there is a common factor on the right.
                    // sum(a,b) = (lhs_a + rhs_a) * common factor on right = k * common factor on the right.
                    const k = add_num_num(lhs_a, lhs_b);
                    // If k is zero then (a + b) is zero.
                    if ($.is_zero(k)) {
                        terms.splice(i, 2);
                        i--;
                        i++;
                        continue;
                    }
                    // If we are here then k is not zero.
                    /**
                     * the common factor on the right of both a and b.
                     *
                     * sum(a, b) = k * s, where s could be a single node or a list of nodes
                     */
                    const ambiguous_s = rhs_a;
                    const s = is_list_s ? cons(MATH_MUL$3, ambiguous_s) : ambiguous_s;
                    const sum_a_b = $.multiply(k, s);
                    // console.lg(`E. splice(${sum12xArg2})`);
                    terms.splice(i, 2, sum_a_b);
                    i--;
                    // this i++ is to match the while
                    i++;
                }
                if (terms.length > 0) {
                    if (terms.length > 1) {
                        // console.lg(`terms => ${items_to_infix(terms, $)}`)
                        return cons(MATH_ADD$1, items_to_cons(...terms));
                    }
                    else {
                        return terms[0];
                    }
                }
                else {
                    return typedZero;
                }
            }
            /**
             * Decomposes an expression according to the following patterns.
             *
             * Notice that lhs * rhs is an invariant equal to the original expression.
             *
             * expr                          denorm  lhs   rhs
             *
             * (multiply a1: Num a2)         false   a1    a2
             *
             * (multiply a1: Num a2 a3 ...)  true    a1    (a2 a3 ...)
             *
             * (multiply a1 a2 a3 ...)       true    1     (a1 a2 a3 ...)
             *
             * expr                          false   1     expr
             */
            function decompose_multiply_num_times(expr) {
                if (is_cons(expr) && is_multiply(expr)) {
                    // (multiply a1 a2 a3 a4 ...)
                    /**
                     * (a1 a2 a3 a4 ...) or NIL
                     */
                    const cdr_expr = expr.cdr;
                    /**
                     * a1 or NIL
                     */
                    const a1 = car(cdr_expr);
                    if (is_num(a1)) {
                        /**
                         * (a2 a3 a4 ...) or NIL
                         */
                        const cddr_expr = cdr(cdr_expr);
                        /**
                         * (a3 a4 ...) or NIL
                         */
                        const cdddr_expr = cdr(cddr_expr);
                        if (nil === cdddr_expr) {
                            // (multiply a1: Num a2)
                            /**
                             * a2 = caddr_expr
                             */
                            const a2 = car(cddr_expr);
                            return { denorm: false, lhs: a1, rhs: a2 };
                        }
                        else {
                            // (multiply a1: Num a2 a3 ...)
                            return { denorm: true, lhs: a1, rhs: cddr_expr };
                        }
                    }
                    else {
                        // a1 is anything
                        // (multiply a1 a2 a3 ...)
                        return { denorm: true, lhs: one, rhs: cdr_expr };
                    }
                }
                else {
                    // Not a multiply
                    return { denorm: false, lhs: one, rhs: expr };
                }
            }

            /**
             * Pushes the term onto the terms array.
             * Zero rational and double are skipped.
             */
            /**
             * Appends a term to the terms array, flattening nested (+ ...) trees and respecting the setting for handling zeros.
             * @param terms The output destination for the term or nested (+ ...) trees.
             * @param term The term to be appended.
             * @param $ The extension environment.
             */
            function append_terms(terms, term, $) {
                if (is_cons(term) && is_add(term)) {
                    // Go recursive here, don't just "spread" them in.
                    // That way we entirely flatten nested add(s) and respect zero value processing.
                    const kids = term.tail();
                    kids.forEach(function (kid) {
                        append_terms(terms, kid, $);
                    });
                }
                else if ($.is_zero(term)) {
                    if ($.getNativeDirective(Directive.keepZeroTermsInSums)) {
                        terms.push(term);
                    }
                }
                else {
                    terms.push(term);
                }
            }
            /*
            export function add_legacy(p1: U, p2: U, $: ExtensionEnv): U {
              const terms: U[] = [];
              push_terms(terms, p1);
              push_terms(terms, p2);
              return add_terms(terms, $);
            }
            */
            function add_terms$1(terms, $) {
                const flattened = [];
                for (const t of terms) {
                    append_terms(flattened, t, $);
                }
                return to_list_add_sort(flattened, $);
            }

            /**
             * Constructs a binary expression and evaluates it.
             * The arguments are not evaluated.
             * @param opr The symbol in the position of the zeroth element of the list.
             * @param lhs The expression in the first element of the list.
             * @param rhs The expression in the second element of the list.
             */
            function binop(opr, lhs, rhs, $) {
                const C = items_to_cons$1(opr, lhs, rhs);
                const D = $.valueOf(C);
                return D;
            }

            function multiply$1(lhs, rhs, $) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    return retval;
                };
                return hook(binop(MATH_MUL$3, lhs, rhs, $));
            }
            // this is useful for example when you are just adding/removing
            // factors from an already factored quantity.
            // e.g. if you factored x^2 + 3x + 2 into (x+1)(x+2)
            // and you want to divide by (x+1) , i.e. you multiply by (x-1)^-1,
            // then there is no need to expand.
            function multiply_noexpand(arg1, arg2, $) {
                return noexpand_binary(multiply$1, arg1, arg2, $);
            }
            /**
             * TODO: Why doesn't this function perform sorting of the factors?
             * multiply n factors
             * [a b c d ...] => (multiply (multiply a b) c)
             * @param items is an integer
             */
            function multiply_items(items, $) {
                // console.lg(`multiply_items items => ${items_to_infix(items, $)} ${items_to_sexpr(items, $)}`);
                if (items.length > 1) {
                    let temp = items[0];
                    for (let i = 1; i < items.length; i++) {
                        temp = $.multiply(temp, items[i]);
                    }
                    return temp;
                }
                else {
                    if (items.length === 1) {
                        return items[0];
                    }
                    return one;
                }
            }
            // n an integer
            function multiply_items_factoring(items, $) {
                $.pushNativeDirective(Directive.factor, true);
                try {
                    return multiply_items(items, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            function negate_noexpand(p1, $) {
                const negate = function (x, $) {
                    return $.negate(x);
                };
                return noexpand_unary(negate, p1, $);
            }
            //-----------------------------------------------------------------------------
            //
            //  > a*hilbert(2)
            //  ((a,1/2*a),(1/2*a,1/3*a))
            //
            //  Note that "a" is presumed to be a scalar. Is this correct?
            //
            //  Yes, because "*" has no meaning if "a" is a tensor.
            //  To multiply tensors, "dot" or "outer" should be used.
            //
            //  > dot(a,hilbert(2))
            //  dot(a,((1,1/2),(1/2,1/3)))
            //
            //  In this case "a" could be a scalar or tensor so the result is not
            //  expanded.
            //
            //-----------------------------------------------------------------------------

            // Greatest common denominator
            // can also be run on polynomials, however
            // it works only on the integers and it works
            // by factoring the polynomials (not Euclidean algorithm)
            function Eval_gcd(p1, $) {
                p1 = cdr(p1);
                let result = $.valueOf(car(p1));
                if (is_cons(p1)) {
                    result = p1.tail().reduce((acc, p) => gcd(acc, $.valueOf(p), $), result);
                }
                return result;
            }
            function gcd(p1, p2, $) {
                return doexpand_binary(gcd_main, p1, p2, $);
            }
            function gcd_main(p1, p2, $) {
                if (p1.equals(p2)) {
                    return p1;
                }
                if (is_rat$1(p1) && is_rat$1(p2)) {
                    return p1.gcd(p2);
                }
                const polyVar = areunivarpolysfactoredorexpandedform(p1, p2);
                if (polyVar) {
                    return gcd_polys(p1, p2, polyVar, $);
                }
                if (is_add(p1) && is_add(p2)) {
                    return gcd_sum_sum(p1, p2, $);
                }
                if (is_add(p1)) {
                    p1 = gcd_sum(p1, $);
                }
                if (is_add(p2)) {
                    p2 = gcd_sum(p2, $);
                }
                if (is_multiply(p1)) {
                    return gcd_sum_product(p1, p2, $);
                }
                if (is_multiply(p2)) {
                    return gcd_product_sum(p1, p2, $);
                }
                if (is_multiply(p1) && is_multiply(p2)) {
                    return gcd_product_product(p1, p2, $);
                }
                return gcd_powers_with_same_base(p1, p2, $);
            }
            // TODO this should probably be in "is"?
            function areunivarpolysfactoredorexpandedform(p1, p2, $) {
                const polyVar = isunivarpolyfactoredorexpandedform(p1, null);
                if (polyVar) {
                    if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {
                        return polyVar;
                    }
                }
            }
            function gcd_polys(p1, p2, polyVar, $) {
                p1 = $.factorize(p1, polyVar);
                p2 = $.factorize(p2, polyVar);
                if (is_multiply(p1) || is_multiply(p2)) {
                    if (!is_multiply(p1)) {
                        p1 = items_to_cons(MULTIPLY$1, p1, one);
                    }
                    if (!is_multiply(p2)) {
                        p2 = items_to_cons(MULTIPLY$1, p2, one);
                    }
                }
                if (is_multiply(p1) && is_multiply(p2)) {
                    return gcd_product_product(p1, p2, $);
                }
                return gcd_powers_with_same_base(p1, p2, $);
            }
            function gcd_product_product(p1, p2, $) {
                const p3 = cdr(p1);
                const p4 = cdr(p2);
                if (is_cons(p3)) {
                    return [...p3].reduce((acc, pOuter) => {
                        if (is_cons(p4)) {
                            return $.multiply(acc, [...p4].reduce((innerAcc, pInner) => $.multiply(innerAcc, gcd(pOuter, pInner, $)), one));
                        }
                        else {
                            throw new Error();
                        }
                    }, one);
                }
                else {
                    // Assertion or do we return void 0?
                    throw new Error();
                }
                // another, (maybe more readable?) version:
                /*
                let totalProduct:U = one;
                let p3 = cdr(p1)
                while (iscons(p3)) {
              
                  let p4: U = cdr(p2)
              
                  if (iscons(p4)) {
                    totalProduct = [...p4].reduce(
                        ((acc: U, p: U) =>
                            $.multiply(gcd(car(p3), p), acc))
                        , totalProduct
                    );
                  }
              
                  p3 = cdr(p3);
                }
              
                return totalProduct;
                */
            }
            function gcd_powers_with_same_base(base1, base2, $) {
                let exponent1, exponent2;
                if (is_power(base1)) {
                    exponent1 = caddr(base1); // exponent
                    base1 = cadr(base1); // base
                }
                else {
                    exponent1 = one;
                }
                if (is_power(base2)) {
                    exponent2 = caddr(base2); // exponent
                    base2 = cadr(base2); // base
                }
                else {
                    exponent2 = one;
                }
                if (!base1.equals(base2)) {
                    return one;
                }
                // are both exponents numerical?
                if (is_num(exponent1) && is_num(exponent2)) {
                    const exponent = compare_num_num(exponent1, exponent2) < 0 ? exponent1 : exponent2;
                    return $.power(base1, exponent);
                }
                // are the exponents multiples of eah other?
                const expo1_div_expo2 = divide(exponent1, exponent2, $);
                if (is_num(expo1_div_expo2)) {
                    // choose the smallest exponent
                    const cadr_expo1 = cadr(exponent1);
                    const p5 = is_multiply(exponent1) && is_num(cadr_expo1) ? cadr_expo1 : one;
                    const cadr_expo2 = cadr(exponent2);
                    const p6 = is_multiply(exponent2) && is_num(cadr_expo2) ? cadr_expo2 : one;
                    const exponent = compare_num_num(p5, p6) < 0 ? exponent1 : exponent2;
                    return $.power(base1, exponent);
                }
                const expo1_minus_expo2 = $.subtract(exponent1, exponent2);
                if (!is_num(expo1_minus_expo2)) {
                    return one;
                }
                // can't be equal because of test near beginning
                // TODO NumExtension.isNegative
                const exponent = is_negative_number(expo1_minus_expo2) ? exponent1 : exponent2;
                return $.power(base1, exponent);
            }
            // in this case gcd is used as a composite function, i.e. gcd(gcd(gcd...
            function gcd_sum_sum(p1, p2, $) {
                if (length_of_cons_otherwise_zero(p1) !== length_of_cons_otherwise_zero(p2)) {
                    return one;
                }
                const p3 = is_cons(p1) ? p1.tail().reduce(function (x, y) {
                    return gcd(x, y, $);
                }) : car(cdr(p1));
                const p4 = is_cons(p2) ? p2.tail().reduce(function (x, y) {
                    return gcd(x, y, $);
                }) : car(cdr(p2));
                const p5 = divide(p1, p3, $);
                const p6 = divide(p2, p4, $);
                if (p5.equals(p6)) {
                    return $.multiply(p5, gcd(p3, p4, $));
                }
                return one;
            }
            function gcd_sum(p, $) {
                return is_cons(p) ? p.tail().reduce(function (x, y) {
                    return gcd(x, y, $);
                }) : car(cdr(p));
            }
            /*
            function gcd_term_term(p1: U, p2: U): U {
              if (!iscons(p1) || !iscons(p2)) {
                return one;
              }
              return p1.tail().reduce((a: U, b: U) => {
                return p2.tail().reduce((x: U, y: U) => $.multiply(x, gcd(b, y)), a);
              }, one);
            }
            */
            function gcd_sum_product(p1, p2, $) {
                return is_cons(p1)
                    ? p1.tail().reduce((a, b) => $.multiply(a, gcd(b, p2, $)), one)
                    : one;
            }
            function gcd_product_sum(p1, p2, $) {
                return is_cons(p2)
                    ? p2.tail().reduce((a, b) => $.multiply(a, gcd(p1, b, $)), one)
                    : one;
            }

            function doexpand_value_of(expr, $) {
                return doexpand_unary(function (x) {
                    return $.valueOf(x);
                }, expr, $);
            }

            // Condense an expression by factoring common terms.
            function Eval_condense(p1, $) {
                const result = condense($.valueOf(cadr(p1)), $);
                return result;
            }
            function condense(p1, $) {
                return noexpand_unary(yycondense, p1, $);
            }
            /**
             * This is a noop if the expression is not an addition.
             * @param P
             * @param $
             * @returns
             */
            function yycondense(P, $) {
                // console.lg("yycondense", render_as_sexpr(P, $));
                // console.lg("yycondense", render_as_infix(P, $));
                if (!is_add(P)) {
                    return P;
                }
                // get gcd of all terms
                const terms_gcd = P.tail().reduce(function (x, y) {
                    return gcd(x, y, $);
                });
                // console.lg("terms_gcd", render_as_infix(terms_gcd, $));
                // divide each term by gcd, which is to say, multiply each by the inverse.
                const one_divided_by_gcd = inverse(terms_gcd, $);
                const P_divided_by_gcd = P
                    .tail()
                    .reduce((a, b) => $.add(a, multiply_noexpand(one_divided_by_gcd, b, $)), zero);
                // We multiplied above w/o expanding so some factors cancelled.
                // Now we expand which normalizes the result and, in some cases,
                // simplifies it too (see test case H).
                // console.lg("P_divided_by_gcd", render_as_infix(P_divided_by_gcd, $));
                const value_of_P_divided_by_gcd = doexpand_value_of(P_divided_by_gcd, $);
                // console.lg("value_of_P_divided_by_gcd", render_as_infix(value_of_P_divided_by_gcd, $));
                // console.lg("one_divided_by_gcd", render_as_infix(one_divided_by_gcd, $));
                // multiply result by gcd, which is to say, divide by 1/gcd.
                const retval = divide(value_of_P_divided_by_gcd, one_divided_by_gcd, $);
                // console.lg(`yycondense(${render_as_infix(P, $)}) => `, render_as_infix(retval, $));
                return retval;
            }

            function float_eval_abs_eval(p1, $) {
                return zzfloat($.valueOf(abs$1($.valueOf(p1), $)), $);
            }

            const testeq$3 = native_sym(Native.test_eq);
            // define POLY p1
            // define X p2
            // define A p3
            // define B p4
            // define C p5
            // define Y p6
            function Eval_roots(expr, $) {
                // console.lg(`Eval_roots expr=${render_as_sexpr(expr, $)}`);
                // A == B -> A - B
                const arg1 = cadr(expr);
                let poly;
                if (car(arg1).equals(testeq$3) || car(arg1).equals(ASSIGN)) {
                    poly = $.subtract($.valueOf(cadr(arg1)), $.valueOf(caddr(arg1)));
                }
                else {
                    const vArg1 = $.valueOf(arg1);
                    if (car(vArg1).equals(testeq$3) || car(vArg1).equals(ASSIGN)) {
                        poly = $.subtract($.valueOf(cadr(vArg1)), $.valueOf(caddr(vArg1)));
                    }
                    else {
                        poly = vArg1;
                    }
                }
                // 2nd arg, x
                const arg2 = $.valueOf(caddr(expr));
                const x = nil === arg2 ? guess(poly) : arg2;
                // console.lg(`poly=${print_expr(poly, $)}`);
                // console.lg(`var =${print_expr(x, $)}`);
                const p = poly;
                if (is_poly_expanded_form(p, x)) {
                    return roots(poly, x, $);
                }
                else {
                    halt('roots: 1st argument is not a polynomial in the variable ' + $.toInfixString(x));
                }
            }
            function is_some_coeff_complex_number(coefficients, $) {
                return coefficients.some((c) => is_complex_number(c));
            }
            /**
             * If the normalized coefficients are sufficiently simple then the polynomial is considered simple.
             * k[0]      Coefficient of x^0
             * k[n-1]    Coefficient of x^(n-1)
             * @param ks The coefficients of the polynomial. ks[i] is the coefficient of x^i
             */
            function is_simple_root(ks, $) {
                if (ks.length <= 2) {
                    return false;
                }
                if ($.is_zero(ks[0])) {
                    return false;
                }
                return ks.slice(1, ks.length - 1).every((el) => $.is_zero(el));
            }
            /**
             * Computes the coefficients of the polynomial then divides each by the highest power coefficient.
             * The coefficients are returned in the order [c0, c1, c2, ..., 1] where c0 is the constant coefficient.
             */
            function normalized_coeff(poly, x, $) {
                // console.lg(`normalized_coeff ${render_as_infix(poly, $)} in variable ${render_as_infix(x, $)}`);
                const coefficients = coeff(poly, x, $);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                coefficients.forEach(function (coefficient) {
                    // console.lg("coefficient", render_as_infix(coefficient, $));
                });
                const divideBy = coefficients[coefficients.length - 1];
                return coefficients.map((coe) => divide(coe, divideBy, $));
            }
            /**
             *
             * @param poly
             * @param x
             * @returns
             */
            function roots(poly, x, $) {
                // eslint-disable-next-line no-console
                // console.lg(`roots ${render_as_infix(poly, $)} in variable ${render_as_infix(x, $)}`);
                // the simplification of nested radicals uses "roots", which in turn uses
                // simplification of nested radicals. Usually there is no problem, one level
                // of recursion does the job. Beyond that, we probably got stuck in a
                // strange case of infinite recursion, so bail out and return NIL.
                if (defs.recursionLevelNestedRadicalsRemoval > 1) {
                    // console.lg(`recursionLevelNestedRadicalsRemoval => ${defs.recursionLevelNestedRadicalsRemoval}`)
                    return new Tensor([], []);
                }
                // log.dbg(`checking if ${top()} is a case of simple roots`);
                const ks = normalized_coeff(poly, x, $);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                ks.forEach(function (k) {
                    // console.lg("k", render_as_infix(k, $));
                });
                const results = [];
                if (is_simple_root(ks, $)) {
                    const kn = ks.length;
                    const lastCoeff = ks[0];
                    const leadingCoeff = ks.pop();
                    const simpleRoots = getSimpleRoots(kn, leadingCoeff, lastCoeff, $);
                    results.push(...simpleRoots);
                }
                else {
                    const roots = roots2(poly, x, $);
                    // console.lg(`roots2 => ${roots}`);
                    results.push(...roots);
                }
                const n = results.length;
                if (n === 0) {
                    halt('roots: the polynomial is not factorable, try nroots');
                }
                if (n === 1) {
                    return new Tensor([1], results);
                }
                results.sort(function (a, b) {
                    // TODO: Make the comparitor for sorting the roots configurable?
                    return cmp_expr(a, b);
                });
                const dims = [n];
                return new Tensor(dims, results);
            }
            // ok to generate these roots take a look at their form
            // in the case of even and odd exponents here:
            // http://www.wolframalpha.com/input/?i=roots+x%5E14+%2B+1
            // http://www.wolframalpha.com/input/?i=roots+ax%5E14+%2B+b
            // http://www.wolframalpha.com/input/?i=roots+x%5E15+%2B+1
            // http://www.wolframalpha.com/input/?i=roots+a*x%5E15+%2B+b
            // leadingCoeff    Coefficient of x^0
            // lastCoeff       Coefficient of x^(n-1)
            function getSimpleRoots(n, leadingCoeff, lastCoeff, $) {
                // console.lg(`getSimpleRoots(n=${n}, leading=${render_as_infix(leadingCoeff, $)}, last=${render_as_infix(lastCoeff, $)})`);
                // log.dbg('getSimpleRoots');
                n = n - 1;
                const commonPart = divide($.power(lastCoeff, rational(1, n)), $.power(leadingCoeff, rational(1, n)), $);
                const results = [];
                if (n % 2 === 0) {
                    for (let i = 1; i <= n; i += 2) {
                        const aSol = $.multiply(commonPart, $.power(negOne, rational(i, n)));
                        results.push(aSol);
                        results.push($.negate(aSol));
                    }
                    return results;
                }
                for (let i = 1; i <= n; i++) {
                    let sol = $.multiply(commonPart, $.power(negOne, rational(i, n)));
                    if (i % 2 === 0) {
                        sol = $.negate(sol);
                    }
                    results.push(sol);
                }
                return results;
            }
            function roots2(P, X, $) {
                // console.lg(`roots2 ${render_as_infix(P, $)} in variable ${render_as_infix(X, $)}`);
                const ks = normalized_coeff(P, X, $);
                if (!is_some_coeff_complex_number(ks)) {
                    const factorized = $.factorize(P, X);
                    // console.lg("factorized", render_as_infix(factorized, $));
                    if (is_multiply(factorized)) {
                        // scan through all the factors and find the roots of each of them
                        const mapped = factorized.tail().map((p) => roots3(p, X, $));
                        return mapped.flat();
                    }
                    return roots3(factorized, X, $);
                }
                else {
                    if (is_multiply(P)) {
                        // scan through all the factors and find the roots of each of them
                        const mapped = P.tail().map((factor) => roots3(factor, X, $));
                        return mapped.flat();
                    }
                    return roots3(P, X, $);
                }
            }
            function roots3(poly, X, $) {
                // console.lg(`roots3 ${render_as_infix(poly, $)} in variable ${render_as_infix(X, $)}`);
                if (is_power(poly) &&
                    is_poly_expanded_form(cadr(poly), X) &&
                    is_rat_and_positive_integer(caddr(poly))) {
                    const n = normalized_coeff(cadr(poly), X, $);
                    return mini_solve(n, $);
                }
                if (is_poly_expanded_form(poly, X)) {
                    const n = normalized_coeff(poly, X, $);
                    return mini_solve(n, $);
                }
                return [];
            }
            // note that for many quadratic, cubic and quartic polynomials we don't
            // actually end up using the quadratic/cubic/quartic formulas in here,
            // since there is a chance we factored the polynomial and in so
            // doing we found some solutions and lowered the degree.
            function mini_solve(coefficients, $) {
                // console.lg("mini_solve");
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                coefficients.forEach(function (coefficient) {
                    // console.lg("coefficient", render_as_infix(coefficient, $));
                });
                const n = coefficients.length;
                // AX + B, X = -B/A
                if (n === 2) {
                    const A = coefficients.pop();
                    const B = coefficients.pop();
                    return _solveDegree1(A, B, $);
                }
                // AX^2 + BX + C, X = (-B +/- (B^2 - 4AC)^(1/2)) / (2A)
                if (n === 3) {
                    const A = coefficients.pop();
                    const B = coefficients.pop();
                    const C = coefficients.pop();
                    return _solveDegree2(A, B, C, $);
                }
                if (n === 4) {
                    const A = coefficients.pop();
                    const B = coefficients.pop();
                    const C = coefficients.pop();
                    const D = coefficients.pop();
                    return _solveDegree3(A, B, C, D, $);
                }
                // See http://www.sscc.edu/home/jdavidso/Math/Catalog/Polynomials/Fourth/Fourth.html
                // for a description of general shapes and properties of fourth degree polynomials
                if (n === 5) {
                    const A = coefficients.pop();
                    const B = coefficients.pop();
                    const C = coefficients.pop();
                    const D = coefficients.pop();
                    const E = coefficients.pop();
                    return _solveDegree4(A, B, C, D, E, $);
                }
                return [];
            }
            function _solveDegree1(A, B, $) {
                return [$.negate(divide(B, A, $))];
            }
            function _solveDegree2(A, B, C, $) {
                // (B^2 - 4AC)^(1/2)
                const p6 = $.power($.subtract($.power(B, two), $.multiply($.multiply(four, A), C)), half);
                // ((B^2 - 4AC)^(1/2) - B)/ (2A)
                const result1 = divide($.subtract(p6, B), $.multiply(A, two), $);
                // 1/2 * -(B + (B^2 - 4AC)^(1/2)) / A
                const result2 = $.multiply(divide($.negate($.add(p6, B)), A, $), half);
                return [result1, result2];
            }
            function _solveDegree3(A, B, C, D, $) {
                // C - only related calculations
                const R_c3 = $.multiply($.multiply(C, C), C);
                // B - only related calculations
                const R_b2 = $.multiply(B, B);
                const R_b3 = $.multiply(R_b2, B);
                const R_m4_b3_d = $.multiply($.multiply(R_b3, D), negFour);
                const R_2_b3 = $.multiply(R_b3, two);
                // A - only related calculations
                const R_3_a = $.multiply(three, A);
                const R_a2_d = $.multiply($.multiply(A, A), D);
                const R_27_a2_d = $.multiply(R_a2_d, create_int(27));
                const R_m27_a2_d2 = $.multiply($.multiply(R_a2_d, D), create_int(-27));
                // mixed calculations
                const R_a_b_c = $.multiply($.multiply(A, C), B);
                const R_3_a_c = $.multiply($.multiply(A, C), three);
                const R_m4_a_c3 = $.multiply(negFour, $.multiply(A, R_c3));
                const R_m9_a_b_c = $.negate($.multiply(R_a_b_c, nine));
                const R_18_a_b_c_d = $.multiply($.multiply(R_a_b_c, D), create_int(18));
                const R_DELTA0 = $.subtract(R_b2, R_3_a_c);
                const R_b2_c2 = $.multiply(R_b2, $.multiply(C, C));
                const R_m_b_over_3a = divide($.negate(B), R_3_a, $);
                const R_4_DELTA03 = $.multiply($.power(R_DELTA0, three), four);
                const R_DELTA0_toBeCheckedIfZero = float_eval_abs_eval(simplify(R_DELTA0, $), $);
                const R_determinant = float_eval_abs_eval(simplify(add_terms$1([R_18_a_b_c_d, R_m4_b3_d, R_b2_c2, R_m4_a_c3, R_m27_a2_d2], $), $), $);
                const R_DELTA1 = add_terms$1([R_2_b3, R_m9_a_b_c, R_27_a2_d], $);
                const R_Q = simplify($.power($.subtract($.power(R_DELTA1, two), R_4_DELTA03), half), $);
                // log.dbg('>>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< ');
                // log.dbg(`cubic: D0: ${toInfixString(R_DELTA0)}`);
                // log.dbg(`cubic: D0 as float: ${toInfixString(R_DELTA0_toBeCheckedIfZero)}`);
                // log.dbg(`cubic: DETERMINANT: ${toInfixString(R_determinant)}`);
                // log.dbg(`cubic: D1: ${toInfixString(R_DELTA1)}`);
                if ($.is_zero(R_determinant)) {
                    const data = {
                        R_DELTA0_toBeCheckedIfZero,
                        R_m_b_over_3a,
                        R_DELTA0,
                        R_b3,
                        R_a_b_c,
                    };
                    return _solveDegree3ZeroRDeterminant(A, B, C, D, data, $);
                }
                let C_CHECKED_AS_NOT_ZERO = false;
                let flipSignOFQSoCIsNotZero = false;
                let R_C = nil;
                // C will go as denominator, we have to check that is not zero
                while (!C_CHECKED_AS_NOT_ZERO) {
                    const arg1 = flipSignOFQSoCIsNotZero ? $.negate(R_Q) : R_Q;
                    R_C = simplify($.power($.multiply($.add(arg1, R_DELTA1), half), third), $);
                    const R_C_simplified_toCheckIfZero = float_eval_abs_eval(simplify(R_C, $), $);
                    // log.dbg(`cubic: C: ${toInfixString(R_C)}`);
                    // log.dbg(`cubic: C as absval and float: ${toInfixString(R_C_simplified_toCheckIfZero)}`);
                    if ($.is_zero(R_C_simplified_toCheckIfZero)) {
                        // log.dbg(' cubic: C IS ZERO flipping the sign');
                        flipSignOFQSoCIsNotZero = true;
                    }
                    else {
                        C_CHECKED_AS_NOT_ZERO = true;
                    }
                }
                const R_6_a_C = $.multiply($.multiply(R_C, R_3_a), two);
                // imaginary parts calculations
                const i_sqrt3 = $.multiply(imu, $.power(three, half));
                const one_plus_i_sqrt3 = $.add(one, i_sqrt3);
                const one_minus_i_sqrt3 = $.subtract(one, i_sqrt3);
                const R_C_over_3a = divide(R_C, R_3_a, $);
                // first solution
                const firstSolTerm1 = R_m_b_over_3a;
                const firstSolTerm2 = $.negate(R_C_over_3a);
                const firstSolTerm3 = $.negate(divide(R_DELTA0, $.multiply(R_C, R_3_a), $));
                const firstSolution = simplify(add_terms$1([firstSolTerm1, firstSolTerm2, firstSolTerm3], $), $);
                // second solution
                const secondSolTerm1 = R_m_b_over_3a;
                const secondSolTerm2 = divide($.multiply(R_C_over_3a, one_plus_i_sqrt3), two, $);
                const secondSolTerm3 = divide($.multiply(one_minus_i_sqrt3, R_DELTA0), R_6_a_C, $);
                const secondSolution = simplify(add_terms$1([secondSolTerm1, secondSolTerm2, secondSolTerm3], $), $);
                // third solution
                const thirdSolTerm1 = R_m_b_over_3a;
                const thirdSolTerm2 = divide($.multiply(R_C_over_3a, one_minus_i_sqrt3), two, $);
                const thirdSolTerm3 = divide($.multiply(one_plus_i_sqrt3, R_DELTA0), R_6_a_C, $);
                const thirdSolution = simplify(add_terms$1([thirdSolTerm1, thirdSolTerm2, thirdSolTerm3], $), $);
                return [firstSolution, secondSolution, thirdSolution];
            }
            function _solveDegree3ZeroRDeterminant(A, B, C, D, common, $) {
                const { R_DELTA0_toBeCheckedIfZero, R_m_b_over_3a, R_DELTA0, R_b3, R_a_b_c, } = common;
                if ($.is_zero(R_DELTA0_toBeCheckedIfZero)) {
                    // log.dbg(' cubic: DETERMINANT IS ZERO and delta0 is zero');
                    return [R_m_b_over_3a]; // just same solution three times
                }
                // log.dbg(' cubic: DETERMINANT IS ZERO and delta0 is not zero');
                const rootSolution = divide($.subtract($.multiply(A, $.multiply(D, nine)), $.multiply(B, C)), $.multiply(R_DELTA0, two), $);
                // second solution here
                // -9*b^3
                const numer_term1 = $.negate(R_b3);
                // -9a*a*d
                const numer_term2 = $.negate($.multiply(A, $.multiply(A, $.multiply(D, nine))));
                // 4*a*b*c
                const numer_term3 = $.multiply(R_a_b_c, four);
                // build the fraction
                // numerator: sum the three terms
                // denominator: a*delta0
                const secondSolution = divide(add_terms$1([numer_term3, numer_term2, numer_term1], $), $.multiply(A, R_DELTA0), $);
                return [rootSolution, rootSolution, secondSolution];
            }
            function _solveDegree4(A, B, C, D, E, $) {
                // log.dbg('>>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< ');
                if ($.is_zero(B) &&
                    $.is_zero(D) &&
                    !$.is_zero(C) &&
                    !$.is_zero(E)) {
                    return _solveDegree4Biquadratic(A, B, C, D, E, $);
                }
                if (!$.is_zero(B)) {
                    return _solveDegree4NonzeroB(A, B, C, D, E, $);
                }
                else {
                    return _solveDegree4ZeroB(A, B, C, D, E, $);
                }
            }
            function _solveDegree4Biquadratic(A, B, C, D, E, $) {
                // log.dbg('biquadratic case');
                const biquadraticSolutions = roots($.add($.multiply(A, $.power(SECRETX, two)), $.add($.multiply(C, SECRETX), E)), SECRETX, $);
                const results = [];
                for (const sol of biquadraticSolutions.copyElements()) {
                    results.push(simplify($.power(sol, half), $));
                    results.push(simplify($.negate($.power(sol, half)), $));
                }
                return results;
            }
            function _solveDegree4ZeroB(A, B, C, D, E, $) {
                const R_p = C;
                const R_q = D;
                const R_r = E;
                // Ferrari's solution
                // https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution
                // finding the "m" in the depressed equation
                const coeff2 = $.multiply(rational(5, 2), R_p);
                const coeff3 = $.subtract($.multiply(two, $.power(R_p, two)), R_r);
                const coeff4 = $.add($.multiply(rational(-1, 2), $.multiply(R_p, R_r)), $.add(divide($.power(R_p, three), two, $), $.multiply(rational(-1, 8), $.power(R_q, two))));
                const arg1 = $.add($.power(SECRETX, three), $.add($.multiply(coeff2, $.power(SECRETX, two)), $.add($.multiply(coeff3, SECRETX), coeff4)));
                // log.dbg(`resolventCubic: ${top()}`);
                const resolventCubicSolutions = roots(arg1, SECRETX, $);
                // log.dbg(`resolventCubicSolutions: ${toInfixString(resolventCubicSolutions)}`);
                let R_m = nil;
                //R_m = resolventCubicSolutions.elem[1]
                for (const sol of resolventCubicSolutions.copyElements()) {
                    // log.dbg(`examining solution: ${toInfixString(sol)}`);
                    const toBeCheckedIfZero = float_eval_abs_eval($.add($.multiply(sol, two), R_p), $);
                    // log.dbg(`abs value is: ${toInfixString(sol)}`);
                    if (!$.is_zero(toBeCheckedIfZero)) {
                        R_m = sol;
                        break;
                    }
                }
                // log.dbg(`chosen solution: ${toInfixString(R_m)}`);
                const sqrtPPlus2M = simplify($.power($.add($.multiply(R_m, two), R_p), half), $);
                const twoQOversqrtPPlus2M = simplify(divide($.multiply(R_q, two), sqrtPPlus2M, $), $);
                const threePPlus2M = $.add($.multiply(R_p, three), $.multiply(R_m, two));
                // solution1
                const sol1Arg = simplify($.power($.negate($.add(threePPlus2M, twoQOversqrtPPlus2M)), half), $);
                const solution1 = divide($.add(sqrtPPlus2M, sol1Arg), two, $);
                // solution2
                const sol2Arg = simplify($.power($.negate($.add(threePPlus2M, twoQOversqrtPPlus2M)), half), $);
                const solution2 = divide($.subtract(sqrtPPlus2M, sol2Arg), two, $);
                // solution3
                const sol3Arg = simplify($.power($.negate($.subtract(threePPlus2M, twoQOversqrtPPlus2M)), half), $);
                const solution3 = divide($.add($.negate(sqrtPPlus2M), sol3Arg), two, $);
                // solution4
                const sol4Arg = simplify($.power($.negate($.subtract(threePPlus2M, twoQOversqrtPPlus2M)), half), $);
                const solution4 = divide($.subtract($.negate(sqrtPPlus2M), sol4Arg), two, $);
                return [solution1, solution2, solution3, solution4];
            }
            function _solveDegree4NonzeroB(A, B, C, D, E, $) {
                const R_p = divide($.add($.multiply(eight, $.multiply(C, A)), $.multiply(create_int(-3), $.power(B, two))), $.multiply(eight, $.power(A, two)), $);
                const R_q = divide($.add($.power(B, three), $.add($.multiply(negFour, $.multiply(A, $.multiply(B, C))), $.multiply(eight, $.multiply(D, $.power(A, two))))), $.multiply(eight, $.power(A, three)), $);
                const R_a3 = $.multiply($.multiply(A, A), A);
                const R_b2 = $.multiply(B, B);
                const R_a2_d = $.multiply($.multiply(A, A), D);
                // convert to depressed quartic
                const R_r = divide($.add($.multiply($.power(B, four), create_int(-3)), $.add($.multiply(create_int(256), $.multiply(R_a3, E)), $.add($.multiply(create_int(-64), $.multiply(R_a2_d, B)), $.multiply(create_int(16), $.multiply(R_b2, $.multiply(A, C)))))), $.multiply(create_int(256), $.power(A, four)), $);
                const four_x_4 = $.power(SECRETX, four);
                const r_q_x_2 = $.multiply(R_p, $.power(SECRETX, two));
                const r_q_x = $.multiply(R_q, SECRETX);
                const simplified = simplify(add_terms$1([four_x_4, r_q_x_2, r_q_x, R_r], $), $);
                const depressedSolutions = roots(simplified, SECRETX, $);
                // log.dbg(`p for depressed quartic: ${toInfixString(R_p)}`);
                // log.dbg(`q for depressed quartic: ${toInfixString(R_q)}`);
                // log.dbg(`r for depressed quartic: ${toInfixString(R_r)}`);
                // log.dbg(`tos 4 ${defs.tos}`);
                // log.dbg(`4 * x^4: ${toInfixString(four_x_4)}`);
                // log.dbg(`R_p * x^2: ${toInfixString(r_q_x_2)}`);
                // log.dbg(`R_q * x: ${toInfixString(r_q_x)}`);
                // log.dbg(`R_r: ${toInfixString(R_r)}`);
                // log.dbg(`solving depressed quartic: ${toInfixString(simplified)}`);
                // log.dbg(`depressedSolutions: ${toInfixString(depressedSolutions)}`);
                return depressedSolutions.mapElements((sol) => {
                    const result = simplify($.subtract(sol, divide(B, $.multiply(four, A), $)), $);
                    // log.dbg(`solution from depressed: ${toInfixString(result)}`);
                    return result;
                });
            }

            const sum = (arr) => arr.reduce((a, b) => a + b, 0);
            function count(p) {
                let n;
                if (is_cons(p)) {
                    const items = [...p];
                    n = sum(items.map(count)) + items.length;
                }
                else {
                    n = 1;
                }
                return n;
            }
            // this probably works out to be
            // more general than just counting symbols, it can
            // probably count instances of anything you pass as
            // first argument but didn't try it.
            function countOccurrencesOfSymbol(needle, p, $) {
                let n = 0;
                if (is_cons(p)) {
                    n = sum([...p].map((el) => countOccurrencesOfSymbol(needle, el, $)));
                }
                else if ($.equals(needle, p)) {
                    n = 1;
                }
                return n;
            }

            function factorial(p1) {
                const n = nativeInt(p1);
                if (n < 0 || isNaN(n)) {
                    return items_to_cons(FACTORIAL, p1);
                }
                return bignum_factorial(n);
            }

            function simfac(p1, $) {
                if (is_add(p1)) {
                    const terms = p1.tail().map(function (x) {
                        return simfac_term(x, $);
                    });
                    return add_terms$1(terms, $);
                }
                return simfac_term(p1, $);
            }
            function simfac_term(p1, $) {
                // if not a product of factors then done
                if (!is_multiply(p1)) {
                    return p1;
                }
                // push all factors
                const factors = p1.tail();
                // keep trying until no more to do
                while (yysimfac(factors, $)) {
                    // do nothing
                }
                return multiply_items_factoring(factors, $);
            }
            // try all pairs of factors
            function yysimfac(stack, $) {
                for (let i = 0; i < stack.length; i++) {
                    const p1 = stack[i];
                    for (let j = 0; j < stack.length; j++) {
                        if (i === j) {
                            continue;
                        }
                        const p2 = stack[j];
                        //  n! / n    ->  (n - 1)!
                        if (is_factorial(p1) && is_power(p2) && is_num_and_eq_minus_one(caddr(p2)) && $.equals(cadr(p1), cadr(p2))) {
                            stack[i] = factorial($.subtract(cadr(p1), one));
                            stack[j] = one;
                            return true;
                        }
                        //  n / n!    ->  1 / (n - 1)!
                        if (is_power(p2) && is_num_and_eq_minus_one(caddr(p2)) && caadr(p2).equals(FACTORIAL) && $.equals(p1, cadadr(p2))) {
                            stack[i] = inverse(factorial($.add(p1, negOne)), $);
                            stack[j] = one;
                            return true;
                        }
                        //  (n + 1) n!  ->  (n + 1)!
                        if (is_factorial(p2)) {
                            const p3 = $.subtract(p1, cadr(p2));
                            if ($.isOne(p3)) {
                                stack[i] = factorial(p1);
                                stack[j] = one;
                                return true;
                            }
                        }
                        //  1 / ((n + 1) n!)  ->  1 / (n + 1)!
                        if (is_power(p1) &&
                            is_num_and_eq_minus_one(caddr(p1)) &&
                            is_power(p2) &&
                            is_num_and_eq_minus_one(caddr(p2)) &&
                            caadr(p2).equals(FACTORIAL)) {
                            const p3 = $.subtract(cadr(p1), cadr(cadr(p2)));
                            if ($.isOne(p3)) {
                                stack[i] = inverse(factorial(cadr(p1)), $);
                                stack[j] = one;
                                return true;
                            }
                        }
                        //  (n + 1)! / n!  ->  n + 1
                        //  n! / (n + 1)!  ->  1 / (n + 1)
                        if (is_factorial(p1) &&
                            is_power(p2) &&
                            is_num_and_eq_minus_one(caddr(p2)) &&
                            caadr(p2).equals(FACTORIAL)) {
                            const p3 = $.subtract(cadr(p1), cadr(cadr(p2)));
                            if ($.isOne(p3)) {
                                stack[i] = cadr(p1);
                                stack[j] = one;
                                return true;
                            }
                            if (is_num_and_eq_minus_one(p3)) {
                                stack[i] = inverse(cadr(cadr(p2)), $);
                                stack[j] = one;
                                return true;
                            }
                            if (equaln(p3, 2)) {
                                stack[i] = cadr(p1);
                                stack[j] = $.add(cadr(p1), negOne);
                                return true;
                            }
                            if (equaln(p3, -2)) {
                                stack[i] = inverse(cadr(cadr(p2)), $);
                                stack[j] = inverse($.add(cadr(cadr(p2)), negOne), $);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            /*
             Convert complex z to clock form

              Input:    push  z

              Output:    Result on stack

              clock(z) = abs(z) * (-1) ^ (arg(z) / pi)

              For example, clock(exp(i * pi/3)) gives the result (-1)^(1/3)
            */
            // P.S. I couldn't find independent definition/aknowledgment
            // of the naming "clock form" anywhere on the web, seems like a
            // naming specific to eigenmath.
            // Clock form is another way to express a complex number, and
            // it has three advantages
            //   1) it's uniform with how for example
            //      i is expressed i.e. (-1)^(1/2)
            //   2) it's very compact
            //   3) it's a straighforward notation for roots of 1 and -1
            /**
             * z => abs(z) * (-1) ^ (arg(z) / pi)
             * @param z
             * @param $
             * @returns
             */
            function clock(z, $) {
                $.pushNativeDirective(Directive.evaluatingAsClock, true);
                try {
                    // console.lg();
                    // console.lg(`clockform z=${print_expr(z, $)}`);
                    // pushing the expression (-1)^... but note
                    // that we can't use "power", as "power" evaluates
                    // clock forms into rectangular form (see "-1 ^ rational"
                    // section in power)
                    const arg_z = $.arg(z);
                    // console.lg(`arg_z=${print_expr(arg_z, $)}`);
                    const pi = DynamicConstants.Pi($);
                    // console.lg(`pi=${print_expr(pi, $)}`);
                    const direction = items_to_cons$1(POWER$1, negOne, divide(arg_z, pi, $));
                    // console.lg(`direction=${print_expr(direction, $)}`);
                    const magnitude = abs$1(z, $);
                    // console.lg(`magnitude=${print_expr(magnitude, $)}`);
                    const clock_z = $.multiply(magnitude, direction);
                    // console.lg(`clock_z  =${print_expr(clock_z, $)}`);
                    return clock_z;
                }
                finally {
                    $.popNativeDirective();
                }
            }

            function Eval_rationalize(expr, $) {
                // const infix = render_as_infix(expr, $);
                // console.lg("infix", infix);
                const arg = cadr(expr);
                // console.lg("arg", render_as_infix(arg, $));
                const value = $.valueOf(arg);
                // console.lg("value", render_as_infix(value, $));
                return rationalize_factoring(value, $);
            }
            function rationalize_factoring(argList, $) {
                $.pushNativeDirective(Directive.factor, true);
                try {
                    return yyrationalize(argList, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }
            function yyrationalize(arg, $) {
                // console.lg(`yyrationalize ${render_as_infix(arg, $)}`);
                if (is_tensor(arg)) {
                    return __rationalize_tensor(arg, $);
                }
                // defs.expanding = false;
                if (!is_add(arg)) {
                    return arg;
                }
                // get common denominator
                const commonDenominator = multiply_denominators(arg, $);
                // console.lg(`commonDenominator ${render_as_infix(commonDenominator, $)}`);
                // multiply each term by common denominator
                let temp = zero;
                if (is_cons(arg)) {
                    temp = arg
                        .tail()
                        .reduce((acc, term) => $.add(acc, $.multiply(commonDenominator, term)), temp);
                }
                // collect common factors
                // divide by common denominator
                // console.lg(`temp ${print_expr(temp, $)}`);
                const condensed = condense(temp, $);
                // console.lg(`condensed ${print_expr(condensed, $)}`);
                const rationalized = divide(condensed, commonDenominator, $);
                // console.lg(`rationalized ${print_expr(rationalized, $)}`);
                return rationalized;
            }
            function multiply_denominators(p, $) {
                if (is_add(p)) {
                    return p
                        .tail()
                        .reduce((acc, el) => multiply_denominators_term(el, acc, $), one);
                }
                return multiply_denominators_term(p, one, $);
            }
            function multiply_denominators_term(p, p2, $) {
                if (is_multiply(p)) {
                    return p
                        .tail()
                        .reduce((acc, el) => multiply_denominators_factor(el, acc, $), p2);
                }
                return multiply_denominators_factor(p, p2, $);
            }
            function multiply_denominators_factor(p, p2, $) {
                if (!is_power(p)) {
                    return p2;
                }
                const arg2 = p;
                p = caddr(p);
                // like x^(-2) ?
                if (is_negative_number(p)) {
                    return __lcm(p2, inverse(arg2, $), $);
                }
                // like x^(-a) ?
                if (is_multiply(p) && is_negative_number(cadr(p))) {
                    return __lcm(p2, inverse(arg2, $), $);
                }
                // no match
                return p2;
            }
            function __rationalize_tensor(p1, $) {
                if (!is_tensor(p1)) {
                    // might be zero
                    return p1;
                }
                const elems = p1.mapElements(function (x) {
                    return rationalize_factoring(x, $);
                });
                return p1.withElements(elems);
            }
            function __lcm(p1, p2, $) {
                return divide($.multiply(p1, p2), gcd(p1, p2, $), $);
            }

            /* denominator =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the denominator of expression x.

            */
            function Eval_denominator(expr, $) {
                return denominator($.valueOf(cadr(expr)), $);
            }
            function denominator(expr, $) {
                // console.lg(`ENTERING denominator of ${$.toInfixString(expr)} ${$.toListString(expr)}`);
                const hook = function (retval) {
                    // console.lg(`LEAVING denominator of ${$.toInfixString(expr)} ${$.toListString(expr)} => ${$.toInfixString(retval)}`);
                    return retval;
                };
                //console.trace "denominator of: " + p1
                if (is_add(expr)) {
                    expr = rationalize_factoring(expr, $);
                }
                // (denom (* x1 x2 x3 ...)) = denom(x1) * denom(x2) * denom(x3)
                // "denominator of products = product of denominators"
                if (is_cons(expr)) {
                    const argList = expr.cdr;
                    // TODO: Why do I care about whether a1 is one?
                    if (is_multiply(expr) && !$.isOne(car(argList))) {
                        // console.lg("(denom (* x1 x2 x3 ...)) = denom(x1) * denom(x2) * denom(x3)");
                        const xs = expr.tail();
                        // console.lg(`xs => ${items_to_infix(xs, $)}`);
                        const denoms = denominators(xs, $);
                        // console.lg(`denominators => ${items_to_infix(denoms, $)}`);
                        const product_of_denoms = multiply_items(denoms, $);
                        // console.lg(`product_of_denoms => ${$.toInfixString(product_of_denoms)}`)
                        return hook(product_of_denoms);
                    }
                }
                if (is_rat$1(expr)) {
                    return hook(mp_denominator(expr));
                }
                if (is_power(expr) && is_negative(caddr(expr))) {
                    return hook(inverse(expr, $));
                }
                return hook(one);
            }
            function denominators(xs, $) {
                const denom_mapper = make_denom_mapper($);
                const denoms = xs.map(denom_mapper);
                return denoms;
            }
            function make_denom_mapper($) {
                return function (x) {
                    return denominator(x, $);
                };
            }

            //-----------------------------------------------------------------------------
            //
            //  Bignum GCD
            //
            //  Uses the binary GCD algorithm.
            //
            //  See "The Art of Computer Programming" p. 338.
            //
            //  mgcd always returns a positive value
            //
            //  mgcd(0, 0) = 0
            //
            //  mgcd(u, 0) = |u|
            //
            //  mgcd(0, v) = |v|
            //
            //-----------------------------------------------------------------------------
            function mgcd(u, v) {
                return BigIntegerExports.gcd(u, v);
            }
            //if SELFTEST

            // Bignum prime test (returns 1 if prime, 0 if not)
            // Uses Algorithm P (probabilistic primality test) from p. 395 of
            // "The Art of Computer Programming, Volume 2" by Donald E. Knuth.
            function mprime(n) {
                return n.isProbablePrime();
            }
            //if SELFTEST

            // Bignum compare
            //  returns
            //  -1    a < b
            //  0    a = b
            //  1    a > b
            function mcmp(a, b) {
                return a.compare(b);
            }
            // a is a bigint, n is a normal int
            /*
            function mcmpint(a: bigInt.BigInteger, n: number): Sign {
              const b = bigInt(n);
              const t = mcmp(a, b);
              return t;
            }
            */

            // Factor using the Pollard rho method
            let n_factor_number = BigIntegerExports(0);
            function factor_number(p1) {
                // 0 or 1?
                if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {
                    return p1;
                }
                n_factor_number = p1.a;
                const factors = factor_a();
                if (factors.length === 0) ;
                if (factors.length === 1) {
                    return factors[0];
                }
                if (factors.length > 1) {
                    return cons(MULTIPLY$1, items_to_cons$1(...factors));
                }
                return nil;
            }
            // factor using table look-up, then switch to rho method if necessary
            // From TAOCP Vol. 2 by Knuth, p. 380 (Algorithm A)
            function factor_a() {
                const result = [];
                if (n_factor_number.isNegative()) {
                    n_factor_number = setSignTo(n_factor_number, 1);
                    result.push(negOne);
                }
                for (let k = 0; k < 10000; k++) {
                    result.push(...try_kth_prime(k));
                    // if n_factor_number is 1 then we're done
                    if (n_factor_number.compare(1) === 0) {
                        return result;
                    }
                }
                result.push(...factor_b());
                return result;
            }
            function try_kth_prime(k) {
                const result = [];
                let q;
                const d = mint(primetab[k]);
                let count = 0;
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    // if n_factor_number is 1 then we're done
                    if (n_factor_number.compare(1) === 0) {
                        if (count) {
                            result.push(_factor(d, count));
                        }
                        return result;
                    }
                    let r;
                    [q, r] = Array.from(mdivrem(n_factor_number, d));
                    // continue looping while remainder is zero
                    if (r.isZero()) {
                        count++;
                        n_factor_number = q;
                    }
                    else {
                        break;
                    }
                }
                if (count) {
                    result.push(_factor(d, count));
                }
                // q = n_factor_number/d, hence if q < d then
                // n_factor_number < d^2 so n_factor_number is prime
                if (mcmp(q, d) === -1) {
                    result.push(_factor(n_factor_number, 1));
                    n_factor_number = mint(1);
                }
                return result;
            }
            // From TAOCP Vol. 2 by Knuth, p. 385 (Algorithm B)
            function factor_b() {
                const result = [];
                const bigint_one = mint(1);
                let x = mint(5);
                let xprime = mint(2);
                let k = 1;
                let l = 1;
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    if (mprime(n_factor_number)) {
                        result.push(_factor(n_factor_number, 1));
                        return result;
                    }
                    // eslint-disable-next-line no-constant-condition
                    while (true) {
                        // g = gcd(x' - x, n_factor_number)
                        let t = xprime.subtract(x);
                        t = setSignTo(t, 1);
                        const g = mgcd(t, n_factor_number);
                        if (g.equals(1)) {
                            if (--k === 0) {
                                xprime = x;
                                l *= 2;
                                k = l;
                            }
                            // x = (x ^ 2 + 1) mod n_factor_number
                            t = mmul(x, x);
                            x = t.add(bigint_one);
                            t = mmod(x, n_factor_number);
                            x = t;
                            continue;
                        }
                        result.push(_factor(g, 1));
                        if (mcmp(g, n_factor_number) === 0) {
                            return result;
                        }
                        // n_factor_number = n_factor_number / g
                        t = mdiv(n_factor_number, g);
                        n_factor_number = t;
                        // x = x mod n_factor_number
                        t = mmod(x, n_factor_number);
                        x = t;
                        // xprime = xprime mod n_factor_number
                        t = mmod(xprime, n_factor_number);
                        xprime = t;
                        break;
                    }
                }
            }
            function _factor(d, count) {
                let factor = new Rat(d, BigIntegerExports.one);
                if (count > 1) {
                    factor = items_to_cons$1(POWER$1, factor, new Rat(mint(count), BigIntegerExports.one));
                }
                return factor;
            }

            function factor_again(p1, p2, $) {
                if (is_multiply(p1)) {
                    const arr = [];
                    p1.tail().forEach((el) => factor_term(arr, el, p2, $));
                    return multiply_items_factoring(arr, $);
                }
                const arr = [];
                factor_term(arr, p1, p2, $);
                return arr[0];
            }
            function factor_term(arr, arg1, arg2, $) {
                const p1 = $.factorize(arg1, arg2);
                if (is_multiply(p1)) {
                    arr.push(...p1.tail());
                    return;
                }
                arr.push(p1);
            }
            function factor(p1, p2, $) {
                if (is_rat_and_integer(p1)) {
                    return factor_number(p1); // see pollard.cpp
                }
                return $.factorize(p1, p2);
            }
            // for factoring small integers (2^32 or less)
            function factor_small_number(n) {
                if (isNaN(n)) {
                    halt('number too big to factor');
                }
                const arr = [];
                if (n < 0) {
                    n = -n;
                }
                for (let i = 0; i < MAXPRIMETAB; i++) {
                    const d = primetab[i];
                    if (d > n / d) {
                        break;
                    }
                    let expo = 0;
                    while (n % d === 0) {
                        n /= d;
                        expo++;
                    }
                    if (expo) {
                        arr.push(create_int(d));
                        arr.push(create_int(expo));
                    }
                }
                if (n > 1) {
                    arr.push(create_int(n));
                    arr.push(one);
                }
                return arr;
            }

            function Eval_numerator(p1, $) {
                return numerator($.valueOf(cadr(p1)), $);
            }
            function numerator(p1, $) {
                // console.lg(`numerator ${$.toInfixString(p1)}`);
                if (is_add(p1)) {
                    //console.trace "rationalising "
                    p1 = rationalize_factoring(p1, $);
                }
                // console.lg(`rationalized=${$.toInfixString(p1)}`);
                // console.lg(`rationalized=${$.toSExprString(p1)}`);
                if (is_multiply(p1) && !$.isOne(car(cdr(p1)))) {
                    // console.lg "p1 inside multiply: " + p1
                    // console.lg "first term: " + car(p1)
                    return multiply_items(p1.tail().map(function (x) {
                        return numerator(x, $);
                    }), $);
                }
                if (is_rat$1(p1)) {
                    return mp_numerator(p1);
                }
                if (is_power(p1) && is_negative(caddr(p1))) {
                    return one;
                }
                return p1;
            }

            /*
            Convert complex z to polar form

              Input:    p1  z
              Output:    Result

              polar(z) = abs(z) * exp(i * arg(z))
            */
            function Eval_polar(expr, $) {
                return polar($.valueOf(cadr(expr)), $);
            }
            function polar(z, $) {
                $.pushNativeDirective(Directive.evaluatingAsPolar, true);
                try {
                    const r = abs$1(z, $);
                    // console.lg("r", $.toInfixString(r));
                    const theta = $.arg(z);
                    // console.lg("theta", $.toInfixString(theta));
                    const imu_times_theta = $.multiply(imu, theta);
                    // console.lg("imu_times_theta", $.toInfixString(imu_times_theta));
                    const unit = exp$1(imu_times_theta, $);
                    // console.lg("unit", $.toInfixString(unit));
                    return $.multiply(r, unit);
                }
                finally {
                    $.popNativeDirective();
                }
            }

            function is_pow(expr) {
                const opr = expr.opr;
                if (is_sym(opr)) {
                    return MATH_POW$2.equalsSym(opr);
                }
                else {
                    return false;
                }
            }

            function is_pow_2_any_any(expr) {
                return is_pow(expr) && is_binop(expr);
            }

            /**
             * cos(x) = ... (expt series)
             */
            const MATH_COS = native_sym(Native.cos);

            /**
             * Wraps the argument in a cosine function and
             */
            function cos(x, $) {
                return $.valueOf(items_to_cons$1(MATH_COS, x));
            }

            /**
             * sin(x) = ...
             */
            const MATH_SIN = create_sym('sin');

            function sin(x, $) {
                return $.valueOf(items_to_cons$1(MATH_SIN, x));
            }

            /**
             * Convert complex z to rectanglar from.
             * @param p1 (rect z)
             */
            function Eval_rect(p1, $) {
                const arg = cadnr(p1, 1);
                const valueOfArg = $.valueOf(arg);
                const result = rect$2(valueOfArg, $);
                return result;
            }
            function rect$2(z, $) {
                // console.lg("rect", $.toSExprString(z));
                // if we assume real variables, then the
                // rect of any symbol is the symbol itself
                // (note that 'i' is not a symbol, it's made of (-1)^(1/2))
                // otherwise we have to leave unevalled
                if (is_sym(z)) {
                    if (!$.is_zero($.getSymbolValue(ASSUME_REAL_VARIABLES))) {
                        return z;
                    }
                    return items_to_cons$1(RECT, z);
                    // TODO this is quite dirty, ideally we don't need this
                    // but removing this creates a few failings in the tests
                    // that I can't investigate right now.
                    // --
                    // if we assume all variables are real AND
                    // it's not an exponential nor a polar nor a clock form
                    // THEN rect(_) = _
                    // note that these matches can be quite sloppy, one can find expressions
                    // which shouldn't match but do
                    //
                }
                const assumeRealVariables = !$.is_zero($.getSymbolValue(ASSUME_REAL_VARIABLES));
                // console.lg("assumeRealVariables", assumeRealVariables);
                // const hasExpForm = has_exp_form(z, $);
                // console.lg("hasExpForm", hasExpForm);
                if (assumeRealVariables && !has_exp_form(z) && !has_clock_form(z, z) && !(z.contains(MATH_SIN$1) && z.contains(COS$3) && z.contains(imu))) {
                    // console.lg("rect has no polar form", $.toSExprString(z));
                    // no polar form?
                    return z; // ib
                }
                if (is_cons(z) && is_multiply(z) && is_imu(cadr(z)) && assumeRealVariables) {
                    // console.lg("rect is sum", $.toSExprString(z));
                    return z; // sum
                }
                if (is_cons(z) && is_add(z)) {
                    // console.lg("rect is add", $.toSExprString(z));
                    return z.tail().reduce((a, b) => $.add(a, rect$2(b, $)), zero);
                }
                // TODO: Shouldn't the final statement be the wrapping of the arg in (rect ...)?
                // Then the code below is used in a matcher.
                // try to get to the rectangular form by doing
                // abs(p1) * (cos (theta) + i * sin(theta))
                // where theta is arg(p1)
                // abs(z) * (cos(arg(z)) + i sin(arg(z)))
                // console.lg("rect is computing abs(z)", $.toInfixString(z));
                // const A = arg(z, $);
                // console.lg("theta", $.toInfixString(A));
                const result = $.multiply(abs$1(z, $), $.add(cos($.arg(z), $), $.multiply(imu, sin($.arg(z), $))));
                return result;
            }

            // Transpose tensor indices
            function Eval_transpose(p1, $) {
                const arg1 = $.valueOf(cadr(p1));
                let arg2 = one;
                let arg3 = two;
                if (nil !== cddr(p1)) {
                    arg2 = $.valueOf(caddr(p1));
                    arg3 = $.valueOf(cadddr(p1));
                }
                return transpose(arg1, arg2, arg3, $);
            }
            // by default p3 is 2 and p2 is 1
            // p3: index to be transposed
            // p2: other index to be transposed
            // p1: what needs to be transposed
            function transpose(p1, p2, p3, $) {
                let t = 0;
                const ai = Array(MAXDIM).fill(0);
                const an = Array(MAXDIM).fill(0);
                // a transposition just goes away when applied to a scalar
                if (is_num(p1)) {
                    return p1;
                }
                // transposition goes away for identity matrix
                if (($.isOne(p2) && is_num_and_eq_two(p3)) || ($.isOne(p3) && is_num_and_eq_two(p2))) {
                    if (is_identity_matrix(p1)) {
                        return p1;
                    }
                }
                // a transposition just goes away when applied to another transposition with
                // the same columns to be switched
                if (is_transpose(p1)) {
                    const innerTranspSwitch1 = car(cdr(cdr(p1)));
                    const innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));
                    if (($.equals(innerTranspSwitch1, p3) && $.equals(innerTranspSwitch2, p2)) ||
                        ($.equals(innerTranspSwitch2, p3) && $.equals(innerTranspSwitch1, p2)) ||
                        ($.equals(innerTranspSwitch1, nil) &&
                            $.equals(innerTranspSwitch2, nil) &&
                            (($.isOne(p3) && is_num_and_eq_two(p2)) || ($.isOne(p2) && is_num_and_eq_two(p3))))) {
                        return car(cdr(p1));
                    }
                }
                // if operand is a sum then distribute (if we are in expanding mode)
                if ($.isExpanding() && is_add(p1)) {
                    // add the dimensions to switch but only if they are not the default ones.
                    return p1
                        .tail()
                        .reduce((a, b) => $.add(a, transpose(b, p2, p3, $)), zero);
                }
                // if operand is a multiplication then distribute (if we are in expanding mode)
                if ($.isExpanding() && is_multiply(p1)) {
                    // add the dimensions to switch but only if they are not the default ones.
                    return p1
                        .tail()
                        .reduce((a, b) => $.multiply(a, transpose(b, p2, p3, $)), one);
                }
                // distribute the transpose of a dot if in expanding mode
                // note that the distribution happens in reverse as per tranpose rules.
                // The dot operator is not commutative, so, it matters.
                if ($.isExpanding() && is_inner_or_dot(p1)) {
                    const accumulator = [];
                    if (is_cons(p1)) {
                        accumulator.push(...p1.tail().map((p) => [p, p2, p3]));
                    }
                    accumulator.reverse();
                    return accumulator.reduce((acc, p) => $.inner(acc, transpose(p[0], p[1], p[2], $)), SYMBOL_IDENTITY_MATRIX);
                }
                if (!is_tensor(p1)) {
                    if (!$.is_zero(p1)) {
                        //stop("transpose: tensor expected, 1st arg is not a tensor")
                        // remove the default "dimensions to be switched"
                        // parameters
                        if ((!$.isOne(p2) || !is_num_and_eq_two(p3)) && (!$.isOne(p3) || !is_num_and_eq_two(p2))) {
                            return items_to_cons(TRANSPOSE, p1, p2, p3);
                        }
                        return items_to_cons(TRANSPOSE, p1);
                    }
                    return zero;
                }
                const { ndim: ndim, nelem: nelem } = p1;
                // is it a vector?
                // so here it's something curious - note how vectors are
                // not really special two-dimensional matrices, but rather
                // 1-dimension objects (like tensors can be). So since
                // they have one dimension, transposition has no effect.
                // (as opposed as if they were special two-dimensional
                // matrices)
                // see also Ran Pan, Tensor Transpose and Its Properties. CoRR abs/1411.1503 (2014)
                if (ndim === 1) {
                    return p1;
                }
                let l = nativeInt(p2);
                let m = nativeInt(p3);
                if (l < 1 || l > ndim || m < 1 || m > ndim) {
                    halt('transpose: index out of range');
                }
                l--;
                m--;
                const elems = new Array(nelem);
                const dims = p1.copyDimensions();
                dims[l] = p1.dim(m);
                dims[m] = p1.dim(l);
                // const a = p1.elems;
                //const b = retval.elems;
                // init tensor index
                for (let i = 0; i < ndim; i++) {
                    ai[i] = 0;
                    an[i] = p1.dim(i);
                }
                // copy components from a to b
                for (let i = 0; i < nelem; i++) {
                    t = ai[l];
                    ai[l] = ai[m];
                    ai[m] = t;
                    t = an[l];
                    an[l] = an[m];
                    an[m] = t;
                    // convert tensor index to linear index k
                    let k = 0;
                    for (let j = 0; j < ndim; j++) {
                        k = k * an[j] + ai[j];
                    }
                    // swap indices back
                    t = ai[l];
                    ai[l] = ai[m];
                    ai[m] = t;
                    t = an[l];
                    an[l] = an[m];
                    an[m] = t;
                    // copy one element
                    elems[k] = p1.elem(i);
                    // increment tensor index
                    // Suppose the tensor dimensions are 2 and 3.
                    // Then the tensor index ai increments as follows:
                    // 00 -> 01
                    // 01 -> 02
                    // 02 -> 10
                    // 10 -> 11
                    // 11 -> 12
                    // 12 -> 00
                    for (let j = ndim - 1; j >= 0; j--) {
                        if (++ai[j] < an[j]) {
                            break;
                        }
                        ai[j] = 0;
                    }
                }
                return new Tensor(dims, elems);
            }
            function transpose_factoring(p1, p2, p3, $) {
                $.pushNativeDirective(Directive.factor, true);
                try {
                    return transpose(p1, p2, p3, $);
                }
                finally {
                    $.popNativeDirective();
                }
            }

            function simplify_if_codegen(expr, $) {
                // when we do code generation, we proceed to
                // fully evaluate and simplify the body of
                // a function, so we resolve all variables
                // indirections and we simplify everything
                // we can given the current assignments.
                if (defs.codeGen && car(expr).equals(FUNCTION)) {
                    const fbody = cadr(expr);
                    // let's simplify the body so we give it a
                    // compact form
                    const p3 = simplify($.valueOf(fbody), $);
                    // replace the evaled body
                    const args = caddr(expr); // p5 is B
                    return items_to_cons(FUNCTION, p3, args);
                }
                else {
                    return expr;
                }
            }
            function simplify_if_contains_factorial(expr, $) {
                if (expr.contains(FACTORIAL)) {
                    const p2 = simfac(expr, $);
                    const p3 = simfac(rationalize_factoring(expr, $), $);
                    return count(p2) < count(p3) ? p2 : p3;
                }
                else {
                    return expr;
                }
            }
            function simplify(expr, $) {
                // console.lg(`ENTERING simplify ${$.toInfixString(expr)}`);
                const hook = function (retval) {
                    // console.lg(`LEAVING simplify ${$.toInfixString(expr)} => ${$.toInfixString(retval)}`);
                    // console.lg(`LEAVING simplify ${$.toListString(expr)} => ${$.toInfixString(retval)}`);
                    return retval;
                };
                const scode = simplify_if_codegen(expr, $);
                if (is_tensor(scode)) {
                    return hook(simplify_tensor(scode, $));
                }
                const sfact = simplify_if_contains_factorial(expr, $);
                // console.lg(`0 ${$.toInfixString(sfact)}`);
                let p1 = simplify_by_i_dunno_what(sfact, $);
                // console.lg(`A ${$.toInfixString(p1)}`);
                p1 = simplify_by_rationalizing(p1, $);
                // console.lg(`B ${$.toInfixString(p1)}`);
                p1 = simplify_by_condensing(p1, $);
                // console.lg(`C ${$.toInfixString(p1)}`);
                p1 = simplify_a_minus_b_divided_by_b_minus_a(p1, $);
                // console.lg(`D ${$.toInfixString(p1)}`);
                p1 = simplify_by_expanding_denominators(p1, $);
                // console.lg(`E ${$.toInfixString(p1)}`);
                p1 = simplify_trig(p1, $);
                // console.lg(`F ${$.toInfixString(p1)}`);
                p1 = simplify_terms(p1, $);
                // console.lg(`G ${$.toInfixString(p1)}`);
                p1 = simplify_polarRect(p1, $);
                // console.lg(`H ${$.toInfixString(p1)}`);
                {
                    let simplify_nested_radicalsResult;
                    [simplify_nested_radicalsResult, p1] = simplify_nested_radicals(p1, $);
                    // console.lg(`I ${$.toInfixString(p1)}`);
                    // if there is some de-nesting then
                    // re-run a simplification because
                    // the shape of the expression might
                    // have changed significantly.
                    // e.g. simplify(14^(1/2) - (16 - 4*7^(1/2))^(1/2))
                    // needs some more simplification after the de-nesting.
                    if (simplify_nested_radicalsResult) {
                        return hook(simplify(p1, $));
                    }
                }
                p1 = simplify_rect_to_clock(p1, $);
                // console.lg(`J ${$.toInfixString(p1)}`);
                p1 = simplify_rational_expressions(p1, $);
                // console.lg(`K ${$.toInfixString(p1)}`);
                return hook(p1);
            }
            /**
             * Simplifying a tensor means that we try to simplify each element separately.
             * @param M
             * @param $
             * @returns
             */
            function simplify_tensor(M, $) {
                const simple_M = M.map(function (x) {
                    return simplify(x, $);
                });
                if ($.is_zero(simple_M)) {
                    return simple_M;
                }
                else {
                    return simple_M;
                }
            }
            // try rationalizing
            function simplify_by_rationalizing(p1, $) {
                // console.lg(`simplify_by_rationalizing`);
                if (!(is_cons(p1) && is_add(p1))) {
                    return p1;
                }
                const p2 = rationalize_factoring(p1, $);
                if (count(p2) < count(p1)) {
                    p1 = p2;
                }
                return p1;
            }
            // try condensing
            function simplify_by_condensing(p1, $) {
                if (!(is_cons(p1) && is_add(p1))) {
                    return p1;
                }
                const p2 = condense(p1, $);
                if (count(p2) <= count(p1)) {
                    p1 = p2;
                }
                return p1;
            }
            // this simplifies forms like (A-B) / (B-A)
            function simplify_a_minus_b_divided_by_b_minus_a(p1, $) {
                const p2 = rationalize_factoring($.negate(rationalize_factoring($.negate(rationalize_factoring(p1, $)), $)), $);
                if (count(p2) < count(p1)) {
                    p1 = p2;
                }
                return p1;
            }
            function simplify_by_i_dunno_what(p1, $) {
                // console.lg(`simplify_by_i_dunno_what`);
                const carp1 = car(p1);
                if (carp1.equals(MULTIPLY$1) || is_inner_or_dot(p1)) {
                    // both operands a transpose?
                    if (car(car(cdr(p1))).equals(TRANSPOSE) && car(car(cdr(cdr(p1)))).equals(TRANSPOSE)) {
                        const a = cadr(car(cdr(p1)));
                        const b = cadr(car(cdr(cdr(p1))));
                        let arg1;
                        if (carp1.equals(MULTIPLY$1)) {
                            arg1 = $.multiply(a, b);
                        }
                        else if (is_inner_or_dot(p1)) {
                            arg1 = $.inner(b, a);
                        }
                        else {
                            arg1 = stack_pop();
                        }
                        const p2 = transpose_factoring(arg1, one, two, $);
                        if (count(p2) < count(p1)) {
                            p1 = p2;
                        }
                    }
                }
                return p1;
            }
            // try expanding denominators
            function simplify_by_expanding_denominators(expr, $) {
                if ($.is_zero(expr)) {
                    return expr;
                }
                const A = rationalize_factoring(expr, $);
                const B = inverse(A, $);
                const C = rationalize_factoring(B, $);
                const D = inverse(C, $);
                const E = rationalize_factoring(D, $);
                if (count(E) < count(expr)) {
                    return E;
                }
                else {
                    return expr;
                }
            }
            // simplifies trig forms
            /**
             * Simplifies trigonometric expressions.
             * This function won't go recursive, so it's quite safe to call anytime.
             */
            function simplify_trig(expr, $) {
                // console.lg(`simplify_trig expr=${print_expr(expr, $)}`);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`simplify_trig expr = ${$.toInfixString(expr)} => ${$.toInfixString(retval)} (${description})`);
                    return retval;
                };
                if (!expr.contains(SIN$1) && !expr.contains(COS$3)) {
                    return hook(expr);
                }
                // TODO: This should be done through the environment, $.
                defs.trigmode = 1;
                const expr1 = $.valueOf(expr);
                defs.trigmode = 2;
                const expr2 = $.valueOf(expr);
                defs.trigmode = 0;
                if (count(expr2) < count(expr1) || nterms(expr2) < nterms(expr1)) {
                    if (count(expr2) < count(expr) || nterms(expr2) < nterms(expr)) {
                        return hook(expr2);
                    }
                    else {
                        return hook(expr);
                    }
                }
                else {
                    if (count(expr1) < count(expr) || nterms(expr1) < nterms(expr)) {
                        return hook(expr1);
                    }
                    else {
                        return hook(expr);
                    }
                }
            }
            // if it's a sum then try to simplify each term
            function simplify_terms(p1, $) {
                if (!(is_cons(p1) && is_add(p1))) {
                    return p1;
                }
                let p2 = cdr(p1);
                if (is_cons(p2)) {
                    p2 = [...p2].reduce((acc, p) => simplify_rational_expressions($.add(acc, simplify(p, $)), $), zero);
                }
                if (count(p2) < count(p1)) {
                    p1 = p2;
                }
                return p1;
            }
            function simplify_rational_expressions(p1, $) {
                const denom = denominator(p1, $);
                if (is_plus_or_minus_one(denom, $)) {
                    return p1;
                }
                const num = numerator(p1, $);
                if (is_plus_or_minus_one(num, $)) {
                    return p1;
                }
                let polyVar;
                if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {
                    return p1;
                }
                const theGCD = factor(gcd(num, denom, $), polyVar, $);
                if (is_plus_or_minus_one(theGCD, $)) {
                    return p1;
                }
                const factoredNum = factor(num, polyVar, $);
                const theGCDInverse = inverse(theGCD, $);
                const multipliedNoeExpandNum = multiply_noexpand(factoredNum, theGCDInverse, $);
                const simplifiedNum = simplify(multipliedNoeExpandNum, $);
                const factoredDenom = factor(denom, polyVar, $);
                const multipliedNoeExpandDenom = multiply_noexpand(factoredDenom, theGCDInverse, $);
                const simplifiedDenom = simplify(multipliedNoeExpandDenom, $);
                const numDividedDenom = divide(simplifiedNum, simplifiedDenom, $);
                const p2 = condense(numDividedDenom, $);
                if (count(p2) < count(p1)) {
                    return p2;
                }
                else {
                    return p1;
                }
            }
            // things like 6*(cos(2/9*pi)+i*sin(2/9*pi)) = 6*exp(2/9*i*pi)
            // where we have sin and cos, those might start to
            // look better in clock form i.e.  6*(-1)^(2/9)
            function simplify_rect_to_clock(expr, $) {
                const oldExpr = expr;
                // console.lg(`simplify_rect_to_clock ${print_expr(oldExpr, $)}`);
                //breakpoint
                if (!oldExpr.contains(SIN$1) && !oldExpr.contains(COS$3)) {
                    return oldExpr;
                }
                const newExpr = clock($.valueOf(oldExpr), $);
                // console.lg(`before simplification clockform: ${oldExpr} after: ${newExpr}`);
                if (count(newExpr) < count(oldExpr)) {
                    return newExpr;
                }
                else {
                    return oldExpr;
                }
            }
            function simplify_polarRect(p1, $) {
                const tmp = polarRectAMinusOneBase(p1, $);
                const p2 = $.valueOf(tmp); // put new (hopefully simplified expr) in p2
                if (count(p2) < count(p1)) {
                    p1 = p2;
                }
                return p1;
            }
            function polarRectAMinusOneBase(p1, $) {
                if (is_imu(p1)) {
                    return p1;
                }
                if (car(p1).equals(POWER$1) && is_num_and_eq_minus_one(cadr(p1))) {
                    // base we just said is minus 1
                    const base = $.negate(one);
                    // exponent
                    const exponent = polarRectAMinusOneBase(caddr(p1), $);
                    // try to simplify it using polar and rect
                    return rect$2(polar($.power(base, exponent), $), $);
                }
                if (is_cons(p1)) {
                    const arr = [];
                    while (is_cons(p1)) {
                        arr.push(polarRectAMinusOneBase(car(p1), $));
                        p1 = cdr(p1);
                    }
                    return items_to_cons(...arr);
                }
                return p1;
            }
            function nterms(p) {
                if (is_cons(p) && is_add(p)) {
                    return length_of_cons_otherwise_zero(p) - 1;
                }
                return 1;
            }
            function simplify_nested_radicals(p1, $) {
                if (defs.recursionLevelNestedRadicalsRemoval > 0) {
                    return [TFLAG_NONE, p1];
                }
                const [simplificationWithoutCondense, somethingSimplified,] = take_care_of_nested_radicals(p1, $);
                // in this paragraph we check whether we can collect
                // common factors without complicating the expression
                // in particular we want to avoid
                // collecting radicals like in this case where
                // we collect sqrt(2):
                //   2-2^(1/2) into 2^(1/2)*(-1+2^(1/2))
                // but we do like to collect other non-radicals e.g.
                //   17/2+3/2*5^(1/2) into 1/2*(17+3*5^(1/2))
                // so what we do is we count the powers and we check
                // which version has the least number of them.
                const simplificationWithCondense = noexpand_unary(yycondense, simplificationWithoutCondense, $);
                // console.lg("occurrences of powers in " + simplificationWithoutCondense + " :" + countOccurrencesOfSymbol(POWER,simplificationWithoutCondense))
                // console.lg("occurrences of powers in " + simplificationWithCondense + " :" + countOccurrencesOfSymbol(POWER,simplificationWithCondense))
                p1 =
                    countOccurrencesOfSymbol(POWER$1, simplificationWithoutCondense, $) <
                        countOccurrencesOfSymbol(POWER$1, simplificationWithCondense, $)
                        ? simplificationWithoutCondense
                        : simplificationWithCondense;
                // we got out result, wrap up
                return [somethingSimplified, p1];
            }
            function take_care_of_nested_radicals(p1, $) {
                if (defs.recursionLevelNestedRadicalsRemoval > 0) {
                    return [p1, TFLAG_NONE];
                }
                if (is_cons(p1)) {
                    if (is_pow_2_any_any(p1)) {
                        return _nestedPowerSymbol(p1, $);
                    }
                    else {
                        return _nestedCons(p1, $);
                    }
                }
                return [p1, TFLAG_NONE];
            }
            function _nestedPowerSymbol(p1, $) {
                // console.lg("ok it's a power ")
                const base = p1.lhs;
                const expo = p1.rhs;
                // console.lg("possible double radical base: " + base)
                // console.lg("possible double radical exponent: " + exponent)
                if ((is_num(expo) && expo.isMinusOne()) || !car(base).equals(ADD$7) || !(is_rat$1(expo) && expo.isFraction()) || (!is_num_and_equalq(expo, 1, 3) && !is_num_and_equalq(expo, 1, 2))) {
                    return [p1, TFLAG_NONE];
                }
                // console.lg("ok there is a radix with a term inside")
                const firstTerm = cadr(base);
                take_care_of_nested_radicals(firstTerm, $);
                const secondTerm = caddr(base);
                take_care_of_nested_radicals(secondTerm, $);
                let numberOfTerms = 0;
                let countingTerms = base;
                while (nil !== cdr(countingTerms)) {
                    numberOfTerms++;
                    countingTerms = cdr(countingTerms);
                }
                if (numberOfTerms > 2) {
                    return [p1, TFLAG_NONE];
                }
                // list here all the factors
                const { commonBases, termsThatAreNotPowers } = _listAll(secondTerm, $);
                if (commonBases.length === 0) {
                    return [p1, TFLAG_NONE];
                }
                const A = firstTerm;
                const C = commonBases.reduce($.multiply, one);
                const B = termsThatAreNotPowers.reduce($.multiply, one);
                let temp = nil;
                if (is_num_and_equalq(expo, 1, 3)) {
                    const checkSize1 = divide($.multiply($.negate(A), C), B, $); // 4th coeff
                    const result1 = nativeDouble(evaluate_as_float(real$2(checkSize1, $), $));
                    if (Math.abs(result1) > Math.pow(2, 32)) {
                        return [p1, TFLAG_NONE];
                    }
                    const checkSize2 = $.multiply(three, C); // 3rd coeff
                    const result2 = nativeDouble(evaluate_as_float(real$2(checkSize2, $), $));
                    if (Math.abs(result2) > Math.pow(2, 32)) {
                        return [p1, TFLAG_NONE];
                    }
                    const arg1b = $.multiply(checkSize2, SECRETX);
                    const checkSize3 = divide($.multiply(create_int(-3), A), B, $); // 2nd coeff
                    const result3 = nativeDouble(evaluate_as_float(real$2(checkSize3, $), $));
                    if (Math.abs(result3) > Math.pow(2, 32)) {
                        return [p1, TFLAG_NONE];
                    }
                    const result = add_terms$1([
                        checkSize1,
                        arg1b,
                        $.multiply(checkSize3, $.power(SECRETX, two)),
                        $.multiply(one, $.power(SECRETX, three)),
                    ], $);
                    temp = result;
                }
                else if (is_num_and_equalq(expo, 1, 2)) {
                    const result1 = nativeDouble(evaluate_as_float(real$2(C, $), $));
                    if (Math.abs(result1) > Math.pow(2, 32)) {
                        return [p1, TFLAG_NONE];
                    }
                    const checkSize = divide($.multiply(create_int(-2), A), B, $);
                    const result2 = nativeDouble(evaluate_as_float(real$2(checkSize, $), $));
                    if (Math.abs(result2) > Math.pow(2, 32)) {
                        return [p1, TFLAG_NONE];
                    }
                    temp = $.add(C, $.add($.multiply(checkSize, SECRETX), $.multiply(one, $.power(SECRETX, two))));
                }
                defs.recursionLevelNestedRadicalsRemoval++;
                const r = roots(temp, SECRETX, $);
                defs.recursionLevelNestedRadicalsRemoval--;
                if (r.ndim === 0) {
                    return [p1, TFLAG_NONE];
                }
                // exclude the solutions with radicals
                const possibleSolutions = r.filterElements((sol) => !sol.contains(POWER$1));
                if (possibleSolutions.length === 0) {
                    return [p1, TFLAG_NONE];
                }
                const possibleRationalSolutions = [];
                const realOfpossibleRationalSolutions = [];
                // console.lg("checking the one with maximum real part ")
                for (const i of Array.from(possibleSolutions)) {
                    const result = nativeDouble(evaluate_as_float(real$2(i, $), $));
                    possibleRationalSolutions.push(i);
                    realOfpossibleRationalSolutions.push(result);
                }
                const whichRationalSolution = realOfpossibleRationalSolutions.indexOf(
                // eslint-disable-next-line prefer-spread
                Math.max.apply(Math, realOfpossibleRationalSolutions));
                const SOLUTION = possibleRationalSolutions[whichRationalSolution];
                if (!is_num_and_equalq(expo, 1, 3) && !is_num_and_equalq(expo, 1, 2)) {
                    return [p1, TFLAG_NONE];
                }
                if (is_num_and_equalq(expo, 1, 3)) {
                    const lowercase_b = $.power(divide(A, $.add($.power(SOLUTION, three), $.multiply($.multiply(three, C), SOLUTION)), $), third);
                    const lowercase_a = $.multiply(lowercase_b, SOLUTION);
                    const result = simplify($.add($.multiply(lowercase_b, $.power(C, half)), lowercase_a), $);
                    return [result, TFLAG_DIFF];
                }
                if (is_num_and_equalq(expo, 1, 2)) {
                    const lowercase_b = $.power(divide(A, $.add($.power(SOLUTION, two), C), $), half);
                    const lowercase_a = $.multiply(lowercase_b, SOLUTION);
                    const possibleNewExpression = simplify($.add($.multiply(lowercase_b, $.power(C, half)), lowercase_a), $);
                    const possibleNewExpressionValue = evaluate_as_float(real$2(possibleNewExpression, $), $);
                    if (!is_negative_number(possibleNewExpressionValue)) {
                        return [possibleNewExpression, TFLAG_DIFF];
                    }
                    const result = simplify($.add($.multiply($.negate(lowercase_b), $.power(C, half)), $.negate(lowercase_a)), $);
                    return [result, TFLAG_DIFF];
                }
                return [nil, TFLAG_DIFF]; // Do we need this?
                // return [null, true];
            }
            function _listAll(secondTerm, $) {
                let commonInnerExponent = null;
                const commonBases = [];
                const termsThatAreNotPowers = [];
                if (is_multiply(secondTerm)) {
                    // product of factors
                    let secondTermFactor = cdr(secondTerm);
                    if (is_cons(secondTermFactor)) {
                        while (is_cons(secondTermFactor)) {
                            const potentialPower = car(secondTermFactor);
                            if (is_power(potentialPower)) {
                                const innerbase = cadr(potentialPower);
                                const innerexponent = caddr(potentialPower);
                                if (is_num_and_equalq(innerexponent, 1, 2)) {
                                    if (commonInnerExponent == null) {
                                        commonInnerExponent = innerexponent;
                                        commonBases.push(innerbase);
                                    }
                                    else if ($.equals(innerexponent, commonInnerExponent)) {
                                        commonBases.push(innerbase);
                                    }
                                }
                            }
                            else {
                                termsThatAreNotPowers.push(potentialPower);
                            }
                            secondTermFactor = cdr(secondTermFactor);
                        }
                    }
                }
                else if (is_power(secondTerm)) {
                    const innerbase = cadr(secondTerm);
                    const innerexponent = caddr(secondTerm);
                    if (commonInnerExponent == null && is_num_and_equalq(innerexponent, 1, 2)) {
                        commonInnerExponent = innerexponent;
                        commonBases.push(innerbase);
                    }
                }
                return { commonBases, termsThatAreNotPowers };
            }
            function _nestedCons(p1, $) {
                let anyRadicalSimplificationWorked = TFLAG_NONE;
                const arr = [];
                if (is_cons(p1)) {
                    const items = Array.from(p1).map((p) => {
                        if (!anyRadicalSimplificationWorked) {
                            let p2;
                            [p2, anyRadicalSimplificationWorked] = take_care_of_nested_radicals(p, $);
                            return p2;
                        }
                        return p;
                    });
                    arr.push(...items);
                }
                return [items_to_cons(...arr), anyRadicalSimplificationWorked];
            }

            const ABS$3 = native_sym(Native.abs);
            //(docs are generated from top-level comments, keep an eye on the formatting!)
            /* abs =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.

            */
            /*
             Absolute value of a number,or magnitude of complex z, or norm of a vector

              z    abs(z)
              -    ------

              a    a

              -a    a

              (-1)^a    1

              exp(a + i b)  exp(a)

              a b    abs(a) abs(b)

              a + i b    sqrt(a^2 + b^2)

            Notes

              1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)

              2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then

                abs(numerator(z)) / abs(denominator(z))

                 must be used to get the correct answer. Now the operation is
                 automatic.
            */
            /**
             * We take the general view that expr is a vector of an inner product space. Every inner product gives rise to a norm,
             * called the canonical or induced norm, where the norm of a vector v is defined by:
             *
             * abs(v) = sqrt(inner(v, v))
             *
             * For real numbers, the inner product of v with itself reduces to the square of v.
             * For complex numbers, the inner product requires taking the conjugate of the second.
             * For our use of tensors as a vector, we also take the conjugate of the second.
             *
             * https://en.wikipedia.org/wiki/Inner_product_space
             *
             * For real numbers,    inner(x,y) = x * y
             * For complex numbers, inner(x,y) = x * conj(y)
             *
             */
            /*
            export function abs(x: U, $: ExtensionEnv): U {
                console.lg(`abs x=${print_list(x, $)}`);
                const A = $.inner(x, x);
                console.lg(`A=${print_list(A, $)}`);
                const B = $.power(A, half);
                return B;
            }
            */
            /**
             * What should be the role of these generic functions?
             * They cannot be the entry point if the system is extensible regarding atoms.
             */
            function abs$1(x, $) {
                // console.lg("abs", $.toSExprString(x));
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`abs ${render_as_infix(x, $)} => ${render_as_infix(retval, $)} @ ${description}`);
                    return retval;
                };
                // Just to prove that the argument is not re-assigned.
                const expr = x;
                if ($.is_zero(expr)) {
                    return hook(expr);
                }
                if ($.isOne(expr)) {
                    return hook(expr);
                }
                if (is_negative_number(expr)) {
                    return hook($.negate(expr));
                }
                if (is_num_and_gt_zero(expr)) {
                    return hook(expr);
                }
                if (is_pi(expr)) {
                    return hook(expr);
                }
                // ??? should there be a shortcut case here for the imaginary unit?
                if (is_imu(expr)) {
                    return hook(one);
                }
                // now handle decomposition cases ----------------------------------------------
                // we catch the "add", "power", "multiply" cases first,
                // before falling back to the
                // negative/positive cases because there are some
                // simplification thay we might be able to do.
                // Note that for this routine to give a correct result, this
                // must be a sum where a complex number appears.
                // If we apply this to "a+b", we get an incorrect result.
                // Note that addition of multivectors is handled in a different operator.
                if (is_cons(expr) && is_add(expr)) {
                    // console.lg("abs", $.toInfixString(expr));
                    // If it looks vaguely like a complex number perhaps?
                    if (has_clock_form(expr, expr) || has_exp_form(expr) || expr.contains(imu)) {
                        // console.lg(`z? => ${$.toInfixString(expr)}`);
                        const z = expr;
                        // const z = rect(expr, $); // convert polar terms, if any
                        // console.lg(`z => ${$.toInfixString(z)}`);
                        const x = real$2(z, $);
                        // console.lg(`x => ${$.toInfixString(x)}`);
                        const y = imag$2(z);
                        const xx = $.power(x, two);
                        const yy = $.power(y, two);
                        const zz = $.add(xx, yy);
                        const abs_z = $.power(zz, half);
                        // console.lg(`x => ${$.toInfixString(x)}`)
                        // console.lg(`y => ${$.toInfixString(y)}`)
                        const retval = simplify_trig(abs_z, $);
                        return hook(retval);
                    }
                }
                if (is_cons(expr) && is_power(expr) && equaln(car(expr.cdr), -1)) {
                    // console.lg("abs of -1 to some expo", $.toInfixString(expr));
                    // console.lg("detected abs(minus one to some power) and returning 1");
                    // -1 to any power
                    // abs( (-1)^x ) = sqrt( (-1)^x * (-1)^x ) = sqrt( 1^x ) = 1
                    return hook($.getNativeDirective(Directive.evaluatingAsFloat) ? oneAsFlt : one);
                }
                // abs(base^expo) is equal to abs(base)^expo IF expo is positive.
                // TODO: This needs more flexibility because (1/a)^(1/m) = a^(-1/m)
                // console.lg("expr", render_as_sexpr(expr, $));
                if (is_cons(expr) && is_power(expr)) {
                    // console.lg("abs of an exponential", $.toInfixString(expr));
                    const base = cadr(expr);
                    const expo = caddr(expr);
                    if (is_num(expo)) {
                        if (is_num_and_gt_zero(expo)) {
                            const abs_base = abs$1(base, $);
                            return hook($.power(abs_base, expo));
                        }
                        if (is_rat$1(expo)) {
                            // const a = base;
                            // const m = expo.numer();
                            // const n = expo.denom();
                            // Let m = numer(expo), n = denom(expo), with n > 0. m is any integer.
                            // abs(a^(m/n)) = abs((a^(1/n))^m) = abs(a^(1/n))^m, for all m (positive, negative, zero)
                            // Notice that if m = +1, we get abs(a^(1/n)) = abs(a^(1/n))^1, which leads to infinite recursion.
                            // If a is a Num that is non-negative then we can take the n-th root and it will be positive.
                            // Under these conditions abs(a^(1/n)) = a^(1/n) and abs(a^(m/n)) = a^(m/n)
                            if (is_num(base) && !base.isNegative()) {
                                return hook($.power(base, expo));
                            }
                        }
                    }
                }
                // abs(e^something)
                const base = cadr(expr);
                if (is_power(expr) && is_base_of_natural_logarithm(base)) {
                    // exponential
                    return hook(exp$1(real$2(caddr(expr), $), $));
                }
                if (is_cons(expr) && is_multiply(expr)) {
                    // console.lg("abs", $.toInfixString(expr));
                    // product
                    return hook(expr.tail().map(function (x) {
                        return abs$1(x, $);
                    }).reduce($.multiply));
                }
                // abs(abs(x)) => abs(x) (abs is a projection operator).
                if (is_cons(expr) && is_abs(expr)) {
                    return hook(expr);
                }
                if (is_tensor(expr)) {
                    const retval = abs_tensor$1(expr, $);
                    return hook(retval);
                }
                if (is_negative(expr) || (is_cons(expr) && is_add(expr) && is_negative(cadr(expr)))) {
                    const neg_expr = $.negate(expr);
                    return hook(items_to_cons$1(ABS$3, neg_expr));
                }
                // But we haven't handled the sum of terms.
                if (is_cons(expr) && is_add(expr)) {
                    // TODO: This should probably be the implementation in all cases.
                    // Everything else is just an optimization.
                    // By selecting only sums of terms, we are narrowing ourselves down to
                    // trying to remove the abs function by applying the Cauchy-Schwartz equality,
                    // hoping for the case that all terms are positive.
                    // https://en.wikipedia.org/wiki/Cauchy%E2%80%93Schwarz_inequality
                    // return hook($.valueOf(simplify($.power($.inner(expr, expr), half), $)), "N");
                    return hook(items_to_cons$1(ABS$3, expr));
                }
                else {
                    // Here we have given up and simply wrap the expression.
                    // Perhaps the real question is whether expr is a vector in an inner product space.
                    return hook(items_to_cons$1(ABS$3, expr));
                }
            }
            // also called the "norm" of a vector
            function abs_tensor$1(M, $) {
                if (M.ndim !== 1) {
                    throw new Error('abs(tensor) with tensor rank > 1');
                }
                // 
                const K = simplify(M, $);
                // TODO: We need to be careful here. The conjugate operation really belongs inside the inner operation for tensors.
                return $.valueOf(simplify($.power($.inner(K, complex_conjugate(K, $)), half), $));
            }

            const MATH_DERIVATIVE = create_sym('derivative');

            /**
             * 'last'
             */
            const RESERVED_KEYWORD_LAST = create_sym('last');

            function assert_str(expr) {
                if (is_str$1(expr)) {
                    return expr;
                }
                else {
                    // Don't need anything fancy here because this is an assertion for dev eyes only.
                    throw new SystemError(`expr => ${expr}`);
                }
            }

            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function bladeEQ(lhs, rhs, field) {
                if (lhs.bitmap !== rhs.bitmap) {
                    return false;
                }
                return true;
            }

            function is_scalar$1(arg) {
                return arg.bitmap === 0;
            }

            function bladeGE(lhs, rhs, field) {
                if (is_scalar$1(lhs) && is_scalar$1(rhs)) {
                    const l = lhs.scalarCoordinate();
                    const r = rhs.scalarCoordinate();
                    return field.ge(l, r);
                }
                else {
                    throw new Error(`${lhs} >= ${rhs} is not implemented.`);
                }
            }

            function bladeGT(lhs, rhs, field) {
                if (is_scalar$1(lhs) && is_scalar$1(rhs)) {
                    const l = lhs.scalarCoordinate();
                    const r = rhs.scalarCoordinate();
                    return field.gt(l, r);
                }
                else {
                    throw new Error(`${lhs} > ${rhs} is not implemented.`);
                }
            }

            function bladeLE(lhs, rhs, field) {
                if (is_scalar$1(lhs) && is_scalar$1(rhs)) {
                    const l = lhs.scalarCoordinate();
                    const r = rhs.scalarCoordinate();
                    return field.le(l, r);
                }
                else {
                    throw new Error(`${lhs} <= ${rhs} is not implemented.`);
                }
            }

            function bladeLT(lhs, rhs, field) {
                if (is_scalar$1(lhs) && is_scalar$1(rhs)) {
                    const l = lhs.scalarCoordinate();
                    const r = rhs.scalarCoordinate();
                    return field.lt(l, r);
                }
                else {
                    throw new Error(`${lhs} < ${rhs} is not implemented.`);
                }
            }

            /**
             * name 'must' message ['in' context].
             */
            function mustSatisfy(name, condition, messageBuilder, contextBuilder) {
                if (!condition) {
                    const message = messageBuilder ? messageBuilder() : "satisfy some condition";
                    const context = contextBuilder ? " in " + contextBuilder() : "";
                    throw new Error(name + " must " + message + context + ".");
                }
            }

            function beDefined() {
                return "not be 'undefined'";
            }
            function mustBeDefined(name, value, contextBuilder) {
                mustSatisfy(name, !!value, beDefined, contextBuilder);
            }

            function isInteger(x) {
                // % coerces its operand to numbers so a typeof test is required.
                // Not ethat ECMAScript 6 provides Number.isInteger().
                return typeof x === 'number' && x % 1 === 0;
            }

            function beAnInteger() {
                return "be an integer";
            }
            function mustBeInteger(name, value, contextBuilder) {
                mustSatisfy(name, isInteger(value), beAnInteger, contextBuilder);
                return value;
            }

            /**
             * Returns sign change due to putting the blade blades represented
             * by <code>a<code> and <code>b</code> into canonical order.
             */
            function canonicalReorderingSign(a, b) {
                // Count the number of basis vector flips required to
                // get a and b into canonical order.
                a >>= 1;
                let sum = 0;
                while (a !== 0) {
                    sum += bitCount(a & b);
                    a >>= 1;
                }
                // even number of flips -> return +1
                // odd number of flips -> return -1
                // The test (sum & 1) === 0 evaluates to true for even numbers.
                return ((sum & 1) === 0) ? 1 : -1;
            }

            /**
             * pow(-1, i), i.e. (-1) raised to the i'th power.
             */
            function minusOnePow(i) {
                return ((i & 1) === 0) ? 1 : -1;
            }

            const SCALAR_BITMAP = 0;
            function create_zero_mask_and_weight(adapter) {
                return create_mask_and_weight(SCALAR_BITMAP, adapter.zero, adapter);
            }
            function create_vector_mask_and_weight(bitmap, adapter) {
                return create_mask_and_weight(bitmap, adapter.one, adapter);
            }
            function create_scalar_mask_and_weight(weight, adapter) {
                return create_mask_and_weight(SCALAR_BITMAP, weight, adapter);
            }
            /**
             *
             * @param b The bitmap representing which blade.
             * @param weight The weight associated with the blade.
             * @param adapter The adapter for the field.
             */
            function create_mask_and_weight(b, weight, adapter) {
                const that = {
                    get bitmap() {
                        return b;
                    },
                    get weight() {
                        return weight;
                    },
                    __neg__() {
                        return create_mask_and_weight(b, adapter.neg(weight), adapter);
                    },
                    __wedge__(rhs) {
                        // If there are any vectors in common then the result is zero.
                        if (b & rhs.bitmap) {
                            return create_scalar_mask_and_weight(adapter.zero, adapter);
                        }
                        else {
                            const bitmap = b ^ rhs.bitmap;
                            const sign = canonicalReorderingSign(b, rhs.bitmap);
                            const newScale = adapter.mul(weight, rhs.weight);
                            return create_mask_and_weight(bitmap, sign > 0 ? newScale : adapter.neg(newScale), adapter);
                        }
                    },
                    grade() {
                        return bitCount(b);
                    },
                    reverse() {
                        const x = that.grade();
                        const sign = minusOnePow(x * (x - 1) / 2);
                        return create_mask_and_weight(b, sign > 0 ? weight : adapter.neg(weight), adapter);
                    },
                    gradeInversion() {
                        const x = that.grade();
                        const sign = minusOnePow(x);
                        return create_mask_and_weight(b, sign > 0 ? weight : adapter.neg(weight), adapter);
                    },
                    cliffordConjugate() {
                        const x = that.grade();
                        const sign = minusOnePow(x * (x + 1) / 2);
                        return create_mask_and_weight(b, sign > 0 ? weight : adapter.neg(weight), adapter);
                    },
                    isOne() {
                        // TODO: What is the more useful semantics? (With or without the isScalar)
                        return that.isScalar() && adapter.isOne(weight);
                    },
                    isScalar() {
                        return b === SCALAR_BITMAP;
                    },
                    isZero() {
                        return adapter.isZero(weight);
                    },
                    zero() {
                        return create_scalar_mask_and_weight(adapter.zero, adapter);
                    },
                    asString(names) {
                        let bladePart = "";
                        let i = 1;
                        let x = b;
                        while (x !== 0) {
                            if ((x & 1) !== 0) {
                                if (bladePart.length > 0)
                                    bladePart += " ^ ";
                                // TODO: redundancy here with isUndefined and the explicit comparison to void 0. TypeScript prefers the latter.
                                // Can isUndefined be better typed? 
                                if (typeof names === 'undefined' || (names === null) || (names === void 0) || (i > names.length) || (names[i - 1] == null)) {
                                    bladePart = bladePart + "e" + i;
                                }
                                else {
                                    bladePart = bladePart + names[i - 1];
                                }
                            }
                            x >>= 1;
                            i++;
                        }
                        if (bladePart.length === 0) {
                            return adapter.asString(weight);
                        }
                        else {
                            if (adapter.isOne(weight)) {
                                return bladePart;
                            }
                            else {
                                return adapter.asString(weight) + " * " + bladePart;
                            }
                        }
                    },
                    toString() {
                        return that.asString(void 0);
                    }
                };
                return that;
            }

            function bladesToArray(map) {
                const bitmaps = Object.keys(map).map(function (keyAsString) {
                    return parseInt(keyAsString);
                });
                const rez = [];
                for (let i = 0; i < bitmaps.length; i++) {
                    const bitmap = bitmaps[i];
                    const blade = map[bitmap];
                    rez.push(blade);
                }
                return rez;
            }

            function combine_mask_and_weights(blades, adapter) {
                const map = {};
                for (let i = 0; i < blades.length; i++) {
                    const B = blades[i];
                    const existing = map[B.bitmap];
                    if (existing) {
                        const scale = adapter.add(existing.weight, B.weight);
                        if (adapter.isZero(scale)) {
                            delete map[B.bitmap];
                        }
                        else {
                            map[B.bitmap] = create_mask_and_weight(B.bitmap, scale, adapter);
                        }
                    }
                    else {
                        if (!adapter.isZero(B.weight)) {
                            map[B.bitmap] = B;
                        }
                    }
                }
                return bladesToArray(map);
            }

            /**
             * Computes the geometric product under a Euclidean metric.
             * @param a
             * @param b
             * @param adapter
             * @returns a * b under a Euclidean metric.
             */
            function gpE(a, b, adapter) {
                const bitmap = a.bitmap ^ b.bitmap;
                const sign = canonicalReorderingSign(a.bitmap, b.bitmap);
                const scale = adapter.mul(a.weight, b.weight);
                if (sign > 0) {
                    return create_mask_and_weight(bitmap, scale, adapter);
                }
                else {
                    return create_mask_and_weight(bitmap, adapter.neg(scale), adapter);
                }
            }

            /**
             * Computes the geometric product of blades when the metric is diagonal.
             * @param a The mask
             * @param b The mask
             * @param m
             * @param adapter
             */
            function gpL(a, b, m, adapter) {
                const temp = gpE(a, b, adapter);
                let weight = temp.weight;
                // compute the meet (bitmap of annihilated vectors):
                let bitmap = a.bitmap & b.bitmap;
                // change the scale according to the metric.
                let i = 0;
                while (bitmap !== 0) {
                    if ((bitmap & 1) !== 0) {
                        weight = adapter.mul(weight, m[i]);
                    }
                    i++;
                    bitmap = bitmap >> 1;
                }
                return create_mask_and_weight(temp.bitmap, weight, adapter);
            }

            /**
             * Computes the geometric product of blades when the metric is general.
             * @param a The mask for the blade.
             * @param b The mask for the blade.
             * @param metric
             * @param adapter
             * @returns
             */
            function gpG(a, b, metric, adapter) {
                const A = metric.toEigenBasis(a);
                const B = metric.toEigenBasis(b);
                const M = metric.getEigenMetric();
                const rez = [];
                for (let i = 0; i < A.length; i++) {
                    for (let k = 0; k < B.length; k++) {
                        A[i].bitmap;
                        A[i].weight;
                        rez.push(gpL(A[i], B[k], M, adapter));
                    }
                }
                return metric.toMetricBasis(combine_mask_and_weights(rez, adapter));
            }

            function grade(bitmap) {
                return bitCount(bitmap);
            }

            function lcoE(a, b, adapter) {
                const ga = a.grade();
                const gb = b.grade();
                if (ga > gb) {
                    return create_zero_mask_and_weight(adapter);
                }
                else {
                    const bitmap = a.bitmap ^ b.bitmap;
                    const g = grade(bitmap);
                    if (g !== (gb - ga)) {
                        return create_zero_mask_and_weight(adapter);
                    }
                    else {
                        return gpE(a, b, adapter);
                    }
                }
            }

            /**
             * Computes the left contraction when the metric is general.
             * @param a
             * @param b
             * @param m
             * @param adapter
             */
            function lcoG(a, b, m, adapter) {
                const ga = a.grade();
                const gb = b.grade();
                if (ga > gb) {
                    return [];
                }
                else {
                    const bitmap = a.bitmap ^ b.bitmap;
                    const g = grade(bitmap);
                    if (g !== (gb - ga)) {
                        return [];
                    }
                    else {
                        return gpG(a, b, m, adapter);
                    }
                }
            }

            /**
             * Computes the left contraction when the metric is diagonal.
             * @param a
             * @param b
             * @param m
             * @param adapter
             * @returns a << b under a diagonal metric.
             */
            function lcoL(a, b, m, adapter) {
                const ga = a.grade();
                const gb = b.grade();
                if (ga > gb) {
                    return create_zero_mask_and_weight(adapter);
                }
                else {
                    const bitmap = a.bitmap ^ b.bitmap;
                    const g = grade(bitmap);
                    if (g !== (gb - ga)) {
                        return create_zero_mask_and_weight(adapter);
                    }
                    else {
                        return gpL(a, b, m, adapter);
                    }
                }
            }

            function rcoE(a, b, adapter) {
                const ga = a.grade();
                const gb = b.grade();
                if (ga < gb) {
                    return create_zero_mask_and_weight(adapter);
                }
                else {
                    const bitmap = a.bitmap ^ b.bitmap;
                    const g = grade(bitmap);
                    if (g !== (ga - gb)) {
                        return create_zero_mask_and_weight(adapter);
                    }
                    else {
                        return gpE(a, b, adapter);
                    }
                }
            }

            function rcoG(a, b, m, adapter) {
                const ga = a.grade();
                const gb = b.grade();
                if (ga < gb) {
                    return [];
                }
                else {
                    const bitmap = a.bitmap ^ b.bitmap;
                    const g = grade(bitmap);
                    if (g !== (ga - gb)) {
                        return [];
                    }
                    else {
                        return gpG(a, b, m, adapter);
                    }
                }
            }

            /**
             * Computes the right contraction when the metric is diagonal.
             * @param a
             * @param b
             * @param m
             * @param adapter
             * @returns a >> b under the specified metric.
             */
            function rcoL(a, b, m, adapter) {
                const ga = a.grade();
                const gb = b.grade();
                if (ga < gb) {
                    return create_zero_mask_and_weight(adapter);
                }
                else {
                    const bitmap = a.bitmap ^ b.bitmap;
                    const g = grade(bitmap);
                    if (g !== (ga - gb)) {
                        return create_zero_mask_and_weight(adapter);
                    }
                    else {
                        return gpL(a, b, m, adapter);
                    }
                }
            }

            /**
             * The JavaScript Bitwise operators use 32-bit signed numbers.
             * &  AND
             * |  OR
             * ~  NOT
             * ^  XOR
             * << Left shift (lhs is what is shifted, rhs is number of bits)
             * >> Right shift
             */
            function is_blade(arg) {
                if (typeof arg === 'object') {
                    const duck = arg;
                    return typeof duck.scalarCoordinate === 'function';
                }
                else {
                    return false;
                }
            }
            function is_metric(arg) {
                const duck = arg;
                return typeof duck.getEigenMetric === 'function';
            }
            /**
             * Computes the dimension of the vector space from the metric.
             */
            function dim(metric, field) {
                if (Array.isArray(metric)) {
                    return metric.length;
                }
                else if (is_metric(metric)) {
                    return metric.getEigenMetric().length;
                }
                else if (field.isDimension(metric)) {
                    return field.dim(metric);
                }
                else {
                    throw new Error("metric is undefined");
                }
            }
            function promote_blades_to_tree(maws, algebra, metric, labels) {
                const field = algebra.field;
                if (maws.length > 0) {
                    const terms = maws.map(function (maw) {
                        return {
                            blade: create_blade(maw.bitmap, algebra, metric, labels), weight: maw.weight
                        };
                    });
                    return field.sum(terms);
                }
                else {
                    return field.treeZero();
                }
            }
            /**
             * The bitmap of the maw (MaskAndWeight) MUST not be zero.
             * @param maw
             * @param algebra
             * @param metric
             * @param labels
             * @returns
             */
            function mask_and_weight_to_term(maw, algebra, metric, labels) {
                const blade = create_blade(maw.bitmap, algebra, metric, labels);
                return { blade, weight: maw.weight };
            }
            function promote_term_to_tree(term, adapter) {
                return adapter.sum([term]);
            }
            function promote_mask_and_weight_to_tree(maw, algebra, metric, labels) {
                const adapter = algebra.field;
                if (maw.bitmap === 0) {
                    return adapter.weightToTree(maw.weight);
                }
                else {
                    const term = mask_and_weight_to_term(maw, algebra, metric, labels);
                    return promote_term_to_tree(term, adapter);
                }
            }
            function add$2(lhs, rhs, algebra, metric, labels) {
                const field = algebra.field;
                if (field.isField(lhs) && is_blade(rhs)) {
                    const rez = [];
                    rez.push(create_scalar_mask_and_weight(lhs, field));
                    rez.push(create_vector_mask_and_weight(rhs.bitmap, field));
                    return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                }
                else if (is_blade(lhs) && field.isField(rhs)) {
                    const rez = [];
                    rez.push(create_scalar_mask_and_weight(rhs, field));
                    rez.push(create_vector_mask_and_weight(lhs.bitmap, field));
                    return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                }
                else {
                    if (is_blade(lhs) && is_blade(rhs)) {
                        const rez = [];
                        rez.push(create_vector_mask_and_weight(lhs.bitmap, field));
                        rez.push(create_vector_mask_and_weight(rhs.bitmap, field));
                        return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                    }
                    else {
                        // We'll be using this function for operator overloading.
                        return void 0;
                    }
                }
            }
            function sub(lhs, rhs, algebra, metric, labels) {
                const field = algebra.field;
                if (field.isField(lhs) && is_blade(rhs)) {
                    const rez = [];
                    rez.push(create_scalar_mask_and_weight(lhs, field));
                    rez.push(create_vector_mask_and_weight(rhs.bitmap, field).__neg__());
                    return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                }
                else if (is_blade(lhs) && field.isField(rhs)) {
                    const rez = [];
                    rez.push(create_scalar_mask_and_weight(field.neg(rhs), field));
                    rez.push(create_vector_mask_and_weight(lhs.bitmap, field));
                    return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                }
                else {
                    if (is_blade(lhs) && is_blade(rhs)) {
                        const rez = [];
                        rez.push(create_vector_mask_and_weight(lhs.bitmap, field));
                        rez.push(create_vector_mask_and_weight(rhs.bitmap, field).__neg__());
                        return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                    }
                    else {
                        // We'll be using this function for operator overloading.
                        return void 0;
                    }
                }
            }
            function mul$1(lhs, rhs, algebra, metric, labels) {
                const field = algebra.field;
                if (field.isField(lhs) && is_blade(rhs)) {
                    const term = { blade: rhs, weight: lhs };
                    return promote_term_to_tree(term, field);
                }
                else if (is_blade(lhs) && field.isField(rhs)) {
                    const term = { blade: lhs, weight: rhs };
                    return promote_term_to_tree(term, field);
                }
                else {
                    if (is_blade(lhs) && is_blade(rhs)) {
                        const B1 = create_mask_and_weight(lhs.bitmap, field.one, field);
                        const B2 = create_mask_and_weight(rhs.bitmap, field.one, field);
                        if (Array.isArray(metric)) {
                            const B = gpL(B1, B2, metric, field);
                            return promote_mask_and_weight_to_tree(B, algebra, metric, labels);
                        }
                        else if (is_metric(metric)) {
                            const B = gpG(B1, B2, metric, field);
                            const rez = [];
                            for (let b = 0; b < B.length; b++) {
                                rez.push(B[b]);
                            }
                            return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                        }
                        else {
                            const B = gpE(B1, B2, field);
                            return promote_mask_and_weight_to_tree(B, algebra, metric, labels);
                        }
                    }
                    else {
                        // We'll be using this function for operator overloading.
                        return void 0;
                    }
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function div(lhs, rhs, algebra) {
                throw new Error(`Multivector division is not yet supported. ${lhs} / ${rhs}`);
            }
            /**
             * Returns the basis vector with index in the integer range [0 ... dim).
             * The bitmap is simply 1 shifted to the left by the index.
             */
            function getBasisVector(index, algebra, metric, labels) {
                mustBeInteger('index', index);
                mustBeDefined('algebra', algebra);
                return create_blade(1 << index, algebra, metric, labels);
            }
            /*
            function create_zero_blade<T, K>(algebra: Algebra<T, K>, metric: METRIC<T>, labels: string[]): BasisBlade<T, K> {
                mustBeDefined('algebra', algebra);
                const field = algebra.field;
                const B = create_zero_mask_and_weight(field);
                return create_blade(0, algebra, metric, labels);
            }
            */
            /*
            function create_scalar_blade<T, K>(weight: T, algebra: Algebra<T, K>, metric: METRIC<T>, labels: string[]): BasisBlade<T, K> {
                mustBeDefined('algebra', algebra);
                const field = algebra.field;
                mustSatisfy('weight', field.isField(weight), () => { return `be a field value`; });
                const B = create_scalar_mask_and_weight(weight, field);
                return create_blade(0, algebra, metric, labels);
            }
            */
            /**
             * The bitmap MUST not be zero.
             * @param bitmap
             * @param algebra
             * @param metric
             * @param labels
             * @returns
             */
            function create_blade(bitmap, algebra, metric, labels) {
                if (bitmap === 0) {
                    const e = new Error("bitmap must be non-zero (without weights a scalar blade is ambiguous)");
                    // console.lg(e.stack);
                    throw e;
                }
                const field = algebra.field;
                const extractGrade = function (grade) {
                    // const bits = bitCount(bitmap);
                    // console.lg(`bitmap=>${bitmap}, bitCount=${bits}`);
                    if (bitCount(bitmap) === grade) {
                        // console.lg(`extractGrade(${that}, grade) returning ${that}`);
                        return field.bladeToTree(theBlade);
                    }
                    else {
                        // console.lg(`extractGrade(${that}, grade) returning zero`);
                        return field.treeZero();
                    }
                };
                let $meta = 0;
                const theBlade = {
                    get bitmap() {
                        return bitmap;
                    },
                    get meta() {
                        return $meta;
                    },
                    set meta(meta) {
                        $meta = meta;
                    },
                    get name() {
                        return 'Blade';
                    },
                    reset(meta) {
                        $meta = reset_meta_flag($meta, meta);
                    },
                    __abs__() {
                        const lhs = field.bladeToTree(theBlade);
                        const rhs = theBlade.rev();
                        const scp = field.treeScp(lhs, rhs);
                        return field.treeSqrt(scp);
                    },
                    add(rhs) {
                        return add$2(theBlade, rhs, algebra, metric, labels);
                    },
                    __add__(rhs) {
                        return add$2(theBlade, rhs, algebra, metric, labels);
                    },
                    __radd__(lhs) {
                        return add$2(lhs, theBlade, algebra, metric, labels);
                    },
                    sub(rhs) {
                        return sub(theBlade, rhs, algebra, metric, labels);
                    },
                    __sub__(rhs) {
                        return sub(theBlade, rhs, algebra, metric, labels);
                    },
                    __rsub__(lhs) {
                        return sub(lhs, theBlade, algebra, metric, labels);
                    },
                    __eq__(rhs) {
                        return bladeEQ(theBlade, rhs);
                    },
                    __ge__(rhs) {
                        return bladeGE(theBlade, rhs, field);
                    },
                    __gt__(rhs) {
                        return bladeGT(theBlade, rhs, field);
                    },
                    __le__(rhs) {
                        return bladeLE(theBlade, rhs, field);
                    },
                    __lt__(rhs) {
                        return bladeLT(theBlade, rhs, field);
                    },
                    __ne__(rhs) {
                        return !bladeEQ(theBlade, rhs);
                    },
                    inv() {
                        throw new Error("Multivector.inv method not implemented.");
                        /*
                        // We'll start by trying the versor inverse before doing the general inverse.
                        const reversed = that.rev();
                        const denom = that.mul(reversed);
                        // If we have a scalar, then we can compute the versor inverse
                        if (denom.blades.length === 1 && denom.blades[0].bitmap === 0) {
                            return reversed.divByScalar(denom.scalarCoordinate());
                        }
                        else {
                            throw new Error(`non-invertible multivector (versor inverse) ${that}`);
                        }
                        */
                    },
                    isCons() {
                        return false;
                    },
                    isNil() {
                        return false;
                    },
                    map(f) {
                        const weight = f(field.one);
                        if (!field.isZero(weight)) {
                            return promote_mask_and_weight_to_tree(create_mask_and_weight(bitmap, weight, field), algebra, metric, labels);
                        }
                        else {
                            return field.treeZero();
                        }
                    },
                    mul(rhs) {
                        return mul$1(theBlade, rhs, algebra, metric, labels);
                    },
                    __mul__(rhs) {
                        return mul$1(theBlade, rhs, algebra, metric, labels);
                    },
                    __rmul__(lhs) {
                        return mul$1(lhs, theBlade, algebra, metric, labels);
                    },
                    __div__(rhs) {
                        return div(theBlade, rhs);
                    },
                    __lshift__(rhs) {
                        const B1 = create_mask_and_weight(bitmap, field.one, field);
                        const B2 = create_mask_and_weight(rhs.bitmap, field.one, field);
                        if (Array.isArray(metric)) {
                            const B = lcoL(B1, B2, metric, field);
                            return promote_mask_and_weight_to_tree(B, algebra, metric, labels);
                        }
                        else if (is_metric(metric)) {
                            const B = lcoG(B1, B2, metric, field);
                            const rez = [];
                            for (let b = 0; b < B.length; b++) {
                                rez.push(B[b]);
                            }
                            return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                        }
                        else {
                            const B = lcoE(B1, B2, field);
                            return promote_mask_and_weight_to_tree(B, algebra, metric, labels);
                        }
                    },
                    __rshift__(rhs) {
                        const B1 = create_mask_and_weight(bitmap, field.one, field);
                        const B2 = create_mask_and_weight(rhs.bitmap, field.one, field);
                        if (Array.isArray(metric)) {
                            const B = rcoL(B1, B2, metric, field);
                            return promote_mask_and_weight_to_tree(B, algebra, metric, labels);
                        }
                        else if (is_metric(metric)) {
                            const rez = [];
                            const B = rcoG(B1, B2, metric, field);
                            for (let b = 0; b < B.length; b++) {
                                rez.push(B[b]);
                            }
                            return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                        }
                        else {
                            const B = rcoE(B1, B2, field);
                            return promote_mask_and_weight_to_tree(B, algebra, metric, labels);
                        }
                    },
                    __vbar__(rhs) {
                        // console.lg(`BasisBlade.__vbar__(lhs=>${theBlade}, rhs=>${rhs})`);
                        // Use the definition of the scalar product in terms of the geometric product.
                        const adapter = algebra.field;
                        const gp = theBlade.__mul__(rhs);
                        // console.lg(`BasisBlade.__vbar__(lhs=>${that}, rhs=>${rhs}) => ${gp}`);
                        // TODO: Why do we need the adapter? We know that we have a BasisBlade.
                        // This changed because we don't have weights.
                        return adapter.extractGrade(gp, 0);
                    },
                    __wedge__(rhs) {
                        const rez = [];
                        const B1 = create_vector_mask_and_weight(bitmap, field);
                        const B2 = create_vector_mask_and_weight(rhs.bitmap, field);
                        const B = B1.__wedge__(B2);
                        rez.push(B);
                        // It seems that promotion is not required in this case.
                        return promote_blades_to_tree(combine_mask_and_weights(rez, field), algebra, metric, labels);
                    },
                    __bang__() {
                        return theBlade.inv();
                    },
                    __pos__() {
                        return field.bladeToTree(theBlade);
                    },
                    neg() {
                        return promote_mask_and_weight_to_tree(create_vector_mask_and_weight(bitmap, field).__neg__(), algebra, metric, labels);
                    },
                    __neg__() {
                        return promote_mask_and_weight_to_tree(create_vector_mask_and_weight(bitmap, field).__neg__(), algebra, metric, labels);
                    },
                    __tilde__() {
                        return theBlade.rev();
                    },
                    cliffordConjugate() {
                        return promote_mask_and_weight_to_tree(create_vector_mask_and_weight(bitmap, field).cliffordConjugate(), algebra, metric, labels);
                    },
                    contains(needle) {
                        return theBlade.equals(needle);
                    },
                    direction() {
                        const me = field.bladeToTree(theBlade);
                        const rev = theBlade.rev();
                        const scp = field.treeScp(me, rev);
                        const squaredNorm = field.scalarCoordinate(scp);
                        const norm = field.sqrt(squaredNorm);
                        if (!field.isZero(norm)) {
                            return theBlade.divByScalar(norm);
                        }
                        else {
                            return me;
                        }
                    },
                    equals(other) {
                        if (theBlade === other) {
                            return true;
                        }
                        else {
                            if (is_blade(other)) {
                                return this.bitmap === other.bitmap;
                            }
                            else {
                                return false;
                            }
                        }
                    },
                    exp() {
                        // TODO: Optimize and Generalize.
                        throw new Error(`BasisBlade.exp`);
                        /*
                        const B = extractGrade(2);
                        const Brev = B.rev();
                        const θ = field.scalarCoordinate(field.treeSqrt(B.__vbar__(Brev)));
                        const i = B.divByScalar(θ);
                        const cosθ = promote_mask_and_weight_to_tree(create_scalar_repr(field.cos(θ), field), algebra, metric, labels);
                        const sinθ = promote_mask_and_weight_to_tree(create_scalar_repr(field.sin(θ), field), algebra, metric, labels);
                        return field.treeAdd(cosθ, field.treeMul(i, sinθ));
                        */
                    },
                    extractGrade,
                    div(rhs) {
                        return field.treeMul(field.bladeToTree(theBlade), rhs.inv());
                    },
                    divByScalar(alpha) {
                        const scale = field.div(field.one, alpha);
                        if (!field.isZero(scale)) {
                            return promote_mask_and_weight_to_tree(create_mask_and_weight(bitmap, scale, field), algebra, metric, labels);
                        }
                        else {
                            return field.treeZero();
                        }
                    },
                    dual() {
                        const n = dim(metric, algebra.field);
                        const I = promote_mask_and_weight_to_tree(create_mask_and_weight((1 << n) - 1, field.one, field), algebra, metric, labels);
                        return field.treeLco(field.bladeToTree(theBlade), I);
                    },
                    gradeInversion() {
                        return promote_mask_and_weight_to_tree(create_vector_mask_and_weight(bitmap, field).gradeInversion(), algebra, metric, labels);
                    },
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    isCompatible(rhs) {
                        // TODO: If we had a leaky abstraction we might check the algebra for equality!
                        // Maybe we can compare the metric?
                        return true;
                    },
                    rev() {
                        return promote_mask_and_weight_to_tree(create_vector_mask_and_weight(bitmap, field).reverse(), algebra, metric, labels);
                    },
                    scalarCoordinate() {
                        if (bitmap === 0) {
                            return field.one;
                        }
                        return field.zero;
                    },
                    scp(rhs) {
                        // console.lg(`BasisBlade.scp(lhs=>${that}, rhs=>${rhs})`);
                        return theBlade.__vbar__(rhs);
                    },
                    sqrt() {
                        if (bitmap === 0) {
                            return promote_mask_and_weight_to_tree(create_mask_and_weight(bitmap, field.one, field).reverse(), algebra, metric, labels);
                        }
                        else {
                            throw new Error(`sqrt on arbitrary multivectors is not yet supported.`);
                        }
                    },
                    asString(names, wedge) {
                        let bladePart = "";
                        let i = 1;
                        let x = bitmap;
                        while (x !== 0) {
                            if ((x & 1) !== 0) {
                                if (bladePart.length > 0)
                                    bladePart += wedge;
                                // TODO: redundancy here with isUndefined and the explicit comparison to void 0. TypeScript prefers the latter.
                                // Can isUndefined be better typed? 
                                if (typeof names === 'undefined' || (names === null) || (names === void 0) || (i > names.length) || (names[i - 1] == null)) {
                                    bladePart = bladePart + "e" + i;
                                }
                                else {
                                    bladePart = bladePart + names[i - 1];
                                }
                            }
                            x >>= 1;
                            i++;
                        }
                        if (bladePart.length > 0) {
                            return bladePart;
                        }
                        else {
                            throw new Error(`Expecting something for bitmap ${bitmap}`);
                        }
                    },
                    toInfixString() {
                        return theBlade.asString(labels, '^');
                    },
                    toListString() {
                        return theBlade.asString(labels, '^');
                    },
                    toLatexString() {
                        return theBlade.asString(labels, ' \\wedge ');
                    },
                    toString() {
                        return theBlade.asString(labels, '^');
                    }
                };
                return theBlade;
            }
            /**
             * Verify that the basis vector labels are strings and that there are the correct number.
             */
            function checkBasisLabels(name, labels, n) {
                if (labels) {
                    if (Array.isArray(labels)) {
                        if (labels.length !== n) {
                            throw new Error(`${name}.length must match the dimensionality of the vector space.`);
                        }
                        for (let i = 0; i < labels.length; i++) {
                            const label = labels[i];
                            if (typeof label !== 'string') {
                                throw new Error(`${name}[${i}] must be a string.`);
                            }
                        }
                    }
                    else {
                        throw new Error(`${name} must be a string[]`);
                    }
                }
            }
            function algebra(metric, field, labels) {
                mustBeDefined('metric', metric);
                const n = dim(metric, field);
                mustBeDefined('field', field);
                checkBasisLabels('labels', labels, n);
                /**
                 * A cache of the basis vectors.
                 */
                const basisVectors = [];
                const that = {
                    get field() {
                        return field;
                    },
                    unit(index) {
                        mustBeInteger('index', index);
                        if (index >= 0 && index < n) {
                            return basisVectors[index];
                        }
                        else {
                            throw new Error(`index must be in range [0 ... ${n - 1})`);
                        }
                    },
                    get units() {
                        // For safety, return a copy of the cached array of basis vectors.
                        return basisVectors.map(x => x);
                    }
                };
                for (let i = 0; i < n; i++) {
                    basisVectors[i] = getBasisVector(i, that, metric, labels);
                }
                return that;
            }

            // gives the capability of printing the unsigned
            // exponent.
            function print_number(p, signed, $) {
                if (is_rat$1(p)) {
                    let str = '';
                    let numerStr = p.a.toString();
                    if (!signed) {
                        if (numerStr[0] === '-') {
                            numerStr = numerStr.substring(1);
                        }
                    }
                    if (defs.printMode === PRINTMODE_LATEX && p.isFraction()) {
                        numerStr = '\\frac{' + numerStr + '}{';
                    }
                    str += numerStr;
                    if (p.isFraction()) {
                        if (defs.printMode !== PRINTMODE_LATEX) {
                            str += '/';
                        }
                        let denomStr = p.b.toString();
                        if (defs.printMode === PRINTMODE_LATEX) {
                            denomStr += '}';
                        }
                        str += denomStr;
                    }
                    return str;
                }
                else if (is_flt$1(p)) {
                    let str = '';
                    let aAsString = number_to_floating_point_string(p.d, $);
                    if (!signed) {
                        if (aAsString[0] === '-') {
                            aAsString = aAsString.substring(1);
                        }
                    }
                    str += aAsString;
                    return str;
                }
                throw new Error(`print_number(p = ${p})`);
            }

            /*

            Prints in "2d", e.g. instead of 1/(x+1)^2 :

                  1
             ----------
                     2
              (1 + x)

             Note that although this looks more natural, a) it's not parsable and
             b) it can be occasionally be ambiguous, such as:

               1
             ----
               2
             x

            is 1/x^2 but it also looks a little like x^(1/2)

            */
            //-----------------------------------------------------------------------------
            //
            //  Examples:
            //
            //     012345678
            //  -2 .........
            //  -1 .........
            //   0 ..hello..  x=2, y=0, h=1, w=5
            //   1 .........
            //   2 .........
            //
            //     012345678
            //  -2 .........
            //  -1 ..355....
            //   0 ..---....  x=2, y=-1, h=3, w=3
            //   1 ..113....
            //   2 .........
            //
            //-----------------------------------------------------------------------------
            const YMAX = 10000;
            class glyph {
                constructor() {
                    this.c = 0;
                    this.x = 0;
                    this.y = 0;
                }
            }
            // will contain glyphs
            let chartab = [];
            for (let charTabIndex = 0; charTabIndex < YMAX; charTabIndex++) {
                chartab[charTabIndex] = new glyph();
            }
            let yindex = 0;
            let level = 0;
            let emit_x = 0;
            // this is not really the translated version,
            // the original is in window.cpp and is
            // rather more complex
            function printchar_nowrap(character) {
                let accumulator = '';
                accumulator += character;
                return accumulator;
            }
            function printchar(character) {
                return printchar_nowrap(character);
            }
            function render_as_ascii(p, $) {
                // console.lg("render_as_ascii", $.toInfixString(p));
                yindex = 0;
                level = 0;
                emit_x = 0;
                emit_top_expr(p, $);
                // if too wide then print flat
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const [h, w, y] = Array.from(get_size(0, yindex));
                if (w > 100) {
                    render_using_non_sexpr_print_mode(p, $);
                    return '';
                }
                const beenPrinted = print_glyphs();
                return beenPrinted;
            }
            function emit_top_expr(p, $) {
                // console.lg("emi_top_expr", $.toInfixString(p));
                if (car(p).equals(ASSIGN)) {
                    emit_expr(cadr(p), $);
                    __emit_str(' = ');
                    emit_expr(caddr(p), $);
                    return;
                }
                if (is_tensor(p)) {
                    emit_tensor(p, $);
                }
                else {
                    emit_expr(p, $);
                }
            }
            function will_be_displayed_as_fraction(p, $) {
                if (level > 0) {
                    return false;
                }
                if (isfraction(p)) {
                    return true;
                }
                if (!is_multiply(p)) {
                    return false;
                }
                if (isfraction(cadr(p))) {
                    return true;
                }
                while (is_cons(p)) {
                    if (isdenominator(car(p))) {
                        return true;
                    }
                    p = cdr(p);
                }
                return false;
            }
            function emit_expr(p, $) {
                // console.lg("emit_expr", $.toInfixString(p));
                //  if (level > 0) {
                //    printexpr(p)
                //    return
                //  }
                if (is_add(p)) {
                    p = cdr(p);
                    if (__is_negative(car(p))) {
                        __emit_char('-');
                        if (will_be_displayed_as_fraction(car(p))) {
                            __emit_char(' ');
                        }
                    }
                    emit_term(car(p), $);
                    p = cdr(p);
                    while (is_cons(p)) {
                        if (__is_negative(car(p))) {
                            __emit_char(' ');
                            __emit_char('-');
                            __emit_char(' ');
                        }
                        else {
                            __emit_char(' ');
                            __emit_char('+');
                            __emit_char(' ');
                        }
                        emit_term(car(p), $);
                        p = cdr(p);
                    }
                }
                else {
                    if (__is_negative(p)) {
                        __emit_char('-');
                        if (will_be_displayed_as_fraction(p)) {
                            __emit_char(' ');
                        }
                    }
                    emit_term(p, $);
                }
            }
            function emit_unsigned_expr(p, $) {
                if (is_add(p)) {
                    p = cdr(p);
                    //    if (__is_negative(car(p)))
                    //      __emit_char('-')
                    emit_term(car(p), $);
                    p = cdr(p);
                    while (is_cons(p)) {
                        if (__is_negative(car(p))) {
                            __emit_char(' ');
                            __emit_char('-');
                            __emit_char(' ');
                        }
                        else {
                            __emit_char(' ');
                            __emit_char('+');
                            __emit_char(' ');
                        }
                        emit_term(car(p), $);
                        p = cdr(p);
                    }
                }
                else {
                    //    if (__is_negative(p))
                    //      __emit_char('-')
                    emit_term(p, $);
                }
            }
            function __is_negative(p) {
                if (is_negative_number(p)) {
                    return true;
                }
                if (is_multiply(p) && is_negative_number(cadr(p))) {
                    return true;
                }
                return false;
            }
            function emit_term(p, $) {
                // console.lg("emit_term", $.toInfixString(p));
                if (is_multiply(p)) {
                    const n = count_denominators(p);
                    if (n && level === 0) {
                        emit_fraction(p, n, $);
                    }
                    else {
                        emit_multiply(p, n, $);
                    }
                }
                else {
                    emit_factor(p, $);
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function isdenominator(p, $) {
                const base = cadr(p);
                return is_power(p) && is_base_of_natural_logarithm(base) && __is_negative(caddr(p));
            }
            function count_denominators(p, $) {
                let count = 0;
                p = cdr(p);
                //  if (isfraction(car(p))) {
                //    count++
                //    p = cdr(p)
                //  }
                while (is_cons(p)) {
                    const q = car(p);
                    if (isdenominator(q)) {
                        count++;
                    }
                    p = cdr(p);
                }
                return count;
            }
            // n is the number of denominators, not counting a fraction like 1/2
            function emit_multiply(p, n, $) {
                if (n === 0) {
                    p = cdr(p);
                    if ($.isOne(car(p)) || is_num_and_eq_minus_one(car(p))) {
                        p = cdr(p);
                    }
                    emit_factor(car(p), $);
                    p = cdr(p);
                    while (is_cons(p)) {
                        __emit_char(' ');
                        emit_factor(car(p), $);
                        p = cdr(p);
                    }
                }
                else {
                    emit_numerators(p, $);
                    __emit_char('/');
                    // need grouping if more than one denominator
                    if (n > 1 || isfraction(cadr(p))) {
                        __emit_char('(');
                        emit_denominators(p, $);
                        __emit_char(')');
                    }
                    else {
                        emit_denominators(p, $);
                    }
                }
            }
            // sign of term has already been emitted
            function emit_fraction(p, d, $) {
                let p1, p2;
                let count = 0;
                let k1 = 0;
                let k2 = 0;
                let n = 0;
                let x = 0;
                let A = one;
                let B = one;
                // handle numerical coefficient
                if (is_rat$1(cadr(p))) {
                    A = abs$1(mp_numerator(cadr(p)), $);
                    B = mp_denominator(cadr(p));
                }
                if (is_flt$1(cadr(p))) {
                    A = abs$1(cadr(p), $);
                }
                // count numerators
                n = $.isOne(A) ? 0 : 1;
                p1 = cdr(p);
                if (is_num(car(p1))) {
                    p1 = cdr(p1);
                }
                while (is_cons(p1)) {
                    p2 = car(p1);
                    if (!isdenominator(p2)) {
                        n++;
                    }
                    p1 = cdr(p1);
                }
                // emit numerators
                x = emit_x;
                k1 = yindex;
                count = 0;
                // emit numerical coefficient
                if (!$.isOne(A)) {
                    // p3 is A
                    emit_number(A, 0, $); // p3 is A
                    count++;
                }
                // skip over "multiply"
                p1 = cdr(p);
                // skip over numerical coefficient, already handled
                if (is_num(car(p1))) {
                    p1 = cdr(p1);
                }
                while (is_cons(p1)) {
                    p2 = car(p1);
                    if (!isdenominator(p2)) {
                        if (count > 0) {
                            __emit_char(' ');
                        }
                        if (n === 1) {
                            emit_expr(p2, $);
                        }
                        else {
                            emit_factor(p2, $);
                        }
                        count++;
                    }
                    p1 = cdr(p1);
                }
                if (count === 0) {
                    __emit_char('1');
                }
                // emit denominators
                k2 = yindex;
                count = 0;
                if (!$.isOne(B)) {
                    emit_number(B, 0, $);
                    count++;
                    d++;
                }
                p1 = cdr(p);
                if (is_rat$1(car(p1))) {
                    p1 = cdr(p1);
                }
                while (is_cons(p1)) {
                    p2 = car(p1);
                    if (isdenominator(p2)) {
                        if (count > 0) {
                            __emit_char(' ');
                        }
                        emit_denominator(p2, d, $);
                        count++;
                    }
                    p1 = cdr(p1);
                }
                fixup_fraction(x, k1, k2);
            }
            // p points to a multiply
            function emit_numerators(p, $) {
                let p1 = one;
                p = cdr(p);
                if (is_rat$1(car(p))) {
                    p1 = abs$1(mp_numerator(car(p)), $);
                    p = cdr(p);
                }
                else if (is_flt$1(car(p))) {
                    p1 = abs$1(car(p), $);
                    p = cdr(p);
                }
                let n = 0;
                if (!$.isOne(p1)) {
                    emit_number(p1, 0, $);
                    n++;
                }
                while (is_cons(p)) {
                    if (!isdenominator(car(p))) {
                        if (n > 0) {
                            __emit_char(' ');
                        }
                        emit_factor(car(p), $);
                        n++;
                    }
                    p = cdr(p);
                }
                if (n === 0) {
                    __emit_char('1');
                }
            }
            // p points to a multiply
            function emit_denominators(p, $) {
                let n = 0;
                p = cdr(p);
                if (isfraction(car(p))) {
                    const p1 = mp_denominator(car(p));
                    emit_number(p1, 0, $);
                    n++;
                    p = cdr(p);
                }
                while (is_cons(p)) {
                    if (isdenominator(car(p))) {
                        if (n > 0) {
                            __emit_char(' ');
                        }
                        emit_denominator(car(p), 0, $);
                        n++;
                    }
                    p = cdr(p);
                }
            }
            function emit_factor(p, $) {
                // console.lg("emit_factor", $.toInfixString(p));
                if (is_tensor(p)) {
                    if (level === 0) {
                        //emit_tensor(p)
                        emit_flat_tensor(p, $);
                    }
                    else {
                        emit_flat_tensor(p, $);
                    }
                    return;
                }
                if (is_flt$1(p)) {
                    emit_number(p, 0, $);
                    return;
                }
                if (is_add(p) || is_multiply(p)) {
                    emit_grouped_expr(p, $);
                    return;
                }
                if (is_power(p)) {
                    emit_power(p, $);
                    return;
                }
                if (is_cons(p)) {
                    //if (car(p) == symbol(FORMAL) && cadr(p).k == SYM)
                    //  emit_symbol(cadr(p))
                    //else
                    emit_function(p, $);
                    return;
                }
                if (is_num(p)) {
                    if (level === 0) {
                        emit_numerical_fraction(p, $);
                    }
                    else {
                        emit_number(p, 0, $);
                    }
                    return;
                }
                if (is_sym(p)) {
                    emit_symbol(p, $);
                    return;
                }
                if (is_str$1(p)) {
                    emit_string(p);
                }
            }
            function emit_numerical_fraction(num, $) {
                if (is_rat$1(num)) {
                    emit_numerical_fraction_rat(num, $);
                }
                if (is_flt$1(num)) {
                    emit_numerical_fraction_flt(num, $);
                }
            }
            function emit_numerical_fraction_rat(num, $) {
                const A = num.numer().abs();
                const B = num.denom();
                if (B.isOne()) {
                    emit_number(A, 0, $);
                    return;
                }
                const x = emit_x;
                const k1 = yindex;
                emit_number(A, 0, $);
                const k2 = yindex;
                emit_number(B, 0, $);
                fixup_fraction(x, k1, k2);
            }
            function emit_numerical_fraction_flt(num, $) {
                const A = num.abs();
                emit_number(A, 0, $);
            }
            // if it's a factor then it doesn't need parens around it, i.e. 1/sin(theta)^2
            function isfactor(p) {
                if (is_cons(p) && !is_add(p) && !is_multiply(p) && !is_power(p)) {
                    return true;
                }
                if (is_sym(p)) {
                    return true;
                }
                if (isfraction(p)) {
                    return false;
                }
                if (is_negative_number(p)) {
                    return false;
                }
                if (is_num(p)) {
                    return true;
                }
                return false;
            }
            function emit_power(p, $) {
                let k1 = 0;
                let k2 = 0;
                let x = 0;
                const base = cadr(p);
                if (is_base_of_natural_logarithm(base)) {
                    __emit_str('exp(');
                    emit_expr(caddr(p), $);
                    __emit_char(')');
                    return;
                }
                if (level > 0) {
                    if (is_num_and_eq_minus_one(caddr(p))) {
                        __emit_char('1');
                        __emit_char('/');
                        if (isfactor(cadr(p))) {
                            emit_factor(cadr(p), $);
                        }
                        else {
                            emit_grouped_expr(cadr(p), $);
                        }
                    }
                    else {
                        if (isfactor(cadr(p))) {
                            emit_factor(cadr(p), $);
                        }
                        else {
                            emit_grouped_expr(cadr(p), $);
                        }
                        if ($.getNativeDirective(Directive.useCaretForExponentiation)) {
                            __emit_char('^');
                        }
                        else {
                            // This comment of '**' or "**" will help you find me.
                            __emit_char('*');
                            __emit_char('*');
                        }
                        if (isfactor(caddr(p))) {
                            emit_factor(caddr(p), $);
                        }
                        else {
                            emit_grouped_expr(caddr(p), $);
                        }
                    }
                    return;
                }
                // special case: 1 over something
                if (__is_negative(caddr(p))) {
                    x = emit_x;
                    k1 = yindex;
                    __emit_char('1');
                    k2 = yindex;
                    //level++
                    emit_denominator(p, 1, $);
                    //level--
                    fixup_fraction(x, k1, k2);
                    return;
                }
                k1 = yindex;
                if (isfactor(cadr(p))) {
                    emit_factor(cadr(p), $);
                }
                else {
                    emit_grouped_expr(cadr(p), $);
                }
                k2 = yindex;
                level++;
                emit_expr(caddr(p), $);
                level--;
                fixup_power(k1, k2);
            }
            // if n == 1 then emit as expr (no parens)
            // p is a power
            function emit_denominator(p, n, $) {
                let k1 = 0;
                let k2 = 0;
                // special case: 1 over something
                if (is_num_and_eq_minus_one(caddr(p))) {
                    if (n === 1) {
                        emit_expr(cadr(p), $);
                    }
                    else {
                        emit_factor(cadr(p), $);
                    }
                    return;
                }
                k1 = yindex;
                // emit base
                if (isfactor(cadr(p))) {
                    emit_factor(cadr(p), $);
                }
                else {
                    emit_grouped_expr(cadr(p), $);
                }
                k2 = yindex;
                // emit exponent, don't emit minus sign
                level++;
                emit_unsigned_expr(caddr(p), $);
                level--;
                fixup_power(k1, k2);
            }
            function emit_function(expr, $) {
                // console.lg("emit_function", $.toInfixString(expr));
                if (expr.opr.equals(SYM_MATH_COMPONENT) && is_sym(cadr(expr))) {
                    emit_index_function(expr, $);
                    return;
                }
                if (is_factorial(expr)) {
                    emit_factorial_function(expr, $);
                    return;
                }
                if (car(expr).equals(MATH_DERIVATIVE)) {
                    __emit_char('d');
                }
                else {
                    emit_symbol(car(expr), $);
                }
                __emit_char('(');
                let argList = expr.cdr;
                if (is_cons(argList)) {
                    emit_expr(argList.head, $);
                    argList = argList.cdr;
                    while (is_cons(argList)) {
                        __emit_char(',');
                        //__emit_char(' ')
                        emit_expr(argList.head, $);
                        argList = argList.cdr;
                    }
                }
                __emit_char(')');
            }
            function emit_index_function(p, $) {
                p = cdr(p);
                // TODO: Probably need INNER, OUTER, LCO, RCO
                if (caar(p).equals(ADD$7) || caar(p).equals(MULTIPLY$1) || caar(p).equals(POWER$1) || caar(p).equals(FACTORIAL)) {
                    emit_grouped_expr(car(p), $);
                }
                else {
                    emit_expr(car(p), $);
                }
                __emit_char('[');
                p = cdr(p);
                if (is_cons(p)) {
                    emit_expr(car(p), $);
                    p = cdr(p);
                    while (is_cons(p)) {
                        __emit_char(',');
                        emit_expr(car(p), $);
                        p = cdr(p);
                    }
                }
                __emit_char(']');
            }
            function emit_factorial_function(p, $) {
                p = cadr(p);
                if (isfraction(p) ||
                    is_add(p) ||
                    is_multiply(p) ||
                    is_power(p) ||
                    is_factorial(p)) {
                    emit_grouped_expr(p, $);
                }
                else {
                    emit_expr(p, $);
                }
                __emit_char('!');
            }
            function emit_grouped_expr(p, $) {
                __emit_char('(');
                emit_expr(p, $);
                __emit_char(')');
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function emit_symbol(sym, $) {
                // console.lg("emit_symbol", $.toInfixString(sym), $.getSymbolPrintName(sym));
                if (is_base_of_natural_logarithm(sym)) {
                    __emit_str('exp(1)');
                    return;
                }
                const printName = $.getSymbolPrintName(sym);
                for (let i = 0; i < printName.length; i++) {
                    __emit_char(printName[i]);
                }
            }
            function emit_string(p) {
                const pString = p.str;
                __emit_char('"');
                for (let i = 0; i < pString.length; i++) {
                    __emit_char(pString[i]);
                }
                __emit_char('"');
            }
            function fixup_fraction(x, k1, k2) {
                let dx = 0;
                let dy = 0;
                const [h1, w1, y1] = Array.from(get_size(k1, k2));
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const [h2, w2, y2] = Array.from(get_size(k2, yindex));
                if (w2 > w1) {
                    dx = (w2 - w1) / 2; // shift numerator right
                }
                else {
                    dx = 0;
                }
                dx++;
                // this is how much is below the baseline
                const y = y1 + h1 - 1;
                dy = -y - 1;
                move(k1, k2, dx, dy);
                if (w2 > w1) {
                    dx = -w1;
                }
                else {
                    dx = -w1 + (w1 - w2) / 2;
                }
                dx++;
                dy = -y2 + 1;
                move(k2, yindex, dx, dy);
                let w = 0;
                if (w2 > w1) {
                    w = w2;
                }
                else {
                    w = w1;
                }
                w += 2;
                emit_x = x;
                for (let i = 0; i < w; i++) {
                    __emit_char('-');
                }
            }
            function fixup_power(k1, k2) {
                let dy = 0;
                let h1 = 0;
                let w1 = 0;
                let y1 = 0;
                let h2 = 0;
                let w2 = 0;
                let y2 = 0;
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                [h1, w1, y1] = Array.from(get_size(k1, k2));
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                [h2, w2, y2] = Array.from(get_size(k2, yindex));
                // move superscript to baseline
                dy = -y2 - h2 + 1;
                // now move above base
                dy += y1 - 1;
                move(k2, yindex, 0, dy);
            }
            function move(j, k, dx, dy) {
                for (let i = j; i < k; i++) {
                    chartab[i].x += dx;
                    chartab[i].y += dy;
                }
            }
            // finds the bounding rectangle and vertical position
            function get_size(j, k) {
                let min_x = chartab[j].x;
                let max_x = chartab[j].x;
                let min_y = chartab[j].y;
                let max_y = chartab[j].y;
                for (let i = j + 1; i < k; i++) {
                    if (chartab[i].x < min_x) {
                        min_x = chartab[i].x;
                    }
                    if (chartab[i].x > max_x) {
                        max_x = chartab[i].x;
                    }
                    if (chartab[i].y < min_y) {
                        min_y = chartab[i].y;
                    }
                    if (chartab[i].y > max_y) {
                        max_y = chartab[i].y;
                    }
                }
                const h = max_y - min_y + 1;
                const w = max_x - min_x + 1;
                const y = min_y;
                return [h, w, y];
            }
            function __emit_char(c) {
                if (yindex === YMAX) {
                    return;
                }
                chartab[yindex].c = c;
                chartab[yindex].x = emit_x;
                chartab[yindex].y = 0;
                yindex++;
                return emit_x++;
            }
            function __emit_str(s) {
                for (let i = 0; i < s.length; i++) {
                    __emit_char(s[i]);
                }
            }
            /**
             * TODO: Refactoring
             * 1. Argument should only accept Num
             * 2. Encapsulate Rat so that a,b are not visible.
             * 3. Avoid re-assignable variables.
             * 4. Assert that the argument is indeed a Num.
             */
            function emit_number(p, emit_sign, $) {
                if (is_rat$1(p)) {
                    let tmpString = p.a.toString();
                    if (tmpString[0] === '-' && emit_sign === 0) {
                        tmpString = tmpString.substring(1);
                    }
                    for (let i = 0; i < tmpString.length; i++) {
                        __emit_char(tmpString[i]);
                    }
                    tmpString = p.b.toString();
                    if (tmpString === '1') {
                        return;
                    }
                    __emit_char('/');
                    for (let i = 0; i < tmpString.length; i++) {
                        __emit_char(tmpString[i]);
                    }
                }
                else if (is_flt$1(p)) {
                    let tmpString = number_to_floating_point_string(p.d, $);
                    if (tmpString[0] === '-' && emit_sign === 0) {
                        tmpString = tmpString.substring(1);
                    }
                    for (let i = 0; i < tmpString.length; i++) {
                        __emit_char(tmpString[i]);
                    }
                }
            }
            // a and b are glyphs
            function cmpGlyphs(a, b) {
                if (a.y < b.y) {
                    return -1;
                }
                if (a.y > b.y) {
                    return 1;
                }
                if (a.x < b.x) {
                    return -1;
                }
                if (a.x > b.x) {
                    return 1;
                }
                return 0;
            }
            function print_glyphs() {
                let accumulator = '';
                // now sort the glyphs by their vertical positions,
                // since we are going to build a string where obviously the
                // "upper" line has to printed out first, followed by
                // a new line, followed by the other lines.
                //qsort(chartab, yindex, sizeof (struct glyph), __cmp)
                const subsetOfStack = chartab.slice(0, yindex);
                subsetOfStack.sort(cmpGlyphs);
                const slices = chartab.slice(yindex);
                chartab.length = 0;
                chartab = chartab.concat(subsetOfStack).concat(slices);
                let x = 0;
                let { y } = chartab[0];
                for (let i = 0; i < yindex; i++) {
                    while (chartab[i].y > y) {
                        accumulator += printchar('\n');
                        x = 0;
                        y++;
                    }
                    while (chartab[i].x > x) {
                        accumulator += printchar_nowrap(' ');
                        x++;
                    }
                    accumulator += printchar_nowrap(chartab[i].c);
                    x++;
                }
                return accumulator;
            }
            const N = 100;
            class oneElement {
                constructor() {
                    this.x = 0;
                    this.y = 0;
                    this.h = 0;
                    this.w = 0;
                    this.index = 0;
                    this.count = 0;
                }
            }
            const elem = [];
            for (let elelmIndex = 0; elelmIndex < 10000; elelmIndex++) {
                elem[elelmIndex] = new oneElement();
            }
            const SPACE_BETWEEN_COLUMNS = 3;
            const SPACE_BETWEEN_ROWS = 1;
            function emit_tensor(p, $) {
                let ncol = 0;
                let dx = 0;
                let dy = 0;
                if (p.ndim > 2) {
                    emit_flat_tensor(p, $);
                    return;
                }
                const nrow = p.dim(0);
                if (p.ndim === 2) {
                    ncol = p.dim(1);
                }
                else {
                    ncol = 1;
                }
                const n = nrow * ncol;
                if (n > N) {
                    emit_flat_tensor(p, $);
                    return;
                }
                // horizontal coordinate of the matrix
                //if 0
                //emit_x += 2; # make space for left paren
                //endif
                const x = emit_x;
                // emit each element
                for (let i = 0; i < n; i++) {
                    elem[i].index = yindex;
                    elem[i].x = emit_x;
                    emit_expr(p.elem(i), $);
                    elem[i].count = yindex - elem[i].index;
                    [elem[i].h, elem[i].w, elem[i].y] = Array.from(get_size(elem[i].index, yindex));
                }
                // find element height and width
                let eh = 0;
                let ew = 0;
                for (let i = 0; i < n; i++) {
                    if (elem[i].h > eh) {
                        eh = elem[i].h;
                    }
                    if (elem[i].w > ew) {
                        ew = elem[i].w;
                    }
                }
                // this is the overall height of the matrix
                const h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;
                // this is the overall width of the matrix
                const w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;
                // this is the vertical coordinate of the matrix
                const y = -(h / 2);
                // move elements around
                for (let row = 0; row < nrow; row++) {
                    for (let col = 0; col < ncol; col++) {
                        const i = row * ncol + col;
                        // first move to upper left corner of matrix
                        dx = x - elem[i].x;
                        dy = y - elem[i].y;
                        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
                        // now move to official position
                        dx = 0;
                        if (col > 0) {
                            dx = col * (ew + SPACE_BETWEEN_COLUMNS);
                        }
                        dy = 0;
                        if (row > 0) {
                            dy = row * (eh + SPACE_BETWEEN_ROWS);
                        }
                        // small correction for horizontal centering
                        dx += (ew - elem[i].w) / 2;
                        // small correction for vertical centering
                        dy += (eh - elem[i].h) / 2;
                        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
                    }
                }
                emit_x = x + w;
                /*
                if 0
              
                  * left brace
              
                  for (i = 0; i < h; i++) {
                    if (yindex == YMAX)
                      break
                    chartab[yindex].c = '|'
                    chartab[yindex].x = x - 2
                    chartab[yindex].y = y + i
                    yindex++
                  }
              
                  * right brace
              
                  emit_x++
              
                  for (i = 0; i < h; i++) {
                    if (yindex == YMAX)
                      break
                    chartab[yindex].c = '|'
                    chartab[yindex].x = emit_x
                    chartab[yindex].y = y + i
                    yindex++
                  }
              
                  emit_x++
              
                endif
                */
            }
            function emit_flat_tensor(p, $) {
                emit_tensor_inner(p, 0, 0, $);
            }
            function emit_tensor_inner(p, j, k, $) {
                __emit_char('(');
                for (let i = 0; i < p.dim(j); i++) {
                    if (j + 1 === p.ndim) {
                        emit_expr(p.elem(k), $);
                        k = k + 1;
                    }
                    else {
                        k = emit_tensor_inner(p, j + 1, k, $);
                    }
                    if (i + 1 < p.dim(j)) {
                        __emit_char(',');
                    }
                }
                __emit_char(')');
                return k;
            }

            /**
             * The standard way of serializing to s-expr format.
             * @param expr The expression to be rendered.
             * @param $ The extension environment.
             */
            function render_as_sexpr(expr, $) {
                if (is_cons(expr)) {
                    let str = '';
                    str += '(';
                    str += render_as_sexpr(car(expr), $);
                    expr = cdr(expr);
                    while (is_cons(expr)) {
                        str += ' ';
                        str += render_as_sexpr(car(expr), $);
                        expr = cdr(expr);
                    }
                    if (expr !== nil) {
                        str += ' . ';
                        str += render_as_sexpr(expr, $);
                    }
                    str += ')';
                    return str;
                }
                return $.toSExprString(expr);
            }

            const ENGLISH_UNDEFINED$1 = 'undefined';
            const MATH_E$1 = native_sym(Native.E);
            const MATH_IMU = native_sym(Native.IMU);
            const MATH_PI$1 = native_sym(Native.PI);
            const testeq$2 = native_sym(Native.test_eq);
            function get_last_print_mode_symbol(printMode) {
                switch (printMode) {
                    case PRINTMODE_ASCII: return LAST_ASCII_PRINT;
                    case PRINTMODE_HUMAN: return LAST_HUMAN_PRINT;
                    case PRINTMODE_LATEX: return LAST_LATEX_PRINT;
                    case PRINTMODE_INFIX: return LAST_INFIX_PRINT;
                    case PRINTMODE_SEXPR: return LAST_SEXPR_PRINT;
                    default: throw new Error(printMode);
                }
            }
            /**
             *
             * @param argList
             * @param printMode
             */
            function print_in_mode(argList, printMode, $) {
                const texts = [];
                let subList = argList;
                while (is_cons(subList)) {
                    const value = $.valueOf(subList.car);
                    const origPrintMode = printMode;
                    defs.setPrintMode(printMode);
                    try {
                        if (printMode === PRINTMODE_INFIX) {
                            const str = render_using_non_sexpr_print_mode(value, $);
                            texts.push(str);
                            store_text_in_binding(str, get_last_print_mode_symbol(printMode), $);
                        }
                        else if (printMode === PRINTMODE_HUMAN) {
                            const str = render_using_non_sexpr_print_mode(value, $);
                            texts.push(str);
                            store_text_in_binding(str, get_last_print_mode_symbol(printMode), $);
                        }
                        else if (printMode === PRINTMODE_ASCII) {
                            const str = render_as_ascii(value, $);
                            texts.push(str);
                            store_text_in_binding(str, get_last_print_mode_symbol(printMode), $);
                        }
                        else if (printMode === PRINTMODE_LATEX) {
                            const str = render_using_non_sexpr_print_mode(value, $);
                            texts.push(str);
                            store_text_in_binding(str, get_last_print_mode_symbol(printMode), $);
                        }
                        else if (printMode === PRINTMODE_SEXPR) {
                            const str = render_as_sexpr(value, $);
                            texts.push(str);
                            store_text_in_binding(str, get_last_print_mode_symbol(printMode), $);
                        }
                    }
                    finally {
                        defs.setPrintMode(origPrintMode);
                    }
                    subList = subList.argList;
                }
                return texts;
            }
            /**
             *
             * @param text The text that will be the binding value.
             * @param sym The symbol that will be used as a key to store the text.
             */
            function store_text_in_binding(text, sym, $) {
                // TODO: Not clear why we go to the trouble to scan the string when we'll just get a string.
                // It does not seem that reliable anyway given the simplistic escaping of the text.
                // Fails when the text is aleady contains double quotes.
                const sourceText = '"' + text + '"';
                // TOOD: Need a better routing to initialize the ScanOptions.
                const [scanned, tree] = scan(sourceText, {
                    useCaretForExponentiation: $.getNativeDirective(Directive.useCaretForExponentiation),
                    explicitAssocAdd: false,
                    explicitAssocMul: false
                });
                if (scanned === sourceText.length) {
                    const str = assert_str(tree);
                    $.setSymbolValue(sym, str);
                }
            }
            function print_str(s) {
                return s;
            }
            function print_char(c) {
                return c;
            }
            function print_base_of_denom(base, $) {
                if (should_group_base_of_denom(base)) {
                    return `(${render_using_non_sexpr_print_mode(base, $)})`;
                }
                else {
                    return render_using_non_sexpr_print_mode(base, $);
                }
            }
            function should_group_base_of_denom(expr) {
                if (is_rat$1(expr) && (expr.isNegative() || expr.isFraction())) {
                    return true;
                }
                if (is_flt$1(expr) && expr.isNegative()) {
                    return true;
                }
                if (is_add(expr)) {
                    return true;
                }
                if (is_multiply(expr)) {
                    return true;
                }
                if (is_power(expr)) {
                    return true;
                }
                return false;
            }
            function print_expo_of_denom(expo, $) {
                if (is_rat$1(expo) && expo.isFraction()) {
                    return `(${render_using_non_sexpr_print_mode(expo, $)})`;
                }
                if (is_add(expo) || is_multiply(expo) || is_power(expo)) {
                    return `(${render_using_non_sexpr_print_mode(expo, $)})`;
                }
                else {
                    return render_using_non_sexpr_print_mode(expo, $);
                }
            }
            // prints stuff after the divide symbol "/"
            // d is the number of denominators
            function print_denom(p, d, $) {
                let str = '';
                const BASE = cadr(p);
                let EXPO = caddr(p);
                // i.e. 1 / (2^(1/3))
                // get the cases like BASE^(-1) out of
                // the way, they just become 1/BASE
                if (is_num_and_eq_minus_one(EXPO)) {
                    str += print_base_of_denom(BASE, $);
                    return str;
                }
                if (d === 1) {
                    str += print_char('(');
                }
                // prepare the exponent
                // (needs to be negated)
                // before printing it out
                EXPO = $.negate(EXPO);
                str += print_power(BASE, EXPO, $);
                if (d === 1) {
                    str += print_char(')');
                }
                return str;
            }
            function print_a_over_b(p, $) {
                // console.lg(`print_a_over_b p => ${$.toListString(p)}`);
                let A, B;
                let str = '';
                let flag = 0;
                // count numerators and denominators
                let n = 0;
                let d = 0;
                let p1 = p.cdr;
                let p2 = car(p1);
                if (is_rat$1(p2)) {
                    A = abs$1(mp_numerator(p2), $);
                    B = mp_denominator(p2);
                    if (!$.isOne(A)) {
                        n++;
                    }
                    if (!$.isOne(B)) {
                        d++;
                    }
                    p1 = cdr(p1);
                }
                else {
                    A = one;
                    B = one;
                }
                while (is_cons(p1)) {
                    p2 = car(p1);
                    if (is_denominator(p2)) {
                        d++;
                    }
                    else {
                        n++;
                    }
                    p1 = cdr(p1);
                }
                //breakpoint
                if (defs.printMode === PRINTMODE_LATEX) {
                    str += print_str('\\frac{');
                }
                if (n === 0) {
                    str += print_char('1');
                }
                else {
                    flag = 0;
                    p1 = cdr(p);
                    if (is_rat$1(car(p1))) {
                        p1 = cdr(p1);
                    }
                    if (!$.isOne(A)) {
                        str += print_factor(A, false, false, $);
                        flag = 1;
                    }
                    while (is_cons(p1)) {
                        p2 = car(p1);
                        if (!is_denominator(p2)) {
                            if (flag) {
                                str += print_multiply_sign();
                            }
                            str += print_factor(p2, false, false, $);
                            flag = 1;
                        }
                        p1 = cdr(p1);
                    }
                }
                if (defs.printMode === PRINTMODE_LATEX) {
                    str += print_str('}{');
                }
                else if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                    str += print_str(' / ');
                }
                else {
                    str += print_str('/');
                }
                if (d > 1 && defs.printMode !== PRINTMODE_LATEX) {
                    str += print_char('(');
                }
                flag = 0;
                p1 = cdr(p);
                if (is_rat$1(car(p1))) {
                    p1 = cdr(p1);
                }
                if (!$.isOne(B)) {
                    str += print_factor(B, false, false, $);
                    flag = 1;
                }
                while (is_cons(p1)) {
                    p2 = car(p1);
                    if (is_denominator(p2)) {
                        if (flag) {
                            str += print_multiply_sign();
                        }
                        str += print_denom(p2, d, $);
                        flag = 1;
                    }
                    p1 = cdr(p1);
                }
                if (d > 1 && defs.printMode !== PRINTMODE_LATEX) {
                    str += print_char(')');
                }
                if (defs.printMode === PRINTMODE_LATEX) {
                    str += print_str('}');
                }
                return str;
            }
            /**
             * This is used for almost everything except printing in s-expr format.
             * TODO: Issue over naming with to_infix_string.
             * @param expr
             * @param $
             * @returns
             */
            function render_using_non_sexpr_print_mode(expr, $) {
                return print_additive_expr(expr, $);
            }
            function print_additive_expr(p, $) {
                // console.lg(`print_additive_expr ${p}`);
                let str = '';
                if (is_add(p)) {
                    p = cdr(p);
                    if (sign_of_term(car(p)) === '-') {
                        str += print_str('-');
                    }
                    str += print_multiplicative_expr(car(p), $);
                    p = cdr(p);
                    while (is_cons(p)) {
                        if (sign_of_term(car(p)) === '+') {
                            if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                                str += print_str(' + ');
                            }
                            else {
                                str += print_str('+');
                            }
                        }
                        else {
                            if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                                str += print_str(' - ');
                            }
                            else {
                                str += print_str('-');
                            }
                        }
                        str += print_multiplicative_expr(car(p), $);
                        p = cdr(p);
                    }
                }
                else {
                    if (sign_of_term(p) === '-') {
                        str += print_str('-');
                    }
                    str += print_multiplicative_expr(p, $);
                }
                return str;
            }
            /**
             * Returns '-' if term is a number less that zero, or if term has the form (* num ...) and num is less than zero.
             * For this to work correctly, it assumes that the term is in canonical form (with numbers move to the left).
             */
            function sign_of_term(term) {
                // (* num ...) and num is less than zero.
                if (is_cons(term)) {
                    if (is_multiply(term)) {
                        const cadr_p = car(term.cdr);
                        if (is_num(cadr_p)) {
                            if (lt_num_num(cadr_p, zero)) {
                                return '-';
                            }
                        }
                    }
                }
                //  term itslef is a number less tahn zero.
                if (is_num(term) && lt_num_num(term, zero)) {
                    return '-';
                }
                else {
                    return '+';
                }
            }
            function print_multiply_when_no_denominators(expr, $) {
                let denom = '';
                let origAccumulator = '';
                let p = cdr(expr);
                // coeff -1?
                if (is_num_and_eq_minus_one(car(p))) {
                    //      print_char('-')
                    p = cdr(p);
                }
                let previousFactorWasANumber = false;
                // print the first factor ------------
                if (is_num(car(p))) {
                    previousFactorWasANumber = true;
                }
                // this numberOneOverSomething thing is so that
                // we show things of the form
                //   numericFractionOfForm1/something * somethingElse
                // as
                //   somethingElse / something
                // so for example 1/2 * sqrt(2) is rendered as
                //   sqrt(2)/2
                // rather than the first form, which looks confusing.
                // NOTE that you might want to avoid this
                // when printing polynomials, as it could be nicer
                // to show the numeric coefficients well separated from
                // the variable, but we'll see when we'll
                // come to it if it's an issue.
                let numberOneOverSomething = false;
                if (defs.printMode === PRINTMODE_LATEX &&
                    is_cons(cdr(p)) &&
                    isNumberOneOverSomething(car(p))) {
                    numberOneOverSomething = true;
                    denom = car(p).b.toString();
                }
                let str = '';
                if (numberOneOverSomething) {
                    origAccumulator = str;
                    str = '';
                }
                else {
                    str += print_outer_expr(car(p), false, false, $);
                }
                p = cdr(p);
                // print all the other factors -------
                while (is_cons(p)) {
                    // check if we end up having a case where two numbers
                    // are next to each other. In those cases, latex needs
                    // to insert a \cdot otherwise they end up
                    // right next to each other and read like one big number
                    if (defs.printMode === PRINTMODE_LATEX) {
                        if (previousFactorWasANumber) {
                            // if what comes next is a power and the base
                            // is a number, then we are in the case
                            // of consecutive numbers.
                            // Note that sqrt() i.e when exponent is 1/2
                            // doesn't count because the radical gives
                            // a nice graphical separation already.
                            if (caar(p).equals(POWER$1)) {
                                if (is_num(car(cdr(car(p))))) {
                                    // rule out square root
                                    if (!isfraction(car(cdr(cdr(car(p)))))) {
                                        str += ' \\cdot ';
                                    }
                                }
                            }
                        }
                    }
                    str += print_multiply_sign();
                    str += print_outer_expr(car(p), false, true, $);
                    previousFactorWasANumber = false;
                    if (is_num(car(p))) {
                        previousFactorWasANumber = true;
                    }
                    p = cdr(p);
                }
                if (numberOneOverSomething) {
                    str = origAccumulator + '\\frac{' + str + '}{' + denom + '}';
                }
                return str;
            }
            function print_multiplicative_expr(expr, $) {
                // console.lg(`print_multiplicative_expr ${expr}`);
                if (is_cons(expr) && is_multiply(expr)) {
                    if (any_denominators(expr)) {
                        return print_a_over_b(expr, $);
                    }
                    return print_multiply_when_no_denominators(expr, $);
                }
                else {
                    return print_outer_expr(expr, false, false, $);
                }
            }
            function print_outer_expr(expr, omitParens, pastFirstFactor, $) {
                // console.lg(`print_outer_expr ${expr}`);
                if (is_cons(expr) && is_outer$1(expr)) {
                    let argList = expr.argList;
                    if (is_cons(argList)) {
                        let str = print_inner_expr(argList.car, false, false, $);
                        argList = argList.cdr;
                        while (is_cons(argList)) {
                            str += print_outer_operator();
                            str += print_inner_expr(car(argList), false, true, $);
                            argList = argList.cdr;
                        }
                        return str;
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    return print_inner_expr(expr, omitParens, pastFirstFactor, $);
                }
            }
            function print_outer_operator() {
                if (defs.printMode === PRINTMODE_LATEX) {
                    return ' \\wedge ';
                }
                if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag && !defs.codeGen) {
                    return print_str(' ^ ');
                }
                else {
                    return print_str('^');
                }
            }
            function print_inner_expr(expr, omitParens, pastFirstFactor, $) {
                // console.lg(`print_inner_expr ${expr}`);
                if (is_cons(expr) && is_inner_or_dot(expr)) {
                    let argList = expr.argList;
                    if (is_cons(argList)) {
                        let str = print_factor(argList.car, false, false, $);
                        argList = argList.cdr;
                        while (is_cons(argList)) {
                            str += print_inner_operator();
                            str += print_factor(car(argList), false, true, $);
                            argList = argList.cdr;
                        }
                        return str;
                    }
                    else {
                        throw new Error();
                    }
                }
                else if (is_cons(expr) && is_lco(expr)) {
                    let argList = expr.argList;
                    if (is_cons(argList)) {
                        let str = print_factor(argList.car, false, false, $);
                        argList = argList.cdr;
                        while (is_cons(argList)) {
                            str += print_lco_operator();
                            str += print_factor(car(argList), false, true, $);
                            argList = argList.cdr;
                        }
                        return str;
                    }
                    else {
                        throw new Error();
                    }
                }
                else if (is_cons(expr) && is_rco(expr)) {
                    let argList = expr.argList;
                    if (is_cons(argList)) {
                        let str = print_factor(argList.car, false, false, $);
                        argList = argList.cdr;
                        while (is_cons(argList)) {
                            str += print_rco_operator();
                            str += print_factor(car(argList), false, true, $);
                            argList = argList.cdr;
                        }
                        return str;
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    return print_factor(expr, omitParens, pastFirstFactor, $);
                }
            }
            function print_inner_operator() {
                if (defs.printMode === PRINTMODE_LATEX) {
                    return ' \\mid ';
                }
                if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag && !defs.codeGen) {
                    return print_str(' | ');
                }
                else {
                    return print_str('|');
                }
            }
            function print_lco_operator() {
                if (defs.printMode === PRINTMODE_LATEX) {
                    return ' \\ll ';
                }
                if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag && !defs.codeGen) {
                    return print_str(' << ');
                }
                else {
                    return print_str('<<');
                }
            }
            function print_rco_operator() {
                if (defs.printMode === PRINTMODE_LATEX) {
                    return ' \\gg ';
                }
                if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag && !defs.codeGen) {
                    return print_str(' >> ');
                }
                else {
                    return print_str('>>');
                }
            }
            function print_grouping_expr(expr, $) {
                // console.lg(`print_grouping_expr ${expr}`);
                let str = '';
                str += print_char('(');
                str += render_using_non_sexpr_print_mode(expr, $);
                str += print_char(')');
                return str;
            }
            function print_factorial_function(p, $) {
                let accumulator = '';
                p = cadr(p);
                if (isfraction(p) ||
                    is_add(p) ||
                    is_multiply(p) ||
                    is_power(p) ||
                    is_factorial(p)) {
                    accumulator += print_grouping_expr(p, $);
                }
                else {
                    accumulator += render_using_non_sexpr_print_mode(p, $);
                }
                accumulator += print_char('!');
                return accumulator;
            }
            function print_abs_latex(expr, $) {
                const arg = expr.argList.head;
                let s = '';
                s += print_str('\\left |');
                s += render_using_non_sexpr_print_mode(arg, $);
                s += print_str(' \\right |');
                return s;
            }
            function print_abs_infix(expr, $) {
                const arg = expr.argList.head;
                let s = '';
                s += print_str('abs(');
                s += render_using_non_sexpr_print_mode(arg, $);
                s += print_str(')');
                return s;
            }
            function print_BINOMIAL_latex(p, $) {
                let accumulator = '';
                accumulator += print_str('\\binom{');
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += print_str('}{');
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                accumulator += print_str('} ');
                return accumulator;
            }
            function print_DOT_latex(p, $) {
                let accumulator = '';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += print_str(' \\cdot ');
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                return accumulator;
            }
            function print_DOT_codegen(p, $) {
                let accumulator = 'dot(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ', ';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_SIN_codegen(p, $) {
                let accumulator = 'Math.sin(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_COS_codegen(p, $) {
                let accumulator = 'Math.cos(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_TAN_codegen(p, $) {
                let accumulator = 'Math.tan(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_ARCSIN_codegen(p, $) {
                let accumulator = 'Math.asin(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_ARCCOS_codegen(p, $) {
                let accumulator = 'Math.acos(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_ARCTAN_codegen(p, $) {
                let accumulator = 'Math.atan(';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ')';
                return accumulator;
            }
            function print_SQRT_latex(p, $) {
                let accumulator = '';
                accumulator += print_str('\\sqrt{');
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += print_str('} ');
                return accumulator;
            }
            function print_TRANSPOSE_latex(p, $) {
                let accumulator = '';
                accumulator += print_str('{');
                if (is_cons(cadr(p))) {
                    accumulator += print_str('(');
                }
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                if (is_cons(cadr(p))) {
                    accumulator += print_str(')');
                }
                accumulator += print_str('}');
                accumulator += print_str('^T');
                return accumulator;
            }
            function print_TRANSPOSE_codegen(p, $) {
                let accumulator = '';
                accumulator += print_str('transpose(');
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += print_str(')');
                return accumulator;
            }
            function print_UNIT_codegen(p, $) {
                let accumulator = '';
                accumulator += print_str('identity(');
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += print_str(')');
                return accumulator;
            }
            function print_INV_latex(p, $) {
                let str = '';
                str += print_str('{');
                if (is_cons(cadr(p))) {
                    str += print_str('(');
                }
                str += render_using_non_sexpr_print_mode(cadr(p), $);
                if (is_cons(cadr(p))) {
                    str += print_str(')');
                }
                str += print_str('}');
                str += print_str('^{-1}');
                return str;
            }
            function print_INV_codegen(p, $) {
                let accumulator = '';
                accumulator += print_str('inv(');
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += print_str(')');
                return accumulator;
            }
            function print_DEFINT_latex(p, $) {
                let accumulator = '';
                const functionBody = car(cdr(p));
                p = cdr(p);
                const originalIntegral = p;
                let numberOfIntegrals = 0;
                while (is_cons(cdr(cdr(p)))) {
                    numberOfIntegrals++;
                    const theIntegral = cdr(cdr(p));
                    accumulator += print_str('\\int^{');
                    accumulator += render_using_non_sexpr_print_mode(car(cdr(theIntegral)), $);
                    accumulator += print_str('}_{');
                    accumulator += render_using_non_sexpr_print_mode(car(theIntegral), $);
                    accumulator += print_str('} \\! ');
                    p = cdr(theIntegral);
                }
                accumulator += render_using_non_sexpr_print_mode(functionBody, $);
                accumulator += print_str(' \\,');
                p = originalIntegral;
                for (let i = 1; i <= numberOfIntegrals; i++) {
                    const theVariable = cdr(p);
                    accumulator += print_str(' \\mathrm{d} ');
                    accumulator += render_using_non_sexpr_print_mode(car(theVariable), $);
                    if (i < numberOfIntegrals) {
                        accumulator += print_str(' \\, ');
                    }
                    p = cdr(cdr(theVariable));
                }
                return accumulator;
            }
            function print_tensor(p, $) {
                let accumulator = '';
                accumulator += print_tensor_inner(p, 0, 0, $)[1];
                return accumulator;
            }
            // j scans the dimensions
            // k is an increment for all the printed elements
            //   since they are all together in sequence in one array
            function print_tensor_inner(p, j, k, $) {
                let accumulator = '';
                accumulator += print_str('[');
                // only the last dimension prints the actual elements
                // e.g. in a matrix, the first dimension contains
                // vectors, not elements, and the second dimension
                // actually contains the elements
                // if not the last dimension, we are just printing wrappers
                // and recursing down i.e. we print the next dimension
                if (j < p.ndim - 1) {
                    for (let i = 0; i < p.dim(j); i++) {
                        let retString;
                        [k, retString] = Array.from(print_tensor_inner(p, j + 1, k, $));
                        accumulator += retString;
                        // add separator between elements dimensions
                        // "above" the inner-most dimension
                        if (i !== p.dim(j) - 1) {
                            accumulator += print_str(',');
                        }
                    }
                    // if we reached the last dimension, we print the actual
                    // elements
                }
                else {
                    for (let i = 0; i < p.dim(j); i++) {
                        accumulator += render_using_non_sexpr_print_mode(p.elem(k), $);
                        // add separator between elements in the
                        // inner-most dimension
                        if (i !== p.dim(j) - 1) {
                            accumulator += print_str(',');
                        }
                        k++;
                    }
                }
                accumulator += print_str(']');
                return [k, accumulator];
            }
            function print_tensor_latex(p, $) {
                let accumulator = '';
                if (p.ndim <= 2) {
                    accumulator += print_tensor_inner_latex(true, p, 0, 0, $)[1];
                }
                return accumulator;
            }
            // firstLevel is needed because printing a matrix
            // is not exactly an elegant recursive procedure:
            // the vector on the first level prints the latex
            // "wrap", while the vectors that make up the
            // rows don't. so it's a bit asymmetric and this
            // flag helps.
            // j scans the dimensions
            // k is an increment for all the printed elements
            //   since they are all together in sequence in one array
            function print_tensor_inner_latex(firstLevel, p, j, k, $) {
                let accumulator = '';
                // open the outer latex wrap
                if (firstLevel) {
                    accumulator += '\\begin{bmatrix} ';
                }
                // only the last dimension prints the actual elements
                // e.g. in a matrix, the first dimension contains
                // vectors, not elements, and the second dimension
                // actually contains the elements
                // if not the last dimension, we are just printing wrappers
                // and recursing down i.e. we print the next dimension
                if (j < p.ndim - 1) {
                    for (let i = 0; i < p.dim(j); i++) {
                        let retString;
                        [k, retString] = Array.from(print_tensor_inner_latex(false, p, j + 1, k, $));
                        accumulator += retString;
                        if (i !== p.dim(j) - 1) {
                            // add separator between rows
                            accumulator += print_str(' \\\\ ');
                        }
                    }
                    // if we reached the last dimension, we print the actual
                    // elements
                }
                else {
                    for (let i = 0; i < p.dim(j); i++) {
                        accumulator += render_using_non_sexpr_print_mode(p.elem(k), $);
                        // separator between elements in each row
                        if (i !== p.dim(j) - 1) {
                            accumulator += print_str(' & ');
                        }
                        k++;
                    }
                }
                // close the outer latex wrap
                if (firstLevel) {
                    accumulator += ' \\end{bmatrix}';
                }
                return [k, accumulator];
            }
            function print_SUM_latex(p, $) {
                let accumulator = '\\sum_{';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                accumulator += '=';
                accumulator += render_using_non_sexpr_print_mode(cadddr(p), $);
                accumulator += '}^{';
                accumulator += render_using_non_sexpr_print_mode(caddddr(p), $);
                accumulator += '}{';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += '}';
                return accumulator;
            }
            function print_SUM_codegen(p, $) {
                const body = cadr(p);
                const variable = caddr(p);
                const lowerlimit = cadddr(p);
                const upperlimit = caddddr(p);
                const accumulator = '(function(){' +
                    ' var ' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    '; ' +
                    ' var holderSum = 0; ' +
                    ' var lowerlimit = ' +
                    render_using_non_sexpr_print_mode(lowerlimit, $) +
                    '; ' +
                    ' var upperlimit = ' +
                    render_using_non_sexpr_print_mode(upperlimit, $) +
                    '; ' +
                    ' for (' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    ' = lowerlimit; ' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    ' < upperlimit; ' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    '++) { ' +
                    '   holderSum += ' +
                    render_using_non_sexpr_print_mode(body, $) +
                    ';' +
                    ' } ' +
                    ' return holderSum;' +
                    '})()';
                return accumulator;
            }
            function print_TEST_latex(p, $) {
                let accumulator = '\\left\\{ \\begin{array}{ll}';
                p = cdr(p);
                while (is_cons(p)) {
                    // odd number of parameters means that the
                    // last argument becomes the default case
                    // i.e. the one without a test.
                    if (nil === cdr(p)) {
                        accumulator += '{';
                        accumulator += render_using_non_sexpr_print_mode(car(p), $);
                        accumulator += '} & otherwise ';
                        accumulator += ' \\\\\\\\';
                        break;
                    }
                    accumulator += '{';
                    accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                    accumulator += '} & if & ';
                    accumulator += render_using_non_sexpr_print_mode(car(p), $);
                    accumulator += ' \\\\\\\\';
                    // test unsuccessful, continue to the
                    // next pair of test,value
                    p = cddr(p);
                }
                accumulator = accumulator.substring(0, accumulator.length - 4);
                return (accumulator += '\\end{array} \\right.');
            }
            function print_TEST_codegen(p, $) {
                let accumulator = '(function(){';
                p = cdr(p);
                let howManyIfs = 0;
                while (is_cons(p)) {
                    // odd number of parameters means that the
                    // last argument becomes the default case
                    // i.e. the one without a test.
                    if (nil === cdr(p)) {
                        accumulator += 'else {';
                        accumulator += 'return (' + render_using_non_sexpr_print_mode(car(p), $) + ');,$';
                        accumulator += '}';
                        break;
                    }
                    if (howManyIfs) {
                        accumulator += ' else ';
                    }
                    accumulator += 'if (' + render_using_non_sexpr_print_mode(car(p), $) + '){,$';
                    accumulator += 'return (' + render_using_non_sexpr_print_mode(cadr(p), $) + ');,$';
                    accumulator += '}';
                    // test unsuccessful, continue to the
                    // next pair of test,value
                    howManyIfs++;
                    p = cddr(p);
                }
                accumulator += '})()';
                return accumulator;
            }
            function print_TESTLT_latex(p, $) {
                let accumulator = '{';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += '}';
                accumulator += ' < ';
                accumulator += '{';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                return (accumulator += '}');
            }
            function print_TESTLE_latex(p, $) {
                let accumulator = '{';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += '}';
                accumulator += ' \\leq ';
                accumulator += '{';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                return (accumulator += '}');
            }
            function print_TESTGT_latex(p, $) {
                let accumulator = '{';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += '}';
                accumulator += ' > ';
                accumulator += '{';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                return (accumulator += '}');
            }
            function print_TESTGE_latex(p, $) {
                let accumulator = '{';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += '}';
                accumulator += ' \\geq ';
                accumulator += '{';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                return (accumulator += '}');
            }
            function print_testeq_latex(expr, $) {
                let s = '{';
                s += render_using_non_sexpr_print_mode(expr.lhs, $);
                s += '}';
                s += ' = ';
                s += '{';
                s += render_using_non_sexpr_print_mode(expr.rhs, $);
                return (s += '}');
            }
            function print_FOR_codegen(p, $) {
                const body = cadr(p);
                const variable = caddr(p);
                const lowerlimit = cadddr(p);
                const upperlimit = caddddr(p);
                const accumulator = '(function(){' +
                    ' var ' +
                    variable +
                    '; ' +
                    ' var lowerlimit = ' +
                    render_using_non_sexpr_print_mode(lowerlimit, $) +
                    '; ' +
                    ' var upperlimit = ' +
                    render_using_non_sexpr_print_mode(upperlimit, $) +
                    '; ' +
                    ' for (' +
                    variable +
                    ' = lowerlimit; ' +
                    variable +
                    ' < upperlimit; ' +
                    variable +
                    '++) { ' +
                    '   ' +
                    render_using_non_sexpr_print_mode(body, $) +
                    ' } ' +
                    '})()';
                return accumulator;
            }
            function print_DO_codegen(p, $) {
                let accumulator = '';
                p = cdr(p);
                while (is_cons(p)) {
                    accumulator += render_using_non_sexpr_print_mode(car(p), $);
                    p = cdr(p);
                }
                return accumulator;
            }
            function print_SETQ_codegen(p, $) {
                let accumulator = '';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += ' = ';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                accumulator += '; ';
                return accumulator;
            }
            function print_PRODUCT_latex(p, $) {
                let accumulator = '\\prod_{';
                accumulator += render_using_non_sexpr_print_mode(caddr(p), $);
                accumulator += '=';
                accumulator += render_using_non_sexpr_print_mode(cadddr(p), $);
                accumulator += '}^{';
                accumulator += render_using_non_sexpr_print_mode(caddddr(p), $);
                accumulator += '}{';
                accumulator += render_using_non_sexpr_print_mode(cadr(p), $);
                accumulator += '}';
                return accumulator;
            }
            function print_PRODUCT_codegen(p, $) {
                const body = cadr(p);
                const variable = caddr(p);
                const lowerlimit = cadddr(p);
                const upperlimit = caddddr(p);
                const accumulator = '(function(){' +
                    ' var ' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    '; ' +
                    ' var holderProduct = 1; ' +
                    ' var lowerlimit = ' +
                    render_using_non_sexpr_print_mode(lowerlimit, $) +
                    '; ' +
                    ' var upperlimit = ' +
                    render_using_non_sexpr_print_mode(upperlimit, $) +
                    '; ' +
                    ' for (' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    ' = lowerlimit; ' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    ' < upperlimit; ' +
                    render_using_non_sexpr_print_mode(variable, $) +
                    '++) { ' +
                    '   holderProduct *= ' +
                    render_using_non_sexpr_print_mode(body, $) +
                    ';' +
                    ' } ' +
                    ' return holderProduct;' +
                    '})()';
                return accumulator;
            }
            function should_tweak_exponent_syntax(base, $) {
                if (is_sym(base)) {
                    if (base.equals(create_sym('x'))) {
                        const sym = PRINT_LEAVE_X_ALONE;
                        const binding = $.getSymbolValue(sym);
                        if (sym === binding) {
                            // There is no override, therefore tweak!
                            return true;
                        }
                        else {
                            return !equaln(binding, 1);
                        }
                    }
                    else {
                        // base symbols that don't have the printname 'x' can have their power expressions tweaked. 
                        return true;
                    }
                }
                else {
                    // e.g. (expt 5 -1) can be written as 1/5
                    return true;
                }
            }
            function print_power(base, expo, $) {
                // console.lg(`print_power base = ${base} expo = ${expo}`);
                let str = '';
                // quick check this is actually a square root.
                if (is_num_and_equal_one_half(expo)) {
                    if (equaln(base, 2)) {
                        if (defs.codeGen) {
                            str += print_str('Math.SQRT2');
                            return str;
                        }
                    }
                    else {
                        if (defs.printMode === PRINTMODE_LATEX) {
                            str += print_str('\\sqrt{');
                            str += render_using_non_sexpr_print_mode(base, $);
                            str += print_str('}');
                            return str;
                        }
                        else if (defs.codeGen) {
                            str += print_str('Math.sqrt(');
                            str += render_using_non_sexpr_print_mode(base, $);
                            str += print_str(')');
                            return str;
                        }
                    }
                }
                if (equaln($.getSymbolValue(PRINT_LEAVE_E_ALONE), 1) && is_base_of_natural_logarithm(base)) {
                    if (defs.codeGen) {
                        str += print_str('Math.exp(');
                        str += print_expo_of_denom(expo, $);
                        str += print_str(')');
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        str += print_str('e^{');
                        str += render_using_non_sexpr_print_mode(expo, $);
                        str += print_str('}');
                    }
                    else {
                        str += print_str('exp(');
                        str += render_using_non_sexpr_print_mode(expo, $);
                        str += print_str(')');
                    }
                    return str;
                }
                if (defs.codeGen) {
                    str += print_str('Math.pow(');
                    str += print_base_of_denom(base, $);
                    str += print_str(', ');
                    str += print_expo_of_denom(expo, $);
                    str += print_str(')');
                    return str;
                }
                if (should_tweak_exponent_syntax(base, $)) {
                    // if the exponent is negative then
                    // we invert the base BUT we don't do
                    // that if the base is "e", because for
                    // example when trigonometric functions are
                    // expressed in terms of exponential functions
                    // that would be really confusing, one wants to
                    // keep "e" as the base and the negative exponent
                    if (!is_base_of_natural_logarithm(base)) {
                        if (is_num(expo) && expo.isMinusOne()) {
                            if (defs.printMode === PRINTMODE_LATEX) {
                                str += print_str('\\frac{1}{');
                            }
                            else if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                                str += print_str('1 / ');
                            }
                            else {
                                str += print_str('1/');
                            }
                            if (is_cons(base) && defs.printMode !== PRINTMODE_LATEX) {
                                str += print_str('(');
                                str += render_using_non_sexpr_print_mode(base, $);
                                str += print_str(')');
                            }
                            else {
                                str += render_using_non_sexpr_print_mode(base, $);
                            }
                            if (defs.printMode === PRINTMODE_LATEX) {
                                str += print_str('}');
                            }
                            return str;
                        }
                        if (is_negative(expo)) {
                            if (defs.printMode === PRINTMODE_LATEX) {
                                str += print_str('\\frac{1}{');
                            }
                            else if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                                str += print_str('1 / ');
                            }
                            else {
                                str += print_str('1/');
                            }
                            const newExponent = $.multiply(expo, negOne);
                            if (is_cons(base) && defs.printMode !== PRINTMODE_LATEX) {
                                str += print_str('(');
                                str += print_power(base, newExponent, $);
                                str += print_str(')');
                            }
                            else {
                                str += print_power(base, newExponent, $);
                            }
                            if (defs.printMode === PRINTMODE_LATEX) {
                                str += print_str('}');
                            }
                            return str;
                        }
                    }
                    if (isfraction(expo) && defs.printMode === PRINTMODE_LATEX) {
                        str += print_str('\\sqrt');
                        const denomExponent = denominator(expo, $);
                        // we omit the "2" on the radical
                        if (!is_num_and_eq_two(denomExponent)) {
                            str += print_str('[');
                            str += render_using_non_sexpr_print_mode(denomExponent, $);
                            str += print_str(']');
                        }
                        str += print_str('{');
                        expo = numerator(expo, $);
                        str += print_power(base, expo, $);
                        str += print_str('}');
                        return str;
                    }
                }
                if (defs.printMode === PRINTMODE_LATEX && $.isOne(expo)) {
                    // if we are in latex mode we turn many
                    // radicals into a radix sign with a power
                    // underneath, and the power is often one
                    // (e.g. square root turns into a radical
                    // with a power one underneath) so handle
                    // this case simply here, just print the base
                    str += render_using_non_sexpr_print_mode(base, $);
                }
                else {
                    // print the base,
                    // determining if it needs to be
                    // wrapped in parentheses or not
                    if (is_power(base)) {
                        // power is right associative so without parens it would be interpreted wrong.
                        // Not sure why we have the LaTeX shananigans.
                        if (defs.printMode !== PRINTMODE_LATEX) {
                            str += print_str('(');
                            str += print_factor(base, true, false, $);
                            str += print_str(')');
                        }
                        else {
                            str += print_factor(base, true, false, $);
                        }
                    }
                    else if (is_negative_number(base)) {
                        // Prevent ambiguity when dealing with unary minus.
                        // As an example, in JavaScript unary minus technically has higher precedence than exponentiation,
                        // but compilers sometimes require parentheses to avoid errors.
                        str += print_str('(');
                        str += render_using_non_sexpr_print_mode(base, $);
                        str += print_str(')');
                    }
                    else if (is_add(base)) {
                        // Addition has lower precedence than power so we need to prevent it from being pulled apart by the exponentiation.
                        str += print_str('(');
                        str += render_using_non_sexpr_print_mode(base, $);
                        str += print_str(')');
                    }
                    else if (is_multiply(base)) {
                        // Multiplicationn has lower precedence than power so we need to prevent it from being pulled apart by the exponentiation.
                        // Not sure why we have the LaTeX shananigans.
                        if (defs.printMode !== PRINTMODE_LATEX) {
                            str += print_str('(');
                            str += print_factor(base, true, false, $);
                            str += print_str(')');
                        }
                        else {
                            str += print_factor(base, true, false, $);
                        }
                    }
                    else if (is_outer$1(base)) {
                        // Outer product has lower precedence than power so we need to prevent it from being pulled apart by the exponentiation.
                        str += print_str('(');
                        str += render_using_non_sexpr_print_mode(base, $);
                        str += print_str(')');
                    }
                    else if (is_inner_or_dot(base)) {
                        // Inner product has lower precedence than power so we need to prevent it from being pulled apart by the exponentiation.
                        str += print_str('(');
                        str += render_using_non_sexpr_print_mode(base, $);
                        str += print_str(')');
                    }
                    else if (is_num(base) && (lt_num_num(base, zero) || isfraction(base))) {
                        str += print_str('(');
                        str += print_factor(base, false, false, $);
                        str += print_str(')');
                    }
                    else {
                        str += print_factor(base, false, false, $);
                    }
                    // print the power symbol
                    if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                        if ($.getNativeDirective(Directive.useCaretForExponentiation)) {
                            str += print_str('^');
                        }
                        else {
                            str += print_str('**');
                        }
                    }
                    else if (defs.printMode === PRINTMODE_LATEX) {
                        // No choice in LaTeX, it's a caret.
                        str += print_str('^');
                    }
                    else {
                        if ($.getNativeDirective(Directive.useCaretForExponentiation)) {
                            str += print_str('^');
                        }
                        else {
                            str += print_str('**');
                        }
                    }
                    // print the exponent
                    if (defs.printMode === PRINTMODE_LATEX) {
                        // in latex mode, one can omit the curly braces
                        // wrapping the exponent if the exponent is only
                        // one character long
                        if (render_using_non_sexpr_print_mode(expo, $).length > 1) {
                            str += print_str('{');
                            str += render_using_non_sexpr_print_mode(expo, $);
                            str += print_str('}');
                        }
                        else {
                            str += render_using_non_sexpr_print_mode(expo, $);
                        }
                    }
                    else if (is_cons(expo) || isfraction(expo) || (is_num(expo) && lt_num_num(expo, zero))) {
                        str += print_str('(');
                        str += render_using_non_sexpr_print_mode(expo, $);
                        str += print_str(')');
                    }
                    else {
                        str += print_factor(expo, false, false, $);
                    }
                }
                return str;
            }
            function print_index_function(p, $) {
                let str = '';
                p = cdr(p);
                // TODO: Porobably need INNER, OUTER, RCO, LCO...
                if (caar(p).equals(ADD$7) || caar(p).equals(MULTIPLY$1) || caar(p).equals(POWER$1) || caar(p).equals(FACTORIAL)) {
                    str += print_grouping_expr(car(p), $);
                }
                else {
                    str += render_using_non_sexpr_print_mode(car(p), $);
                }
                str += print_str('[');
                p = cdr(p);
                if (is_cons(p)) {
                    str += render_using_non_sexpr_print_mode(car(p), $);
                    p = cdr(p);
                    while (is_cons(p)) {
                        str += print_str(',');
                        str += render_using_non_sexpr_print_mode(car(p), $);
                        p = cdr(p);
                    }
                }
                str += print_str(']');
                return str;
            }
            function print_factor(expr, omitParens = false, pastFirstFactor = false, $) {
                const omtPrns = omitParens;
                // console.lg(`print_factor ${expr} omitParens => ${omitParens} pastFirstFactor => ${false}`);
                if (is_num(expr)) {
                    let str = '';
                    // in an evaluated term, all the numeric parts
                    // are at the beginning of the term.
                    // When printing the EXPRESSION,
                    // we peek into the first factor of the term and we
                    // look at whether it's a number less then zero.
                    // if it is, we print the "-" as the "leading" part of the
                    // print of the EXPRESSION, and then we proceed printint the factors
                    // of the term. This means that when we come here, we must
                    // skip printing the minus if the number is negative,
                    // because it's already been printed.
                    if (pastFirstFactor && lt_num_num(expr, zero)) {
                        str += '(';
                    }
                    str += print_number(expr, pastFirstFactor, $);
                    if (pastFirstFactor && lt_num_num(expr, zero)) {
                        str += ')';
                    }
                    return str;
                }
                if (is_boo(expr)) {
                    return expr.equals(booT) ? 'true' : 'false';
                }
                if (is_str$1(expr)) {
                    let str = '';
                    str += print_str('"');
                    str += print_str(expr.str);
                    str += print_str('"');
                    return str;
                }
                if (is_tensor(expr)) {
                    let str = '';
                    if (defs.printMode === PRINTMODE_LATEX) {
                        str += print_tensor_latex(expr, $);
                    }
                    else {
                        str += print_tensor(expr, $);
                    }
                    return str;
                }
                if (is_blade(expr)) {
                    let str = '';
                    if (defs.printMode === PRINTMODE_LATEX) {
                        str += expr.toLatexString();
                    }
                    else {
                        str += expr.toInfixString();
                    }
                    return str;
                }
                if (is_cons(expr) && is_multiply(expr)) {
                    let str = '';
                    if (!omtPrns) {
                        if (sign_of_term(expr) === '-' || defs.printMode !== PRINTMODE_LATEX) {
                            if (defs.printMode === PRINTMODE_LATEX) {
                                str += print_str(' \\left (');
                            }
                            else {
                                str += print_str('(');
                            }
                        }
                    }
                    str += render_using_non_sexpr_print_mode(expr, $);
                    if (!omtPrns) {
                        if (sign_of_term(expr) === '-' || defs.printMode !== PRINTMODE_LATEX) {
                            if (defs.printMode === PRINTMODE_LATEX) {
                                str += print_str(' \\right ) ');
                            }
                            else {
                                str += print_str(')');
                            }
                        }
                    }
                    return str;
                }
                else if (is_add(expr)) {
                    let str = '';
                    if (!omtPrns) {
                        str += print_str('(');
                    }
                    str += render_using_non_sexpr_print_mode(expr, $);
                    if (!omtPrns) {
                        str += print_str(')');
                    }
                    return str;
                }
                if (is_power(expr)) {
                    let str = '';
                    const base = cadr(expr);
                    const exponent = caddr(expr);
                    str += print_power(base, exponent, $);
                    return str;
                }
                //  if (car(p) == _list) {
                //    print_str("{")
                //    p = cdr(p)
                //    if (iscons(p)) {
                //      print_expr(car(p),$)
                //      p = cdr(p)
                //    }
                //    while (iscons(p)) {
                //      print_str(",")
                //      print_expr(car(p),$)
                //      p = cdr(p)
                //    }
                //    print_str("}")
                //    return
                //  }
                if (car(expr).equals(FUNCTION)) {
                    let str = '';
                    const fbody = cadr(expr);
                    if (!defs.codeGen) {
                        const parameters = caddr(expr);
                        str += print_str('function ');
                        const returned = render_as_sexpr(parameters, $);
                        str += returned;
                        str += print_str(' -> ');
                    }
                    str += render_using_non_sexpr_print_mode(fbody, $);
                    return str;
                }
                if (car(expr).equals(PATTERN)) {
                    let str = '';
                    str += render_using_non_sexpr_print_mode(caadr(expr), $);
                    if (defs.printMode === PRINTMODE_LATEX) {
                        str += print_str(' \\rightarrow ');
                    }
                    else {
                        if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag) {
                            str += print_str(' -> ');
                        }
                        else {
                            str += print_str('->');
                        }
                    }
                    str += render_using_non_sexpr_print_mode(car(cdr(cadr(expr))), $);
                    return str;
                }
                if (car(expr).equals(SYM_MATH_COMPONENT) && is_sym(cadr(expr))) {
                    let str = '';
                    str += print_index_function(expr, $);
                    return str;
                }
                // TODO: The generalization here would be that we look up the operator then ask for the right format
                // based upon defs.printMode, defs.codeGen
                if (is_cons(expr) && is_factorial(expr)) {
                    return print_factorial_function(expr, $);
                }
                else if (is_cons(expr) && is_abs(expr)) {
                    // console.lg(`print_factor ${expr} omitParens => ${omitParens} pastFirstFactor => ${false} printMode: ${defs.printMode}`);
                    switch (defs.printMode) {
                        case PRINTMODE_HUMAN:
                        case PRINTMODE_INFIX: {
                            return print_abs_infix(expr, $);
                        }
                        case PRINTMODE_LATEX: {
                            return print_abs_latex(expr, $);
                        }
                        default: {
                            // PRINTMODE_ASCII and PRINTMODE_SEXPR is the other mode but that doesn't use this function.
                            throw new Error(defs.printMode);
                        }
                    }
                }
                else if (car(expr).equals(SQRT) && defs.printMode === PRINTMODE_LATEX) {
                    let str = '';
                    str += print_SQRT_latex(expr, $);
                    return str;
                    // eslint-disable-next-line no-dupe-else-if
                }
                else if (is_transpose(expr)) {
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_TRANSPOSE_latex(expr, $);
                        return str;
                    }
                    else if (defs.codeGen) {
                        let str = '';
                        str += print_TRANSPOSE_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(UNIT)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_UNIT_codegen(expr, $);
                        return str;
                    }
                }
                else if (is_cons(expr) && is_opr_eq_inv(expr)) {
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_INV_latex(expr, $);
                        return str;
                    }
                    else if (defs.codeGen) {
                        let str = '';
                        str += print_INV_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(BINOMIAL) && defs.printMode === PRINTMODE_LATEX) {
                    let str = '';
                    str += print_BINOMIAL_latex(expr, $);
                    return str;
                }
                else if (car(expr).equals(DEFINT) && defs.printMode === PRINTMODE_LATEX) {
                    let str = '';
                    str += print_DEFINT_latex(expr, $);
                    return str;
                }
                else if (is_inner_or_dot(expr)) {
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_DOT_latex(expr, $);
                        return str;
                    }
                    else if (defs.codeGen) {
                        let str = '';
                        str += print_DOT_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(SIN$1)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_SIN_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(COS$3)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_COS_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(TAN)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_TAN_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(ARCSIN)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_ARCSIN_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(ARCCOS)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_ARCCOS_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(ARCTAN)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_ARCTAN_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(SUM)) {
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_SUM_latex(expr, $);
                        return str;
                    }
                    else if (defs.codeGen) {
                        let str = '';
                        str += print_SUM_codegen(expr, $);
                        return str;
                    }
                    //else if car(p) == symbol(QUOTE)
                    //  if printMode == PRINTMODE_LATEX
                    //    print_expr(cadr(p),$)
                    //    return accumulator
                }
                else if (car(expr).equals(PRODUCT)) {
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_PRODUCT_latex(expr, $);
                        return str;
                    }
                    else if (defs.codeGen) {
                        let str = '';
                        str += print_PRODUCT_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(FOR)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_FOR_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(DO)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_DO_codegen(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(TEST)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_TEST_codegen(expr, $);
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_TEST_latex(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(TESTLT)) {
                    if (defs.codeGen) {
                        let str = '';
                        str +=
                            '((' + render_using_non_sexpr_print_mode(cadr(expr), $) + ') < (' + render_using_non_sexpr_print_mode(caddr(expr), $) + '))';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_TESTLT_latex(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(TESTLE)) {
                    if (defs.codeGen) {
                        let str = '';
                        str +=
                            '((' + render_using_non_sexpr_print_mode(cadr(expr), $) + ') <= (' + render_using_non_sexpr_print_mode(caddr(expr), $) + '))';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_TESTLE_latex(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(TESTGT)) {
                    if (defs.codeGen) {
                        let str = '';
                        str +=
                            '((' + render_using_non_sexpr_print_mode(cadr(expr), $) + ') > (' + render_using_non_sexpr_print_mode(caddr(expr), $) + '))';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_TESTGT_latex(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(TESTGE)) {
                    if (defs.codeGen) {
                        let str = '';
                        str +=
                            '((' + render_using_non_sexpr_print_mode(cadr(expr), $) + ') >= (' + render_using_non_sexpr_print_mode(caddr(expr), $) + '))';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_TESTGE_latex(expr, $);
                        return str;
                    }
                }
                else if (is_cons(expr) && expr.opr.equals(testeq$2)) {
                    if (defs.codeGen) {
                        let str = '';
                        str +=
                            '((' + render_using_non_sexpr_print_mode(cadr(expr), $) + ') === (' + render_using_non_sexpr_print_mode(caddr(expr), $) + '))';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += print_testeq_latex(expr, $);
                        return str;
                    }
                }
                else if (car(expr).equals(FLOOR)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += 'Math.floor(' + render_using_non_sexpr_print_mode(cadr(expr), $) + '),$';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += ' \\lfloor {' + render_using_non_sexpr_print_mode(cadr(expr), $) + '} \\rfloor ,$';
                        return str;
                    }
                }
                else if (car(expr).equals(CEILING)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += 'Math.ceiling(' + render_using_non_sexpr_print_mode(cadr(expr), $) + '),$';
                        return str;
                    }
                    if (defs.printMode === PRINTMODE_LATEX) {
                        let str = '';
                        str += ' \\lceil {' + render_using_non_sexpr_print_mode(cadr(expr), $) + '} \\rceil ,$';
                        return str;
                    }
                }
                else if (car(expr).equals(ROUND)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += 'Math.round(' + render_using_non_sexpr_print_mode(cadr(expr), $) + '),$';
                        return str;
                    }
                }
                else if (car(expr).equals(ASSIGN)) {
                    if (defs.codeGen) {
                        let str = '';
                        str += print_SETQ_codegen(expr, $);
                        return str;
                    }
                    else {
                        let str = '';
                        str += render_using_non_sexpr_print_mode(cadr(expr), $);
                        str += print_str('=');
                        str += render_using_non_sexpr_print_mode(caddr(expr), $);
                        return str;
                    }
                }
                return print_factor_fallback(expr, omtPrns, $);
            }
            function print_factor_fallback(expr, omtPrns, $) {
                if (is_cons(expr)) {
                    let str = '';
                    str += print_factor(expr.car, false, false, $);
                    expr = expr.cdr;
                    if (nil === expr) {
                        return str;
                    }
                    else {
                        if (!omtPrns) {
                            str += print_str('(');
                        }
                        if (is_cons(expr)) {
                            str += render_using_non_sexpr_print_mode(car(expr), $);
                            expr = cdr(expr);
                            while (is_cons(expr)) {
                                str += print_str(',');
                                str += render_using_non_sexpr_print_mode(car(expr), $);
                                expr = cdr(expr);
                            }
                        }
                        if (!omtPrns) {
                            str += print_str(')');
                        }
                        return str;
                    }
                }
                if (is_uom$1(expr)) {
                    let str = '';
                    str += expr.toString();
                    return str;
                }
                if (is_blade(expr)) {
                    let str = '';
                    str += expr.toString();
                    return str;
                }
                if (MATH_DERIVATIVE.equals(expr)) {
                    return print_char('d');
                }
                else if (is_base_of_natural_logarithm(expr)) {
                    if (defs.codeGen) {
                        return print_str('Math.E');
                    }
                    else {
                        if (defs.printMode === PRINTMODE_LATEX) {
                            return print_str('e');
                        }
                        else {
                            return print_str($.getSymbolPrintName(MATH_E$1));
                        }
                    }
                }
                else if (is_pi(expr)) {
                    if (defs.printMode === PRINTMODE_LATEX) {
                        return print_str('\\pi');
                    }
                    else {
                        return print_str($.getSymbolPrintName(MATH_PI$1));
                    }
                }
                else {
                    if (is_sym(expr)) {
                        if (defs.printMode === PRINTMODE_INFIX) {
                            return $.toInfixString(expr);
                        }
                        if (defs.printMode === PRINTMODE_LATEX) {
                            return $.toLatexString(expr);
                        }
                        return expr.text;
                    }
                    if (is_hyp(expr)) {
                        return expr.printname;
                    }
                    if (is_nil(expr)) {
                        return print_str($.getSymbolPrintName(native_sym(Native.NIL)));
                    }
                    if (is_err(expr)) {
                        return ENGLISH_UNDEFINED$1;
                    }
                    if (is_imu(expr)) {
                        if (defs.printMode === PRINTMODE_LATEX) {
                            return print_str('i');
                        }
                        else {
                            return print_str($.getSymbolPrintName(MATH_IMU));
                        }
                    }
                    throw new Error(`${expr} ???`);
                }
            }
            function print_multiply_sign() {
                if (defs.printMode === PRINTMODE_LATEX) {
                    return '';
                }
                if (defs.printMode === PRINTMODE_HUMAN && !defs.testFlag && !defs.codeGen) {
                    return print_str(' ');
                }
                else {
                    return print_str('*');
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function is_denominator(expr, $) {
                if (is_cons(expr)) {
                    if (is_power(expr)) {
                        const argList = expr.cdr;
                        if (is_cons(argList)) {
                            const base = argList.car;
                            if (!is_base_of_natural_logarithm(base)) {
                                const cdr_argList = argList.cdr;
                                if (is_cons(cdr_argList)) {
                                    const exponent = cdr_argList.car;
                                    return is_negative(exponent);
                                }
                            }
                        }
                    }
                }
                return false;
            }
            // don't consider the leading fraction
            // we want 2/3*a*b*c instead of 2*a*b*c/3
            function any_denominators(expr, $) {
                let p = expr.cdr;
                while (is_cons(p)) {
                    const q = p.car;
                    if (is_denominator(q)) {
                        return true;
                    }
                    p = p.cdr;
                }
                return false;
            }

            function render_as_infix(expr, $) {
                const codeGen = defs.codeGen;
                const printMode = defs.printMode;
                defs.codeGen = false;
                defs.setPrintMode(PRINTMODE_INFIX);
                try {
                    let str = render_using_non_sexpr_print_mode(expr, $);
                    // some variables might contain underscores, escape those
                    str = str.replace(/_/g, '\\_');
                    return str;
                }
                finally {
                    defs.codeGen = codeGen;
                    defs.setPrintMode(printMode);
                }
            }

            function render_as_latex(expr, $) {
                const codeGen = defs.codeGen;
                const printMode = defs.printMode;
                defs.codeGen = false;
                defs.setPrintMode(PRINTMODE_LATEX);
                try {
                    let str = render_using_non_sexpr_print_mode(expr, $);
                    // some variables might contain underscores, escape those
                    str = str.replace(/_/g, '\\_');
                    return str;
                }
                finally {
                    defs.codeGen = codeGen;
                    defs.setPrintMode(printMode);
                }
            }

            /**
             * Provides a base implementation of an operator.
             * The main reusable features are:
             * 1. Matching in both operator and operand position.
             * 2. Rendering to Infix, LaTeX, and SExpr.
             * 3. contains()
             * TODO: The hope is that the dead-code methods can be removed when refactoring is complete.
             */
            class AbstractOperator {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor(name, $) {
                    this.name = name;
                    this.$ = $;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                compareFactors(lhs, rhs) {
                    throw new Error("Abtract Operator Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                compareTerms(lhs, rhs) {
                    throw new Error("Abtract Operator Method not implemented.");
                }
                subst(expr, oldExpr, newExpr) {
                    const $ = this.$;
                    if ($.equals(expr, oldExpr)) {
                        return newExpr;
                    }
                    if (is_cons(expr)) {
                        const opr = cadnr(expr, 0);
                        const subst_opr = subst(opr, oldExpr, newExpr, $);
                        if ($.equals(subst_opr, opr)) {
                            // TODO: Generalize the assumption of binary.
                            const lhs = cadnr(expr, 1);
                            const rhs = cadnr(expr, 2);
                            const subst_lhs = subst(lhs, oldExpr, newExpr, $);
                            const subst_rhs = subst(rhs, oldExpr, newExpr, $);
                            if ($.equals(lhs, subst_lhs) && $.equals(rhs, subst_rhs)) {
                                return expr;
                            }
                            else {
                                return items_to_cons$1(opr, subst_lhs, subst_rhs);
                            }
                        }
                        else {
                            const lhs = cadnr(expr, 1);
                            const rhs = cadnr(expr, 2);
                            return items_to_cons$1(subst_opr, subst(lhs, oldExpr, newExpr, $), subst(rhs, oldExpr, newExpr, $));
                        }
                    }
                    if (is_sym(expr)) {
                        if (is_sym(oldExpr)) {
                            if (expr.equalsSym(oldExpr)) {
                                return newExpr;
                            }
                            else {
                                return expr;
                            }
                        }
                        else {
                            return expr;
                        }
                    }
                    throw new SystemError();
                }
                toInfixString(expr) {
                    return render_as_infix(expr, this.$);
                }
                toLatexString(expr) {
                    return render_as_latex(expr, this.$);
                }
                toListString(expr) {
                    return render_as_sexpr(expr, this.$);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(expr) {
                    throw new Error(`AbstractOperator.valueOf ${expr} method not implemented.`);
                }
            }

            /**
             * An operator that matches (opr ...), with a variable number of arguments.
             */
            class FunctionVarArgs extends AbstractOperator {
                constructor(name, opr, $) {
                    super(name, $);
                    this.opr = opr;
                    this.key = `(${opr.key()})`;
                }
                evaluate(argList) {
                    const expr = cons(this.opr, argList);
                    return this.transform(expr, this.$);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform(expr, $) {
                    throw new Error(`FunctionVarArgs.transform must be implemented in ${this.name}`);
                }
                isKind(expr) {
                    return expr.opr.equals(this.opr);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    return false;
                }
            }

            class Function1 extends FunctionVarArgs {
                constructor(name, opr, guard, $) {
                    super(name, opr, $);
                    this.guard = guard;
                }
                isKind(expr) {
                    return !!this.match(expr);
                }
                match(expr) {
                    if (is_cons(expr) && expr.length === 2) {
                        const opr = expr.opr;
                        const arg = expr.item(1);
                        if (is_sym(opr) && this.opr.equalsSym(opr) && this.guard(arg)) {
                            return expr;
                        }
                        else {
                            return void 0;
                        }
                    }
                    else {
                        return void 0;
                    }
                }
                transform(expr) {
                    const m = this.match(expr);
                    if (m) {
                        const $ = this.$;
                        const arg = $.valueOf(m.arg);
                        if (!arg.equals(m.arg)) {
                            return [TFLAG_DIFF, $.valueOf(items_to_cons$1(m.opr, arg))];
                        }
                        else {
                            return this.transform1(m.opr, m.arg, m);
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            }

            class CompositeOperator extends Function1 {
                constructor(outerOpr, innerOpr, $) {
                    super(`${outerOpr}∘${innerOpr}`, outerOpr, is_cons, $);
                    this.innerOpr = innerOpr;
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.arg;
                        if (is_cons(innerExpr)) {
                            return innerExpr.opr.equals(this.innerOpr);
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }

            const abs = native_sym(Native.abs);
            const add$1 = native_sym(Native.add);
            let Builder$5f = class Builder {
                create($) {
                    return new Op$4t($);
                }
            };
            /**
             *
             */
            let Op$4t = class Op extends CompositeOperator {
                constructor($) {
                    super(abs, add$1, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const addExpr = expr.argList.head;
                        const terms = addExpr.tail();
                        return terms.some(contains_single_blade);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    // console.lg(this.name, this.$.toInfixString(innerExpr));
                    const retval = $.valueOf(simplify($.power($.inner(innerExpr, innerExpr), half), $));
                    return [TFLAG_DIFF, retval];
                }
            };
            const abs_add_blades = new Builder$5f();

            function is_any(expr) {
                if (typeof expr === 'undefined') {
                    throw new Error();
                }
                return true;
            }

            /**
             * A convenience function.
             */
            function wrap_as_transform(newExpr, oldExpr) {
                const flags = newExpr.equals(oldExpr) ? TFLAG_NONE : TFLAG_DIFF;
                return [flags, newExpr];
            }

            const ABS$2 = native_sym(Native.abs);
            let Builder$5e = class Builder {
                create($) {
                    return new Op$4s($);
                }
            };
            let Op$4s = class Op extends Function1 {
                constructor($) {
                    super('abs_any', ABS$2, is_any, $);
                    this.phases = MODE_EXPANDING;
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const arg = expr.arg;
                        if (is_sym(arg)) {
                            return true;
                        }
                        else if (is_atom(arg)) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, arg, expr) {
                    // console.lg(this.name, this.$.toInfixString(arg));
                    const $ = this.$;
                    const retval = abs$1(arg, $);
                    return wrap_as_transform(retval, expr);
                }
            };
            const abs_any = new Builder$5e();

            /**
             * sqrt(x) = (expt x 1/2)
             */
            const MATH_SQRT = create_sym('sqrt');

            let Builder$5d = class Builder {
                create($) {
                    return new Op$4r($);
                }
            };
            let Function1Atom$1 = class Function1Atom extends Function1 {
                constructor(opr, guard, hash, $) {
                    super(`${opr.text}_${hash}`, opr, guard, $);
                    this.hash = hash_unaop_atom(this.opr, hash);
                }
            };
            class FunctionBlade extends Function1Atom$1 {
                constructor(opr, $) {
                    super(opr, is_blade$1, HASH_BLADE, $);
                }
            }
            let Op$4r = class Op extends FunctionBlade {
                constructor($) {
                    super(native_sym(Native.abs), $);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const innerProduct = arg.__vbar__(arg);
                    const retval = $.valueOf(items_to_cons$1(MATH_SQRT, $.valueOf(innerProduct)));
                    return wrap_as_transform(retval, expr);
                }
            };
            const abs_blade = new Builder$5d();

            let Builder$5c = class Builder {
                create($) {
                    return new Op$4q($);
                }
            };
            let Op$4q = class Op extends Function1 {
                constructor($) {
                    super('abs_rat', native_sym(Native.abs), is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                transform1(opr, arg, expr) {
                    return wrap_as_transform(arg.abs(), expr);
                }
            };
            const abs_flt = new Builder$5c();

            let Builder$5b = class Builder {
                create($) {
                    return new Op$4p($);
                }
            };
            let Op$4p = class Op extends Function1 {
                constructor($) {
                    super('abs_imu', native_sym(Native.abs), is_imu, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_IMU);
                }
                transform1(opr, arg, expr) {
                    return wrap_as_transform(one, expr);
                }
            };
            const abs_imu = new Builder$5b();

            const POW$d = native_sym(Native.pow);
            const ABS$1 = native_sym(Native.abs);
            let Builder$5a = class Builder {
                create($) {
                    return new Op$4o($);
                }
            };
            /**
             * abs(1/z) <=> 1/abs(z)
             */
            let Op$4o = class Op extends CompositeOperator {
                constructor($) {
                    super(ABS$1, POW$d, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const pow = expr.argList.head;
                        const expo = pow.rhs;
                        return is_rat$1(expo) && expo.isMinusOne();
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(absOpr, powExpr, expr) {
                    const $ = this.$;
                    const z = powExpr.lhs;
                    const abs_z = $.valueOf(items_to_cons$1(absOpr, z));
                    const one_over_abs_z = $.valueOf(items_to_cons$1(powExpr.opr, abs_z, negOne));
                    return [TFLAG_DIFF, one_over_abs_z];
                }
            };
            const abs_pow_any_negone = new Builder$5a();

            let Builder$59 = class Builder {
                create($) {
                    return new Op$4n($);
                }
            };
            let Op$4n = class Op extends Function1 {
                constructor($) {
                    super('abs_rat', native_sym(Native.abs), is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                transform1(opr, arg, expr) {
                    return wrap_as_transform(arg.abs(), expr);
                }
            };
            const abs_rat = new Builder$59();

            let Builder$58 = class Builder {
                create($) {
                    return new Op$4m($);
                }
            };
            class FunctionTensor extends Function1 {
                constructor(opr, $) {
                    super(`${opr.text}_${HASH_TENSOR}`, opr, is_tensor, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_TENSOR);
                }
            }
            let Op$4m = class Op extends FunctionTensor {
                constructor($) {
                    super(native_sym(Native.abs), $);
                }
                transform1(opr, arg, expr) {
                    return wrap_as_transform(abs_of_tensor(arg, this.$), expr);
                }
            };
            // also called the "norm" of a vector
            function abs_of_tensor(M, $) {
                if (M.ndim !== 1) {
                    throw new Error('abs(tensor) with tensor rank > 1');
                }
                // 
                const K = simplify(M, $);
                // TODO: We need to be careful here. The conjugate operation really belongs inside the inner operation for tensors.
                return $.valueOf(simplify($.power($.inner(K, complex_conjugate(K, $)), half), $));
            }
            const abs_tensor = new Builder$58();

            let Builder$57 = class Builder {
                create($) {
                    return new Op$4l($);
                }
            };
            class Function1Atom extends Function1 {
                constructor(opr, guard, hash, $) {
                    super(`${opr.text}_${HASH_UOM}`, opr, guard, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_UOM);
                }
            }
            class FunctionUom extends Function1Atom {
                constructor(opr, $) {
                    super(opr, is_uom$1, HASH_UOM, $);
                }
            }
            let Op$4l = class Op extends FunctionUom {
                constructor($) {
                    super(native_sym(Native.abs), $);
                }
                transform1(opr, arg, expr) {
                    return wrap_as_transform(arg, expr);
                }
            };
            const abs_uom = new Builder$57();

            function do_factorize_rhs(lhs, rhs, prod, orig, $) {
                if (lhs.equals(rhs)) {
                    const A = $.valueOf(items_to_cons$1(MATH_MUL$3, lhs, prod));
                    const B = $.valueOf(items_to_cons$1(MATH_MUL$3, two, A));
                    return [TFLAG_DIFF, B];
                }
                if (is_num(lhs) && is_num(rhs)) {
                    const A = $.valueOf(items_to_cons$1(MATH_MUL$3, add_num_num(lhs, rhs), prod));
                    return [TFLAG_DIFF, A];
                }
                if (is_cons(lhs) && is_mul_2_any_any(lhs)) {
                    if (is_num(lhs.lhs) && lhs.rhs.equals(rhs)) {
                        const A = $.valueOf(items_to_cons$1(MATH_MUL$3, add_num_num(lhs.lhs, one), rhs));
                        const B = $.valueOf(items_to_cons$1(MATH_MUL$3, A, prod));
                        return [TFLAG_DIFF, B];
                    }
                    if (is_cons(rhs) && is_mul_2_any_any(rhs)) {
                        if (lhs.rhs.equals(rhs.rhs)) {
                            return do_factorize_rhs(lhs.lhs, rhs.lhs, $.valueOf(items_to_cons$1(MATH_MUL$3, lhs.rhs, prod)), orig, $);
                        }
                    }
                    if (lhs.rhs.equals(rhs)) {
                        const A = items_to_cons$1(MATH_ADD$1, lhs.lhs, one);
                        const B = items_to_cons$1(MATH_MUL$3, A, rhs);
                        const C = items_to_cons$1(MATH_MUL$3, B, prod);
                        return [TFLAG_DIFF, C];
                    }
                }
                if (is_cons(rhs) && is_mul_2_any_any(rhs)) {
                    if (is_num(rhs.lhs) && rhs.rhs.equals(lhs)) {
                        const A = $.valueOf(items_to_cons$1(MATH_MUL$3, add_num_num(rhs.lhs, one), lhs));
                        const B = $.valueOf(items_to_cons$1(MATH_MUL$3, A, prod));
                        return [TFLAG_DIFF, B];
                    }
                }
                return [TFLAG_NONE, orig];
            }

            /**
             * WARNING: Depends on binary multiplication.
             * Determines whether two expressions have a common factor on the right.
             * @param lhs
             * @param rhs
             * @returns
             */
            function is_factorize_rhs(lhs, rhs) {
                if (lhs.equals(rhs)) {
                    return true;
                }
                if (is_num(lhs) && is_num(rhs)) {
                    return true;
                }
                if (is_cons(lhs) && is_mul_2_any_any(lhs)) {
                    if (is_num(lhs.lhs) && lhs.rhs.equals(rhs)) {
                        return true;
                    }
                    if (is_cons(rhs) && is_mul_2_any_any(rhs)) {
                        if (lhs.rhs.equals(rhs.rhs)) {
                            return is_factorize_rhs(lhs.lhs, rhs.lhs);
                        }
                    }
                    if (lhs.rhs.equals(rhs)) {
                        return true;
                    }
                }
                if (is_cons(rhs) && is_mul_2_any_any(rhs)) {
                    if (is_num(rhs.lhs) && rhs.rhs.equals(lhs)) {
                        return true;
                    }
                }
                return false;
            }

            function and(guardL, guardR) {
                return function (arg) {
                    return guardL(arg) && guardR(arg);
                };
            }

            class Function2 extends FunctionVarArgs {
                constructor(name, opr, guardL, guardR, $) {
                    super(name, opr, $);
                    this.guardL = guardL;
                    this.guardR = guardR;
                }
                isKind(expr) {
                    const m = this.match(expr);
                    return !!m;
                }
                match(expr) {
                    try {
                        if (is_cons(expr) && expr.length === 3) {
                            const opr = expr.opr;
                            const lhs = expr.item(1);
                            const rhs = expr.item(2);
                            if (is_sym(opr)) {
                                if (this.opr.equalsSym(opr)) {
                                    if (this.guardL(lhs)) {
                                        if (this.guardR(rhs)) {
                                            return expr;
                                        }
                                        else {
                                            return void 0;
                                        }
                                    }
                                    else {
                                        return void 0;
                                    }
                                }
                                else {
                                    return void 0;
                                }
                            }
                            else {
                                return void 0;
                            }
                        }
                        else {
                            return void 0;
                        }
                    }
                    catch (e) {
                        throw new Error(`${this.name} + ${e}`);
                    }
                }
                transform(expr) {
                    const m = this.match(expr);
                    if (m) {
                        const $ = this.$;
                        const [flagsL, lhs] = $.transform(m.lhs);
                        const [flagsR, rhs] = $.transform(m.rhs);
                        /*
                        if (changedL === lhs.equals(m.lhs)) {
                            throw new Error(`changedL = ${changedL} newExpr=${lhs} oldExpr=${m.lhs}`);
                        }
                        if (changedR === rhs.equals(m.rhs)) {
                            throw new Error(`changedR = ${changedR} newExpr=${rhs} oldExpr=${m.rhs}`);
                        }
                        */
                        if (diffFlag(flagsL) || diffFlag(flagsR)) {
                            return [TFLAG_DIFF, $.valueOf(items_to_cons$1(m.opr, lhs, rhs))];
                        }
                        else {
                            return this.transform2(m.opr, m.lhs, m.rhs, m);
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            }

            /**
             * In addition to predicates for left and right, provided a cross predicate.
             */
            class Function2X extends Function2 {
                constructor(name, opr, guardL, guardR, cross, $) {
                    super(name, opr, guardL, guardR, $);
                    this.cross = cross;
                    this.$ = $;
                }
                match(expr) {
                    const m = super.match(expr);
                    if (m) {
                        if (this.cross(m.lhs, m.rhs, m)) {
                            return m;
                        }
                    }
                    return void 0;
                }
                transform(expr) {
                    const m = this.match(expr);
                    if (m) {
                        const $ = this.$;
                        const [flagsL, lhs] = $.transform(m.lhs);
                        const [flagsR, rhs] = $.transform(m.rhs);
                        if (diffFlag(flagsL) || diffFlag(flagsR)) {
                            return [TFLAG_DIFF, $.valueOf(items_to_cons$1(m.opr, lhs, rhs))];
                        }
                        else {
                            // Delegate to the function that must be implemented by the derived, concrete, class.
                            return this.transform2(m.opr, m.lhs, m.rhs, m);
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            }

            function is_add_2_any_any(expr) {
                return is_opr_2_any_any(MATH_ADD$1)(expr);
            }

            let Builder$56 = class Builder {
                create($) {
                    return new Op$4k($);
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$y($) {
                return function (lhs, rhs) {
                    // A problem with this is that we have performed the tree transformation either twice
                    // if is successful, or partially if it fails.
                    return is_factorize_rhs(lhs.rhs, rhs);
                };
            }
            /**
             * (X + Y) + Z => (X + m * A) + n * A => X + (m + n) * A, where Y = m * A, and Z = n * A.
             */
            let Op$4k = class Op extends Function2X {
                constructor($) {
                    super('add_2_add_2_any_any_any_factorize_rhs', MATH_ADD$1, and(is_cons, is_add_2_any_any), is_any, cross$y(), $);
                    this.hash = hash_binop_cons_atom(MATH_ADD$1, MATH_ADD$1, HASH_ANY);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        const X = lhs.lhs;
                        const Y = lhs.rhs;
                        const Z = rhs;
                        const mnA = do_factorize_rhs(Y, Z, one, orig, $)[1];
                        return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_ADD$1, X, mnA))];
                    }
                    else {
                        return [TFLAG_NONE, orig];
                    }
                }
            };
            const add_2_add_2_any_any_any_factorize_rhs = new Builder$56();

            function is_mul_2_rat_sym(expr) {
                return is_mul_2_any_any(expr) && is_rat$1(expr.lhs) && is_sym(expr.rhs);
            }

            function is_add_2_any_sym(expr) {
                if (is_add_2_any_any(expr)) {
                    const lhs = expr.lhs;
                    const rhs = expr.rhs;
                    return is_any(lhs) && is_sym(rhs);
                }
                else {
                    return false;
                }
            }

            let Builder$55 = class Builder {
                create($) {
                    return new Op$4j($);
                }
            };
            function cross$x(lhs, rhs) {
                switch (lhs.rhs.compare(rhs.rhs)) {
                    case SIGN_GT:
                    case SIGN_EQ: {
                        return true;
                    }
                    default: {
                        return false;
                    }
                }
            }
            /**
             * (X + c) + (k * b) => (X + (k * b)) + c
             * (X + c) + (k * c) => X + (K + 1) * c
             */
            let Op$4j = class Op extends Function2X {
                constructor($) {
                    super('add_2_add_2_any_mul_2_rat_sym', MATH_ADD$1, and(is_cons, is_add_2_any_sym), and(is_cons, is_mul_2_rat_sym), cross$x, $);
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_ADD$1, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const X = lhs.lhs;
                    const c = lhs.rhs;
                    const b = rhs.rhs;
                    const k = rhs.lhs;
                    switch (c.compare(b)) {
                        case SIGN_GT: {
                            const retval = $.valueOf(items_to_cons(MATH_ADD$1, $.valueOf(items_to_cons(MATH_ADD$1, X, rhs)), c));
                            return [TFLAG_DIFF, retval];
                        }
                        default: {
                            const retval = $.valueOf(items_to_cons(MATH_ADD$1, X, $.valueOf(items_to_cons(MATH_MUL$3, k.succ(), c))));
                            return [TFLAG_DIFF, retval];
                        }
                    }
                }
            };
            const add_2_add_2_any_mul_2_rat_sym = new Builder$55();

            let Builder$54 = class Builder {
                create($) {
                    return new Op$4i($);
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$w($) {
                return function (lhs, rhs) {
                    if ($.isFactoring()) {
                        return is_factorize_rhs(lhs, rhs);
                    }
                    else {
                        return false;
                    }
                };
            }
            let Op$4i = class Op extends Function2X {
                constructor($) {
                    super('add_2_any_any_factorize_rhs', MATH_ADD$1, is_any, is_any, cross$w($), $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_ANY, HASH_ANY);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    return do_factorize_rhs(lhs, rhs, one, expr, $);
                }
            };
            const add_2_any_any_factorize_rhs = new Builder$54();

            /**
             * Given expr = lhs + rhs, does it simplify to zero. i.e. do the terms cancel?
             */
            function is_zero_sum(lhs, rhs, $) {
                if (is_num(lhs) && is_num(rhs)) {
                    return is_zero_sum_num_num(lhs, rhs);
                }
                if (is_cons(lhs) && is_mul_2_any_any(lhs)) {
                    // (X * Y) + Z
                    const X = lhs.lhs;
                    const Y = lhs.rhs;
                    const Z = rhs;
                    if (Y.equals(Z)) {
                        // (X * Y) + Y = (X + 1) * Y
                        return $.isMinusOne(X) || $.is_zero(Y);
                    }
                    if (is_cons(rhs) && is_mul_2_any_any(rhs)) {
                        // (X * Y) + (Z * W)
                        const Z = rhs.lhs;
                        const W = rhs.rhs;
                        if (Y.equals(W)) {
                            // (X * Y) + (Z * Y) = (X + Z) * Y
                            return is_zero_sum(X, Z, $) || $.is_zero(Y);
                        }
                    }
                }
                if (is_cons(rhs) && is_mul_2_any_any(rhs)) {
                    // X + (Y * Z)
                    const X = lhs;
                    const Y = rhs.lhs;
                    const Z = rhs.rhs;
                    if (Z.equals(X)) {
                        // X + (Y * X) = (1 + Y) * X
                        return $.isMinusOne(Y) || $.is_zero(X);
                    }
                }
                return false;
            }
            function is_zero_sum_num_num(lhs, rhs) {
                // We hope to get an answer without actually creating a new number (object).
                // But for now we use an un-optimized version.
                return add_num_num(lhs, rhs).isZero();
            }

            let Builder$53 = class Builder {
                create($) {
                    return new Op$4h($);
                }
            };
            function cross$v($) {
                return function (lhs, rhs) {
                    return is_zero_sum(lhs, rhs, $);
                };
            }
            let Op$4h = class Op extends Function2X {
                constructor($) {
                    super('add_2_any_any_zero_sum', MATH_ADD$1, is_any, is_any, cross$v($), $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_ANY, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    return [TFLAG_DIFF, zero];
                }
            };
            const add_2_any_any_zero_sum = new Builder$53();

            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function compare_blade_blade_terms(lhs, rhs, $) {
                if (is_blade$1(lhs) && is_blade$1(rhs)) {
                    return compare_blade_blade(lhs, rhs);
                }
                else {
                    throw new Error();
                }
            }
            let Builder$52 = class Builder {
                create($, config) {
                    if (config.noOptimize) {
                        return new Op$4g($, cmp_terms);
                    }
                    else {
                        return new Op$4g($, compare_blade_blade_terms);
                    }
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$u(lhs, rhs) {
                return true;
            }
            /**
             * Blade + Blade
             */
            let Op$4g = class Op extends Function2X {
                constructor($, comparator) {
                    super('add_2_blade_blade', MATH_ADD$1, is_blade$1, is_blade$1, cross$u, $);
                    this.comparator = comparator;
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_BLADE, HASH_BLADE);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    // console.lg(this.name, decodeMode($.getMode()), render_as_infix(expr, $));
                    switch (this.comparator(lhs, rhs, $)) {
                        case SIGN_GT: {
                            return [TFLAG_DIFF, items_to_cons$1(opr, rhs, lhs)];
                        }
                        case SIGN_EQ: {
                            return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3, two, lhs)];
                        }
                        default: {
                            return [TFLAG_HALT, expr];
                        }
                    }
                }
            };
            const add_2_blade_blade = new Builder$52();

            function is_mul_2_rat_blade(expr) {
                return is_mul_2_any_any(expr) && is_rat$1(expr.lhs) && is_blade$1(expr.rhs);
            }

            let Builder$51 = class Builder {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                create($, config) {
                    return new Op$4f($, config);
                }
            };
            let Op$4f = class Op extends Function2 {
                constructor($, config) {
                    super('add_2_blade_mul_2_rat_blade', MATH_ADD$1, is_blade$1, and(is_cons, is_mul_2_rat_blade), $);
                    this.config = config;
                    this.hash = hash_binop_atom_cons(MATH_ADD$1, HASH_BLADE, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    // console.lg(this.name, decodeMode($.getMode()), render_as_infix(expr, $));
                    if (this.config.noOptimize) {
                        return [TFLAG_NONE, expr];
                    }
                    if ($.isExpanding()) {
                        switch (compare_blade_blade(lhs, rhs.rhs)) {
                            case SIGN_GT: {
                                return [TFLAG_DIFF, items_to_cons$1(opr, rhs, lhs)];
                            }
                            case SIGN_EQ: {
                                const sum = rhs.lhs.succ();
                                if (sum.isZero()) {
                                    return [TFLAG_DIFF, zero];
                                }
                                if (sum.isOne()) {
                                    return [TFLAG_DIFF, lhs];
                                }
                                return [TFLAG_DIFF, items_to_cons$1(rhs.opr, sum, lhs)];
                            }
                            default: {
                                return [TFLAG_HALT, expr];
                            }
                        }
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const add_2_blade_mul_2_rat_blade = new Builder$51();

            let Builder$50 = class Builder {
                create($) {
                    return new Op$4e($);
                }
            };
            let Op$4e = class Op extends Function2 {
                constructor($) {
                    super('add_2_flt_any', MATH_ADD$1, is_flt$1, is_any, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_FLT, HASH_ANY);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const rhs_as_flt = evaluate_as_float(rhs, $);
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, rhs_as_flt];
                    }
                    else {
                        // Prevent infinite recursion...
                        if (rhs_as_flt.equals(rhs)) {
                            return [TFLAG_NONE, expr];
                        }
                        else {
                            const sum = $.add(lhs, rhs_as_flt);
                            return wrap_as_transform(sum, expr);
                        }
                    }
                }
            };
            const add_2_flt_any = new Builder$50();

            let Builder$4$ = class Builder {
                create($) {
                    return new Op$4d($);
                }
            };
            let Op$4d = class Op extends Function2 {
                constructor($) {
                    super('add_2_flt_flt', MATH_ADD$1, is_flt$1, is_flt$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_FLT, HASH_FLT);
                }
                transform2(opr, lhs, rhs, orig) {
                    return [TFLAG_DIFF, orig.lhs.add(orig.rhs)];
                }
            };
            const add_2_flt_flt = new Builder$4$();

            let Builder$4_ = class Builder {
                create($) {
                    return new Op$4c($);
                }
            };
            let Op$4c = class Op extends Function2 {
                constructor($) {
                    super('add_2_flt_rat', MATH_ADD$1, is_flt$1, is_rat$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_FLT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    const lhsNum = lhs.toNumber();
                    const rhsNum = rhs.toNumber();
                    return [TFLAG_DIFF, create_flt(lhsNum + rhsNum)];
                }
            };
            const add_2_flt_rat = new Builder$4_();

            function is_uom(p) {
                return p instanceof Uom;
            }
            class UomExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return Uom.ONE.name;
                }
                get hash() {
                    return HASH_UOM;
                }
                get name() {
                    return 'UomExtension';
                }
                get dependencies() {
                    return ['Uom'];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(expr, $) {
                    throw new Error('Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                isKind(arg) {
                    return is_uom(arg);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(arg) {
                    return false;
                }
                isOne(arg) {
                    // TODO: We can have a dimensionless unit, but maybe we should avoid that?
                    // It would make expression simplification easier by avoiding redundancy.
                    return arg.isOne();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                isZero() {
                    // A Unit is never zero becuse it has no weighting factor.
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (is_uom(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                toInfixString(uom) {
                    return uom.toInfixString();
                }
                toLatexString(uom) {
                    // TODO: Can we do better?
                    return uom.toInfixString();
                }
                toListString(uom) {
                    return uom.toListString();
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    if (is_uom(expr)) {
                        return [TFLAG_HALT, expr];
                    }
                    return [TFLAG_NONE, expr];
                }
            }
            /**
             * The Extension for Unit of Measure.
             */
            const uom_extension = new ExtensionOperatorBuilder(function ($) {
                return new UomExtension($);
            });

            let Builder$4Z = class Builder {
                create($) {
                    return new Op$4b($);
                }
            };
            let Op$4b = class Op extends Function2 {
                constructor($) {
                    super('add_2_flt_uom', MATH_ADD$1, is_flt$1, is_uom, $);
                    this.dependencies = ['Flt', 'Uom'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_FLT, HASH_UOM);
                }
                transform2(opr, lhs, rhs, expr) {
                    throw new TypeError(this.$.toInfixString(expr));
                }
            };
            const add_2_flt_uom = new Builder$4Z();

            let Builder$4Y = class Builder {
                create($) {
                    return new Op$4a($);
                }
            };
            /**
             * Imu + Flt => Flt + Imu
             */
            let Op$4a = class Op extends Function2 {
                constructor($) {
                    super('add_2_imu_flt', MATH_ADD$1, is_imu, is_flt$1, $);
                    this.phases = PHASE_FLAGS_EXPANDING_UNION_FACTORING;
                    this.dependencies = ['Flt', 'Imu'];
                    // TODO: This looks like it is assuming the structure of imu.
                    this.hash = hash_binop_cons_atom(MATH_ADD$1, MATH_POW$2, HASH_FLT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, items_to_cons$1(opr, rhs, lhs)];
                }
            };
            const add_2_imu_flt = new Builder$4Y();

            /**
             * A convenience function for swapping lhs and rhs expressions.
             * The value of the operands are not computed.
             */
            function binswap(expr) {
                return items_to_cons$1(expr.opr, expr.rhs, expr.lhs);
            }

            function is_opr_2_lhs_rhs(sym, guardL, guardR) {
                return function (expr) {
                    return is_opr_2_any_any(sym)(expr) && guardL(expr.lhs) && guardR(expr.rhs);
                };
            }

            let Builder$4X = class Builder {
                create($) {
                    return new Op$49($);
                }
            };
            /**
             * (y * i) + x => x + (y * i)
             */
            let Op$49 = class Op extends Function2 {
                constructor($) {
                    super('add_2_mul_2_any_imu_sym', MATH_ADD$1, and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, is_any, is_imu)), is_sym, $);
                    this.hash = hash_binop_cons_atom(MATH_ADD$1, MATH_MUL$3, HASH_SYM);
                }
                transform2(opr, lhs, rhs, orig) {
                    return [TFLAG_DIFF, binswap(orig)];
                }
            };
            const add_2_mul_2_any_imu_sym = new Builder$4X();

            function is_mul_2_rat_any(expr) {
                return is_mul_2_any_any(expr) && is_rat$1(expr.lhs);
            }

            let Builder$4W = class Builder {
                create($) {
                    return new Op$48($);
                }
            };
            function cross$t(lhs, rhs) {
                const x1 = lhs.rhs;
                const x2 = rhs.rhs;
                if (x1.equals(x2)) {
                    return true;
                }
                return false;
            }
            /**
             * (p * X) + (q * X) => (p + q) * X
             */
            let Op$48 = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_rat_X_mul_2_rat_X', MATH_ADD$1, and(is_cons, is_mul_2_rat_any), and(is_cons, is_mul_2_rat_any), cross$t, $);
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const p = lhs.lhs;
                    const X = lhs.rhs;
                    const q = rhs.lhs;
                    const pq = p.add(q);
                    const retval = $.valueOf(items_to_cons$1(MATH_MUL$3, pq, X));
                    return [TFLAG_DIFF, retval];
                }
            };
            const add_2_mul_2_rat_X_mul_2_rat_X = new Builder$4W();

            let Builder$4V = class Builder {
                create($) {
                    return new Op$47($);
                }
            };
            function cross$s(lhs, rhs) {
                return compare_sym_sym(lhs.rhs, rhs) > 0;
            }
            //
            // (Rat * zzz) + aaa => aaa + (Rat * zzz)
            //
            let Op$47 = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_rat_zzz_aaa', MATH_ADD$1, and(is_cons, is_mul_2_rat_sym), is_sym, cross$s, $);
                    this.hash = hash_binop_cons_atom(MATH_ADD$1, MATH_MUL$3, HASH_SYM);
                }
                transform2(opr, lhs, rhs, orig) {
                    return [TFLAG_DIFF, binswap(orig)];
                }
            };
            const add_2_mul_2_rat_zzz_aaa = new Builder$4V();

            let Builder$4U = class Builder {
                create($) {
                    return new Op$46($);
                }
            };
            /**
             * Power + Multiply => Multiply + Power (prettyfmtMode only)
             * THIS SEEMS TO CONFLICT
             */
            let Op$46 = class Op extends Function2 {
                constructor($) {
                    super('add_2_pow_2_any_any_mul_2_any_any', MATH_ADD$1, and(is_cons, is_pow_2_any_any), and(is_cons, is_mul_2_any_any), $);
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_POW$2, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    // const $ = this.$;
                    /*
                    if ($.prettyfmtMode) {
                        return [true, reverse_binop(orig)];
                    }
                    */
                    return [TFLAG_NONE, orig];
                }
            };
            const add_2_pow_2_any_any_mul_2_any_any = new Builder$4U();

            let Builder$4T = class Builder {
                create($) {
                    return new Op$45($);
                }
            };
            let Op$45 = class Op extends Function2 {
                constructor($) {
                    super('add_2_rat_blade', MATH_ADD$1, is_rat$1, is_blade$1, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_RAT, HASH_BLADE);
                }
                transform2(opr, lhs, rhs, expr) {
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    else {
                        // It's a multivector in canonical order.
                        return [TFLAG_HALT, expr];
                    }
                }
            };
            const add_2_rat_blade = new Builder$4T();

            let Builder$4S = class Builder {
                create($) {
                    return new Op$44($);
                }
            };
            /**
             * Rat + Flt => Flt
             */
            let Op$44 = class Op extends Function2 {
                constructor($) {
                    super('add_rat_flt', MATH_ADD$1, is_rat$1, is_flt$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_RAT, HASH_FLT);
                }
                transform2(opr, lhs, rhs) {
                    const lhsNum = lhs.toNumber();
                    const rhsNum = rhs.toNumber();
                    return [TFLAG_DIFF, create_flt(lhsNum + rhsNum)];
                }
            };
            const add_2_rat_flt = new Builder$4S();

            let Builder$4R = class Builder {
                create($) {
                    return new Op$43($);
                }
            };
            /**
             * Rat + Rat => Rat
             */
            let Op$43 = class Op extends Function2 {
                constructor($) {
                    super('add_2_rat_rat', MATH_ADD$1, is_rat$1, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_RAT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.add(rhs)];
                }
            };
            const add_2_rat_rat = new Builder$4R();

            let Builder$4Q = class Builder {
                create($) {
                    return new Op$42($);
                }
            };
            /**
             * Rat + Sym => Rat + Sym (Rat != 0)
             *           => Sym       (Rat == 0)
             */
            let Op$42 = class Op extends Function2 {
                constructor($) {
                    super('add_2_rat_sym', MATH_ADD$1, is_rat$1, is_sym, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_RAT, HASH_SYM);
                }
                isScalar(expr) {
                    const lhs = expr.lhs;
                    const rhs = expr.rhs;
                    // console.lg(`lhs=${lhs}`);
                    // console.lg(`rhs=${rhs}`);
                    return this.$.isScalar(lhs) && this.$.isScalar(rhs);
                }
                isReal(expr) {
                    const lhs = expr.lhs;
                    const rhs = expr.rhs;
                    // console.lg(`lhs=${lhs}`);
                    // console.lg(`rhs=${rhs}`);
                    // Stronger than needed...
                    return this.$.is_real(lhs) && this.$.is_real(rhs);
                }
                transform2(opr, lhs, rhs, orig) {
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    return [TFLAG_HALT, orig];
                }
            };
            const add_2_rat_sym = new Builder$4Q();

            let Builder$4P = class Builder {
                create($) {
                    return new Op$41($);
                }
            };
            let Op$41 = class Op extends Function2 {
                constructor($) {
                    super('add_2_rat_uom', MATH_ADD$1, is_rat$1, is_uom, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_RAT, HASH_UOM);
                }
                transform2(opr, lhs, rhs, expr) {
                    throw new TypeError(this.$.toInfixString(expr));
                }
            };
            const add_2_rat_uom = new Builder$4P();

            let Builder$4O = class Builder {
                create($) {
                    return new Op$40($);
                }
            };
            /**
             * Sym + Rat => Rat + Sym
             */
            let Op$40 = class Op extends Function2 {
                constructor($) {
                    super('add_2_sym_rat', MATH_ADD$1, is_sym, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_SYM, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    else {
                        const $ = this.$;
                        return [TFLAG_DIFF, $.valueOf(items_to_cons$1(opr, rhs, lhs))];
                    }
                }
            };
            const add_2_sym_rat = new Builder$4O();

            let Builder$4N = class Builder {
                create($) {
                    return new Op$3$($);
                }
            };
            /**
             * b + a => a + b
             * a + a => 2 * a
             */
            let Op$3$ = class Op extends Function2 {
                constructor($) {
                    super('add_2_sym_sym', MATH_ADD$1, is_sym, is_sym, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_SYM, HASH_SYM);
                }
                transform2(opr, lhs, rhs, orig) {
                    switch (compare_sym_sym(lhs, rhs)) {
                        case SIGN_GT: {
                            return [TFLAG_DIFF, items_to_cons$1(opr, rhs, lhs)];
                        }
                        case SIGN_LT: {
                            return [TFLAG_HALT, orig];
                        }
                        default: {
                            if (lhs.equals(rhs)) {
                                return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), two, lhs)];
                            }
                            else {
                                return [TFLAG_HALT, orig];
                            }
                        }
                    }
                }
            };
            const add_2_sym_sym = new Builder$4N();

            /**
             * Computes the infix representation of the expression.
             * Infix notation is the notation commonly used in arithmetical and logical formulae and statements.
             * It is characterized by the placement of operators between operands.
             * @param expr The expression for which the infix notation is required. MUST be defined.
             */
            function to_infix_string(expr, $) {
                // The following deserves explaination.
                // Does print_term not print signs?. How would it know not to?
                if (sign_of_term(expr) === '-') {
                    return `-${print_multiplicative_expr(expr, $)}`;
                }
                else {
                    return print_multiplicative_expr(expr, $);
                }
            }

            function equal_elements(as, bs, $) {
                const length = as.length;
                for (let i = 0; i < length; i++) {
                    const cmp = $.equals(as[i], bs[i]);
                    if (!cmp) {
                        return false;
                    }
                }
                return true;
            }
            function add_tensor_tensor(A, B, $) {
                if (!A.sameDimensions(B)) {
                    return nil;
                }
                return A.map(function (a, i) {
                    return $.add(a, B.elem(i));
                });
            }
            class TensorExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                    // Nothing to see here.
                }
                get key() {
                    return HASH_TENSOR;
                }
                get hash() {
                    return HASH_TENSOR;
                }
                get name() {
                    return 'TensorExtension';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                isKind(arg) {
                    return arg instanceof Tensor;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(arg) {
                    // TODO: What about the square matrix identity element for multiplication? 
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(arg) {
                    // TODO: What about the square matrix identity element for multiplication? 
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                isScalar() {
                    return false;
                }
                isZero(arg, $) {
                    return arg.everyElement(function (element) {
                        return $.is_zero(element);
                    });
                }
                subst(expr, oldExpr, newExpr, $) {
                    if (is_tensor(oldExpr) && expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    const elems = expr.mapElements((elem) => {
                        const result = subst(elem, oldExpr, newExpr, $);
                        return result;
                    });
                    if (equal_elements(expr.copyElements(), elems, $)) {
                        return expr;
                    }
                    else {
                        return expr.withElements(elems);
                    }
                }
                toInfixString(matrix, $) {
                    return to_infix_string(matrix, $);
                }
                toLatexString(matrix, $) {
                    return to_infix_string(matrix, $);
                }
                toListString(matrix, $) {
                    return to_infix_string(matrix, $);
                }
                evaluate(matrix, argList) {
                    return this.transform(cons(matrix, argList));
                }
                transform(expr) {
                    const $ = this.$;
                    // console.lg(`TensorExtension.transform ${print_expr(expr, $)}`);
                    if (this.isKind(expr)) {
                        const new_elements = expr.mapElements(function (element) {
                            return $.valueOf(element);
                        });
                        // TODO: We should only create a new expression if the elements have changed.
                        // To do this...
                        // 1. zip the old and new elements together.
                        // 2. Determine if there have been changes.
                        // 3. Possibly construct a new matrix.
                        const retval = expr.withElements(new_elements);
                        const changed = !retval.equals(expr);
                        return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                    }
                    return [TFLAG_NONE, expr];
                }
                valueOf(expr, $) {
                    // const old_elements = expr.copyElements();
                    const new_elements = expr.mapElements(function (element) {
                        return $.valueOf(element);
                    });
                    // TODO: We should only create a new expression if the elements have changed.
                    // To do this...
                    // 1. zip the ols and new elements together.
                    // 2. Determine if there have been changes.
                    // 3. Possibly construct a new matrix.
                    return expr.withElements(new_elements);
                }
            }
            const tensor_extension = new ExtensionOperatorBuilder(function ($) {
                return new TensorExtension($);
            });

            let Builder$4M = class Builder {
                create($) {
                    return new Op$3_($);
                }
            };
            /**
             * Tensor + Tensor => Tensor
             */
            let Op$3_ = class Op extends Function2 {
                constructor($) {
                    super('add_2_tensor_tensor', MATH_ADD$1, is_tensor, is_tensor, $);
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_TENSOR, HASH_TENSOR);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    return [TFLAG_DIFF, add_tensor_tensor(lhs, rhs, $)];
                }
            };
            const add_2_tensor_tensor = new Builder$4M();

            let Builder$4L = class Builder {
                create($) {
                    return new Op$3Z($);
                }
            };
            let Op$3Z = class Op extends Function2 {
                constructor($) {
                    super('add_2_uom_flt', MATH_ADD$1, is_uom, is_flt$1, $);
                    this.dependencies = ['Flt', 'Uom'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_UOM, HASH_FLT);
                }
                transform2(opr, lhs, rhs, expr) {
                    throw new TypeError(this.$.toInfixString(expr));
                }
            };
            const add_2_uom_flt = new Builder$4L();

            let Builder$4K = class Builder {
                create($) {
                    return new Op$3Y($);
                }
            };
            let Op$3Y = class Op extends Function2 {
                constructor($) {
                    super('add_2_uom_rat', MATH_ADD$1, is_uom, is_rat$1, $);
                    this.dependencies = ['Uom'];
                    this.hash = hash_binop_atom_atom(MATH_ADD$1, HASH_UOM, HASH_RAT);
                }
                transform2(opr, lhs, rhs, expr) {
                    throw new TypeError(this.$.toInfixString(expr));
                }
            };
            const add_2_uom_rat = new Builder$4K();

            let Builder$4J = class Builder {
                create($) {
                    return new Op$3X($);
                }
            };
            function cross$r(lhs, rhs) {
                return rhs.lhs.isMinusOne() && lhs.equalsSym(rhs.rhs);
            }
            /**
             * x + (-1 * x) => 0, where
             */
            let Op$3X = class Op extends Function2X {
                constructor($) {
                    super('add_2_xxx_mul_2_rm1_xxx', MATH_ADD$1, is_sym, and(is_cons, is_mul_2_rat_sym), cross$r, $);
                    this.hash = hash_binop_atom_cons(MATH_ADD$1, HASH_SYM, MATH_MUL$3);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    return [TFLAG_DIFF, zero];
                }
            };
            /**
             * x + (-1 * x) => 0, where x is a Sym and -1 is a Rat.
             */
            const add_2_xxx_mul_2_rm1_xxx = new Builder$4J();

            function Eval_add(expr, $) {
                // console.lg("Eval_add", $.toSExprString(expr));
                const terms = [];
                const args = expr.argList;
                const vals = args.map($.valueOf);
                if (vals.equals(args)) {
                    const values = [...vals];
                    const some_term_is_zero_float = values.some((term) => is_flt$1(term) && term.isZero());
                    for (const value of values) {
                        if (some_term_is_zero_float) {
                            push_terms(terms, evaluate_as_float(value, $));
                        }
                        else {
                            push_terms(terms, $.valueOf(value));
                        }
                    }
                    return add_terms(terms, $);
                }
                else {
                    // Evaluation of the arguments has produced changes so we give other operators a chance to evaluate.
                    return $.valueOf(cons(expr.car, vals));
                }
            }
            /**
             * Pushes a term onto the terms array with side effects that association is removed and zeros are omitted.
             */
            function push_terms(terms, term) {
                if (is_add(term)) {
                    terms.push(...term.tail());
                }
                else if (is_num(term) && term.isZero()) ;
                else {
                    terms.push(term);
                }
            }
            function add_terms(terms, $) {
                // console.lg("add_terms");
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                terms.forEach(function (term) {
                    // console.lg("term", render_as_infix(term, $));
                });
                /**
                 * The canonical comparator function for comparing terms.
                 */
                const cmp_terms = $.compareFn(MATH_ADD$1);
                // ensure no infinite loop, use "for"
                for (let i = 0; i < 10; i++) {
                    if (terms.length < 2) {
                        break;
                    }
                    let flag = 0;
                    const compareFn = function (rawL, rawR) {
                        if (is_num(rawL) && is_num(rawR)) {
                            // Num(s) can be combined.
                            flag = 1;
                            return SIGN_EQ;
                        }
                        // We make sure that terms differing only in numerical factors can be combined.
                        // We don't assume that the canonical addition comparator will return SIGN_EQ
                        // if the numerical factors are the same (even though this might be reasonable).
                        const lhs = canonical_factor_num_rhs(rawL);
                        const rhs = canonical_factor_num_rhs(rawR);
                        if (is_tensor(lhs) && is_tensor(rhs)) {
                            if (lhs.ndim < rhs.ndim) {
                                return SIGN_LT;
                            }
                            if (lhs.ndim > rhs.ndim) {
                                return SIGN_GT;
                            }
                            const rank = lhs.ndim;
                            for (let i = 0; i < rank; i++) {
                                if (lhs.dim(i) < rhs.dim(i)) {
                                    return SIGN_LT;
                                }
                                if (lhs.dim(i) > rhs.dim(i)) {
                                    return SIGN_GT;
                                }
                            }
                            flag = 1;
                            return SIGN_EQ;
                        }
                        if (contains_single_blade(lhs) && contains_single_blade(rhs)) {
                            const bladeL = extract_single_blade(lhs);
                            const bladeR = extract_single_blade(rhs);
                            switch (compare_blade_blade(bladeL, bladeR)) {
                                case SIGN_LT: {
                                    return SIGN_LT;
                                }
                                case SIGN_GT: {
                                    return SIGN_GT;
                                }
                                default: {
                                    switch (cmp_terms(remove_factors(lhs, is_blade$1), remove_factors(rhs, is_blade$1))) {
                                        case SIGN_LT: {
                                            return SIGN_LT;
                                        }
                                        case SIGN_GT: {
                                            return SIGN_GT;
                                        }
                                        case SIGN_EQ: {
                                            // We have terms containing a single common blade that can be combined.
                                            flag = 1;
                                            return SIGN_EQ;
                                        }
                                    }
                                }
                            }
                        }
                        const sign = cmp_terms(lhs, rhs);
                        // console.lg("sign", sign);
                        if (sign === SIGN_EQ) {
                            // TODO: How would we end up here?
                            flag = 1;
                        }
                        return sign;
                    };
                    // console.lg("sorting terms");
                    terms.sort(compareFn);
                    if (flag === 0) {
                        break;
                    }
                    combine_terms(terms, $);
                }
                switch (terms.length) {
                    case 0: {
                        // We are assuming here that any zeros that were thrown away were Rat(s).
                        // But we may have thrown away a float.
                        // console.lg("terms are empty, returning a Rat");
                        return zero;
                    }
                    case 1: {
                        return terms[0];
                    }
                    default: {
                        terms.unshift(MATH_ADD$1);
                        return items_to_cons$1(...terms);
                    }
                }
            }
            function combine_terms(terms, $) {
                // console.lg("combine_terms");
                // I had to turn the coffeescript for loop into
                // a more mundane while loop because the i
                // variable was changed from within the body,
                // which is something that is not supposed to
                // happen in the coffeescript 'vector' form.
                // Also this means I had to add a 'i++' jus before
                // the end of the body and before the "continue"s
                let i = 0;
                while (i < terms.length - 1) {
                    let lhs = terms[i];
                    let rhs = terms[i + 1];
                    if (is_tensor(lhs) && is_tensor(rhs)) {
                        const sum = add_tensor_tensor(lhs, rhs, $);
                        if (!is_nil(sum)) {
                            terms.splice(i, 2, sum);
                            i--;
                        }
                        i++;
                        continue;
                    }
                    if (is_tensor(lhs) || is_tensor(rhs)) {
                        i++;
                        continue;
                    }
                    if (is_num(lhs) && is_num(rhs)) {
                        const sum = add_num_num(lhs, rhs);
                        // console.lg("sum", render_as_infix(sum, $));
                        if (is_num_or_tensor_and_zero(sum, $)) {
                            // At this point we are in danger of forgetting if the zero was a Flt (as opposed to a Rat).
                            // If there are exactly two terms, keep the sum as a zero with a particular type.
                            // console.lg("terms.length", terms.length);
                            if (terms.length === 2) {
                                terms.splice(i, 2, sum);
                            }
                            else {
                                terms.splice(i, 2);
                            }
                        }
                        else {
                            terms.splice(i, 2, sum);
                        }
                        i--;
                        i++;
                        continue;
                    }
                    if (is_num(lhs) || is_num(rhs)) {
                        i++;
                        continue;
                    }
                    let p1 = one;
                    let p2 = one;
                    let t = 0;
                    if (is_multiply(lhs)) {
                        lhs = cdr(lhs);
                        t = 1; // p3 is now denormal
                        if (is_num(car(lhs))) {
                            p1 = car(lhs);
                            lhs = cdr(lhs);
                            if (is_nil(cdr(lhs))) {
                                lhs = car(lhs);
                                t = 0;
                            }
                        }
                    }
                    if (is_multiply(rhs)) {
                        rhs = cdr(rhs);
                        if (is_num(car(rhs))) {
                            p2 = car(rhs);
                            rhs = cdr(rhs);
                            if (is_nil(cdr(rhs))) {
                                rhs = car(rhs);
                            }
                        }
                    }
                    if (!lhs.equals(rhs)) {
                        i++;
                        continue;
                    }
                    p1 = add_num_num(p1, p2);
                    if (is_num_or_tensor_and_zero(p1, $)) {
                        terms.splice(i, 2);
                        i--;
                        i++;
                        continue;
                    }
                    const arg2 = t ? cons(MATH_MUL$3, lhs) : lhs;
                    terms.splice(i, 2, $.multiply(p1, arg2));
                    i--;
                    // this i++ is to match the while
                    i++;
                }
            }
            function is_num_or_tensor_and_zero(expr, $) {
                return is_num_and_zero(expr) || is_tensor_and_zero(expr, $);
            }
            function is_num_and_zero(expr) {
                return is_num(expr) && expr.isZero();
            }
            function is_tensor_and_zero(expr, $) {
                // TODO: We can see here that we could simply as if the term is zero.
                return is_tensor(expr) && $.is_zero(expr);
            }

            let Builder$4I = class Builder {
                create($) {
                    return new AddOperator($);
                }
            };
            /**
             * (+)
             * (+ a)
             * (+ a b)
             * (+ a b c ...)
             */
            class AddOperator extends FunctionVarArgs {
                constructor($) {
                    super('add_varargs', ADD$7, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    // console.lg(this.name, render_as_sexpr(expr, $));
                    const hook = (where, retval) => {
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_infix(expr, this.$), "=>", render_as_infix(retval, $));
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_sexpr(expr, this.$), "=>", render_as_sexpr(retval, $));
                        return retval;
                    };
                    const retval = Eval_add(expr, $);
                    const flag = retval.equals(expr) ? TFLAG_NONE : TFLAG_DIFF;
                    return [flag, hook('A', retval)];
                }
            }
            const add_varargs = new Builder$4I();

            /* det =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            m

            General description
            -------------------
            Returns the determinant of matrix m.
            Uses Gaussian elimination for numerical matrices.

            Example:

              det(((1,2),(3,4)))
              > -2

            */
            function det(M, $) {
                const hook = function (retval) {
                    // console.lg(`det of ${$.toInfixString(M)} => ${$.toInfixString(retval)}`);
                    return retval;
                };
                if (!is_square_matrix(M)) {
                    // console.lg(`must be square M=${print_expr(M, $)}`);
                    return hook(items_to_cons(DET, M));
                }
                const elems = M.copyElements();
                const is_numeric = elems.every((element) => is_num(element));
                if (is_numeric) {
                    return hook(determinant_numeric(M, $));
                }
                else {
                    return hook(determinant_symbolic(elems, M.dim(0), $));
                }
            }
            // determinant of n * n matrix elements on the stack
            function determinant_symbolic(elements, n, $) {
                if (n === 0) {
                    // The remainder of this code should do this!
                    return one;
                }
                let q = 0;
                const a = [];
                for (let i = 0; i < n; i++) {
                    a[i] = i;
                    a[i + n] = 0;
                    a[i + n + n] = 1;
                }
                let sign_ = 1;
                let outerTemp = zero;
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    let temp = create_int(sign_);
                    for (let i = 0; i < n; i++) {
                        const k = (n * a[i] + i);
                        temp = $.multiply(temp, elements[k]); // FIXME -- problem here
                    }
                    outerTemp = $.add(outerTemp, temp);
                    // next permutation (Knuth's algorithm P)
                    let j = n - 1;
                    let s = 0;
                    let break_from_outer_loop = false;
                    // eslint-disable-next-line no-constant-condition
                    while (true) {
                        q = a[n + j] + a[n + n + j];
                        if (q < 0) {
                            a[n + n + j] = -a[n + n + j];
                            j--;
                            continue;
                        }
                        if (q === j + 1) {
                            if (j === 0) {
                                break_from_outer_loop = true;
                                break;
                            }
                            s++;
                            a[n + n + j] = -a[n + n + j];
                            j--;
                            continue;
                        }
                        break;
                    }
                    if (break_from_outer_loop) {
                        break;
                    }
                    const t = a[j - a[n + j] + s];
                    a[j - a[n + j] + s] = a[j - q + s];
                    a[j - q + s] = t;
                    a[n + j] = q;
                    sign_ = sign_ === 1 ? -1 : 1;
                }
                return outerTemp;
            }
            /**
             * Uses Gaussian elimination which is faster for numerical matrices.
             *
             * @param m
             * @param $
             * @returns
             */
            function determinant_numeric(m, $) {
                const n = m.dim(0);
                const elements = m.copyElements();
                const decomp = lu_decomp(elements, n, $);
                return decomp;
            }
            function getM(arr, n, i, j) {
                return arr[n * i + j];
            }
            function setM(arr, n, i, j, value) {
                arr[n * i + j] = value;
            }
            //-----------------------------------------------------------------------------
            //
            //  Input:    n * n matrix elements
            //
            //  Output:    upper diagonal matrix
            //
            //-----------------------------------------------------------------------------
            function lu_decomp(elements, n, $) {
                let p1 = one;
                for (let d = 0; d < n - 1; d++) {
                    if ($.equals(getM(elements, n, d, d), zero)) {
                        let i = 0;
                        for (i = d + 1; i < n; i++) {
                            if (!$.equals(getM(elements, n, i, d), zero)) {
                                break;
                            }
                        }
                        if (i === n) {
                            p1 = zero;
                            break;
                        }
                        // exchange rows
                        for (let j = d; j < n; j++) {
                            const p2 = getM(elements, n, d, j);
                            setM(elements, n, d, j, getM(elements, n, i, j));
                            setM(elements, n, i, j, p2);
                        }
                        // negate det
                        p1 = $.negate(p1);
                    }
                    // update det
                    p1 = $.multiply(p1, getM(elements, n, d, d));
                    // update lower diagonal matrix
                    for (let i = d + 1; i < n; i++) {
                        const p2 = $.negate(divide(getM(elements, n, i, d), getM(elements, n, d, d), $));
                        // update one row
                        setM(elements, n, i, d, zero); // clear column below pivot d
                        for (let j = d + 1; j < n; j++) {
                            const added = $.add($.multiply(getM(elements, n, d, j), p2), getM(elements, n, i, j));
                            setM(elements, n, i, j, added);
                        }
                    }
                }
                // last diagonal element
                return $.multiply(p1, getM(elements, n, n - 1, n - 1));
            }

            //-----------------------------------------------------------------------------
            //
            //  Input:    Matrix (must have two dimensions but it can be non-numerical)
            //
            //  Output:    Inverse
            //
            //  Example:
            //
            //  > inv(((1,2),(3,4))
            //  ((-2,1),(3/2,-1/2))
            //
            //  > inv(((a,b),(c,d))
            //  ((d / (a d - b c),-b / (a d - b c)),(-c / (a d - b c),a / (a d - b c)))
            //
            //  Note:
            //
            //  THIS IS DIFFERENT FROM INVERSE OF AN EXPRESSION (inv)
            //   Uses Gaussian elimination for numerical matrices.
            //
            //-----------------------------------------------------------------------------
            function inv(expr, $) {
                const hook = function (retval) {
                    // console.lg(`inv of ${$.toInfixString(p1)} => ${$.toInfixString(retval)}`);
                    return retval;
                };
                // an inv just goes away when applied to another inv
                if (is_cons(expr) && is_opr_eq_inv(expr)) {
                    return expr.argList;
                }
                // inverse goes away in case of identity matrix
                if (is_identity_matrix(expr)) {
                    return hook(expr);
                }
                // distribute the inverse of a dot if in expanding mode
                // note that the distribution happens in reverse.
                // The dot operator is not commutative, so, it matters.
                if ($.isExpanding() && is_inner_or_dot(expr)) {
                    const accumulator = is_cons(expr) ? expr.tail() : [];
                    const inverses = accumulator.map(function (x) {
                        return inv(x, $);
                    });
                    for (let i = inverses.length - 1; i > 0; i--) {
                        inverses[i - 1] = $.inner(inverses[i], inverses[i - 1]);
                    }
                    return hook(inverses[0]);
                }
                if (!is_square_matrix(expr)) {
                    return hook(items_to_cons$1(INV$1, expr));
                }
                if (is_num_or_tensor_or_identity_matrix(expr)) {
                    return hook(inverse_tensor(expr, $));
                }
                const p2 = det(expr, $);
                if ($.is_zero(p2)) {
                    halt('inverse of singular matrix');
                }
                return hook(divide(adj(expr, $), p2, $));
            }
            // inverse using gaussian elimination
            function inverse_tensor(M, $) {
                const n = M.dim(0);
                // create an identity matrix
                const units = new Array(n * n);
                units.fill(zero);
                for (let i = 0; i < n; i++) {
                    units[i * n + i] = one;
                }
                const inverse = INV_decomp(units, M.copyElements(), n, $);
                return new Tensor([n, n], inverse);
            }
            //-----------------------------------------------------------------------------
            //
            //  Input:    n * n unit matrix
            //            n * n operand
            //
            //  Output:    n * n inverse matrix
            //
            //-----------------------------------------------------------------------------
            function INV_decomp(units, elements, n, $) {
                for (let d = 0; d < n; d++) {
                    if ($.equals(elements[n * d + d], zero)) {
                        let i = 0;
                        for (i = d + 1; i < n; i++) {
                            if (!$.equals(elements[n * i + d], zero)) {
                                break;
                            }
                        }
                        if (i === n) {
                            halt('inverse of singular matrix');
                        }
                        // exchange rows
                        for (let j = 0; j < n; j++) {
                            let p2 = elements[n * d + j];
                            elements[n * d + j] = elements[n * i + j];
                            elements[n * i + j] = p2;
                            p2 = units[n * d + j];
                            units[n * d + j] = units[n * i + j];
                            units[n * i + j] = p2;
                        }
                    }
                    // multiply the pivot row by 1 / pivot
                    const p2 = elements[n * d + d];
                    for (let j = 0; j < n; j++) {
                        if (j > d) {
                            elements[n * d + j] = divide(elements[n * d + j], p2, $);
                        }
                        units[n * d + j] = divide(units[n * d + j], p2, $);
                    }
                    for (let i = 0; i < n; i++) {
                        if (i === d) {
                            continue;
                        }
                        // multiplier
                        const p2 = elements[n * i + d];
                        for (let j = 0; j < n; j++) {
                            if (j > d) {
                                elements[n * i + j] = $.subtract(elements[n * i + j], $.multiply(elements[n * d + j], p2));
                            }
                            units[n * i + j] = $.subtract(units[n * i + j], $.multiply(units[n * d + j], p2));
                        }
                    }
                }
                return units;
            }

            function Eval_dirac(p1, $) {
                return dirac($.valueOf(cadr(p1)), $);
            }
            function dirac(p1, $) {
                if (is_flt$1(p1)) {
                    if ($.is_zero(p1)) {
                        return one;
                    }
                    return zero;
                }
                if (is_rat$1(p1)) {
                    if ($.is_zero(p1)) {
                        return one;
                    }
                    return zero;
                }
                if (is_power(p1)) {
                    return items_to_cons$1(DIRAC, cadr(p1));
                }
                if (is_negative(p1)) {
                    return items_to_cons$1(DIRAC, $.negate(p1));
                }
                if (is_negative(p1) || (is_cons(p1) && is_add(p1) && is_negative(cadr(p1)))) {
                    p1 = $.negate(p1);
                }
                return items_to_cons$1(DIRAC, p1);
            }

            /* besselj =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x,n

            General description
            -------------------

            Returns a solution to the Bessel differential equation (Bessel function of first kind).

            Recurrence relation:

              besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)

              besselj(x,1/2) = sqrt(2/pi/x) sin(x)

              besselj(x,-1/2) = sqrt(2/pi/x) cos(x)

            For negative n, reorder the recurrence relation as:

              besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)

            Substitute n+2 for n to obtain

              besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)

            Examples:

              besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)

              besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)

            */
            function Eval_besselj(p1, $) {
                return besselj($.valueOf(cadr(p1)), $.valueOf(caddr(p1)), $);
            }
            function besselj(p1, p2, $) {
                return yybesselj(p1, p2, $);
            }
            function yybesselj(X, N, $) {
                const n = nativeInt(N);
                // numerical result
                if (is_flt$1(X) && !isNaN(n)) {
                    const d = jn(n, X.d);
                    return create_flt(d);
                }
                // bessej(0,0) = 1
                if ($.is_zero(X) && $.is_zero(N)) {
                    return one;
                }
                // besselj(0,n) = 0
                if ($.is_zero(X) && !isNaN(n)) {
                    return zero;
                }
                // half arguments
                if (is_rat$1(N) && MEQUAL(N.b, 2)) {
                    // n = 1/2
                    if (MEQUAL(N.a, 1)) {
                        const twoOverPi = $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(2.0 / Math.PI) : divide(two, PI$7, $);
                        return $.multiply($.power(divide(twoOverPi, X, $), half), sin(X, $));
                    }
                    // n = -1/2
                    if (MEQUAL(N.a, -1)) {
                        const twoOverPi = $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(2.0 / Math.PI) : divide(two, PI$7, $);
                        return $.multiply($.power(divide(twoOverPi, X, $), half), cos(X, $));
                    }
                    // besselj(x,n) = (2/x) (n-sgn(n)) besselj(x,n-sgn(n)) - besselj(x,n-2*sgn(n))
                    const SGN = create_int(MSIGN(N.a));
                    return $.subtract($.multiply($.multiply(divide(two, X, $), N.sub(SGN)), besselj(X, $.subtract(N, SGN), $)), besselj(X, $.subtract(N, two.mul(SGN)), $));
                }
                //if 0 # test cases needed
                if (is_negative(X)) {
                    return $.multiply($.multiply($.power($.negate(X), N), $.power(X, $.negate(N))), items_to_cons(BESSELJ, $.negate(X), N));
                }
                if (is_negative(N)) {
                    return $.multiply($.power(negOne, N), items_to_cons(BESSELJ, X, $.negate(N)));
                }
                return items_to_cons(BESSELJ, X, N);
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function jn(n, x) {
                throw new Error('Not implemented');
                // See https://git.musl-libc.org/cgit/musl/tree/src/math/jn.c
                // https://github.com/SheetJS/bessel
            }

            /* bessely =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x,n

            General description
            -------------------

            Bessel function of second kind.

            */
            function Eval_bessely(p1, $) {
                return bessely($.valueOf(cadr(p1)), $.valueOf(caddr(p1)), $);
            }
            function bessely(p1, p2, $) {
                return yybessely(p1, p2, $);
            }
            function yybessely(X, N, $) {
                const n = nativeInt(N);
                if (is_flt$1(X) && !isNaN(n)) {
                    const d = yn(n, X.d);
                    return create_flt(d);
                }
                if (is_negative(N)) {
                    return $.multiply($.power(negOne, N), items_to_cons(BESSELY, X, $.negate(N)));
                }
                return items_to_cons(BESSELY, X, N);
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function yn(n, x) {
                throw new Error('Not implemented');
                // See https://git.musl-libc.org/cgit/musl/tree/src/math/jn.c
                // https://github.com/SheetJS/bessel
            }

            /* cosh =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the hyperbolic cosine of x

            ```
                        exp(x) + exp(-x)
              cosh(x) = ----------------
                               2
            ```

            */
            function Eval_cosh(p1, $) {
                return ycosh($.valueOf(cadr(p1)), $);
            }
            function ycosh(p1, $) {
                if (car(p1).equals(ARCCOSH)) {
                    return cadr(p1);
                }
                if (is_flt$1(p1)) {
                    let d = Math.cosh(p1.d);
                    if (Math.abs(d) < 1e-10) {
                        d = 0.0;
                    }
                    return create_flt(d);
                }
                if ($.is_zero(p1)) {
                    return one;
                }
                return items_to_cons$1(COSH, p1);
            }

            //-----------------------------------------------------------------------------
            //
            //  Hermite polynomial
            //
            //  Input:    p1    x  (can be a symbol or expr)
            //            p2    n
            //
            //  Output:    Result
            //
            //-----------------------------------------------------------------------------
            function hermite(p1, p2, $) {
                return yyhermite(p1, p2, $);
            }
            // uses the recurrence relation H(x,n+1)=2*x*H(x,n)-2*n*H(x,n-1) = 2 * (x*H(x,n)-n*H(x,n-1))
            function yyhermite(X, N, $) {
                const n = nativeInt(N);
                if (n < 0 || isNaN(n)) {
                    return items_to_cons(HERMITE, X, N);
                }
                if (is_sym(X)) {
                    return yyhermite2(n, X, $);
                }
                return $.valueOf(subst(yyhermite2(n, SECRETX, $), SECRETX, X, $));
            }
            function yyhermite2(n, X, $) {
                let Y1 = zero;
                let temp = one;
                for (let i = 0; i < n; i++) {
                    const Y0 = Y1;
                    Y1 = temp;
                    temp = $.multiply($.subtract($.multiply(X, Y1), $.multiply(create_int(i), Y0)), two);
                }
                return temp;
            }

            let Builder$4H = class Builder {
                create($) {
                    return new SgnFlt$1($);
                }
            };
            let SgnFlt$1 = class SgnFlt extends Function1 {
                constructor($) {
                    super('sgn_any', SGN, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                // This may not be needed for uniqueness because of hash in other operators.
                isKind(expr) {
                    if (super.isKind(expr)) {
                        if (is_flt$1(expr)) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, sgn(arg, this.$)];
                }
            };
            const sgn_any = new Builder$4H();
            /**
             * sgn(x) = x / abs(x) is the generalized defnition.
             * The meaning is that we are discerning the normalized direction.
             */
            function sgn(X, $) {
                // TODO: The definition is undefined when abs(x) is zero.
                // But in the case of numbers, sgn evaluates to zero.
                const numer = X;
                const denom = abs$1(X, $);
                return divide(numer, denom, $);
            }

            //            exp(x) - exp(-x)
            //  sinh(x) = ----------------
            //                   2
            /**
             * sinh(x) = (1/2) * (exp(x) - exp(-x))
             */
            function sinh(expr, $) {
                if (car(expr).equals(ARCSINH)) {
                    return cadr(expr);
                }
                if (is_flt$1(expr)) {
                    let d = Math.sinh(expr.d);
                    if (Math.abs(d) < 1e-10) {
                        d = 0.0;
                    }
                    return create_flt(d);
                }
                if ($.is_zero(expr)) {
                    return zero;
                }
                return items_to_cons(SINH, expr);
            }

            // Natural logarithm.
            //
            // Note that we use the mathematics / Javascript / Mathematica
            // convention that "log" is indeed the natural logarithm.
            //
            // In engineering, biology, astronomy, "log" can stand instead
            // for the "common" logarithm i.e. base 10. Also note that Google
            // calculations use log for the common logarithm.
            function Eval_log(expr, $) {
                return logarithm($.valueOf(cadr(expr)), $);
            }
            function logarithm(expr, $) {
                // console.lg("logarithm", $.toSExprString(expr));
                if (is_base_of_natural_logarithm(expr)) {
                    return one;
                }
                if (is_rat$1(expr) && expr.isOne()) {
                    return zero;
                }
                if (is_flt$1(expr) && expr.isOne()) {
                    return zeroAsFlt;
                }
                if (is_negative_number(expr)) {
                    const termRe = logarithm($.negate(expr), $);
                    const termIm = $.multiply(imu, DynamicConstants.Pi($));
                    return $.add(termRe, termIm);
                }
                if (is_flt$1(expr)) {
                    return create_flt(Math.log(expr.d));
                }
                // rational number and not an integer?
                if (is_rat$1(expr) && expr.isFraction()) {
                    return $.subtract(logarithm(numerator(expr, $), $), logarithm(denominator(expr, $), $));
                }
                // log(a ^ b) --> b log(a)
                if (is_power(expr)) {
                    return $.multiply(caddr(expr), logarithm(cadr(expr), $));
                }
                // log(a * b) --> log(a) + log(b)
                if (is_multiply(expr)) {
                    return expr.tail().map(function (x) {
                        return logarithm(x, $);
                    }).reduce(function (x, y) {
                        return $.add(x, y);
                    }, zero);
                }
                return items_to_cons(LOG$1, expr);
            }

            //-----------------------------------------------------------------------------
            //
            //       v
            //  y = u                         (1)
            //
            //  take log of #1
            //
            //  log y = v log u               (2)
            //
            // differentiate #2 wrt x
            //
            //  1 dy   v du           dv
            //  - -- = - -- + (log u) --
            //  y dx   u dx           dx
            //
            //  dy    v  v du           dv
            //  -- = u  (- -- + (log u) --)
            //  dx       u dx           dx
            //
            //-----------------------------------------------------------------------------
            function dpower(u_pow_v, x, $) {
                const u = cadr(u_pow_v);
                const v = caddr(u_pow_v);
                // v/u
                const v_div_u = divide(v, u, $);
                // du/dx
                const du_by_dx = derivative(u, x, $);
                // log u
                const log_u = logarithm(u, $);
                // dv/dx
                const dv_by_dx = derivative(v, x, $);
                // u^v
                return $.multiply($.add($.multiply(v_div_u, du_by_dx), $.multiply(log_u, dv_by_dx)), u_pow_v);
            }

            /**
             * TODO: This function allows the product to be of more than two expressions.
             * In our associated implementation we only really need a product of two expressions.
             * @param F = (* a1 a2 a3 ...)
             * @param X
             * @param $
             * @returns
             */
            function dproduct(F, X, $) {
                const n = length_of_cons_otherwise_zero(F) - 1;
                const terms = [];
                for (let i = 0; i < n; i++) {
                    const factors = [];
                    // We'll chomp through each argument in F
                    let argList = cdr(F);
                    // Using this inner loop like this ensures that we don't accidentally commute the factors.
                    // Of course, the sorting of factors may be inclined to move the derivative around.
                    for (let j = 0; j < n; j++) {
                        const a = car(argList);
                        if (i === j) {
                            factors.push(derivative(a, X, $));
                        }
                        else {
                            factors.push(a);
                        }
                        argList = cdr(argList);
                    }
                    // We are assuming here
                    terms.push(multiply_items(factors, $));
                }
                return add_terms$1(terms, $);
            }

            /* eslint-disable no-console */
            function d_scalar_scalar(F, X, $) {
                // console.lg(`d_scalar_scalar F=>${render_as_infix(F, $)} X=>${render_as_infix(X, $)}`);
                if (is_sym(X)) {
                    return d_scalar_scalar_1(F, X, $);
                }
                // Example: d(sin(cos(x)),cos(x))
                // Replace cos(x) <- X, find derivative, then do X <- cos(x)
                const arg1 = subst(F, X, SECRETX, $); // p1: sin(cos(x)), p2: cos(x), SECRETX: X => sin(cos(x)) -> sin(X)
                const darg1x = derivative(arg1, SECRETX, $);
                return subst(darg1x, SECRETX, X, $); // p2:  cos(x)  =>  cos(X) -> cos(cos(x))
            }
            function d_scalar_scalar_1(F, X, $) {
                // console.lg(`d_scalar_scalar_1 F=>${render_as_infix(F, $)} X=>${render_as_infix(X, $)}`);
                // d(x,x)
                if (F.equals(X)) {
                    return one;
                }
                // console.lg(`f=>${render_as_infix(F, $)} is_sym(F)=>${is_sym(F)}`);
                // d(a,x)?
                if (is_sym(F)) {
                    if (F.equals(MATH_E$2)) {
                        return zero;
                    }
                    if (F.equals(MATH_PI$2)) {
                        return zero;
                    }
                    // For all other symbolic constants that we don't know what they represent...
                    return items_to_cons$1(MATH_DERIVATIVE, F, X);
                }
                // TODO: Better to check for types explicitly (extensibility required).
                // We are really checking for constantness here.
                if (!is_cons(F)) {
                    return zero;
                }
                // TODO: The generalization here would seem to be that we delegate the task to a binary operation implemented by the
                // operator that matches.
                if (is_abs(F)) {
                    return dabs(F, X, $);
                }
                if (is_add(F)) {
                    return dsum(F, X, $);
                }
                // console.lg(`car(p1)=>${car(p1)}`);
                // Turning these into matching patterns...
                const opr = car(F);
                if (opr.equals(MULTIPLY$1)) {
                    return dproduct(F, X, $);
                }
                if (opr.equals(POWER$1)) {
                    return dpower(F, X, $);
                }
                if (opr.equals(MATH_DERIVATIVE)) {
                    return dd(F, X, $);
                }
                if (opr.equals(LOG$1)) {
                    return dlog(F, X, $);
                }
                if (opr.equals(SIN$1)) {
                    return dsin(F, X, $);
                }
                if (opr.equals(COS$3)) {
                    return dcos(F, X, $);
                }
                if (opr.equals(TAN)) {
                    return dtan(F, X, $);
                }
                if (opr.equals(ARCSIN)) {
                    return darcsin(F, X, $);
                }
                if (opr.equals(ARCCOS)) {
                    return darccos(F, X, $);
                }
                if (opr.equals(ARCTAN)) {
                    return darctan(F, X, $);
                }
                if (opr.equals(SINH)) {
                    return dsinh(F, X, $);
                }
                if (opr.equals(COSH)) {
                    return dcosh(F, X, $);
                }
                if (opr.equals(TANH)) {
                    return dtanh(F, X, $);
                }
                if (opr.equals(ARCSINH)) {
                    return darcsinh(F, X, $);
                }
                if (opr.equals(ARCCOSH)) {
                    return darccosh(F, X, $);
                }
                if (opr.equals(ARCTANH)) {
                    return darctanh(F, X, $);
                }
                if (opr.equals(SGN)) {
                    return dsgn(F, X, $);
                }
                if (opr.equals(HERMITE)) {
                    return dhermite(F, X, $);
                }
                if (opr.equals(ERF)) {
                    return derf(F, X, $);
                }
                if (opr.equals(ERFC)) {
                    return derfc(F, X, $);
                }
                if (opr.equals(BESSELJ)) {
                    return dbesselj(F, X, $);
                }
                if (opr.equals(BESSELY)) {
                    return dbessely(F, X, $);
                }
                if (car(F).equals(INTEGRAL) && caddr(F).equals(X)) {
                    return derivative_of_integral(F);
                }
                return dfunction(F, X);
            }
            function dsum(p1, p2, $) {
                const toAdd = is_cons(p1) ? p1.tail().map((el) => derivative(el, p2, $)) : [];
                return add_terms$1(toAdd, $);
            }
            function dlog(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return divide(deriv, cadr(p1), $);
            }
            //  derivative of derivative
            //
            //  example: d(d(f(x,y),y),x)
            //
            //  p1 = d(f(x,y),y)
            //
            //  p2 = x
            //
            //  cadr(p1) = f(x,y)
            //
            //  caddr(p1) = y
            function dd(p1, p2, $) {
                // d(f(x,y),x)
                const p3 = derivative(cadr(p1), p2, $);
                if (car(p3).equals(MATH_DERIVATIVE)) {
                    // handle dx terms
                    const caddr_p3 = caddr(p3);
                    const caddr_p1 = caddr(p1);
                    const cadr_p3 = cadr(p3);
                    // Determine whether we should be comparing as terms or factors. I think it is as terms.
                    if ($.compareFn(MATH_ADD$1)(caddr_p3, caddr_p1) < 0) {
                        return items_to_cons$1(MATH_DERIVATIVE, items_to_cons$1(MATH_DERIVATIVE, cadr_p3, caddr_p3), caddr_p1);
                    }
                    else {
                        return items_to_cons$1(MATH_DERIVATIVE, items_to_cons$1(MATH_DERIVATIVE, cadr_p3, caddr_p1), caddr_p3);
                    }
                }
                return derivative(p3, caddr(p1), $);
            }
            // derivative of a generic function
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function dfunction(F, X, $) {
                // console.lg(`dfunction F=>${render_as_infix(F, $)} X=>${render_as_infix(X, $)}`);
                const argList = F.argList;
                if (nil === argList || argList.contains(X)) {
                    return items_to_cons$1(MATH_DERIVATIVE, F, X);
                }
                else {
                    // 
                    // return zero;
                    return items_to_cons$1(MATH_DERIVATIVE, F, X);
                }
            }
            function dsin(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, cos(cadr(p1), $));
            }
            function dcos(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.negate($.multiply(deriv, sin(cadr(p1), $)));
            }
            function dtan(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, $.power(cos(cadr(p1), $), create_int(-2)));
            }
            function darcsin(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, $.power($.subtract(one, $.power(cadr(p1), two)), rational(-1, 2)));
            }
            function darccos(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.negate($.multiply(deriv, $.power($.subtract(one, $.power(cadr(p1), two)), rational(-1, 2))));
            }
            //        Without simplify  With simplify
            //
            //  d(arctan(y/x),x)  -y/(x^2*(y^2/x^2+1))  -y/(x^2+y^2)
            //
            //  d(arctan(y/x),y)  1/(x*(y^2/x^2+1))  x/(x^2+y^2)
            function darctan(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                const A = inverse($.add(one, $.power(cadr(p1), two)), $);
                return simplify($.multiply(deriv, A), $);
            }
            function dsinh(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, ycosh(cadr(p1), $));
            }
            function dcosh(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, sinh(cadr(p1), $));
            }
            function dtanh(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, $.power(ycosh(cadr(p1), $), create_int(-2)));
            }
            function darcsinh(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, $.power($.add($.power(cadr(p1), two), one), rational(-1, 2)));
            }
            function darccosh(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, $.power($.add($.power(cadr(p1), two), negOne), rational(-1, 2)));
            }
            function darctanh(p1, X, $) {
                const deriv = derivative(cadr(p1), X, $);
                const A = inverse($.subtract(one, $.power(cadr(p1), two)), $);
                return $.multiply(deriv, A);
            }
            function dabs(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply(deriv, sgn(cadr(p1), $));
            }
            function dsgn(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply($.multiply(deriv, dirac(cadr(p1), $)), two);
            }
            function dhermite(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply($.multiply(deriv, $.multiply(two, caddr(p1))), hermite(cadr(p1), $.add(caddr(p1), negOne), $));
            }
            function derf(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply($.multiply($.multiply(exp$1($.multiply($.power(cadr(p1), two), negOne), $), $.power(DynamicConstants.Pi($), rational(-1, 2))), two), deriv);
            }
            function derfc(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply($.multiply($.multiply(exp$1($.multiply($.power(cadr(p1), two), negOne), $), $.power(DynamicConstants.Pi($), rational(-1, 2))), create_int(-2)), deriv);
            }
            function dbesselj(p1, p2, $) {
                if ($.is_zero(caddr(p1))) {
                    return dbesselj0(p1, p2, $);
                }
                return dbesseljn(p1, p2, $);
            }
            function dbesselj0(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply($.multiply(deriv, besselj(cadr(p1), one, $)), negOne);
            }
            function dbesseljn(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                const A = $.add(caddr(p1), negOne);
                const B = $.multiply(caddr(p1), negOne);
                const C = besselj(cadr(p1), A, $);
                const D = divide(B, cadr(p1), $);
                const E = besselj(cadr(p1), caddr(p1), $);
                const F = $.multiply(D, E);
                const G = $.add(C, F);
                return $.multiply(deriv, G);
            }
            function dbessely(p1, p2, $) {
                if ($.is_zero(caddr(p1))) {
                    return dbessely0(p1, p2, $);
                }
                return dbesselyn(p1, p2, $);
            }
            function dbessely0(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                return $.multiply($.multiply(deriv, besselj(cadr(p1), one, $)), negOne);
            }
            function dbesselyn(p1, p2, $) {
                const deriv = derivative(cadr(p1), p2, $);
                const A = $.add(caddr(p1), negOne);
                const B = $.multiply(caddr(p1), negOne);
                const C = divide(B, cadr(p1), $);
                const D = bessely(cadr(p1), caddr(p1), $);
                const E = bessely(cadr(p1), A, $);
                const F = $.multiply(C, D);
                const G = $.add(E, F);
                return $.multiply(deriv, G);
            }
            function derivative_of_integral(p1) {
                return cadr(p1);
            }

            /**
             * Constructs the derivative of expr with respect to X.
             */
            function derivative(expr, X, $) {
                // console.lg("derivative");
                // console.lg(`expr=${render_as_sexpr(expr, $)}`);
                // console.lg(`X=${render_as_sexpr(X, $)}`);
                if (is_num(X)) {
                    throw new SystemError('undefined function');
                }
                if (is_tensor(expr)) {
                    if (is_tensor(X)) {
                        return d_tensor_tensor(expr, X, $);
                    }
                    else {
                        return d_tensor_scalar(expr, X, $);
                    }
                }
                else {
                    if (is_tensor(X)) {
                        return d_scalar_tensor(expr, X, $);
                    }
                    else {
                        return d_scalar_scalar(expr, X, $);
                    }
                }
            }

            /**
             * Determines whether the expression is a square matrix.
             * To be a square matrix, it must be a tensor with two dimensions, with the sizes of each dimension being equal.
             */
            function is_square_matrix(expr) {
                return is_tensor(expr) && is_square_matrix_tensor(expr);
            }
            function is_square_matrix_tensor(tensor) {
                return tensor.ndim === 2 && tensor.dim(0) === tensor.dim(1);
            }
            function assert_square_matrix_tensor(tensor, $) {
                if (is_square_matrix_tensor(tensor)) {
                    return tensor.dim(0);
                }
                else {
                    throw new Error(`tensor => ${$.toInfixString(tensor)} MUST be a square matrix. ${tensor} ndim=${tensor.ndim}`);
                }
            }
            //-----------------------------------------------------------------------------
            //
            //  gradient of tensor
            //
            //-----------------------------------------------------------------------------
            function d_tensor_tensor(p1, p2, $) {
                if (p1.ndim + 1 >= MAXDIM) {
                    return items_to_cons(MATH_DERIVATIVE, p1, p2);
                }
                const sizes = p1.copyDimensions();
                sizes.push(p2.dim(0));
                const iLen = p1.nelem;
                const jLen = p2.nelem;
                const elems = new Array(iLen * jLen);
                for (let i = 0; i < iLen; i++) {
                    for (let j = 0; j < jLen; j++) {
                        elems[i * jLen + j] = derivative(p1.elem(i), p2.elem(j), $);
                    }
                }
                return new Tensor(sizes, elems);
            }
            //-----------------------------------------------------------------------------
            //
            //  gradient of scalar
            //
            //-----------------------------------------------------------------------------
            function d_scalar_tensor(p1, p2, $) {
                const sizes = [p2.dim(0)];
                const elems = p2.mapElements((elem) => derivative(p1, elem, $));
                return new Tensor(sizes, elems);
            }
            //-----------------------------------------------------------------------------
            //
            //  Derivative of tensor
            //
            //-----------------------------------------------------------------------------
            function d_tensor_scalar(p1, p2, $) {
                const elems = p1.mapElements((elem) => derivative(elem, p2, $));
                return p1.withElements(elems);
            }
            //-----------------------------------------------------------------------------
            //
            //  Raise a tensor to a power
            //
            //  Input:    p1  tensor
            //            p2  exponent
            //
            //  Output:    Result
            //
            //-----------------------------------------------------------------------------
            function power_tensor(p1, p2, $) {
                // first and last dims must be equal
                const k = p1.ndim - 1;
                if (p1.dim(0) !== p1.dim(k)) {
                    return items_to_cons(POWER$1, p1, p2);
                }
                let n = nativeInt(p2);
                if (isNaN(n)) {
                    return items_to_cons(POWER$1, p1, p2);
                }
                if (n === 0) {
                    if (p1.ndim !== 2) {
                        throw new Error('power(tensor,0) with tensor rank not equal to 2');
                    }
                    n = p1.dim(0);
                    // p1 = create_mat(n * n);
                    const sizes = [n, n];
                    const elems = create_tensor_elements_diagonal(n, one, zero);
                    // TODO: I think p1 has to be square, in which case we can use p1.withElements(elems).
                    return new Tensor(sizes, elems);
                }
                let p3 = p1;
                if (n < 0) {
                    n = -n;
                    p3 = inv(p3, $);
                }
                let prev = p3;
                for (let i = 1; i < n; i++) {
                    prev = $.inner(prev, p3);
                    if ($.is_zero(prev)) {
                        break;
                    }
                }
                return prev;
            }

            function evaluate_integer(p, $) {
                return nativeInt($.valueOf(p));
            }

            /* cofactor =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            m,i,j

            General description
            -------------------
            Cofactor of a matrix component.
            Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).
            This function returns c[i,j].

            */
            function Eval_cofactor(expr, $) {
                const m = $.valueOf(cadr(expr));
                if (!is_square_matrix(m)) {
                    halt('cofactor: 1st arg: square matrix expected');
                }
                const n = m.dim(0);
                const i = evaluate_integer(caddr(expr), $);
                if (i < 1 || i > n) {
                    halt('cofactor: 2nd arg: row index expected');
                }
                const j = evaluate_integer(cadddr(expr), $);
                if (j < 1 || j > n) {
                    halt('cofactor: 3rd arg: column index expected');
                }
                return cofactor(m, i - 1, j - 1, $);
            }
            function cofactor(m, row, col, $) {
                const hook = function (retval) {
                    return retval;
                };
                const n = m.dim(0);
                const elements = [];
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (i !== row && j !== col) {
                            elements.push(m.elem(n * i + j));
                        }
                    }
                }
                const det = determinant_symbolic(elements, n - 1, $);
                if ((row + col) % 2) {
                    return hook($.negate(det));
                }
                else {
                    return hook(det);
                }
            }

            /* adj =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            m

            General description
            -------------------
            Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).

            */
            function Eval_adj(expr, $) {
                const argList = expr.cdr;
                const arg = car(argList);
                const m = $.valueOf(arg);
                if (is_tensor(m)) {
                    const result = adj(m, $);
                    return result;
                }
                else {
                    throw new Error(`adj argument MUST be a tensor.`);
                }
            }
            function adj(M, $) {
                const hook = function (retval) {
                    // console.lg(`adj of ${$.toInfixString(M)} => ${$.toInfixString(retval)}`);
                    return retval;
                };
                const n = assert_square_matrix_tensor(M, $);
                const elems = new Array(M.nelem);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        elems[n * j + i] = cofactor(M, i, j, $);
                    }
                }
                return hook(M.withElements(elems));
            }

            let Builder$4G = class Builder {
                create($) {
                    return new Op$3W($);
                }
            };
            let Op$3W = class Op extends Function1 {
                constructor($) {
                    super('adj', ADJ, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const retval = Eval_adj(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                }
            };
            const adj_any = new Builder$4G();

            function extract_grade(arg, grade, $) {
                // TODO: Do we need a generic grade(arg, n) function?
                if (is_blade$1(arg)) {
                    const extracted = arg.extractGrade(grade);
                    return extracted;
                }
                else if (is_sym(arg)) {
                    // We're treating symbols as scalars.
                    if (grade === 0) {
                        return arg;
                    }
                    else {
                        return zero;
                    }
                }
                else if (is_flt$1(arg)) {
                    if (grade === 0) {
                        return arg;
                    }
                    else {
                        return zero;
                    }
                }
                else if (is_rat(arg)) {
                    if (grade === 0) {
                        return arg;
                    }
                    else {
                        return zero;
                    }
                }
                else if (is_cons(arg) && is_mul_2_any_any(arg)) {
                    const lhs = arg.lhs;
                    const rhs = arg.rhs;
                    if ($.isScalar(lhs)) {
                        return $.multiply(lhs, extract_grade(rhs, grade, $));
                    }
                    if ($.isScalar(rhs)) {
                        return $.multiply(extract_grade(lhs, grade, $), rhs);
                    }
                    throw new Error(`extractGrade   ${lhs} * ${rhs}`);
                }
                else {
                    throw new Error(`extractGrade(arg => ${arg}, grade => ${grade}) function not implemented.`);
                }
            }

            function blade_times_weight(blade, weight, $) {
                if ($.isOne(weight)) {
                    return blade;
                }
                else {
                    return cons(MATH_MUL$3, items_to_cons$1(blade, weight));
                }
            }
            class AlgebraFieldAdapter {
                constructor(dimensions, $) {
                    this.dimensions = dimensions;
                    this.$ = $;
                }
                get ε() {
                    return create_flt(1e-6);
                }
                get one() {
                    return one;
                }
                get zero() {
                    return zero;
                }
                abs() {
                    throw new Error('abs Method not implemented.');
                }
                add(lhs, rhs) {
                    if (this.$.isOne(lhs)) {
                        if (this.$.isOne(rhs)) {
                            return two;
                        }
                        else {
                            throw new Error('add Method not implemented.');
                        }
                    }
                    else {
                        throw new Error('add Method not implemented.');
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                sub(lhs, rhs) {
                    throw new Error('sub Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                eq(lhs, rhs) {
                    throw new Error('eq Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                ne(lhs, rhs) {
                    throw new Error('ne Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                le(lhs, rhs) {
                    throw new Error('le Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                lt(lhs, rhs) {
                    throw new Error('lt Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                ge(lhs, rhs) {
                    throw new Error('ge Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                gt(lhs, rhs) {
                    throw new Error('gt Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                max(lhs, rhs) {
                    throw new Error('max Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                min(lhs, rhs) {
                    throw new Error('min Method not implemented.');
                }
                mul(lhs, rhs) {
                    return this.$.multiply(lhs, rhs);
                    /*
                    if (is_rat(lhs)) {
                        if (is_rat(rhs)) {
                            return lhs.mul(rhs);
                        }
                    }
                    throw new Error(`mul Method not implemented.`);
                    */
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                div(lhs, rhs) {
                    throw new Error('div Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                neg(arg) {
                    if (is_rat$1(arg)) {
                        return arg.neg();
                    }
                    throw new Error(`neg ${arg} Method not implemented.`);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                asString(arg) {
                    throw new Error('asString Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                cos(arg) {
                    throw new Error('cos Method not implemented.');
                }
                isField(arg) {
                    if (is_rat$1(arg)) {
                        return true;
                    }
                    else if (is_flt$1(arg)) {
                        return true;
                    }
                    else if (is_blade(arg)) {
                        return false;
                    }
                    else {
                        throw new Error(`isField method not implemented.`);
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(arg) {
                    throw new Error('isOne Method not implemented.');
                }
                isZero(arg) {
                    return this.$.is_zero(arg);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                sin(arg) {
                    throw new Error('sin Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                sqrt(arg) {
                    throw new Error('sqrt Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isDimension(arg) {
                    throw new Error('isDimension Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                dim(arg) {
                    throw new Error('dim Method not implemented.');
                }
                sum(terms) {
                    // The general idea here is to implement optimizations and then to fall back to mathematical addition.
                    // The fallback should be able to handle the undefined cases.
                    if (terms.length === 1) {
                        const term = terms[0];
                        const weight = term.weight;
                        const blade = term.blade;
                        return this.$.multiply(weight, blade);
                    }
                    else if (terms.length === 2) {
                        const a = blade_times_weight(terms[0].blade, terms[0].weight, this.$);
                        const b = blade_times_weight(terms[1].blade, terms[1].weight, this.$);
                        // TODO: Why don't we use add terms?
                        return cons(MATH_ADD$1, items_to_cons$1(a, b));
                    }
                    else {
                        // We may get more than two terms when we consider general metrics.
                        // const bws = terms.map(function(term){return multiply(term.blade,term.weight)});
                        throw new Error(`sum of ${terms.length} terms Method not implemented.`);
                    }
                }
                extractGrade(arg, grade) {
                    return extract_grade(arg, grade, this.$);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                treeAdd(lhs, rhs) {
                    throw new Error('treeAdd Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                treeLco(lhs, rhs) {
                    if (is_blade(lhs) && is_blade(rhs)) {
                        return lhs.__lshift__(rhs);
                    }
                    throw new Error(`treeLco(lhs=${lhs}, rhs=${rhs}) Method not implemented.`);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                treeMul(lhs, rhs) {
                    throw new Error('treeMul Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                treeScp(lhs, rhs) {
                    throw new Error('treeScp Method not implemented.');
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                treeSqrt(arg) {
                    throw new Error('treeSqrt Method not implemented.');
                }
                treeZero() {
                    return zero;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                scalarCoordinate(arg) {
                    throw new Error('scalarCoordinate Method not implemented.');
                }
                bladeToTree(blade) {
                    return blade;
                }
                weightToTree(weight) {
                    return weight;
                }
            }
            /**
             * The implementation of the algebra constructor function.
             * @param metric
             * @param labels
             * @param $
             * @returns
             */
            function algebraAsTensor(metric, labels, $) {
                const uFieldAdaptor = new AlgebraFieldAdapter(metric.length, $);
                const GA = algebra(metric, uFieldAdaptor, labels);
                /**
                 * Number of basis vectors in algebra is dimensionality.
                 */
                const dimensions = metric.length;
                const dims = [metric.length];
                const elems = new Array(dimensions);
                for (let index = 0; index < dimensions; index++) {
                    elems[index] = GA.unit(index);
                }
                return new Tensor(dims, elems);
            }
            function convertMetricToNative(tensor) {
                if (is_tensor(tensor)) {
                    return tensor.mapElements(function (e) {
                        if (is_sym(e)) {
                            return e;
                        }
                        else if (is_num(e)) {
                            return e;
                        }
                        else if (is_rat_and_integer(e)) {
                            return e;
                        }
                        else {
                            throw new Error(`${e} must be an integer.`);
                        }
                    });
                }
                else {
                    throw new Error("must be a tensor.");
                }
            }
            function convertLabelsToNative(tensor) {
                if (is_tensor(tensor)) {
                    return tensor.mapElements(function (element) {
                        if (is_str$1(element)) {
                            return element.str;
                        }
                        else {
                            throw new Error("must be a string.");
                        }
                    });
                }
                else {
                    throw new Error("must be a tensor.");
                }
            }

            let Builder$4F = class Builder {
                create($) {
                    return new Op$3V($);
                }
            };
            /**
             * G = algebra([1,1,1],['e1','e2','e3'])
             * e1 = G[1]
             * e2 = G[2]
             * e3 = G[3]
             */
            let Op$3V = class Op extends Function2 {
                constructor($) {
                    super('algebra_2_tensor_tensor', create_sym('algebra'), is_tensor, is_tensor, $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_binop_atom_atom(create_sym('algebra'), HASH_TENSOR, HASH_TENSOR);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const metric = convertMetricToNative(lhs);
                    const labels = convertLabelsToNative(rhs);
                    const newExpr = algebraAsTensor(metric, labels, $);
                    return [TFLAG_DIFF, newExpr];
                }
            };
            const algebra_2_tensor_tensor = new Builder$4F();

            /* arccos =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the inverse cosine of x.

            */
            function arccos(x, $) {
                if (car(x).equals(COS$3)) {
                    return cadr(x);
                }
                if (is_flt$1(x)) {
                    return create_flt(Math.acos(x.d));
                }
                // if x == 1/sqrt(2) then return 1/4*pi (45 degrees)
                // second if catches the other way of saying it, sqrt(2)/2
                if (isoneoversqrttwo(x) ||
                    (is_multiply(x) &&
                        is_num_and_equalq(car(cdr(x)), 1, 2) &&
                        car(car(cdr(cdr(x)))).equals(POWER$1) &&
                        equaln(car(cdr(car(cdr(cdr(x))))), 2) &&
                        is_num_and_equalq(car(cdr(cdr(car(cdr(cdr(x)))))), 1, 2))) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 4.0) : $.multiply(rational(1, 4), PI$7);
                }
                // if x == -1/sqrt(2) then return 3/4*pi (135 degrees)
                // second if catches the other way of saying it, -sqrt(2)/2
                if (isminusoneoversqrttwo(x) ||
                    (is_multiply(x) &&
                        is_num_and_equalq(car(cdr(x)), -1, 2) &&
                        car(car(cdr(cdr(x)))).equals(POWER$1) &&
                        equaln(car(cdr(car(cdr(cdr(x))))), 2) &&
                        is_num_and_equalq(car(cdr(cdr(car(cdr(cdr(x)))))), 1, 2))) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt((Math.PI * 3.0) / 4.0) : $.multiply(rational(3, 4), PI$7);
                }
                // if x == sqrt(3)/2 then return 1/6*pi (30 degrees)
                if (isSqrtThreeOverTwo(x)) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 6.0) : $.multiply(rational(1, 6), PI$7);
                }
                // if x == -sqrt(3)/2 then return 5/6*pi (150 degrees)
                if (isMinusSqrtThreeOverTwo(x)) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt((5.0 * Math.PI) / 6.0) : $.multiply(rational(5, 6), PI$7);
                }
                if (!is_rat$1(x)) {
                    return items_to_cons(ARCCOS, x);
                }
                const n = nativeInt($.multiply(x, two));
                switch (n) {
                    case -2:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? piAsFlt : PI$7;
                    case -1:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt((Math.PI * 2.0) / 3.0) : $.multiply(rational(2, 3), PI$7);
                    case 0:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 2.0) : $.multiply(half, PI$7);
                    case 1:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 3.0) : $.multiply(third, PI$7);
                    case 2:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? zeroAsFlt : zero;
                    default:
                        return items_to_cons(ARCCOS, x);
                }
            }

            /* arccos =====================================================================
             
            Tags
            ----
            scripting, JS, internal, treenode, general concept
             
            Parameters
            ----------
            x
             
            General description
            -------------------
            Returns the inverse cosine of x.
             
            */
            function Eval_arccos(x, $) {
                return arccos($.valueOf(cadr(x)), $);
            }

            let Builder$4E = class Builder {
                create($) {
                    return new Op$3U($);
                }
            };
            let Op$3U = class Op extends FunctionVarArgs {
                constructor($) {
                    super('arccos', ARCCOS, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_arccos(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const arccos_varargs = new Builder$4E();

            /* arccosh =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the inverse hyperbolic cosine of x.

            */
            function Eval_arccosh(x, $) {
                return arccosh($.valueOf(cadr(x)), $);
            }
            function arccosh(x, $) {
                if (car(x).equals(COSH)) {
                    return cadr(x);
                }
                if (is_flt$1(x)) {
                    let { d } = x;
                    if (d < 1.0) {
                        halt('arccosh function argument is less than 1.0');
                    }
                    d = Math.log(d + Math.sqrt(d * d - 1.0));
                    return create_flt(d);
                }
                if ($.isOne(x)) {
                    return zero;
                }
                return items_to_cons(ARCCOSH, x);
            }

            let Builder$4D = class Builder {
                create($) {
                    return new Op$3T($);
                }
            };
            let Op$3T = class Op extends FunctionVarArgs {
                constructor($) {
                    super('arccosh', ARCCOSH, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_arccosh(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const arccosh_varargs = new Builder$4D();

            /* arcsin =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the inverse sine of x.

            */
            function arcsin(x, $) {
                // arcsin(sin(x)) => x
                if (is_cons(x) && is_sin(x)) {
                    return car(x.cdr);
                }
                if (is_flt$1(x)) {
                    return create_flt(Math.asin(x.d));
                }
                // if x == 1/sqrt(2) then return 1/4*pi (45 degrees)
                // second if catches the other way of saying it, sqrt(2)/2
                if (isoneoversqrttwo(x) ||
                    (is_multiply(x) &&
                        is_num_and_equalq(car(cdr(x)), 1, 2) &&
                        car(car(cdr(cdr(x)))).equals(POWER$1) &&
                        equaln(car(cdr(car(cdr(cdr(x))))), 2) &&
                        is_num_and_equalq(car(cdr(cdr(car(cdr(cdr(x)))))), 1, 2))) {
                    return $.multiply(rational(1, 4), PI$7);
                }
                // if x == -1/sqrt(2) then return -1/4*pi (-45 degrees)
                // second if catches the other way of saying it, -sqrt(2)/2
                if (isminusoneoversqrttwo(x) ||
                    (is_multiply(x) &&
                        is_num_and_equalq(car(cdr(x)), -1, 2) &&
                        car(car(cdr(cdr(x)))).equals(POWER$1) &&
                        equaln(car(cdr(car(cdr(cdr(x))))), 2) &&
                        is_num_and_equalq(car(cdr(cdr(car(cdr(cdr(x)))))), 1, 2))) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(-Math.PI / 4.0) : $.multiply(rational(-1, 4), PI$7);
                }
                // if x == sqrt(3)/2 then return 1/3*pi (60 degrees)
                if (isSqrtThreeOverTwo(x)) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 3.0) : $.multiply(third, PI$7);
                }
                // if x == -sqrt(3)/2 then return -1/3*pi (-60 degrees)
                if (isMinusSqrtThreeOverTwo(x)) {
                    return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(-Math.PI / 3.0) : $.multiply(rational(-1, 3), PI$7);
                }
                if (!is_rat$1(x)) {
                    return items_to_cons(ARCSIN, x);
                }
                const n = nativeInt(x.mul(two));
                switch (n) {
                    case -2:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(-Math.PI / 2.0) : $.multiply(rational(-1, 2), PI$7);
                    case -1:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(-Math.PI / 6.0) : $.multiply(rational(-1, 6), PI$7);
                    case 0:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? zeroAsFlt : zero;
                    case 1:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 6.0) : $.multiply(rational(1, 6), PI$7);
                    case 2:
                        return $.getNativeDirective(Directive.evaluatingAsFloat) ? create_flt(Math.PI / 2.0) : $.multiply(half, PI$7);
                    default:
                        return items_to_cons(ARCSIN, x);
                }
            }

            /* arcsin =====================================================================
             
            Tags
            ----
            scripting, JS, internal, treenode, general concept
             
            Parameters
            ----------
            x
             
            General description
            -------------------
            Returns the inverse sine of x.
             
            */
            function Eval_arcsin(x, $) {
                return arcsin($.valueOf(cadr(x)), $);
            }

            let Builder$4C = class Builder {
                create($) {
                    return new Op$3S($);
                }
            };
            let Op$3S = class Op extends FunctionVarArgs {
                constructor($) {
                    super('arcsin', ARCSIN, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_arcsin(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const arcsin_varargs = new Builder$4C();

            function arcsinh(x, $) {
                if (car(x).equals(SINH)) {
                    return cadr(x);
                }
                if (is_flt$1(x)) {
                    let { d } = x;
                    d = Math.log(d + Math.sqrt(d * d + 1.0));
                    return create_flt(d);
                }
                if ($.is_zero(x)) {
                    return zero;
                }
                return items_to_cons(ARCSINH, x);
            }

            let Builder$4B = class Builder {
                create($) {
                    return new Op$3R($);
                }
            };
            let Op$3R = class Op extends Function1 {
                constructor($) {
                    super('arcsinh', ARCSINH, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const retval = arcsinh(arg, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                }
            };
            const arcsinh_any = new Builder$4B();

            /* arctan =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the inverse tangent of x.

            */
            function Eval_arctan(expr, $) {
                const x = expr.argList.head;
                return arctan($.valueOf(x), $);
            }
            function arctan(x, $) {
                // console.lg("arctan", $.toInfixString(x), "expanding", $.isExpanding());
                if (car(x).equals(TAN)) {
                    return cadr(x);
                }
                if (is_flt$1(x)) {
                    return create_flt(Math.atan(x.d));
                }
                if ($.is_zero(x)) {
                    return zero;
                }
                if (is_negative(x)) {
                    return $.negate($.arctan($.negate(x)));
                }
                // arctan(sin(a) / cos(a)) ?
                if (x.contains(SIN$1) && x.contains(COS$3)) {
                    const p2 = numerator(x, $);
                    const p3 = denominator(x, $);
                    if (car(p2).equals(SIN$1) && car(p3).equals(COS$3) && $.equals(cadr(p2), cadr(p3))) {
                        return cadr(p2);
                    }
                }
                // arctan(1/sqrt(3)) -> pi/6
                // second if catches the other way of saying it, sqrt(3)/3
                if ((is_power(x) && equaln(cadr(x), 3) && is_num_and_equalq(caddr(x), -1, 2)) ||
                    (is_multiply(x) &&
                        is_num_and_equalq(car(cdr(x)), 1, 3) &&
                        car(car(cdr(cdr(x)))).equals(POWER$1) &&
                        equaln(car(cdr(car(cdr(cdr(x))))), 3) &&
                        is_num_and_equalq(car(cdr(cdr(car(cdr(cdr(x)))))), 1, 2))) {
                    return $.multiply(rational(1, 6), $.getNativeDirective(Directive.evaluatingAsFloat) ? piAsFlt : PI$7);
                }
                // arctan(1) -> pi/4
                if (equaln(x, 1)) {
                    return $.multiply(rational(1, 4), DynamicConstants.Pi($));
                }
                // arctan(sqrt(3)) -> pi/3
                if (is_power(x) && equaln(cadr(x), 3) && is_num_and_equalq(caddr(x), 1, 2)) {
                    return $.multiply(third, DynamicConstants.Pi($));
                }
                return items_to_cons(ARCTAN, x);
            }

            let Builder$4A = class Builder {
                create($) {
                    return new Op$3Q($);
                }
            };
            let Op$3Q = class Op extends FunctionVarArgs {
                constructor($) {
                    super('arctan', ARCTAN, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_arctan(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const arctan_varargs = new Builder$4A();

            /* arctanh =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            x

            General description
            -------------------
            Returns the inverse hyperbolic tangent of x.

            */
            function Eval_arctanh(x, $) {
                return arctanh($.valueOf(cadr(x)), $);
            }
            function arctanh(x, $) {
                if (car(x).equals(TANH)) {
                    return cadr(x);
                }
                if (is_flt$1(x)) {
                    let { d } = x;
                    if (d < -1.0 || d > 1.0) {
                        throw new Error('arctanh function argument is not in the interval [-1,1]');
                    }
                    d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;
                    return create_flt(d);
                }
                if ($.is_zero(x)) {
                    return zero;
                }
                return items_to_cons(ARCTANH, x);
            }

            let Builder$4z = class Builder {
                create($) {
                    return new Op$3P($);
                }
            };
            let Op$3P = class Op extends FunctionVarArgs {
                constructor($) {
                    super('arctanh', ARCTANH, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_arctanh(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const arctanh_varargs = new Builder$4z();

            const ARG$7 = native_sym(Native.arg);
            const ADD$6 = native_sym(Native.add);
            let Builder$4y = class Builder {
                create($) {
                    return new Op$3O($);
                }
            };
            function arg_of_sum(z, $) {
                const y = $.imag(z);
                const x = $.real(z);
                if ($.is_zero(x)) {
                    if ($.is_zero(y)) {
                        // Undefined
                        return new Err(items_to_cons$1(ARG$7, $.add(x, y)));
                    }
                    else {
                        const k = is_negative(y) ? half.neg() : half;
                        const pi = DynamicConstants.Pi($);
                        return $.multiply(k, pi);
                    }
                    /*
                    else if (is_negative(y)) {
                        return $.negate(pi);
                    }
                    else {
                        return divide(pi,two,$);
                    }
                    */
                }
                else {
                    if (is_negative(x)) {
                        const pi = DynamicConstants.Pi($);
                        if (is_negative(y)) {
                            return $.subtract($.arctan($.divide(y, x)), pi);
                        }
                        else {
                            const lhs = $.arctan($.divide(y, x));
                            const rhs = pi;
                            const sum = $.add(lhs, rhs);
                            return sum;
                        }
                    }
                    else {
                        // TODO: We're getting arg(x) is zero because of assumptions that x is not negative.
                        return $.arctan($.divide(y, x));
                    }
                }
            }
            /**
             * arg(a + b + c ...)
             */
            let Op$3O = class Op extends CompositeOperator {
                constructor($) {
                    super(ARG$7, ADD$6, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    return [TFLAG_DIFF, arg_of_sum(innerExpr, this.$)];
                }
            };
            const arg_add = new Builder$4y();

            const ARG$6 = native_sym(Native.arg);
            let Builder$4x = class Builder {
                create($) {
                    return new Op$3N($);
                }
            };
            let Op$3N = class Op extends Function1 {
                constructor($) {
                    super('arg_any', ARG$6, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    // console.lg("arg BACKSTOP", "expanding", this.$.isExpanding(), "factoring", this.$.isFactoring());
                    return [TFLAG_NONE, expr];
                }
            };
            const arg_any = new Builder$4x();

            const ARG$5 = native_sym(Native.arg);
            let Builder$4w = class Builder {
                create($) {
                    return new Op$3M($);
                }
            };
            let Op$3M = class Op extends Function1 {
                constructor($) {
                    super('arg_flt', ARG$5, is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    if (arg.isZero()) {
                        return [TFLAG_DIFF, new Err(expr)];
                    }
                    else if (arg.isNegative()) {
                        return [TFLAG_DIFF, piAsFlt];
                    }
                    else {
                        return [TFLAG_DIFF, zeroAsFlt];
                    }
                }
            };
            const arg_flt = new Builder$4w();

            const ARG$4 = native_sym(Native.arg);
            const PI$6 = native_sym(Native.PI);
            let Builder$4v = class Builder {
                create($) {
                    return new Op$3L($);
                }
            };
            let Op$3L = class Op extends Function1 {
                constructor($) {
                    super('arg_imu', ARG$4, is_imu, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_IMU);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_DIFF, this.$.divide(PI$6, two)];
                }
            };
            const arg_imu = new Builder$4v();

            const ARG$3 = native_sym(Native.arg);
            const MUL$4 = native_sym(Native.multiply);
            const PI$5 = native_sym(Native.PI);
            let Builder$4u = class Builder {
                create($) {
                    return new Op$3K($);
                }
            };
            /**
             * [-pi,pi]
             * @param arg
             * @param $
             * @returns
             */
            function principal_value_radians(arg, $) {
                const pis = $.divide(arg, PI$5);
                // console.lg("pis", $.toInfixString(pis));
                if (is_rat$1(pis)) {
                    return $.multiply(principal_value_rats(pis), PI$5);
                }
                else if (is_flt$1(pis)) {
                    return $.multiply(principal_value_flts(pis), PI$5);
                }
                return arg;
            }
            function principal_value_rats(arg, $) {
                if (arg.isOne()) {
                    return arg;
                }
                else if (arg.isMinusOne()) {
                    return arg;
                }
                else if (arg.pred().isPositive()) {
                    return principal_value_rats(arg.pred().pred());
                }
                else if (arg.succ().isNegative()) {
                    return principal_value_rats(arg.succ().succ());
                }
                return arg;
            }
            function principal_value_flts(arg, $) {
                // console.lg("pvf", $.toInfixString(arg));
                if (arg.isOne()) {
                    return arg;
                }
                else if (arg.isMinusOne()) {
                    return arg;
                }
                else if (arg.sub(oneAsFlt).isPositive()) {
                    return principal_value_flts(arg.sub(oneAsFlt).sub(oneAsFlt));
                }
                else if (arg.add(oneAsFlt).isNegative()) {
                    return principal_value_flts(arg.add(oneAsFlt).add(oneAsFlt));
                }
                return arg;
            }
            /**
             * arg(a * b * c ...) = arg(a) + arg(b) + arg(c) + ...
             */
            let Op$3K = class Op extends CompositeOperator {
                constructor($) {
                    super(ARG$3, MUL$4, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const sum = innerExpr.tail().map($.arg).reduce((lhs, rhs) => $.add(lhs, rhs), zero);
                    const pv = principal_value_radians(sum, $);
                    return [TFLAG_DIFF, pv];
                }
            };
            const arg_mul = new Builder$4u();

            const ARG$2 = native_sym(Native.arg);
            const POW$c = native_sym(Native.pow);
            let Builder$4t = class Builder {
                create($) {
                    return new Op$3J($);
                }
            };
            /**
             *
             */
            let Op$3J = class Op extends CompositeOperator {
                constructor($) {
                    super(ARG$2, POW$c, $);
                }
                transform1(opr, innerExpr) {
                    const $ = this.$;
                    const base = innerExpr.lhs;
                    const expo = innerExpr.rhs;
                    const theta = compute_theta_from_base_and_expo(base, expo, $);
                    return [TFLAG_DIFF, theta];
                }
            };
            const arg_pow = new Builder$4t();

            const ARG$1 = native_sym(Native.arg);
            const PI$4 = native_sym(Native.PI);
            let Builder$4s = class Builder {
                create($) {
                    return new Op$3I($);
                }
            };
            let Op$3I = class Op extends Function1 {
                constructor($) {
                    super('arg_rat', ARG$1, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    if (arg.isZero()) {
                        return [TFLAG_DIFF, new Err(expr)];
                    }
                    else if (arg.isNegative()) {
                        return [TFLAG_DIFF, PI$4];
                    }
                    else {
                        return [TFLAG_DIFF, zero];
                    }
                }
            };
            const arg_rat = new Builder$4s();

            const ARG = native_sym(Native.arg);
            const E = native_sym(Native.E);
            const PI$3 = native_sym(Native.PI);
            let Builder$4r = class Builder {
                create($) {
                    return new Op$3H($);
                }
            };
            let Op$3H = class Op extends Function1 {
                constructor($) {
                    super('arg_sym', ARG, is_sym, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_SYM);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    if (arg.equalsSym(E)) {
                        return [TFLAG_DIFF, zero];
                    }
                    else if (arg.equalsSym(PI$3)) {
                        return [TFLAG_DIFF, zero];
                    }
                    else if ($.is_real(arg)) {
                        // The arg could still be zero, undefined, or pi.
                        return [TFLAG_DIFF, expr];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const arg_sym = new Builder$4r();

            // Store a function definition
            //
            // Example:
            //
            //      f(x,y)=x^y
            //
            // For this definition, p1 points to the following structure.
            //
            //     p1
            //      |
            //   ___v__    ______                        ______
            //  |CONS  |->|CONS  |--------------------->|CONS  |
            //  |______|  |______|                      |______|
            //      |         |                             |
            //   ___v__    ___v__    ______    ______    ___v__    ______    ______
            //  |SETQ  |  |CONS  |->|CONS  |->|CONS  |  |CONS  |->|CONS  |->|CONS  |
            //  |______|  |______|  |______|  |______|  |______|  |______|  |______|
            //                |         |         |         |         |         |
            //             ___v__    ___v__    ___v__    ___v__    ___v__    ___v__
            //            |SYM f |  |SYM x |  |SYM y |  |POWER |  |SYM x |  |SYM y |
            //            |______|  |______|  |______|  |______|  |______|  |______|
            //
            // the result (in f) is a FUNCTION node
            // that contains both the body and the argument list.
            //
            // We have
            //
            //  caadr(p1) points to the function name i.e. f
            //  cdadr(p1) points to the arguments i.e. the list (x y)
            //  caddr(p1) points to the function body i.e. (expt x y)
            // F function name
            // A argument list
            // B function body
            /**
             * The assignment is converted info a binding of f to (function body argList).
             *
             * @param p1 (= (f argList) body)
             */
            function define_user_function(p1, $) {
                // console.lg(`define_user_function ${print_list(p1, $)}`);
                /**
                 * The function name.
                 */
                const F = caadr(p1);
                /**
                 * The argument list.
                 */
                const A = cdadr(p1);
                /**
                 * The function body.
                 */
                let B = caddr(p1);
                // console.lg(`F => ${F}`);
                // console.lg(`A => ${A}`);
                // console.lg(`B => ${B}`);
                if (!is_sym(F)) {
                    halt('function name?');
                }
                // evaluate function body (maybe)
                if (car(B).equals(EVAL)) {
                    B = $.valueOf(cadr(B));
                }
                // note how, unless explicitly forced by an eval,
                // (handled by the if just above)
                // we don't eval/simplify
                // the body.
                // Why? because it's the easiest way
                // to solve scope problems i.e.
                //   x = 0
                //   f(x) = x + 1
                //   f(4) # would reply 1
                // which would need to otherwise
                // be solved by some scope device
                // somehow
                B = items_to_cons(FUNCTION, B, A);
                $.setSymbolValue(F, B);
                return nil;
            }

            //-----------------------------------------------------------------------------
            //
            //  Input:    n    Number of args on stack
            //
            //      tos-n    Right-hand value
            //
            //      tos-n+1    Left-hand value
            //
            //      tos-n+2    First index
            //
            //      .
            //      .
            //      .
            //
            //      tos-1    Last index
            //
            //  Output:    Result on stack
            //
            //-----------------------------------------------------------------------------
            function set_component(n) {
                if (n < 3) {
                    halt('error in indexed assign');
                }
                const s = defs.tos - n;
                const RVALUE = defs.stack[s];
                const lhs = defs.stack[s + 1];
                if (!is_tensor(lhs)) {
                    halt('error in indexed assign: assigning to something that is not a tensor');
                }
                const m = n - 2;
                if (m > lhs.ndim) {
                    halt('error in indexed assign');
                }
                let k = 0;
                for (let i = 0; i < m; i++) {
                    const t = nativeInt(defs.stack[s + i + 2]);
                    if (t < 1 || t > lhs.dim(i)) {
                        halt('error in indexed assign\n');
                    }
                    k = k * lhs.dim(i) + t - 1;
                }
                for (let i = m; i < lhs.ndim; i++) {
                    k = k * lhs.dim(i) + 0;
                }
                const dims = lhs.copyDimensions();
                const elems = lhs.copyElements();
                if (lhs.ndim === m) {
                    if (is_tensor(RVALUE)) {
                        halt('error in indexed assign');
                    }
                    elems[k] = RVALUE;
                    move_top_of_stack(defs.tos - n);
                    stack_push(new Tensor(dims, elems));
                    return;
                }
                // see if the rvalue matches
                if (!is_tensor(RVALUE)) {
                    halt('error in indexed assign');
                }
                if (lhs.ndim - m !== RVALUE.ndim) {
                    halt('error in indexed assign');
                }
                for (let i = 0; i < RVALUE.ndim; i++) {
                    if (dims[m + i] !== RVALUE.dim(i)) {
                        halt('error in indexed assign');
                    }
                }
                // copy rvalue
                for (let i = 0; i < RVALUE.nelem; i++) {
                    elems[k + i] = RVALUE.elem(i);
                }
                move_top_of_stack(defs.tos - n);
                stack_push(new Tensor(dims, elems));
            }

            // Here "setq" is a misnomer because
            //-----------------------------------------------------------------------------
            function setq_indexed(p1, $) {
                const p4 = cadadr(p1);
                // console.lg(`p4: ${toInfixString(p4)}`);
                if (!is_sym(p4)) {
                    // this is likely to happen when one tries to
                    // do assignments like these
                    //   1[2] = 3
                    // or
                    //   f(x)[1] = 2
                    // or
                    //   [[1,2],[3,4]][5] = 6
                    //
                    // In other words, one can only do
                    // a straight assignment like
                    //   existingMatrix[index] = something
                    throw new Error('indexed assignment: expected a symbol name');
                }
                const h = defs.tos;
                stack_push($.valueOf(caddr(p1)));
                const p2 = cdadr(p1);
                if (is_cons(p2)) {
                    stack_push_items([...p2].map(function (x) {
                        return $.valueOf(x);
                    }));
                }
                set_component(defs.tos - h);
                const p3 = stack_pop();
                $.setSymbolValue(p4, p3);
                return nil;
            }

            let Builder$4q = class Builder {
                create($) {
                    return new Op$3G($);
                }
            };
            // Evaluates the right side and assigns the
            // result of the evaluation to the left side.
            // It's called setq because it stands for "set quoted" from Lisp,
            // see:
            //   http://stackoverflow.com/questions/869529/difference-between-set-setq-and-setf-in-common-lisp
            // Note that this also takes case of assigning to a tensor
            // element, which is something that setq wouldn't do
            // in list, see comments further down below.
            // Example:
            //   f = x
            //   // f evaluates to x, so x is assigned to g really
            //   // rather than actually f being assigned to g
            //   g = f
            //   f = y
            //   g
            //   > x
            /**
             * @param expr (set! var expr)
             */
            function Eval_setq(expr, $) {
                // console.lg(`Eval_setq ${expr}`);
                const lhs = expr.lhs;
                // case of tensor
                if (caadr(expr).equals(SYM_MATH_COMPONENT)) {
                    return setq_indexed(expr, $);
                }
                // case of function definition
                if (is_cons(lhs)) {
                    define_user_function(expr, $);
                    return nil;
                }
                if (!is_sym(lhs)) {
                    halt('symbol assignment: error in symbol');
                }
                // TODO: The evaluation of the right hand side is not really necessary.
                const binding = $.valueOf(expr.rhs);
                $.setSymbolValue(lhs, binding);
                // An assignment returns nothing.
                // This is unlike most programming languages
                // where an assignment does return the
                // assigned value.
                // TODO Could be changed.
                return nil;
            }
            /**
             *
             */
            let Op$3G = class Op extends Function2 {
                constructor($) {
                    super('assign_any_any', ASSIGN, is_any, is_any, $);
                }
                transform(expr) {
                    const m = this.match(expr);
                    if (m) {
                        return this.transform2(m.opr, m.lhs, m.rhs, m);
                    }
                    return [TFLAG_NONE, expr];
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    // console.lg(`${this.name} ${print_expr(lhs, $)} ${ASSIGN} ${print_expr(rhs, $)}`);
                    // $.setBinding(lhs, rhs);
                    // Assignments return NIL to prevent them from being printed.
                    // That's a bit unfortunate for chained assignments.
                    // The kernel of the problem is the printing of expressions by default in the REPL.
                    return [TFLAG_DIFF, Eval_setq(expr, $)];
                }
            };
            const assign_any_any = new Builder$4q();

            let Builder$4p = class Builder {
                create($) {
                    return new Op$3F($);
                }
            };
            let Op$3F = class Op extends Function2 {
                constructor($) {
                    super('assign_sym_any', ASSIGN, is_sym, is_any, $);
                    this.hash = hash_binop_atom_atom(ASSIGN, HASH_SYM, HASH_ANY);
                }
                transform(expr) {
                    const m = this.match(expr);
                    if (m) {
                        const $ = this.$;
                        // Unlike the base class, we do not evaluate the left hand side (var) of the assignment.
                        const [flagsR, rhs] = $.transform(m.rhs);
                        if (diffFlag(flagsR)) {
                            return [TFLAG_DIFF, $.valueOf(items_to_cons$1(m.opr, m.lhs, rhs))];
                        }
                        else {
                            return this.transform2(m.opr, m.lhs, m.rhs, m);
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    $.setSymbolValue(lhs, rhs);
                    // Assignments return NIL to prevent them from being printed.
                    // That's a bit unfortunate for chained assignments.
                    // The kernel of the problem is the printing of expressions by default in the REPL.
                    return [TFLAG_DIFF, nil];
                }
            };
            const assign_sym_any = new Builder$4p();

            let Builder$4o = class Builder {
                create($) {
                    return new Op$3E($);
                }
            };
            let Op$3E = class Op extends FunctionVarArgs {
                constructor($) {
                    super('besselj', BESSELJ, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_besselj(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const besselj_varargs = new Builder$4o();

            let Builder$4n = class Builder {
                create($) {
                    return new Op$3D($);
                }
            };
            let Op$3D = class Op extends FunctionVarArgs {
                constructor($) {
                    super('bessely', BESSELY, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_bessely(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const bessely_varargs = new Builder$4n();

            //  Binomial coefficient
            //
            //  Input:    tos-2    n
            //
            //      tos-1    k
            //
            //  Output:    Binomial coefficient on stack
            //
            //  binomial(n, k) = n! / k! / (n - k)!
            //
            //  The binomial coefficient vanishes for k < 0 or k > n. (A=B, p. 19)
            function Eval_binomial(p1, $) {
                const N = $.valueOf(cadr(p1));
                const K = $.valueOf(caddr(p1));
                const result = binomial(N, K, $);
                return result;
            }
            function binomial(N, K, $) {
                return ybinomial(N, K, $);
            }
            function ybinomial(N, K, $) {
                if (!BINOM_check_args(N, K)) {
                    return zero;
                }
                return divide(divide(factorial(N), factorial(K), $), factorial($.subtract(N, K)), $);
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function BINOM_check_args(N, K, $) {
                if (is_num(N) && lt_num_num(N, zero)) {
                    return false;
                }
                else if (is_num(K) && lt_num_num(K, zero)) {
                    return false;
                }
                else if (is_num(N) && is_num(K) && lt_num_num(N, K)) {
                    return false;
                }
                else {
                    return true;
                }
            }

            let Builder$4m = class Builder {
                create($) {
                    return new Op$3C($);
                }
            };
            let Op$3C = class Op extends FunctionVarArgs {
                constructor($) {
                    super('binomial', BINOMIAL, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_binomial(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const binomial_varargs = new Builder$4m();

            class BooExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return booT.name;
                }
                get hash() {
                    return HASH_BOO;
                }
                get name() {
                    return 'BooExtension';
                }
                evaluate(expr, argList, $) {
                    return this.transform(cons(expr, argList), $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform(expr, $) {
                    if (expr instanceof Boo) {
                        return [TFLAG_HALT, expr];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(expr, $) {
                    return expr;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    throw new Error("Boo Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isKind(arg) {
                    return arg instanceof Boo;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(arg, $) {
                    throw new Error("Boo Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(arg, $) {
                    throw new Error("Boo Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    throw new Error("Boo Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar() {
                    throw new Error("Boo Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(arg, $) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                subst(expr, oldExpr, newExpr, $) {
                    return expr;
                    // throw new Error(`Boo.subst(expr=${render_as_infix(expr, $)}, oldExpr=${render_as_infix(oldExpr, $)}, newExpr=${render_as_infix(newExpr, $)}) Method not implemented.`);
                }
                toInfixString(expr) {
                    return expr.equals(booT) ? 'true' : 'false';
                }
                toLatexString(expr) {
                    return expr.equals(booT) ? 'true' : 'false';
                }
                toListString(expr) {
                    return expr.equals(booT) ? '#t' : '#f';
                }
            }
            const boo_extension = new ExtensionOperatorBuilder(function ($) {
                return new BooExtension($);
            });

            let Builder$4l = class Builder {
                create($) {
                    return new Ceiling($);
                }
            };
            class Ceiling extends Function1 {
                constructor($) {
                    super('ceiling_cons', create_sym('ceiling'), is_cons, $);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                }
            }
            const ceiling_cons = new Builder$4l();

            let Builder$4k = class Builder {
                create($) {
                    return new CeilingFlt($);
                }
            };
            class CeilingFlt extends Function1 {
                constructor($) {
                    super('ceiling_flt', create_sym('ceiling'), is_flt$1, $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, create_flt(Math.ceil(arg.d))];
                }
            }
            const ceiling_flt = new Builder$4k();

            let Builder$4j = class Builder {
                create($) {
                    return new CeilingRat($);
                }
            };
            class CeilingRat extends Function1 {
                constructor($) {
                    super('ceiling_rat', create_sym('ceiling'), is_rat, $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg.ceiling()];
                }
            }
            const ceiling_rat = new Builder$4j();

            // like Eval() except "=" (assignment) is treated
            const testeq$1 = native_sym(Native.test_eq);
            /**
             * Allows users to be lazy and use "=" as a test for equality.
             * There is no evaluation by this function.
             */
            function replace_assign_with_testeq(expr) {
                if (is_cons(expr) && expr.head.equals(ASSIGN)) {
                    // replace the assignment in the head with an equality test
                    const argList = expr.argList;
                    const lhs = argList.head;
                    const rhs = argList.cdr.head;
                    return items_to_cons$1(testeq$1, lhs, rhs);
                }
                else {
                    return expr;
                }
            }

            // This is a key routine to try to determine whether
            // routine is sufficient.
            function isZeroLikeOrNonZeroLikeOrUndetermined(valueOrPredicate, $) {
                // just like Eval but turns assignments into equality checks
                const value = $.valueOf(replace_assign_with_testeq(valueOrPredicate));
                // OK first check if we already have
                // a simple zero (or simple zero tensor)
                if ($.is_zero(value)) {
                    return false;
                }
                // also check if we have a simple numeric value, or a tensor
                // full of simple numeric values (i.e. straight doubles or fractions).
                // In such cases, since we
                // just excluded they are zero, then we take it as
                // a "true"
                if (is_num_or_tensor_or_identity_matrix(value)) {
                    return true;
                }
                // if we are here we are in the case of value that
                // is not a zero and not a simple numeric value.
                // e.g. stuff like
                // 'sqrt(2)', or 'sin(45)' or '1+i', or 'a'
                // so in such cases let's try to do a float()
                // so we might get down to a simple numeric value
                // in some of those cases
                // TODO: Why do we use zz float when we know that the value is fully evaluated?
                const valueAsFlt = zzfloat(value, $);
                // anything that could be calculated down to a simple
                // numeric value is now indeed either a
                // double OR a double with an imaginary component
                // e.g. 2.0 or 2.4 + i*5.6
                // (Everything else are things that don't have a numeric
                // value e.g. 'a+b')
                // So, let's take care of the case where we have
                // a simple numeric value with NO imaginary component,
                // things like sqrt(2) or sin(PI)
                // by doing the simple numeric
                // values checks again
                if ($.is_zero(valueAsFlt)) {
                    return false;
                }
                if (is_num_or_tensor_or_identity_matrix(valueAsFlt)) {
                    return true;
                }
                // here we still have cases of simple numeric values
                // WITH an imaginary component e.g. '1+i',
                // or things that don't have a numeric value e.g. 'a'
                // so now let's take care of the imaginary numbers:
                // since we JUST have to spot "zeros" we can just
                // calculate the absolute value and re-do all the checks
                // we just did
                if (valueAsFlt.contains(imu)) {
                    const complexValue = $.valueOf(replace_assign_with_testeq(float_eval_abs_eval(valueAsFlt, $)));
                    // re-do the simple-number checks...
                    if ($.is_zero(complexValue)) {
                        return false;
                    }
                    if (is_num_or_tensor_or_identity_matrix(complexValue)) {
                        return true;
                    }
                }
                // here we have stuff that is not reconducible to any
                // numeric value (or tensor with numeric values) e.g.
                // 'a+b', so it just means that we just don't know the
                // truth value, so we have
                // to leave the whole thing unevalled
                return null;
            }

            /* check =====================================================================
             
            Tags
            ----
            scripting, JS, internal, treenode, general concept
             
            Parameters
            ----------
            p
             
            General description
            -------------------
            Returns whether the predicate p is true/false or unknown:
            0 if false, 1 if true or remains unevaluated if unknown.
            Note that if "check" is passed an assignment, it turns it into a test,
            i.e. check(a = b) is turned into check(a==b)
            so "a" is not assigned anything.
            Like in many programming languages, "check" also gives truthyness/falsyness
            for numeric values. In which case, "true" is returned for non-zero values.
            Potential improvements: "check" can't evaluate strings yet.
             
            */
            function Eval_check(expr, $) {
                // Don't evaluate the arguments! We don't want assignment as a side effect.
                const arg = expr.argList.head;
                const checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(arg, $);
                if (typeof checkResult === 'boolean') {
                    // returned JavaScript true or false -> 1 or 0
                    // TODO: More natural to return Bool. Should we make this configurable.
                    // e.g. $.getNativeDirective(Directive.useIntegerForBoolean)
                    return create_int(Number(checkResult));
                }
                else if (checkResult) {
                    throw new Error();
                }
                else {
                    // returned null: unknown result
                    // leave the whole check unevalled
                    return expr;
                }
            }

            /* choose =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            n,k

            General description
            -------------------

            Returns the number of combinations of n items taken k at a time.

            For example, the number of five card hands is choose(52,5)

            ```
                                      n!
                  choose(n,k) = -------------
                                 k! (n - k)!
            ```
            */
            function Eval_choose(expr, $) {
                // console.lg(`Eval_choose ${$.toListString(expr)}`);
                const cdr_expr = expr.cdr;
                const N = $.valueOf(car(cdr_expr));
                // console.lg(`N => ${$.toListString(N)}`);
                const K = $.valueOf(cadr(cdr_expr));
                // console.lg(`K => ${$.toListString(K)}`);
                const result = choose(N, K, $);
                return result;
            }
            function choose(N, K, $) {
                // console.lg(`choose(N = ${$.toListString(N)}, K = ${$.toListString(N)})`);
                if (!choose_check_args(N, K)) {
                    return zero;
                }
                return divide(divide(factorial(N), factorial(K), $), factorial($.subtract(N, K)), $);
            }
            // Result vanishes for k < 0 or k > n. (A=B, p. 19)
            function choose_check_args(N, K) {
                if (is_num(N) && compare_num_num(N, zero) < 0) {
                    return false;
                }
                else if (is_num(K) && compare_num_num(K, zero) < 0) {
                    return false;
                }
                else if (is_num(N) && is_num(K) && compare_num_num(N, K) < 0) {
                    return false;
                }
                else {
                    return true;
                }
            }

            let Builder$4i = class Builder {
                create($) {
                    return new Op$3B($);
                }
            };
            let Op$3B = class Op extends FunctionVarArgs {
                constructor($) {
                    super('choose', CHOOSE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_choose(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const choose_varargs = new Builder$4i();

            const e = native_sym(Native.E);
            const pow$1 = native_sym(Native.pow);
            /**
             * expcos(x) = (1/2)*(exp(x*i)+exp(-x*i))
             */
            function expcos(x, $) {
                const exp_pos_x_times_i = items_to_cons$1(pow$1, e, $.multiply(x, imu));
                exp_pos_x_times_i.meta |= TFLAG_KEEP;
                const exp_neg_x_times_i = items_to_cons$1(pow$1, e, $.multiply($.negate(x), imu));
                exp_neg_x_times_i.meta |= TFLAG_KEEP;
                return $.multiply(half, $.add(exp_pos_x_times_i, exp_neg_x_times_i));
            }

            function expsin(x, $) {
                const exp_pos_ix = items_to_cons$1(MATH_POW$2, MATH_E$2, $.multiply(imu, x));
                exp_pos_ix.meta |= TFLAG_KEEP;
                const exp_neg_ix = items_to_cons$1(MATH_POW$2, MATH_E$2, $.multiply($.negate(imu), x));
                exp_neg_ix.meta |= TFLAG_KEEP;
                return $.subtract($.multiply(divide(exp_pos_ix, imu, $), half), $.multiply(divide(exp_neg_ix, imu, $), half));
            }

            function circexp(p1, $) {
                if (car(p1).equals(COS$3)) {
                    return expcos(cadr(p1), $);
                }
                if (car(p1).equals(SIN$1)) {
                    return expsin(cadr(p1), $);
                }
                if (car(p1).equals(TAN)) {
                    p1 = cadr(p1);
                    const p2 = exp$1($.multiply(imu, p1), $);
                    const p3 = exp$1($.negate($.multiply(imu, p1)), $);
                    return divide($.multiply($.subtract(p3, p2), imu), $.add(p2, p3), $);
                }
                if (car(p1).equals(COSH)) {
                    p1 = cadr(p1);
                    return $.multiply($.add(exp$1(p1, $), exp$1($.negate(p1), $)), half);
                }
                if (car(p1).equals(SINH)) {
                    p1 = cadr(p1);
                    return $.multiply($.subtract(exp$1(p1, $), exp$1($.negate(p1), $)), half);
                }
                if (car(p1).equals(TANH)) {
                    p1 = exp$1($.multiply(cadr(p1), two), $);
                    return divide($.subtract(p1, one), $.add(p1, one), $);
                }
                if (is_cons(p1)) {
                    return p1.map(function (x) {
                        return circexp(x, $);
                    });
                }
                if (is_tensor(p1)) {
                    const elems = p1.mapElements(function (x) {
                        return circexp(x, $);
                    });
                    return p1.withElements(elems);
                }
                return p1;
            }

            let Builder$4h = class Builder {
                create($) {
                    return new Op$3A($);
                }
            };
            let Op$3A = class Op extends Function1 {
                constructor($) {
                    super('circexp_any', CIRCEXP, is_any, $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, oldExpr) {
                    const $ = this.$;
                    $.pushNativeDirective(Directive.evaluatingTrigAsExp, true);
                    try {
                        const rawExpr = circexp(arg, $);
                        const newExpr = $.valueOf(rawExpr);
                        // console.lg(`oldExpr=${oldExpr}`);
                        // console.lg(`rawExpr=${rawExpr}`);
                        // console.lg(`newExpr=${newExpr}`);
                        const changed = !newExpr.equals(oldExpr);
                        return [changed ? TFLAG_DIFF : TFLAG_NONE, newExpr];
                    }
                    finally {
                        $.popNativeDirective();
                    }
                }
            };
            const circexp_any = new Builder$4h();

            let Builder$4g = class Builder {
                create($) {
                    return new Op$3z($);
                }
            };
            let Op$3z = class Op extends Function1 {
                constructor($) {
                    super('clock_any', CLOCK, is_any, $);
                    this.hash = hash_unaop_atom(CLOCK, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, oldExpr) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        const newExpr = clock(arg, $);
                        return [TFLAG_DIFF, newExpr];
                    }
                    else {
                        return [TFLAG_NONE, oldExpr];
                    }
                }
            };
            const clock_any = new Builder$4g();

            let Builder$4f = class Builder {
                create($) {
                    return new Op$3y($);
                }
            };
            let Op$3y = class Op extends FunctionVarArgs {
                constructor($) {
                    super('coeff', COEFF, $);
                    this.phases = PHASE_FLAGS_EXPANDING_UNION_FACTORING;
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_coeff(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const coeff_varargs = new Builder$4f();

            let Builder$4e = class Builder {
                create($) {
                    return new Op$3x($);
                }
            };
            let Op$3x = class Op extends FunctionVarArgs {
                constructor($) {
                    super('cofactor', COFACTOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_cofactor(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const cofactor_varargs = new Builder$4e();

            let Builder$4d = class Builder {
                create($) {
                    return new Op$3w($);
                }
            };
            let Op$3w = class Op extends FunctionVarArgs {
                constructor($) {
                    super('condense', CONDENSE, $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_condense(expr, $);
                    retval.meta |= TFLAG_KEEP;
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const condense_varargs = new Builder$4d();

            const conj = native_sym(Native.conj);
            const add = native_sym(Native.add);
            let Builder$4c = class Builder {
                create($) {
                    return new Op$3v($);
                }
            };
            /**
             * conj(a + b + c ...) = conj(a) + conj(b) + conj(c) + ...
             */
            let Op$3v = class Op extends CompositeOperator {
                constructor($) {
                    super(conj, add, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const terms = innerExpr.tail();
                    const mapped = terms.map(function (term) {
                        return $.conj(term);
                    });
                    return [TFLAG_DIFF, $.valueOf(items_to_cons$1(add, ...mapped))];
                }
            };
            const conj_add = new Builder$4c();

            const MATH_CONJ = create_sym('conj');

            let Builder$4b = class Builder {
                create($) {
                    return new ConjAny($);
                }
            };
            class ConjAny extends Function1 {
                constructor($) {
                    super('conj_any', MATH_CONJ, is_any, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    throw new Error(this.$.toInfixString(arg));
                    /*
                    if (is_cons(arg)) {
                        if (this.$.is_real(arg)) {
                            return [TFLAG_DIFF, arg];
                        }
                    }
                    return [TFLAG_NONE, expr];
                    */
                }
            }
            const conj_any = new Builder$4b();

            let Builder$4a = class Builder {
                create($) {
                    return new ConjBlade($);
                }
            };
            class ConjBlade extends Function1 {
                constructor($) {
                    super('conj_blade', MATH_CONJ, is_blade$1, $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg.rev()];
                }
            }
            const conj_blade = new Builder$4a();

            let Builder$49 = class Builder {
                create($) {
                    return new ConjRat$1($);
                }
            };
            let ConjRat$1 = class ConjRat extends Function1 {
                constructor($) {
                    super('conj_flt', MATH_CONJ, is_flt, $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg];
                }
            };
            const conj_flt = new Builder$49();

            let Builder$48 = class Builder {
                create($) {
                    return new ConjImaginaryUnit($);
                }
            };
            class ConjImaginaryUnit extends Function1 {
                constructor($) {
                    super('conj_imu', MATH_CONJ, is_imu, $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3, negOne, arg)];
                }
            }
            const conj_imu = new Builder$48();

            function is_inner(expr) {
                const opr = expr.opr;
                if (is_sym(opr)) {
                    return MATH_INNER.equalsSym(opr);
                }
                else {
                    return false;
                }
            }

            function is_inner_2_any_any(expr) {
                return is_inner(expr) && is_binop(expr);
            }

            let Builder$47 = class Builder {
                create($) {
                    return new ConjInner($);
                }
            };
            /**
             * conj(inner(y,x)) = inner(x,y)
             */
            class ConjInner extends Function1 {
                constructor($) {
                    super('conj_inner', MATH_CONJ, and(is_cons, is_inner_2_any_any), $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, items_to_cons$1(arg.opr, arg.rhs, arg.lhs)];
                }
            }
            const conj_inner = new Builder$47();

            let Builder$46 = class Builder {
                create($) {
                    return new Op$3u($);
                }
            };
            /**
             * conj(a * b) => conj(a) * conj(b), for a,b scalars.
             */
            let Op$3u = class Op extends Function1 {
                constructor($) {
                    // TODO; Could the name be replaced by the hash?
                    super('conj_mul_2_any_any', MATH_CONJ, and(is_cons, is_opr_2_any_any(MATH_MUL$3)), $);
                    this.hash = hash_unaop_cons(MATH_CONJ, MATH_MUL$3);
                }
                transform1(opr, arg, expr) {
                    // console.lg(`${this.name} arg=>${render_as_infix(arg, this.$)} expr=>${render_as_infix(expr, this.$)}`);
                    const $ = this.$;
                    const M = arg.opr;
                    const L = arg.lhs;
                    const R = arg.rhs;
                    // console.lg(`isExpanding=${$.isExpanding()}`);
                    if ($.isExpanding()) {
                        if ($.isScalar(L) && $.isScalar(R)) {
                            const conj_L = $.valueOf(items_to_cons$1(MATH_CONJ, L));
                            const conj_R = $.valueOf(items_to_cons$1(MATH_CONJ, R));
                            const retval = items_to_cons$1(M, conj_L, conj_R);
                            return [TFLAG_DIFF, retval];
                        }
                        else {
                            return [TFLAG_NONE, expr];
                        }
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const conj_mul_2_any_any = new Builder$46();

            let Builder$45 = class Builder {
                create($) {
                    return new ConjRat($);
                }
            };
            class ConjRat extends Function1 {
                constructor($) {
                    super('conj_rat', MATH_CONJ, is_rat$1, $);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg];
                }
            }
            const conj_rat = new Builder$45();

            let Builder$44 = class Builder {
                create($) {
                    return new ConjSym($);
                }
            };
            class ConjSym extends Function1 {
                constructor($) {
                    super('conj_sym', MATH_CONJ, is_sym, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    // TODO: Strictly speaking we need the symbol to be a real number.
                    return [TFLAG_DIFF, arg];
                }
            }
            const conj_sym = new Builder$44();

            /* deg =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            p,x

            General description
            -------------------
            Returns the degree of polynomial p(x).

            */
            function Eval_degree(degreeInvoke, $) {
                const p1 = $.valueOf(caddr(degreeInvoke));
                const top = $.valueOf(cadr(p1));
                const variable = nil.equals(p1) ? guess(top) : p1;
                return degree(top, variable, $);
            }
            //-----------------------------------------------------------------------------
            //
            //  Find the degree of a polynomial
            //
            //  Input:    POLY    p(x)
            //            X       x
            //
            //  Output:    Result
            //
            //  Note: Finds the largest numerical power of x. Does not check for
            //  weirdness in p(x).
            //
            //-----------------------------------------------------------------------------
            function degree(P, X, $) {
                return yydegree(P, X, zero, $);
            }
            function yydegree(P, X, d, $) {
                if (P.equals(X)) {
                    if ($.is_zero(d)) {
                        return one;
                    }
                    else {
                        return d;
                    }
                }
                else if (is_cons(P) && is_power(P)) {
                    // It's not obvious in the following that we are looking at the base and exponent.
                    // A match on (expt base exponent) would make this clearer.
                    const caddr_poly = caddr(P);
                    if ($.equals(cadr(P), X) && is_num(caddr_poly) && compare_num_num(d, caddr_poly) < 0) {
                        return caddr_poly;
                    }
                    else {
                        return d;
                    }
                }
                else if (is_cons(P)) {
                    return P.tail().reduce(function (prev, curr) {
                        return yydegree(curr, X, prev, $);
                    }, d);
                }
                else {
                    return d;
                }
            }

            // we test A==B by first subtracting and checking if we symbolically
            // get zero. If not, we evaluate to float and check if we get a zero.
            // If we get another NUMBER then we know they are different.
            // If we get something else, then we don't know and we return the
            // unaveluated test, which is the same as saying "maybe".
            function Eval_testeq(p1, $) {
                // first try without simplifyng both sides
                const orig = p1;
                let subtractionResult = $.subtract($.valueOf(cadr(p1)), $.valueOf(caddr(p1)));
                // OK so we are doing something tricky here
                // we are using isZeroLikeOrNonZeroLikeOrUndetermined to check if the result
                // is zero or not zero or unknown.
                // isZeroLikeOrNonZeroLikeOrUndetermined has some routines
                // to determine the zero-ness/non-zero-ness or
                // undeterminate-ness of things so we use
                // that here and down below.
                let checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult, $);
                if (checkResult) {
                    return zero;
                }
                else if (checkResult != null && !checkResult) {
                    return one;
                }
                // we didn't get a simple numeric result but
                // let's try again after doing
                // a simplification on both sides
                const arg1 = simplify($.valueOf(cadr(p1)), $);
                const arg2 = simplify($.valueOf(caddr(p1)), $);
                subtractionResult = $.subtract(arg1, arg2);
                checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult, $);
                if (checkResult) {
                    return zero;
                }
                else if (checkResult != null && !checkResult) {
                    return one;
                }
                // if we didn't get to a number then we
                // don't know whether the quantities are
                // different so do nothing
                return orig;
            }
            // Relational operators expect a numeric result for operand difference.
            function Eval_testge(p1, $) {
                const orig = p1;
                const comparison = cmp_args(p1, $);
                if (comparison == null) {
                    return orig;
                }
                if (comparison >= 0) {
                    return one;
                }
                else {
                    return zero;
                }
            }
            function Eval_testgt(p1, $) {
                const orig = p1;
                const comparison = cmp_args(p1, $);
                if (comparison == null) {
                    return orig;
                }
                if (comparison > 0) {
                    return one;
                }
                else {
                    return zero;
                }
            }
            function Eval_testle(p1, $) {
                const orig = p1;
                const comparison = cmp_args(p1, $);
                if (comparison == null) {
                    return orig;
                }
                if (comparison <= 0) {
                    return one;
                }
                else {
                    return zero;
                }
            }
            function Eval_testlt(arg, $) {
                const orig = arg;
                const comparison = cmp_args(arg, $);
                // console.lg(`comparison => ${comparison}`);
                if (comparison == null) {
                    // I hope this is dead code.
                    return orig;
                }
                if (comparison < 0) {
                    return one;
                }
                else {
                    return zero;
                }
            }
            // not definition
            function Eval_not(expr, $) {
                const wholeAndExpression = expr;
                const checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(expr), $);
                if (checkResult == null) {
                    // inconclusive test on predicate
                    return wholeAndExpression;
                }
                else if (checkResult) {
                    // true -> false
                    return zero;
                }
                else {
                    // false -> true
                    return one;
                }
            }
            /* and =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            a,b,...

            General description
            -------------------
            Logical-and of predicate expressions.

            */
            // and definition
            function Eval_and(p1, $) {
                const wholeAndExpression = p1;
                let andPredicates = cdr(wholeAndExpression);
                let somePredicateUnknown = false;
                while (is_cons(andPredicates)) {
                    // eval each predicate
                    const checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates), $);
                    if (checkResult == null) {
                        // here we have stuff that is not reconducible to any
                        // numeric value (or tensor with numeric values) e.g.
                        // 'a+b', so it just means that we just don't know the
                        // truth value of this particular predicate.
                        // We'll track the fact that we found an unknown
                        // predicate and we continue with the other predicates.
                        // (note that in case some subsequent predicate will be false,
                        // it won't matter that we found some unknowns and
                        // the whole test will be immediately zero).
                        somePredicateUnknown = true;
                        andPredicates = cdr(andPredicates);
                    }
                    else if (checkResult) {
                        // found a true, move on to the next predicate
                        andPredicates = cdr(andPredicates);
                    }
                    else if (!checkResult) {
                        // found a false, enough to falsify everything and return
                        return zero;
                    }
                }
                // We checked all the predicates and none of them
                // was false. So they were all either true or unknown.
                // Now, if even just one was unknown, we'll have to call this
                // test as inconclusive and return the whole test expression.
                // If all the predicates were known, then we can conclude
                // that the test returns true.
                if (somePredicateUnknown) {
                    return wholeAndExpression;
                }
                else {
                    return one;
                }
            }
            // or definition
            function Eval_or(p1, $) {
                const wholeOrExpression = p1;
                let orPredicates = cdr(wholeOrExpression);
                let somePredicateUnknown = false;
                while (is_cons(orPredicates)) {
                    // eval each predicate
                    const checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates), $);
                    if (checkResult == null) {
                        // here we have stuff that is not reconducible to any
                        // numeric value (or tensor with numeric values) e.g.
                        // 'a+b', so it just means that we just don't know the
                        // truth value of this particular predicate.
                        // We'll track the fact that we found an unknown
                        // predicate and we continue with the other predicates.
                        // (note that in case some subsequent predicate will be false,
                        // it won't matter that we found some unknowns and
                        // the whole test will be immediately zero).
                        somePredicateUnknown = true;
                        orPredicates = cdr(orPredicates);
                    }
                    else if (checkResult) {
                        // found a true, enough to return true
                        return one;
                    }
                    else if (!checkResult) {
                        // found a false, move on to the next predicate
                        orPredicates = cdr(orPredicates);
                    }
                }
                // We checked all the predicates and none of them
                // was true. So they were all either false or unknown.
                // Now, if even just one was unknown, we'll have to call this
                // test as inconclusive and return the whole test expression.
                // If all the predicates were known, then we can conclude
                // that the test returns false.
                if (somePredicateUnknown) {
                    return wholeOrExpression;
                }
                else {
                    return zero;
                }
            }
            // use subtract for cases like A < A + 1
            // TODO you could be smarter here and
            // simplify both sides only in the case
            // of "relational operator: cannot determine..."
            // a bit like we do in Eval_testeq
            /**
             *
             * @param args
             * @param $
             * @returns
             */
            function cmp_args(args, $) {
                let t = SIGN_EQ;
                const arg1 = simplify($.valueOf(cadr(args)), $);
                const arg2 = simplify($.valueOf(caddr(args)), $);
                let diff = $.subtract(arg1, arg2);
                // try floating point if necessary
                // This will go recursive and you will think your values are being promoted.
                // Stay calm! Don't panic.
                if (!is_rat$1(diff) && !is_flt$1(diff)) {
                    diff = $.valueOf(evaluate_as_float(diff, $));
                }
                if ($.is_zero(diff)) {
                    return 0;
                }
                if (is_rat$1(diff)) {
                    if (MSIGN(diff.a) === -1) {
                        t = -1;
                    }
                    else {
                        t = 1;
                    }
                }
                else if (is_flt$1(diff)) {
                    if (diff.d < 0.0) {
                        t = -1;
                    }
                    else {
                        t = 1;
                    }
                }
                else {
                    t = null;
                }
                return t;
            }

            /**
             * Cons, like Sym is actually fundamental to the tree (not an Extension).
             * However, this is defined so that extensions can define operators with Cons.
             * e.g. Defining operator * (Tensor, Cons) would allow Cons expressions to multiply Tensor elements.
             * TODO: It may be possible to register this as an Extension, but we don't do it for now.
             * There may be some advantages in registering it as an extension. e.g. We could explicitly
             * define where Cons appears when sorting elements. Also, less special-case code for Cons.
             */
            class ConsExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return 'Cons';
                }
                get hash() {
                    return 'Cons';
                }
                get name() {
                    return 'ConsExtension';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                compareFactors(lhs, rhs, $) {
                    throw new Error("Cons Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr, $) {
                    return false;
                }
                isKind(expr) {
                    if (is_cons(expr)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(arg, $) {
                    // The answer would be false if we give up.
                    throw new Error("Cons Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(arg, $) {
                    throw new Error("Cons Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr, $) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr, $) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(arg, $) {
                    throw new Error("Cons Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                subst(expr, oldExpr, newExpr, $) {
                    throw new Error(`expr = ${expr} oldExpr = ${oldExpr} newExpr = ${newExpr}`);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(cons, $) {
                    return to_infix_string(cons, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(cons, $) {
                    return to_infix_string(cons, $);
                }
                toListString(cons, $) {
                    let str = '';
                    str += '(';
                    str += $.toSExprString(cons.car);
                    let expr = cons.cdr;
                    while (is_cons(expr)) {
                        str += ' ';
                        str += $.toSExprString(expr.car);
                        expr = expr.cdr;
                    }
                    if (expr !== nil) {
                        str += ' . ';
                        str += $.toSExprString(expr);
                    }
                    str += ')';
                    return str;
                }
                evaluate(expr, argList, $) {
                    return this.transform(cons(expr, argList), $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform(expr, $) {
                    // console.lg(`ConsExtension.transform ${expr}`);
                    return [TFLAG_NONE, expr];
                }
                valueOf(expr, $) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const hook = function (retval, description) {
                        // console.lg(`ConsExtension.valueOf expr => ${expr} @ ${description}`);
                        return retval;
                    };
                    /**
                     * The car of the expression is the symbol for the operator.
                     */
                    const op = expr.car;
                    // If we didn't fall in the EVAL case above
                    // then at this point we must have a symbol, or maybe a list containing stuff that does not have a symbol
                    // in the operator position.
                    if (!is_sym(op)) {
                        const operator = $.operatorFor(op);
                        if (is_nil(expr.cdr)) {
                            // We are being asked to evaluate a list containing a single item.
                            // That's just the evaluation of the item.
                            return hook(operator.valueOf(op));
                        }
                        else {
                            return hook(expr);
                        }
                    }
                    else {
                        return expr;
                    }
                }
            }
            const cons_extension = new ExtensionOperatorBuilder(function ($) {
                return new ConsExtension($);
            });

            /* contract =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            a,i,j

            General description
            -------------------
            Contract across tensor indices i.e. returns "a" summed over indices i and j.
            If i and j are omitted then 1 and 2 are used.
            contract(m) is equivalent to the trace of matrix m.

            */
            function Eval_contract(p1, $) {
                const p1_prime = $.valueOf(cadr(p1));
                let p2, p3;
                if (nil.equals(cddr(p1))) {
                    p2 = one;
                    p3 = two;
                }
                else {
                    p2 = $.valueOf(caddr(p1));
                    p3 = $.valueOf(cadddr(p1));
                }
                const result = contract(p1_prime, p2, p3, $);
                return result;
            }
            function contract(p1, p2, p3, $) {
                // console.lg(`contract ${print_expr(p1, $)} ${print_expr(p2, $)} ${print_expr(p3, $)}`);
                const ai = [];
                const an = [];
                if (!is_tensor(p1)) {
                    if (!$.is_zero(p1)) {
                        halt('contract: tensor expected, 1st arg is not a tensor');
                    }
                    return zero;
                }
                let l = nativeInt(p2);
                let m = nativeInt(p3);
                const { ndim: ndim } = p1;
                if (l < 1 ||
                    l > ndim ||
                    m < 1 ||
                    m > ndim ||
                    l === m ||
                    p1.dim(l - 1) !== p1.dim(m - 1)) {
                    halt('contract: index out of range');
                }
                l--;
                m--;
                const n = p1.dim(l);
                // nelem is the number of elements in "b"
                let nelem = 1;
                for (let i = 0; i < ndim; i++) {
                    if (i !== l && i !== m) {
                        nelem *= p1.dim(i);
                    }
                }
                const dims = new Array(ndim - 2);
                const elems = new Array(nelem);
                let j = 0;
                for (let i = 0; i < ndim; i++) {
                    if (i !== l && i !== m) {
                        dims[j++] = p1.dim(i);
                    }
                }
                const a = p1.copyElements();
                const b = elems;
                for (let i = 0; i < ndim; i++) {
                    ai[i] = 0;
                    an[i] = p1.dim(i);
                }
                for (let i = 0; i < nelem; i++) {
                    let temp = zero;
                    for (let j = 0; j < n; j++) {
                        ai[l] = j;
                        ai[m] = j;
                        let h = 0;
                        for (let k = 0; k < ndim; k++) {
                            h = h * an[k] + ai[k];
                        }
                        // console.lg "a[h]: " + a[h]
                        temp = $.add(temp, a[h]);
                    }
                    // console.lg "tos: " + stack[tos-1]
                    b[i] = temp;
                    // console.lg "b[i]: " + b[i]
                    for (let j = ndim - 1; j >= 0; j--) {
                        if (j === l || j === m) {
                            continue;
                        }
                        if (++ai[j] < an[j]) {
                            break;
                        }
                        ai[j] = 0;
                    }
                }
                if (nelem === 1) {
                    return b[0];
                }
                return new Tensor(dims, elems);
            }

            let Builder$43 = class Builder {
                create($) {
                    return new Op$3t($);
                }
            };
            let Op$3t = class Op extends FunctionVarArgs {
                constructor($) {
                    super('contract', CONTRACT, $);
                    this.dependencies = [];
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_contract(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const contract_varargs = new Builder$43();

            function is_opr_2_lhs_any(sym, guardL) {
                return function (expr) {
                    return is_opr_2_any_any(sym)(expr) && guardL(expr.lhs);
                };
            }

            let Builder$42 = class Builder {
                create($) {
                    return new Op$3s($);
                }
            };
            /**
             * cos(a+b) => cos(a)*cos(b)-sin(a)*sin(b)
             */
            let Op$3s = class Op extends Function1 {
                constructor($) {
                    super('cos_add_2_any_any', MATH_COS, and(is_cons, is_opr_2_lhs_any(MATH_ADD$1, is_any)), $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_unaop_cons(MATH_COS, MATH_ADD$1);
                }
                transform1(opr, arg) {
                    const $ = this.$;
                    const a = arg.lhs;
                    const b = arg.rhs;
                    const cosA = $.valueOf(items_to_cons$1(MATH_COS, a));
                    const cosB = $.valueOf(items_to_cons$1(MATH_COS, b));
                    const sinA = $.valueOf(items_to_cons$1(MATH_SIN, a));
                    const sinB = $.valueOf(items_to_cons$1(MATH_SIN, b));
                    const cacb = $.valueOf(items_to_cons$1(MATH_MUL$3, cosA, cosB));
                    const sasb = $.valueOf(items_to_cons$1(MATH_MUL$3, sinA, sinB));
                    const retval = $.valueOf(items_to_cons$1(MATH_ADD$1, cacb, $.negate(sasb)));
                    return [TFLAG_DIFF, retval];
                }
            };
            const cos_add_2_any_any = new Builder$42();

            function cosine_of_angle(x, oldExpr, $) {
                // console.lg(`cosine_of_angle arg=${render_as_infix(x, $)}`);
                if (car(x).equals(ARCCOS)) {
                    return [TFLAG_DIFF, cadr(x)];
                }
                if (is_flt$1(x)) {
                    let d = Math.cos(x.d);
                    if (Math.abs(d) < 1e-10) {
                        d = 0.0;
                    }
                    return [TFLAG_DIFF, create_flt(d)];
                }
                // cosine function is symmetric, cos(-x) = cos(x)
                if (is_negative(x)) {
                    return [TFLAG_DIFF, $.valueOf(items_to_cons$1(COS$3, $.negate(x)))];
                }
                // cos(arctan(x)) = 1 / sqrt(1 + x^2)
                // see p. 173 of the CRC Handbook of Mathematical Sciences
                if (car(x).equals(ARCTAN)) {
                    const base = $.add(one, $.power(cadr(x), two));
                    return [TFLAG_DIFF, $.power(base, rational(-1, 2))];
                }
                // multiply by 180/pi to go from radians to degrees.
                // we go from radians to degrees because it's much
                // easier to calculate symbolic results of most (not all) "classic"
                // angles (e.g. 30,45,60...) if we calculate the degrees
                // and the we do a switch on that.
                // Alternatively, we could look at the fraction of pi
                // (e.g. 60 degrees is 1/3 pi) but that's more
                // convoluted as we'd need to look at both numerator and
                // denominator.
                const x_times_180 = $.multiply(x, create_int(180));
                const Pi = DynamicConstants.Pi($);
                const n = nativeInt(divide(x_times_180, Pi, $));
                // most "good" (i.e. compact) trigonometric results
                // happen for a round number of degrees. There are some exceptions
                // though, e.g. 22.5 degrees, which we don't capture here.
                if (n < 0 || isNaN(n)) {
                    return [TFLAG_NONE, oldExpr];
                }
                switch (n % 360) {
                    case 90:
                    case 270:
                        return [TFLAG_DIFF, zero];
                    case 60:
                    case 300:
                        return [TFLAG_DIFF, half];
                    case 120:
                    case 240:
                        return [TFLAG_DIFF, rational(-1, 2)];
                    case 45:
                    case 315:
                        return [TFLAG_DIFF, $.multiply(half, $.power(two, half))];
                    case 135:
                    case 225:
                        return [TFLAG_DIFF, $.multiply(rational(-1, 2), $.power(two, half))];
                    case 30:
                    case 330:
                        return [TFLAG_DIFF, $.multiply(half, $.power(three, half))];
                    case 150:
                    case 210:
                        return [TFLAG_DIFF, $.multiply(rational(-1, 2), $.power(three, half))];
                    case 0:
                        return [TFLAG_DIFF, one];
                    case 180:
                        return [TFLAG_DIFF, negOne];
                    default:
                        return [TFLAG_NONE, oldExpr];
                }
            }

            // special multiple of pi?
            //  4  1  2  3  1  2  3  4
            function is_multiple_of_pi(p, $) {
                let n = 0;
                if (is_pi(p)) {
                    return 2;
                }
                if (!is_multiply(p) ||
                    !is_num(cadr(p)) ||
                    !is_pi(caddr(p)) ||
                    length_of_cons_otherwise_zero(p) !== 3) {
                    return 0;
                }
                n = nativeInt($.multiply(cadr(p), two));
                if (isNaN(n)) {
                    return 0;
                }
                if (n < 0) {
                    n = 4 - (-n % 4);
                }
                else {
                    n = 1 + ((n - 1) % 4);
                }
                return n;
            }

            // Use angle sum formula for special angles.
            function cosine_of_angle_sum(x, oldExpr, $) {
                for (const B of x.tail()) {
                    if (is_multiple_of_pi(B, $)) {
                        const A = $.subtract(x, B);
                        return [TFLAG_DIFF, $.subtract($.multiply(cos(A, $), cos(B, $)), $.multiply(sin(A, $), sin(B, $)))];
                    }
                }
                return cosine_of_angle(x, oldExpr, $);
            }

            function transform_cos(x, origExpr, $) {
                if (is_add(x)) {
                    return cosine_of_angle_sum(x, origExpr, $);
                }
                return cosine_of_angle(x, origExpr, $);
            }

            let Builder$41 = class Builder {
                create($) {
                    return new Op$3r($);
                }
            };
            let Op$3r = class Op extends Function1 {
                constructor($) {
                    super('cos_any', MATH_COS, is_any, $);
                    this.hash = hash_unaop_atom(MATH_COS, HASH_ANY);
                }
                transform1(opr, arg, orig) {
                    if (this.$.isExpanding()) {
                        return transform_cos(arg, orig, this.$);
                    }
                    else {
                        return [TFLAG_NONE, orig];
                    }
                }
            };
            const cos_any = new Builder$41();

            let Builder$40 = class Builder {
                create($) {
                    return new Op$3q($);
                }
            };
            /**
             * cos(Hyp) => 1
             */
            let Op$3q = class Op extends Function1 {
                constructor($) {
                    super('cos_hyp', MATH_COS, is_hyp, $);
                    this.hash = hash_unaop_atom(MATH_COS, HASH_HYP);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg) {
                    return [TFLAG_DIFF, one];
                }
            };
            const cos_hyp = new Builder$40();

            function is_opr_2_any_rhs(sym, guardR) {
                return function (expr) {
                    return is_opr_2_any_any(sym)(expr) && guardR(expr.rhs);
                };
            }

            let Builder$3$ = class Builder {
                create($) {
                    return new Op$3p($);
                }
            };
            /**
             * cos(X * i) => cosh(X)
             */
            let Op$3p = class Op extends Function1 {
                constructor($) {
                    super('cos_mul_2_any_imu', MATH_COS, and(is_cons, is_opr_2_any_rhs(MATH_MUL$3, is_imu)), $);
                    this.hash = hash_unaop_cons(MATH_COS, MATH_MUL$3);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const X = arg.lhs;
                    if ($.isExpanding()) {
                        const cosh_X = $.valueOf(items_to_cons$1(COSH, X));
                        return [TFLAG_DIFF, cosh_X];
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const cos_mul_2_any_imu = new Builder$3$();

            let Builder$3_ = class Builder {
                create($) {
                    return new Op$3o($);
                }
            };
            let Op$3o = class Op extends Function1 {
                constructor($) {
                    super('cos_sym', MATH_COS, is_sym, $);
                    this.hash = hash_unaop_atom(MATH_COS, HASH_SYM);
                }
                isReal(exp) {
                    return this.$.is_real(exp.arg);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    // TODO: Optimize.I
                    return transform_cos(arg, expr, $);
                }
            };
            const cos_sym = new Builder$3_();

            let Builder$3Z = class Builder {
                create($) {
                    return new Op$3n($);
                }
            };
            let Op$3n = class Op extends Function1 {
                constructor($) {
                    super('cosh_sym', COSH, is_sym, $);
                    this.hash = hash_unaop_atom(COSH, HASH_SYM);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(exp) {
                    return true;
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_HALT, expr];
                }
            };
            const cosh_sym = new Builder$3Z();

            let Builder$3Y = class Builder {
                create($) {
                    return new Op$3m($);
                }
            };
            let Op$3m = class Op extends FunctionVarArgs {
                constructor($) {
                    super('cosh', COSH, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_cosh(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const cosh_varargs = new Builder$3Y();

            /**
             * cross(Blade, Blade)
             */
            const MATH_VECTOR_CROSS_PRODUCT = create_sym('cross');

            let Builder$3X = class Builder {
                create($) {
                    return new Op$3l($);
                }
            };
            let Op$3l = class Op extends Function2 {
                constructor($) {
                    super('cross_any_any', MATH_VECTOR_CROSS_PRODUCT, is_any, is_any, $);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    if (contains_single_blade(lhs)) {
                        const bladeL = extract_single_blade(lhs);
                        if (!bladeL.equals(lhs)) {
                            const residueL = remove_factors(lhs, is_blade$1);
                            const A = $.valueOf(items_to_cons$1(opr, bladeL, rhs));
                            const B = $.valueOf(items_to_cons$1(MATH_MUL$3, residueL, A));
                            return [TFLAG_DIFF, B];
                        }
                    }
                    if (contains_single_blade(rhs)) {
                        const bladeR = extract_single_blade(rhs);
                        if (!bladeR.equals(rhs)) {
                            const residueR = remove_factors(rhs, is_blade$1);
                            const A = $.valueOf(items_to_cons$1(opr, lhs, bladeR));
                            const B = $.valueOf(items_to_cons$1(MATH_MUL$3, A, residueR));
                            return [TFLAG_DIFF, B];
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            };
            const cross_any_any = new Builder$3X();

            function is_mul_2_blade_rat(expr) {
                return is_mul_2_any_any(expr) && is_blade$1(expr.lhs) && is_rat(expr.rhs);
            }

            let Builder$3W = class Builder {
                create($) {
                    return new Op$3k($);
                }
            };
            /**
             * cross(A,B) = -1 * dual(A^B), were '^' denotes the outer product of vectors.
             */
            let Op$3k = class Op extends Function2 {
                constructor($) {
                    super('cross_blade_blade', MATH_VECTOR_CROSS_PRODUCT, is_blade$1, is_blade$1, $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_binop_atom_atom(MATH_VECTOR_CROSS_PRODUCT, HASH_BLADE, HASH_BLADE);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const wedge = $.valueOf(lhs.__wedge__(rhs));
                    if (is_blade$1(wedge)) {
                        return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_MUL$3, negOne, wedge.dual()))];
                    }
                    if (is_rat(wedge)) {
                        return [TFLAG_DIFF, wedge];
                    }
                    if (is_cons(wedge) && is_mul_2_blade_rat(wedge)) {
                        const bld = wedge.lhs;
                        const num = wedge.rhs;
                        return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_MUL$3, negOne.mul(num), bld.dual()))];
                    }
                    if (is_cons(wedge) && is_mul_2_rat_blade(wedge)) {
                        const num = wedge.lhs;
                        const bld = wedge.rhs;
                        return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_MUL$3, negOne.mul(num), bld.dual()))];
                    }
                    // More generally, we should extract the blade from the factors and treat the remaning factors as scalars.
                    // Other possibilities...
                    // Rat * Blade
                    // Num * Blade
                    throw new Error(`${$.toSExprString(wedge)}`);
                }
            };
            const cross_blade_blade = new Builder$3W();

            /*
             Partition a term

              Input:
                p1: term (factor or product of factors)
                p2: free variable

              Output:
                constant expression
                variable expression
            */
            function partition(p1, p2, $) {
                let p3 = one;
                let p4 = p3;
                p1 = cdr(p1);
                if (!is_cons(p1)) {
                    return [p3, p4];
                }
                for (const p of p1) {
                    if (p.contains(p2)) {
                        p4 = $.multiply(p4, p);
                    }
                    else {
                        p3 = $.multiply(p3, p);
                    }
                }
                return [p3, p4];
            }

            /**
             * This is called by the top level execution (and by itself recursively to evaluate the operands of Cons expressions).
             * @param expr
             * @param $
             * @returns
             */
            function bake(expr, $) {
                return doexpand_unary(bake_internal, expr, $);
            }
            function bake_internal(expr, $) {
                // console.lg(`bake_internal ${print_expr(expr, $)}`);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    return retval;
                };
                // Determine which variable the polynomial contains.
                const s = is_poly_expanded_form(expr, SYMBOL_S);
                const t = is_poly_expanded_form(expr, SYMBOL_T);
                const x = is_poly_expanded_form(expr, SYMBOL_X);
                const y = is_poly_expanded_form(expr, SYMBOL_Y);
                const z = is_poly_expanded_form(expr, SYMBOL_Z);
                if (s && !t && !x && !y && !z) {
                    return hook(bake_poly(expr, SYMBOL_S, $));
                }
                else if (!s && t && !x && !y && !z) {
                    return hook(bake_poly(expr, SYMBOL_T, $));
                }
                else if (!s && !t && x && !y && !z) {
                    return hook(bake_poly(expr, SYMBOL_X, $));
                }
                else if (!s && !t && !x && y && !z) {
                    return hook(bake_poly(expr, SYMBOL_Y, $));
                }
                else if (!s && !t && !x && !y && z) {
                    return hook(bake_poly(expr, SYMBOL_Z, $));
                    // don't bake the contents of some constructs such as "for"
                    // because we don't want to evaluate the body of
                    // such constructs "statically", i.e. without fully running
                    // the loops.
                    // TODO: The fact that we have to special case the "for" suggests that the handlers
                    // of operators should be called so that the system is generic.
                }
                else if (is_cons(expr) && !car(expr).equals(FOR)) {
                    const bakeList = items_to_cons(car(expr), ...expr.tail().map(function (x) {
                        return bake(x, $);
                    }));
                    return hook(bakeList);
                }
                else {
                    return hook(expr);
                }
            }
            function polyform(p1, p2, $) {
                if (is_poly_expanded_form(p1, p2)) {
                    return bake_poly(p1, p2, $);
                }
                if (is_cons(p1)) {
                    return items_to_cons(car(p1), ...p1.tail().map((el) => polyform(el, p2, $)));
                }
                return p1;
            }
            /**
             * Returns the poynomial (in expanded form when in expanding mode).
             * Algorithm...
             * Computes the coefficients of the polynomial by iteratively...
             * 1. Evaluating at zero.
             * 2. Subtracting the constant term.
             * 3. Dividing by the variable.
             * 4. Rinse and repeat.
             *
             * , then rebuilds the polynomial using the coefficients.
             * However, this is all happening while in expanding mode.
             *
             * @param p The polynomial.
             * @param x The polynomial variable.
             */
            function bake_poly(p, x, $) {
                // console.lg(`bake_poly ${p} ${x}`);
                const beans = coeff(p, x, $);
                // console.lg(`beans => ${beans}`);
                // We're not getting to see this because coeff blows up
                const result = [];
                for (let i = beans.length - 1; i >= 0; i--) {
                    const bean = beans[i];
                    const baked_beans = bake_poly_term(i, bean, x, $);
                    // console.lg(`baked_beans => ${items_to_infix(baked_beans, $)}`);
                    result.push(...baked_beans);
                }
                if (result.length > 1) {
                    return cons(ADD$7, items_to_cons(...result));
                }
                if (result.length > 0) {
                    return result[0];
                }
                else {
                    throw new SystemError();
                }
            }
            // p1 points to coefficient of p2 ^ k
            // k is an int
            function bake_poly_term(k, coefficient, term, $) {
                if ($.is_zero(coefficient)) {
                    return [];
                }
                // constant term?
                if (k === 0) {
                    if (is_cons(coefficient) && is_add(coefficient)) {
                        return coefficient.tail();
                    }
                    return [coefficient];
                }
                const result = [];
                // coefficient
                if (is_multiply(coefficient)) {
                    result.push(...coefficient.tail());
                }
                else if (!equaln(coefficient, 1)) {
                    result.push(coefficient);
                }
                // x ^ k
                if (k === 1) {
                    result.push(term);
                }
                else {
                    result.push(items_to_cons(POWER$1, term, create_int(k)));
                }
                if (result.length > 1) {
                    return [items_to_cons(MULTIPLY$1, ...result)];
                }
                return result;
            }

            function pushTryNotToDuplicateLocal(localStack, item) {
                if (localStack.length > 0 && item.equals(localStack[localStack.length - 1])) {
                    return false;
                }
                localStack.push(item);
                return true;
            }
            // returns constant expressions on the stack
            function decomp(generalTransform, p1, p2, $) {
                // is the entire expression constant?
                if (generalTransform) {
                    if (!is_cons(p1)) {
                        return [p1];
                    }
                }
                else {
                    if (!p1.contains(p2)) {
                        return [p1];
                    }
                }
                // sum?
                if (is_add(p1)) {
                    return decomp_sum(generalTransform, p1, p2, $);
                }
                // product?
                if (is_multiply(p1)) {
                    return decomp_product(generalTransform, p1, p2, $);
                }
                let p3 = cdr(p1);
                // naive decomp if not sum or product
                const stack = [];
                while (is_cons(p3)) {
                    // for a general transformations,
                    // we want to match any part of the tree so
                    // we need to push the subtree as well
                    // as recurse to its parts
                    if (generalTransform) {
                        stack.push(car(p3));
                    }
                    stack.push(...decomp(generalTransform, car(p3), p2, $));
                    p3 = cdr(p3);
                }
                return stack;
            }
            function decomp_sum(generalTransform, p1, p2, $) {
                // decomp terms involving x
                let temp = cdr(p1);
                const stack = [];
                while (is_cons(temp)) {
                    if (car(temp).contains(p2) || generalTransform) {
                        stack.push(...decomp(generalTransform, car(temp), p2, $));
                    }
                    temp = cdr(temp);
                }
                // add together all constant terms
                const constantPart = cdr(p1);
                const constantTerms = [...constantPart].filter((t) => !t.contains(p2));
                if (constantTerms.length) {
                    const p3 = add_terms$1(constantTerms, $);
                    pushTryNotToDuplicateLocal(stack, p3);
                    stack.push($.negate(p3)); // need both +a, -a for some integrals
                }
                return stack;
            }
            function decomp_product(generalTransform, p1, p2, $) {
                // decomp factors involving x
                let p3 = cdr(p1);
                const stack = [];
                while (is_cons(p3)) {
                    if (car(p3).contains(p2) || generalTransform) {
                        stack.push(...decomp(generalTransform, car(p3), p2, $));
                    }
                    p3 = cdr(p3);
                }
                // multiply together all constant factors
                p3 = cdr(p1);
                const constantFactors = [];
                while (is_cons(p3)) {
                    const item = car(p3);
                    if (!item.contains(p2)) {
                        if (constantFactors.length < 1 ||
                            !item.equals(constantFactors[constantFactors.length - 1])) {
                            constantFactors.push(item);
                        }
                    }
                    p3 = cdr(p3);
                }
                if (constantFactors.length > 0) {
                    stack.push(multiply_items(constantFactors, $));
                }
                return stack;
            }

            /*
            Transform an expression using a pattern. The
            pattern can come from the integrals table or
            the user-defined patterns.

            The expression and free variable are on the stack.

            The argument s is a null terminated list of transform rules.

            For example, see the itab (integrals table)

            Internally, the following symbols are used:

              F  input expression

              X  free variable, i.e. F of X

              A  template expression

              B  result expression

              C  list of conditional expressions

            Puts the final expression on top of stack
            (whether it's transformed or not) and returns
            true is successful, false if not.

            */
            // p1 and p2 are tmps
            //define F p3
            //define X p4
            //define A p5
            //define B p6
            //define C p7
            function transform$1(F, X, s, generalTransform, $) {
                const state = saveMetaBindings($);
                $.setSymbolValue(METAX, X);
                const arg = polyform(F, X, $); // collect coefficients of x, x^2, etc.
                const result = decomp(generalTransform, arg, X, $);
                let transformationSuccessful = false;
                let B = nil;
                if (generalTransform) {
                    // "general tranform" mode is supposed to be more generic than
                    // "integrals" mode.
                    // In general transform mode we get only one transformation
                    // in s
                    // simple numbers can end up matching complicated templates,
                    // which we don't want.
                    // for example "1" ends up matching "inner(transpose(a_),a_)"
                    // since "1" is decomposed to "1" and replacing "a_" with "1"
                    // there is a match.
                    // Although this match is OK at some fundamental level, we want to
                    // avoid it because that's not what the spirit of this match
                    // is: "1" does not have any structural resemblance with
                    // "inner(transpose(a_),a_)". There are probably better ways
                    // to so this, for example we might notice that "inner" is an
                    // anchor since it "sits above" any meta variables, so we
                    // might want to mandate it to be matched at the top
                    // of the tree. For the time
                    // being let's just skip matching on simple numbers.
                    if (!is_num(F)) {
                        const theTransform = s;
                        // replacements of meta variables. Note that we don't
                        // use scan_meta because the pattern is not a string
                        // that we have to parse, it's a tree already.
                        // replace a_ with METAA in the passed transformation
                        let expr = subst(theTransform, SYMBOL_A_UNDERSCORE, METAA, $);
                        // replace b_ with METAB in the passed transformation
                        expr = subst(expr, SYMBOL_B_UNDERSCORE, METAB, $);
                        // replace x_ with METAX in the passed transformation
                        const p1 = subst(expr, SYMBOL_X_UNDERSCORE, METAX, $);
                        const A = car(p1);
                        B = cadr(p1);
                        const C = cddr(p1);
                        if (f_equals_a([one, ...result], generalTransform, F, A, C, $)) {
                            // successful transformation, transformed result is in p6
                            transformationSuccessful = true;
                        }
                        else {
                            // the match failed but perhaps we can match something lower down in
                            // the tree, so let's recurse the tree
                            const transformedTerms = [];
                            let restTerm = F;
                            if (is_cons(restTerm)) {
                                transformedTerms.push(car(F));
                                restTerm = cdr(F);
                            }
                            while (is_cons(restTerm)) {
                                const secondTerm = car(restTerm);
                                restTerm = cdr(restTerm);
                                const [t, success] = transform$1(secondTerm, nil, s, generalTransform, $);
                                transformationSuccessful = transformationSuccessful || success;
                                transformedTerms.push(t);
                            }
                            // recreate the tree we were passed,
                            // but with all the terms being transformed
                            if (transformedTerms.length !== 0) {
                                B = items_to_cons(...transformedTerms);
                            }
                        }
                    }
                }
                else {
                    // "integrals" mode
                    // TODO; Make the cast safe. 
                    for (const eachTransformEntry of Array.from(s)) {
                        if (eachTransformEntry) {
                            const temp = scan_meta(eachTransformEntry);
                            const p5 = cadr(temp);
                            B = caddr(temp);
                            const p7 = cdddr(temp);
                            if (f_equals_a([one, ...result], generalTransform, F, p5, p7, $)) {
                                // there is a successful transformation, transformed result is in p6
                                transformationSuccessful = true;
                                break;
                            }
                        }
                    }
                }
                const temp = transformationSuccessful ? $.valueOf(B) : generalTransform ? F : nil;
                restoreMetaBindings(state, $);
                return [temp, transformationSuccessful];
            }
            function saveMetaBindings($) {
                return {
                    METAA: $.getSymbolValue(METAA),
                    METAB: $.getSymbolValue(METAB),
                    METAX: $.getSymbolValue(METAX),
                };
            }
            function restoreMetaBindings(state, $) {
                $.setSymbolValue(METAX, state.METAX);
                $.setSymbolValue(METAB, state.METAB);
                $.setSymbolValue(METAA, state.METAA);
            }
            // search for a METAA and METAB such that F = A
            function f_equals_a(stack, generalTransform, F, A, C, $) {
                for (const fea_i of stack) {
                    $.setSymbolValue(METAA, fea_i);
                    for (const fea_j of stack) {
                        $.setSymbolValue(METAB, fea_j);
                        // now test all the conditions (it's an and between them)
                        let temp = C;
                        while (is_cons(temp)) {
                            const p2 = $.valueOf(temp.car);
                            if ($.is_zero(p2)) {
                                break;
                            }
                            temp = temp.cdr;
                        }
                        if (is_cons(temp)) {
                            // conditions are not met, skip to the next binding of metas
                            continue;
                        }
                        const arg2 = generalTransform ? noexpand_unary(function (x) {
                            return $.valueOf(x);
                        }, A, $) : $.valueOf(A);
                        if ($.is_zero($.subtract(F, arg2))) {
                            return true; // yes
                        }
                    }
                }
                return false; // no
            }

            function Eval_integral(expr, $) {
                let n = 0;
                // evaluate 1st arg to get function F
                let p1 = cdr(expr);
                /**
                 * The function to be integrated.
                 */
                let F = $.valueOf(car(p1));
                /**
                 * The measure variable.
                 */
                let X;
                /**
                 * The Nth integral.
                 */
                let N;
                // evaluate 2nd arg and then...
                // example    result of 2nd arg  what to do
                //
                // integral(f)    NIL      guess X, N = NIL
                // integral(f,2)  2      guess X, N = 2
                // integral(f,x)  x      X = x, N = NIL
                // integral(f,x,2)  x      X = x, N = 2
                // integral(f,x,y)  x      X = x, N = y
                p1 = cdr(p1);
                const p2 = $.valueOf(car(p1));
                if (nil === p2) {
                    X = guess(F);
                    N = nil;
                }
                else if (is_num(p2)) {
                    X = guess(F);
                    N = p2;
                }
                else {
                    X = p2;
                    p1 = cdr(p1);
                    N = $.valueOf(car(p1));
                }
                // console.lg(`F=${F}`);
                // console.lg(`X=${X}`);
                // console.lg(`N=${N}`);
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    // N might be a symbol instead of a number
                    if (is_num(N)) {
                        n = nativeInt(N);
                        if (isNaN(n)) {
                            halt('nth integral: check n');
                        }
                    }
                    else {
                        n = 1;
                    }
                    let temp = F;
                    if (n >= 0) {
                        for (let i = 0; i < n; i++) {
                            temp = integral(temp, X, $);
                        }
                    }
                    else {
                        n = -n;
                        for (let i = 0; i < n; i++) {
                            temp = derivative(temp, X, $);
                        }
                    }
                    F = temp;
                    // if N is NIL then arglist is exhausted
                    if (nil === N) {
                        break;
                    }
                    // otherwise...
                    // N    arg1    what to do
                    //
                    // number  NIL    break
                    // number  number    N = arg1, continue
                    // number  symbol    X = arg1, N = arg2, continue
                    //
                    // symbol  NIL    X = N, N = NIL, continue
                    // symbol  number    X = N, N = arg1, continue
                    // symbol  symbol    X = N, N = arg1, continue
                    if (is_num(N)) {
                        p1 = cdr(p1);
                        N = $.valueOf(car(p1));
                        if (nil === N) {
                            break; // arglist exhausted
                        }
                        if (!is_num(N)) {
                            X = N;
                            p1 = cdr(p1);
                            N = $.valueOf(car(p1));
                        }
                    }
                    else {
                        X = N;
                        p1 = cdr(p1);
                        N = $.valueOf(car(p1));
                    }
                }
                return F;
            }
            function integral(F, X, $) {
                // console.lg(`integral(F=${F}, X=${X})`);
                let integ;
                if (is_add(F)) {
                    integ = integral_of_sum(F, X, $);
                }
                else if (is_multiply(F)) {
                    integ = integral_of_product(F, X, $);
                }
                else {
                    integ = integral_of_form(F, X, $);
                }
                if (integ.contains(INTEGRAL)) {
                    halt('integral: sorry, could not find a solution');
                }
                // polish then normalize
                return $.valueOf(simplify(integ, $));
            }
            function integral_of_sum(F, X, $) {
                F = cdr(F);
                let result = integral(car(F), X, $);
                if (is_cons(F)) {
                    result = F.tail().reduce((acc, b) => $.add(acc, integral(b, X, $)), result);
                }
                return result;
            }
            function integral_of_product(F, X, $) {
                const [constantExpr, variableExpr] = partition(F, X, $);
                return $.multiply(constantExpr, integral_of_form(variableExpr, X, $)); // multiply constant part
            }
            function integral_of_form(F, X, $) {
                // console.lg(`integral_of_form(F=${F}, X=${X})`);
                const hc = italu_hashcode(F, X, $).toFixed(6);
                // console.lg(`hc=${hc}`);
                const tab = hashed_itab[hc];
                // console.lg(`tab=${tab}`);
                if (!tab) {
                    // breakpoint
                    // italu_hashcode(p1, p2)
                    return items_to_cons(INTEGRAL, F, X);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const [p3, _] = transform$1(F, X, tab, false, $);
                if (nil === p3) {
                    return items_to_cons(INTEGRAL, F, X);
                }
                return p3;
            }
            // Implementation of hash codes based on ITALU (An Integral Table Look-Up)
            // https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680004891.pdf
            // see Appendix A, page 153
            // The first two values are from the ITALU paper.
            // The others are just arbitrary constants.
            const hashcode_values = {
                x: 0.95532,
                constexp: 1.43762,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                constant: 1.14416593629414332,
                constbase: 1.20364122304218824,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                sin: 1.73305482518303221,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                arcsin: 1.6483368529465804,
                cos: 1.058672123686340116,
                arccos: 1.8405225918106694,
                tan: 1.12249437762925064,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                arctan: 1.1297397925394962,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                sinh: 1.8176164926060078,
                cosh: 1.9404934661708022,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                tanh: 1.6421307715103121,
                // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
                log: 1.47744370135492387,
                erf: 1.0825269225702916,
            };
            function italu_hashcode(u, x, $) {
                if (is_sym(u)) {
                    if (is_sym(x) && u.equals(x)) {
                        return hashcode_values.x;
                    }
                    else {
                        return hashcode_values.constant;
                    }
                }
                else if (is_cons(u)) {
                    const opr = u.car;
                    if (opr.equals(ADD$7)) {
                        return hash_addition(cdr(u), x, $);
                    }
                    if (opr.equals(MULTIPLY$1)) {
                        return hash_multiplication(cdr(u), x, $);
                    }
                    if (opr.equals(POWER$1)) {
                        return hash_power(cadr(u), caddr(u), x, $);
                    }
                    if (opr.equals(EXP$7)) {
                        return hash_power(exp$1(one, $), cadr(u), x, $);
                    }
                    if (opr.equals(SQRT)) {
                        return hash_power(cadr(u), create_flt(0.5), x, $);
                    }
                    return hash_function(u, x, $);
                }
                return hashcode_values.constant;
            }
            function hash_function(u, x, $) {
                if (!cadr(u).contains(x)) {
                    return hashcode_values.constant;
                }
                const sym = u.car;
                if (is_sym(sym)) {
                    const arg_hash = italu_hashcode(car(u.cdr), x, $);
                    const printname = sym.key();
                    const base = hashcode_values[printname];
                    if (!base) {
                        throw new Error('Unsupported function ' + printname);
                    }
                    return Math.pow(base, arg_hash);
                }
                else {
                    throw new Error("is_sym(car(u)) MUST be true.");
                }
            }
            function hash_addition(terms, x, $) {
                const term_set = {};
                while (is_cons(terms)) {
                    const term = car(terms);
                    terms = cdr(terms);
                    let term_hash = 0;
                    if (term.contains(x)) {
                        term_hash = italu_hashcode(term, x, $);
                    }
                    else {
                        // The original algorithm would skip this,
                        // but recording that it was present helps
                        // prevent collisions.
                        term_hash = hashcode_values.constant;
                    }
                    term_set[term_hash.toFixed(6)] = true;
                }
                let sum = 0;
                for (const k of Object.keys(term_set || {})) {
                    // const v = term_set[k];
                    sum = sum + Number(k);
                }
                return sum;
            }
            function hash_multiplication(terms, x, $) {
                let product = 1;
                if (is_cons(terms)) {
                    [...terms].forEach((term) => {
                        if (term.contains(x)) {
                            product = product * italu_hashcode(term, x, $);
                        }
                    });
                }
                return product;
            }
            function hash_power(base, power_number, x, $) {
                let base_hash = hashcode_values.constant;
                let exp_hash = hashcode_values.constexp;
                if (base.contains(x)) {
                    base_hash = italu_hashcode(base, x, $);
                }
                if (power_number.contains(x)) {
                    exp_hash = italu_hashcode(power_number, x, $);
                }
                else {
                    // constant to constant = constant
                    if (base_hash === hashcode_values.constant) {
                        return hashcode_values.constant;
                    }
                    if (is_num_and_eq_minus_one(power_number)) {
                        exp_hash = -1;
                    }
                    else if (is_num_and_equal_one_half(power_number)) {
                        exp_hash = 0.5;
                    }
                    else if (is_num_and_equal_minus_half(power_number)) {
                        exp_hash = -0.5;
                    }
                    else if (is_num_and_equalq(power_number, 2, 1)) {
                        exp_hash = 2;
                    }
                    else if (is_num_and_equalq(power_number, -2, 1)) {
                        exp_hash = -2;
                    }
                }
                return Math.pow(base_hash, exp_hash);
            }
            // pre-calculated hashed integral table.
            // in case the integral table is changed, use this
            // make_hashed_itab()
            // and copy the resulting JSON in here.
            const hashed_itab = {
                '1.144166': ['f(a,a*x)'],
                '1.046770': ['f(1/x,log(x))'],
                '0.936400': ['f(x**a,x**(a+1)/(a+1))'],
                '1.095727': ['f(x**(-2),-x**(-1))'],
                '1.023118': ['f(x**(-1/2),2*x**(1/2))'],
                '0.977405': ['f(x**(1/2),2/3*x**(3/2))'],
                '0.955320': ['f(x,x**2/2)'],
                '0.912636': ['f(x**2,x**3/3)'],
                '1.137302': [
                    'f(exp(a*x),1/a*exp(a*x))',
                    'f(a**x,a**x/log(a),or(not(number(a)),a>0))',
                ],
                '1.326774': ['f(exp(a*x+b),1/a*exp(a*x+b))'],
                '1.080259': ['f(x*exp(a*x**2),exp(a*x**2)/(2*a))'],
                '1.260228': ['f(x*exp(a*x**2+b),exp(a*x**2+b)/(2*a))'],
                '1.451902': ['f(log(a*x),x*log(a*x)-x)'],
                '0.486192': [
                    'f(1/(a+x**2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))',
                    'f(1/(a-x**2),1/sqrt(a)*arctanh(x/sqrt(a)))',
                    'f(1/(a+b*x**2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))',
                    'f(1/(a+b*x**2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))',
                ],
                '0.697274': [
                    'f(1/sqrt(a-x**2),arcsin(x/(sqrt(a))))',
                    'f(1/sqrt(a+x**2),log(x+sqrt(a+x**2)))',
                    'f(1/sqrt(x**2+a),log(x+sqrt(x**2+a)))',
                ],
                '0.476307': ['f(1/(a+b*x),1/b*log(a+b*x))'],
                '0.226868': ['f(1/(a+b*x)**2,-1/(b*(a+b*x)))'],
                '2.904531': ['f(1/(a+b*x)**3,-1/(2*b)*1/(a+b*x)**2)'],
                '0.455026': ['f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)'],
                '0.216732': ['f(x/(a+b*x)**2,1/b**2*(log(a+b*x)+a/(a+b*x)))'],
                '0.434695': [
                    'f(x**2/(a+b*x),1/b**2*(1/2*(a+b*x)**2-2*a*(a+b*x)+a**2*log(a+b*x)))',
                ],
                '0.207048': ['f(x**2/(a+b*x)**2,1/b**3*(a+b*x-2*a*log(a+b*x)-a**2/(a+b*x)))'],
                '2.650781': [
                    'f(x**2/(a+b*x)**3,1/b**3*(log(a+b*x)+2*a/(a+b*x)-1/2*a**2/(a+b*x)**2))',
                ],
                '0.498584': ['f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))'],
                '0.237479': ['f(1/x*1/(a+b*x)**2,1/a*1/(a+b*x)-1/a**2*log((a+b*x)/x))'],
                '3.040375': [
                    'f(1/x*1/(a+b*x)**3,1/a**3*(1/2*((2*a+b*x)/(a+b*x))**2+log(x/(a+b*x))))',
                ],
                '0.521902': ['f(1/x**2*1/(a+b*x),-1/(a*x)+b/a**2*log((a+b*x)/x))'],
                '0.446014': [
                    'f(1/x**3*1/(a+b*x),(2*b*x-a)/(2*a**2*x**2)+b**2/a**3*log(x/(a+b*x)))',
                ],
                '0.248586': [
                    'f(1/x**2*1/(a+b*x)**2,-(a+2*b*x)/(a**2*x*(a+b*x))+2*b/a**3*log((a+b*x)/x))',
                ],
                '0.464469': ['f(x/(a+b*x**2),1/2*1/b*log(a+b*x**2))'],
                '0.443716': ['f(x**2/(a+b*x**2),x/b-a/b*integral(1/(a+b*x**2),x))'],
                '0.236382': [
                    'f(1/(a+b*x**2)**2,x/(2*a*(a+b*x**2))+1/2*1/a*integral(1/(a+b*x**2),x))',
                ],
                '0.508931': ['f(1/x*1/(a+b*x**2),1/2*1/a*log(x**2/(a+b*x**2)))'],
                '0.532733': ['f(1/x**2*1/(a+b*x**2),-1/(a*x)-b/a*integral(1/(a+b*x**2),x))'],
                '0.480638': [
                    'f(1/(a+b*x**3),1/3*1/a*(a/b)**(1/3)*(1/2*log(((a/b)**(1/3)+x)**3/(a+b*x**3))+sqrt(3)*arctan((2*x-(a/b)**(1/3))*(a/b)**(-1/3)/sqrt(3))))',
                ],
                '0.438648': ['f(x**2/(a+b*x**3),1/3*1/b*log(a+b*x**3))'],
                '0.459164': [
                    'f(x/(a+b*x**4),1/2*sqrt(b/a)/b*arctan(x**2*sqrt(b/a)),or(not(number(a*b)),a*b>0))',
                    'f(x/(a+b*x**4),1/4*sqrt(-b/a)/b*log((x**2-sqrt(-a/b))/(x**2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))',
                ],
                '0.450070': ['f(x**3/(a+b*x**4),1/4*1/b*log(a+b*x**4))'],
                '1.448960': ['f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)**3))'],
                '1.384221': ['f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)**3)/15/b**2)'],
                '1.322374': [
                    'f(x**2*sqrt(a+b*x),2*(8*a**2-12*a*b*x+15*b**2*x**2)*sqrt((a+b*x)**3)/105/b**3)',
                ],
                '1.516728': [
                    'f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))',
                ],
                '1.587665': [
                    'f(sqrt(a+b*x)/x**2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))',
                ],
                '0.690150': ['f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)'],
                '0.659314': ['f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b**2)'],
                '0.629856': [
                    'f(x**2/sqrt(a+b*x),2/15*(8*a**2-4*a*b*x+3*b**2*x**2)*sqrt(a+b*x)/b**3)',
                ],
                '0.722428': [
                    'f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))',
                    'f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))',
                ],
                '0.756216': [
                    'f(1/x**2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))',
                ],
                '1.434156': [
                    'f(sqrt(x**2+a),1/2*(x*sqrt(x**2+a)+a*log(x+sqrt(x**2+a))))',
                    'f(sqrt(a-x**2),1/2*(x*sqrt(a-x**2)+a*arcsin(x/sqrt(abs(a)))))',
                    'f(sqrt(a*x**2+b),x*sqrt(a*x**2+b)/2+b*log(x*sqrt(a)+sqrt(a*x**2+b))/2/sqrt(a),and(number(a),a>0))',
                    'f(sqrt(a*x**2+b),x*sqrt(a*x**2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))',
                ],
                '0.729886': [
                    'f(1/x*1/sqrt(x**2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))',
                    'f(1/x*1/sqrt(x**2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x**2+a))/x),or(not(number(a)),a>0))',
                    'f(1/x*1/sqrt(a-x**2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x**2))/x),or(not(number(a)),a>0))',
                ],
                '1.501230': [
                    'f(sqrt(x**2+a)/x,sqrt(x**2+a)-sqrt(a)*log((sqrt(a)+sqrt(x**2+a))/x),or(not(number(a)),a>0))',
                    'f(sqrt(x**2+a)/x,sqrt(x**2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))',
                    'f(sqrt(a-x**2)/x,sqrt(a-x**2)-sqrt(a)*log((sqrt(a)+sqrt(a-x**2))/x),or(not(number(a)),a>0))',
                ],
                '0.666120': ['f(x/sqrt(x**2+a),sqrt(x**2+a))', 'f(x/sqrt(a-x**2),-sqrt(a-x**2))'],
                '1.370077': [
                    'f(x*sqrt(x**2+a),1/3*sqrt((x**2+a)**3))',
                    'f(x*sqrt(a-x**2),-1/3*sqrt((a-x**2)**3))',
                ],
                '1.730087': [
                    'f(sqrt(a+x**6+3*a**(1/3)*x**4+3*a**(2/3)*x**2),1/4*(x*sqrt((x**2+a**(1/3))**3)+3/2*a**(1/3)*x*sqrt(x**2+a**(1/3))+3/2*a**(2/3)*log(x+sqrt(x**2+a**(1/3)))))',
                    'f(sqrt(-a+x**6-3*a**(1/3)*x**4+3*a**(2/3)*x**2),1/4*(x*sqrt((x**2-a**(1/3))**3)-3/2*a**(1/3)*x*sqrt(x**2-a**(1/3))+3/2*a**(2/3)*log(x+sqrt(x**2-a**(1/3)))))',
                ],
                '0.578006': [
                    'f(1/sqrt(a+x**6+3*a**(1/3)*x**4+3*a**(2/3)*x**2),x/a**(1/3)/sqrt(x**2+a**(1/3)))',
                ],
                '0.552180': [
                    'f(x/sqrt(a+x**6+3*a**(1/3)*x**4+3*a**(2/3)*x**2),-1/sqrt(x**2+a**(1/3)))',
                ],
                '1.652787': [
                    'f(x*sqrt(a+x**6+3*a**(1/3)*x**4+3*a**(2/3)*x**2),1/5*sqrt((x**2+a**(1/3))**5))',
                ],
                '1.308862': [
                    'f(x**2*sqrt(x**2+a),1/4*x*sqrt((x**2+a)**3)-1/8*a*x*sqrt(x**2+a)-1/8*a**2*log(x+sqrt(x**2+a)))',
                    'f(x**2*sqrt(a-x**2),-x/4*sqrt((a-x**2)**3)+1/8*a*(x*sqrt(a-x**2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))',
                ],
                '1.342944': [
                    'f(x**3*sqrt(x**2+a),(1/5*x**2-2/15*a)*sqrt((x**2+a)**3),and(number(a),a>0))',
                    'f(x**3*sqrt(x**2+a),sqrt((x**2+a)**5)/5-a*sqrt((x**2+a)**3)/3,and(number(a),a<0))',
                    'f(x**3*sqrt(a-x**2),(-1/5*x**2-2/15*a)*sqrt((a-x**2)**3),or(not(number(a)),a>0))',
                    'f(sqrt(a-x**2)/x**3,-1/2*sqrt(a-x**2)/x**2+1/2*log((sqrt(a)+sqrt(a-x**2))/x)/sqrt(a),or(not(number(a)),a>0))',
                    'f(sqrt(a-x**2)/x**4,-1/3*sqrt((a-x**2)**3)/a/x**3,or(not(number(a)),a>0))',
                ],
                '0.636358': [
                    'f(x**2/sqrt(x**2+a),1/2*x*sqrt(x**2+a)-1/2*a*log(x+sqrt(x**2+a)))',
                    'f(x**2/sqrt(a-x**2),-x/2*sqrt(a-x**2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))',
                ],
                '0.652928': [
                    'f(x**3/sqrt(x**2+a),1/3*sqrt((x**2+a)**3)-a*sqrt(x**2+a))',
                    'f(1/x**3*1/sqrt(x**2+a),-1/2*sqrt(x**2+a)/a/x**2+1/2*log((sqrt(a)+sqrt(x**2+a))/x)/a**(3/2),or(not(number(a)),a>0))',
                    'f(1/x**3*1/sqrt(x**2-a),1/2*sqrt(x**2-a)/a/x**2+1/2*1/(a**(3/2))*arcsec(x/(a**(1/2))),or(not(number(a)),a>0))',
                ],
                '0.764022': [
                    'f(1/x**2*1/sqrt(x**2+a),-sqrt(x**2+a)/a/x)',
                    'f(1/x**2*1/sqrt(a-x**2),-sqrt(a-x**2)/a/x,or(not(number(a)),a>0))',
                ],
                '1.578940': [
                    'f(x**2*sqrt(a+x**6+3*a**(1/3)*x**4+3*a**(2/3)*x**2),1/6*x*sqrt((x**2+a**(1/3))**5)-1/24*a**(1/3)*x*sqrt((x**2+a**(1/3))**3)-1/16*a**(2/3)*x*sqrt(x**2+a**(1/3))-1/16*a*log(x+sqrt(x**2+a**(1/3))),or(not(number(a)),a>0))',
                    'f(x**2*sqrt(-a-3*a**(1/3)*x**4+3*a**(2/3)*x**2+x**6),1/6*x*sqrt((x**2-a**(1/3))**5)+1/24*a**(1/3)*x*sqrt((x**2-a**(1/3))**3)-1/16*a**(2/3)*x*sqrt(x**2-a**(1/3))+1/16*a*log(x+sqrt(x**2-a**(1/3))),or(not(number(a)),a>0))',
                ],
                '1.620055': [
                    'f(x**3*sqrt(a+x**6+3*a**(1/3)*x**4+3*a**(2/3)*x**2),1/7*sqrt((x**2+a**(1/3))**7)-1/5*a**(1/3)*sqrt((x**2+a**(1/3))**5),or(not(number(a)),a>0))',
                    'f(x**3*sqrt(-a-3*a**(1/3)*x**4+3*a**(2/3)*x**2+x**6),1/7*sqrt((x**2-a**(1/3))**7)+1/5*a**(1/3)*sqrt((x**2-a**(1/3))**5),or(not(number(a)),a>0))',
                ],
                '0.332117': [
                    'f(1/(x-a)/sqrt(x**2-a**2),-sqrt(x**2-a**2)/a/(x-a))',
                    'f(1/(x+a)/sqrt(x**2-a**2),sqrt(x**2-a**2)/a/(x+a))',
                ],
                '1.571443': [
                    'f(sqrt(a-x**2)/x**2,-sqrt(a-x**2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))',
                ],
                '1.690994': ['f(sin(a*x),-cos(a*x)/a)'],
                '1.055979': ['f(cos(a*x),sin(a*x)/a)'],
                '1.116714': ['f(tan(a*x),-log(cos(a*x))/a)'],
                '0.895484': ['f(1/tan(a*x),log(sin(a*x))/a)'],
                '0.946989': ['f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)'],
                '0.591368': ['f(1/sin(a*x),log(tan(a*x/2))/a)'],
                '2.859462': ['f(sin(a*x)**2,x/2-sin(2*a*x)/(4*a))'],
                '2.128050': [
                    'f(sin(a*x)**3,-cos(a*x)*(sin(a*x)**2+2)/(3*a))',
                    'f(sin(a*x)**4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))',
                ],
                '1.115091': ['f(cos(a*x)**2,x/2+sin(2*a*x)/(4*a))'],
                '1.081452': [
                    'f(cos(a*x)**3,sin(a*x)*(cos(a*x)**2+2)/(3*a))',
                    'f(cos(a*x)**4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))',
                ],
                '0.349716': ['f(1/sin(a*x)**2,-1/(a*tan(a*x)))'],
                '0.896788': ['f(1/cos(a*x)**2,tan(a*x)/a)'],
                '1.785654': ['f(sin(a*x)*cos(a*x),sin(a*x)**2/(2*a))'],
                '3.188560': ['f(sin(a*x)**2*cos(a*x)**2,-sin(4*a*x)/(32*a)+x/8)'],
                '1.516463': ['f(sin(a*x)/cos(a*x)**2,1/(a*cos(a*x)))'],
                '2.707879': ['f(sin(a*x)**2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)'],
                '0.369293': ['f(cos(a*x)/sin(a*x)**2,-1/(a*sin(a*x)))'],
                '0.560019': ['f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)'],
                '0.530332': ['f(1/(sin(a*x)*cos(a*x)**2),(1/cos(a*x)+log(tan(a*x/2)))/a)'],
                '0.331177': [
                    'f(1/(sin(a*x)**2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)',
                ],
                '0.313621': ['f(1/(sin(a*x)**2*cos(a*x)**2),-2/(a*tan(2*a*x)))'],
                '3.172365': ['f(sin(a+b*x),-cos(a+b*x)/b)'],
                '1.127162': ['f(cos(a+b*x),sin(a+b*x)/b)'],
                '0.352714': [
                    'f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)',
                    'f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)',
                    'f(1/(a+b*sin(x)),1/sqrt(b**2-a**2)*log((a*tan(x/2)+b-sqrt(b**2-a**2))/(a*tan(x/2)+b+sqrt(b**2-a**2))),b**2-a**2)',
                ],
                '0.454515': [
                    'f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)',
                    'f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)',
                    'f(1/(a+b*cos(x)),1/sqrt(b**2-a**2)*log((sqrt(b**2-a**2)*tan(x/2)+a+b)/(sqrt(b**2-a**2)*tan(x/2)-a-b)),b**2-a**2)',
                ],
                '1.615441': ['f(x*sin(a*x),sin(a*x)/a**2-x*cos(a*x)/a)'],
                '1.543263': ['f(x**2*sin(a*x),2*x*sin(a*x)/a**2-(a**2*x**2-2)*cos(a*x)/a**3)'],
                '1.008798': ['f(x*cos(a*x),cos(a*x)/a**2+x*sin(a*x)/a)'],
                '0.963724': ['f(x**2*cos(a*x),2*x*cos(a*x)/a**2+(a**2*x**2-2)*sin(a*x)/a**3)'],
                '1.611938': ['f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a**2*x**2)/a)'],
                '1.791033': ['f(arccos(a*x),x*arccos(a*x)-sqrt(1-a**2*x**2)/a)'],
                '1.123599': ['f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a**2*x**2)/a)'],
                '1.387031': ['f(x*log(a*x),x**2*log(a*x)/2-x**2/4)'],
                '1.325058': ['f(x**2*log(a*x),x**3*log(a*x)/3-1/9*x**3)'],
                '2.108018': ['f(log(x)**2,x*log(x)**2-2*x*log(x)+2*x)'],
                '0.403214': ['f(1/x*1/(a+log(x)),log(a+log(x)))'],
                '2.269268': ['f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)'],
                '2.486498': ['f(log(a*x+b)/x**2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)'],
                '1.769733': ['f(sinh(x),cosh(x))'],
                '1.883858': ['f(cosh(x),sinh(x))'],
                '1.606140': ['f(tanh(x),log(cosh(x)))'],
                '1.690661': ['f(x*sinh(x),x*cosh(x)-sinh(x))'],
                '1.799688': ['f(x*cosh(x),x*sinh(x)-cosh(x))'],
                '3.131954': ['f(sinh(x)**2,sinh(2*x)/4-x/2)'],
                '2.579685': ['f(tanh(x)**2,x-tanh(x))'],
                '3.548923': ['f(cosh(x)**2,sinh(2*x)/4+x/2)'],
                '1.058866': ['f(x**3*exp(a*x**2),exp(a*x**2)*(x**2/a-1/(a**2))/2)'],
                '1.235270': ['f(x**3*exp(a*x**2+b),exp(a*x**2)*exp(b)*(x**2/a-1/(a**2))/2)'],
                '1.130783': ['f(exp(a*x**2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)'],
                '1.078698': ['f(erf(a*x),x*erf(a*x)+exp(-a**2*x**2)/a/sqrt(pi))'],
                '2.573650': [
                    'f(x**2*(1-x**2)**(3/2),(x*sqrt(1-x**2)*(-8*x**4+14*x**2-3)+3*arcsin(x))/48)',
                    'f(x**2*(1-x**2)**(5/2),(x*sqrt(1-x**2)*(48*x**6-136*x**4+118*x**2-15)+15*arcsin(x))/384)',
                ],
                '2.640666': [
                    'f(x**4*(1-x**2)**(3/2),(-x*sqrt(1-x**2)*(16*x**6-24*x**4+2*x**2+3)+3*arcsin(x))/128)',
                ],
                '1.086487': ['f(x*exp(a*x),exp(a*x)*(a*x-1)/(a**2))'],
                '1.267493': ['f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a**2))'],
                '1.037943': ['f(x**2*exp(a*x),exp(a*x)*(a**2*x**2-2*a*x+2)/(a**3))'],
                '1.210862': ['f(x**2*exp(a*x+b),exp(a*x+b)*(a**2*x**2-2*a*x+2)/(a**3))'],
                '1.064970': ['f(x**3*exp(a*x),exp(a*x)*x**3/a-3/a*integral(x**2*exp(a*x),x))'],
                '1.242392': [
                    'f(x**3*exp(a*x+b),exp(a*x+b)*x**3/a-3/a*integral(x**2*exp(a*x+b),x))',
                ],
            };

            /* defint =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            f,x,a,b[,y,c,d...]

            General description
            -------------------
            Returns the definite integral of f with respect to x evaluated from "a" to b.
            The argument list can be extended for multiple integrals (or "iterated
            integrals"), for example a double integral (which can represent for
            example a volume under a surface), or a triple integral, etc. For
            example, defint(f,x,a,b,y,c,d).

            */
            /**
             * Evaluates (defint f x a b [y c d ...])
             * @param expr
             * @param $
             * @returns
             */
            function Eval_defint(expr, $) {
                let F = $.valueOf(cadr(expr));
                // console.lg(`F=${print_expr(F, $)}`);
                let p1 = cddr(expr);
                // defint can handle multiple
                // integrals, so we loop over the
                // multiple integrals here
                while (is_cons(p1)) {
                    const X = $.valueOf(car(p1));
                    // console.lg(`X=${print_expr(X, $)}`);
                    p1 = cdr(p1);
                    const A = $.valueOf(car(p1));
                    // console.lg(`A=${print_expr(A, $)}`);
                    p1 = cdr(p1);
                    const B = $.valueOf(car(p1));
                    // console.lg(`B=${print_expr(B, $)}`);
                    p1 = cdr(p1);
                    // obtain the primitive of F against the
                    // specified variable X
                    // note that the primitive changes over
                    // the calculation of the multiple
                    // integrals.
                    F = integral(F, X, $); // contains the antiderivative of F
                    // console.lg(`F=${print_expr(F, $)}`);
                    // evaluate the integral in A
                    const arg1 = $.valueOf(subst(F, X, B, $));
                    // evaluate the integral in B
                    const arg2 = $.valueOf(subst(F, X, A, $));
                    // integral between B and A is the
                    // subtraction. Note that this could
                    // be a number but also a function.
                    // and we might have to integrate this
                    // number/function again doing the while
                    // loop again if this is a multiple
                    // integral.
                    F = $.subtract(arg1, arg2);
                }
                return F;
            }

            let Builder$3V = class Builder {
                create($) {
                    return new Op$3j($);
                }
            };
            let Op$3j = class Op extends FunctionVarArgs {
                constructor($) {
                    super('defint', DEFINT, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_defint(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const defint = new Builder$3V();

            let Builder$3U = class Builder {
                create($) {
                    return new Op$3i($);
                }
            };
            let Op$3i = class Op extends FunctionVarArgs {
                constructor($) {
                    super('degree', DEGREE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_degree(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const degree_varargs = new Builder$3U();

            let Builder$3T = class Builder {
                create($) {
                    return new Op$3h($);
                }
            };
            let Op$3h = class Op extends FunctionVarArgs {
                constructor($) {
                    super('denominator', DENOMINATOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_denominator(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const denominator_fn = new Builder$3T();

            let Builder$3S = class Builder {
                create($) {
                    return new Op$3g($);
                }
            };
            /**
             * (derivative F X) where F is (* f g)
             *
             * TODO: This should now be covered elsewhere.
             */
            let Op$3g = class Op extends Function2 {
                constructor($) {
                    super('derivative_2_mul_any', MATH_DERIVATIVE, and(is_cons, is_opr_2_any_any(MATH_MUL$3)), is_sym, $);
                    this.hash = hash_binop_cons_atom(MATH_DERIVATIVE, MATH_MUL$3, HASH_ANY);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const retval = dproduct(lhs, rhs, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                    /*
                    // Here, we evaluate the derivative using nonstandard analyis.
                    // https://en.wikipedia.org/wiki/Nonstandard_analysis
                    const X = rhs;
                    const p0 = new Hyp(`d${X}`, X.pos, X.end);
                    const p1 = subst(lhs, X, makeList(MATH_ADD, X, p0), $);
                    const p2 = $.negate(lhs);
                    const p3 = makeList(MATH_ADD, p1, p2);
                    const p4 = $.divide(p3, p0);
                    const p5 = $.valueOf(makeList(MATH_STANDARD_PART, p4));
                    const changed = true;
                    // The following implementaion encodes the chain rule.
                    // const retval = dproduct(lhs, X, $);
                    // const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : NOFLAGS, p5];
                    */
                }
            };
            const derivative_2_mul_any = new Builder$3S();

            let Builder$3R = class Builder {
                create($) {
                    return new Op$3f($);
                }
            };
            /**
             * (derivative (expt base expo) X)
             */
            let Op$3f = class Op extends Function2 {
                constructor($) {
                    super('derivative_2_pow_any', MATH_DERIVATIVE, and(is_cons, is_opr_2_any_any(MATH_POW$2)), is_any, $);
                    this.hash = hash_binop_cons_atom(MATH_DERIVATIVE, MATH_POW$2, HASH_ANY);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const retval = dpower(lhs, rhs, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                }
            };
            const derivative_2_pow_any = new Builder$3R();

            function Eval_derivative(expr, $) {
                // eslint-disable-next-line no-console
                // console.lg(`Eval_derivative(expr=${render_as_sexpr(expr, $)})`);
                // console.lg(`car(expr.cdr)=${render_as_sexpr(car(expr.cdr), $)})`);
                // evaluate 1st arg to get function F
                let F = $.valueOf(car(expr.cdr));
                // evaluate 2nd arg and then...
                // example   result of 2nd arg  what to do
                // -------   -----------------  ---------------
                // d(f)      NIL                guess X, N = NIL
                // d(f,2)    2                  guess X, N = 2
                // d(f,x)    x                  X = x, N = NIL
                // d(f,x,2)  x                  X = x, N = 2
                // d(f,x,y)  x                  X = x, N = y
                let p1 = cdr(expr.cdr);
                let X, N;
                const p2 = $.valueOf(car(p1));
                if (nil.equals(p2)) {
                    X = guess(F);
                    N = nil;
                }
                else if (is_num(p2)) {
                    X = guess(F);
                    N = p2;
                }
                else {
                    X = p2;
                    p1 = cdr(p1);
                    N = $.valueOf(car(p1));
                }
                // console.lg(`F=${render_as_sexpr(F, $)}`);
                // console.lg(`X=${render_as_sexpr(X, $)}`);
                // console.lg(`p1=${render_as_sexpr(p1, $)}`);
                // console.lg(`p2=${render_as_sexpr(p2, $)}`);
                // console.lg(`N=${render_as_sexpr(N, $)}`);
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    // p5 (N) might be a symbol instead of a number
                    let n;
                    if (is_num(N)) {
                        n = nativeInt(N);
                        if (isNaN(n)) {
                            throw new Error('nth derivative: check n');
                        }
                    }
                    else {
                        n = 1;
                    }
                    let temp = F;
                    if (n >= 0) {
                        for (let i = 0; i < n; i++) {
                            temp = derivative(temp, X, $);
                        }
                    }
                    else {
                        n = -n;
                        for (let i = 0; i < n; i++) {
                            temp = integral(temp, X, $);
                        }
                    }
                    F = temp;
                    // if p5 (N) is NIL then arglist is exhausted
                    if (nil === N) {
                        break;
                    }
                    // otherwise...
                    // N    arg1    what to do
                    //
                    // number  NIL    break
                    // number  number    N = arg1, continue
                    // number  symbol    X = arg1, N = arg2, continue
                    //
                    // symbol  NIL    X = N, N = NIL, continue
                    // symbol  number    X = N, N = arg1, continue
                    // symbol  symbol    X = N, N = arg1, continue
                    if (is_num(N)) {
                        p1 = cdr(p1);
                        N = $.valueOf(car(p1));
                        if (nil === N) {
                            break; // arglist exhausted
                        }
                        if (!is_num(N)) {
                            X = N;
                            p1 = cdr(p1);
                            N = $.valueOf(car(p1));
                        }
                    }
                    else {
                        X = N;
                        p1 = cdr(p1);
                        N = $.valueOf(car(p1));
                    }
                }
                return F;
            }

            let Builder$3Q = class Builder {
                create($) {
                    return new Op$3e($);
                }
            };
            let Op$3e = class Op extends FunctionVarArgs {
                constructor($) {
                    super('derivative', MATH_DERIVATIVE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_derivative(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const derivative_fn = new Builder$3Q();

            let Builder$3P = class Builder {
                constructor(name, opr, oprNew) {
                    this.name = name;
                    this.opr = opr;
                    this.oprNew = oprNew;
                }
                create($) {
                    return new Op$3d(this.name, this.opr, this.oprNew, $);
                }
            };
            function is_opr(sym, expr) {
                const opr = expr.opr;
                if (is_sym(opr)) {
                    return sym.equalsSym(opr);
                }
                else {
                    return false;
                }
            }
            /**
             * (d t1 t2 t3 t4 ...) => (derivative t1 t2 t3 t4 ...), provided d is not bound
             */
            let Op$3d = class Op extends FunctionVarArgs {
                constructor(name, oprOld, oprNew, $) {
                    super(name, oprOld, $);
                    this.oprNew = oprNew;
                }
                transform(expr) {
                    if (is_cons(expr) && is_opr(this.opr, expr)) {
                        const $ = this.$;
                        if (is_nil($.getSymbolValue(this.opr))) {
                            const retval = items_to_cons$1(this.oprNew, ...expr.tail());
                            return [TFLAG_DIFF, $.valueOf(retval)];
                        }
                        else {
                            return [TFLAG_NONE, expr];
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            };
            const d_to_derivative = new Builder$3P(`d_to_derivative`, create_sym('d'), MATH_DERIVATIVE);

            let Builder$3O = class Builder {
                create($) {
                    return new Op$3c($);
                }
            };
            function Eval_det(expr, $) {
                const arg = $.valueOf(cadr(expr));
                return det(arg, $);
            }
            let Op$3c = class Op extends Function1 {
                constructor($) {
                    super('determinant', DET, is_any, $);
                    this.hash = hash_unaop_atom(DET, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const retval = Eval_det(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                }
            };
            const det_any = new Builder$3O();

            /* dim =====================================================================
             
            Tags
            ----
            scripting, JS, internal, treenode, general concept
             
            Parameters
            ----------
            m,n
             
            General description
            -------------------
            Returns the cardinality of the nth index of tensor "m".
             
            */
            function Eval_dim(p1, $) {
                //int n
                const p2 = $.valueOf(cadr(p1));
                const n = is_cons(cddr(p1)) ? evaluate_integer(caddr(p1), $) : 1;
                if (!is_tensor(p2)) {
                    return one; // dim of scalar is 1
                }
                else if (n < 1 || n > p2.ndim) {
                    return p1;
                }
                else {
                    return create_int(p2.dim(n - 1));
                }
            }

            let Builder$3N = class Builder {
                create($) {
                    return new Op$3b($);
                }
            };
            let Op$3b = class Op extends FunctionVarArgs {
                constructor($) {
                    super('dim', DIM, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_dim(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const dim_varargs = new Builder$3N();

            let Builder$3M = class Builder {
                create($) {
                    return new Op$3a($);
                }
            };
            let Op$3a = class Op extends FunctionVarArgs {
                constructor($) {
                    super('dirac', DIRAC, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_dirac(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const dirac_varargs = new Builder$3M();

            function make_is_cons_and_opr_eq_sym$1(lower) {
                return function (expr) {
                    return is_cons(expr) && is_cons_opr_eq_sym(expr, lower);
                };
            }
            /**
             * (upper A (lower x1 x2 x3 ...))
             */
            class DistributiveLawExpandLeft extends Function2 {
                constructor($, upper, lower) {
                    super(`${upper} left-distributive over ${lower}`, upper, is_any, make_is_cons_and_opr_eq_sym$1(lower), $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_binop_atom_cons(upper, HASH_ANY, lower);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const add = rhs.opr;
                    const A = lhs;
                    const xs = rhs.tail();
                    const terms = xs.map(function (x) {
                        return $.valueOf(items_to_cons$1(opr, A, x));
                    });
                    const retval = $.valueOf(items_to_cons$1(add, ...terms));
                    return [TFLAG_DIFF, retval];
                }
            }

            function make_is_cons_and_opr_eq_sym(lower) {
                return function (expr) {
                    return is_cons(expr) && is_cons_opr_eq_sym(expr, lower);
                };
            }
            /**
             * (upper (lower x1 x2 x3 ...) Z)
             */
            class DistributiveLawExpandRight extends Function2 {
                constructor($, upper, lower) {
                    super(`${upper} right-distributive over ${lower}`, upper, make_is_cons_and_opr_eq_sym(lower), is_any, $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_binop_cons_atom(upper, lower, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(upper, lhs, rhs, orig) {
                    const $ = this.$;
                    const lower = lhs.opr;
                    const Z = rhs;
                    const xs = lhs.tail();
                    const terms = xs.map(function (x) {
                        return $.valueOf(items_to_cons$1(upper, x, Z));
                    });
                    const retval = $.valueOf(items_to_cons$1(lower, ...terms));
                    return [TFLAG_DIFF, retval];
                }
            }

            class BuilderDistributiveLawExpandLeft {
                constructor(upper, lower) {
                    this.upper = upper;
                    this.lower = lower;
                }
                create($) {
                    return new DistributiveLawExpandLeft($, this.upper, this.lower);
                }
            }
            class BuilderDistributiveLawExpandRight {
                constructor(upper, lower) {
                    this.upper = upper;
                    this.lower = lower;
                }
                create($) {
                    return new DistributiveLawExpandRight($, this.upper, this.lower);
                }
            }
            function make_lhs_distrib_expand_law(upper, lower) {
                return new BuilderDistributiveLawExpandLeft(upper, lower);
            }
            function make_rhs_distrib_expand_law(upper, lower) {
                return new BuilderDistributiveLawExpandRight(upper, lower);
            }

            /**
             * Sorts an array of factors while respecting whether the factors are scalars (can they commute?).
             * @param factors The unsorted array of factors. WARNING: This array may be reordered in future implementations.
             * @param $
             * @returns A new array containing the sorted factors.
             */
            function sort_factors(factors, $) {
                const sortable = factors.map(function (value, index) {
                    return { value, index };
                });
                sortable.sort(function (x, y) {
                    const x_comp_y = $.compareFn(MATH_MUL$3)(x.value, y.value);
                    // console.lg(render_as_infix(x.value, $), "x is scalar?", $.isScalar(x.value));
                    // console.lg(render_as_infix(y.value, $), "y is scalar?", $.isScalar(y.value));
                    // If either side is a scalar then we are allowed to take the canonical reordering as is.
                    if ($.isScalar(x.value) || $.isScalar(y.value)) {
                        return x_comp_y;
                    }
                    else {
                        // If neither are scalars then keep the order stable by sorting based on original index.
                        return x.index - y.index;
                    }
                });
                // TODO: It's tempting to copy
                const sorted = sortable.map(function (elem) {
                    return elem.value;
                });
                // console.lg(`sort_factors(${items_to_infix(factors, $)}) => ${items_to_infix(sorted, $)}`);
                return sorted;
            }

            function signum(n) {
                if (n < 0) {
                    return -1;
                }
                else if (n > 0) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            //-----------------------------------------------------------------------------
            //
            //  Generate all divisors of a term
            //
            //  Input:    Term (factor * factor * ...)
            //
            //  Output:    Divisors
            //
            //-----------------------------------------------------------------------------
            function divisors(term, $) {
                const factors = ydivisors(term, $);
                const n = factors.length;
                return new Tensor([n], sort_factors(factors, $));
            }
            function ydivisors(p1, $) {
                const stack = [];
                // push all of the term's factors
                if (is_num(p1)) {
                    stack.push(...factor_small_number(nativeInt(p1)));
                }
                else if (is_cons(p1) && is_add(p1)) {
                    stack.push(...__factor_add(p1, $));
                }
                else if (is_multiply(p1)) {
                    p1 = cdr(p1);
                    if (is_num(car(p1))) {
                        stack.push(...factor_small_number(nativeInt(car(p1))));
                        p1 = cdr(p1);
                    }
                    if (is_cons(p1)) {
                        const mapped = [...p1].map((p2) => {
                            if (is_power(p2)) {
                                return [cadr(p2), caddr(p2)];
                            }
                            return [p2, one];
                        });
                        stack.push(...mapped.flat());
                    }
                }
                else if (is_power(p1)) {
                    stack.push(cadr(p1), caddr(p1));
                }
                else {
                    stack.push(p1, one);
                }
                const k = stack.length;
                // contruct divisors by recursive descent
                stack.push(one);
                gen(stack, 0, k, $);
                return stack.slice(k);
            }
            //-----------------------------------------------------------------------------
            //
            //  Generate divisors
            //
            //  Input:    Base-exponent pairs on stack
            //
            //      h  first pair
            //
            //      k  just past last pair
            //
            //  Output:    Divisors on stack
            //
            //  For example, factor list 2 2 3 1 results in 6 divisors,
            //
            //    1
            //    3
            //    2
            //    6
            //    4
            //    12
            //
            //-----------------------------------------------------------------------------
            function gen(stack, h, k, $) {
                const ACCUM = stack.pop();
                if (h === k) {
                    stack.push(ACCUM);
                    return;
                }
                const BASE = stack[h + 0];
                const EXPO = stack[h + 1];
                const expo = nativeInt(EXPO);
                if (!isNaN(expo)) {
                    for (let i = 0; i <= Math.abs(expo); i++) {
                        stack.push($.multiply(ACCUM, $.power(BASE, create_int(signum(expo) * i))));
                        gen(stack, h + 2, k, $);
                    }
                }
            }
            //-----------------------------------------------------------------------------
            //
            //  Factor ADD expression
            //
            //  Input:    Expression
            //
            //  Output:    Factors
            //
            //  Each factor consists of two expressions, the factor itself followed
            //  by the exponent.
            //
            //-----------------------------------------------------------------------------
            function __factor_add(p1, $) {
                // get gcd of all terms
                const temp1 = is_cons(p1) ? p1.tail().reduce(function (x, y) {
                    return gcd(x, y, $);
                }) : car(p1);
                const stack = [];
                // check gcd
                let p2 = temp1;
                if ($.isOne(p2)) {
                    stack.push(p1, one);
                    return stack;
                }
                // push factored gcd
                if (is_num(p2)) {
                    stack.push(...factor_small_number(nativeInt(p2)));
                }
                else if (is_multiply(p2)) {
                    const p3 = cdr(p2);
                    if (is_num(car(p3))) {
                        stack.push(...factor_small_number(nativeInt(car(p3))));
                    }
                    else {
                        stack.push(car(p3), one);
                    }
                    if (is_cons(p3)) {
                        p3.tail().forEach((p) => stack.push(p, one));
                    }
                }
                else {
                    stack.push(p2, one);
                }
                // divide each term by gcd
                p2 = inverse(p2, $);
                const temp2 = is_cons(p1)
                    ? p1.tail().reduce((a, b) => $.add(a, $.multiply(p2, b)), zero)
                    : cdr(p1);
                stack.push(temp2, one);
                return stack;
            }

            function Eval_divisors(p1, $) {
                return divisors($.valueOf(cadr(p1)), $);
            }
            let Builder$3L = class Builder {
                create($) {
                    return new Op$39($);
                }
            };
            let Op$39 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('divisors', DIVISORS, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_divisors(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const divisors_varargs = new Builder$3L();

            /* do =====================================================================
             
            Tags
            ----
            scripting, JS, internal, treenode, general concept
             
            Parameters
            ----------
            a,b,...
             
            General description
            -------------------
            Evaluates each argument from left to right. Returns the result of the last argument.
             
            */
            function Eval_do(expr, $) {
                // console.lg("Eval_do", render_as_infix(expr, $));
                let result = car(expr);
                let p1 = cdr(expr);
                while (is_cons(p1)) {
                    result = $.valueOf(car(p1));
                    p1 = cdr(p1);
                }
                return result;
            }

            let Builder$3K = class Builder {
                create($) {
                    return new Op$38($);
                }
            };
            let Op$38 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('do', DO, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_do(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const do_varargs = new Builder$3K();

            /* eigen =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            m

            General description
            -------------------
            Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.
            The eigenval function returns a matrix with the eigenvalues along the diagonal.
            The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.
            The eigen function does not return anything but stores the eigenvalue matrix in D
            and the eigenvector matrix in Q.

            Input:    stack[tos - 1]    symmetric matrix

            Output:    D      diagnonal matrix
                  Q      eigenvector matrix

            D and Q have the property that

              A == dot(transpose(Q),D,Q)

            where A is the original matrix.

            The eigenvalues are on the diagonal of D.
            The eigenvectors are row vectors in Q.

            The eigenvalue relation:

              A X = lambda X

            can be checked as follows:

              lambda = D[1,1]
              X = Q[1]
              dot(A,X) - lambda X

            Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.

            Enter:

                 A = hilbert(3)

                 eigen(A)

                 lambda = D[1,1]

                 X = Q[1]

                 dot(A,X) - lambda X

            Result:

                 -1.16435e-14
             
                 -6.46705e-15
             
                 -4.55191e-15

            Example 2: Check the relation A = QTDQ.

            Enter:

              A - dot(transpose(Q),D,Q)

            Result:

              6.27365e-12    -1.58236e-11   1.81902e-11
             
              -1.58236e-11   -1.95365e-11   2.56514e-12
             
              1.81902e-11    2.56514e-12    1.32627e-11

            */
            //define D(i, j) yydd[EIG_N * (i) + (j)]
            //define Q(i, j) yyqq[EIG_N * (i) + (j)]
            let EIG_N = 0;
            const EIG_yydd = [];
            const EIG_yyqq = [];
            function Eval_eigen(expr, $) {
                const { arg } = EIG_check_arg(expr, $);
                if (!arg) {
                    halt('eigen: argument is not a square matrix');
                }
                const [D, Q] = eigen(EIGEN, arg);
                // TODO: Who consumes these? Should we use a special namespace?
                // Better to return a Tensor.
                $.setSymbolValue(create_sym('D'), D);
                $.setSymbolValue(create_sym('Q'), Q);
                return nil;
            }
            /* eigenval =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            m

            General description
            -------------------
            Compute eigenvalues of m. See "eigen" for more info.

            */
            function Eval_eigenval(p1, $) {
                return _eigenval(p1, $);
            }
            function _eigenval(p1, $) {
                const { arg, invalid } = EIG_check_arg(p1, $);
                if (invalid) {
                    return items_to_cons$1(EIGENVAL, invalid);
                }
                // TODO: Refactor to eliminate the cast.
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const [D, _] = eigen(EIGENVAL, arg);
                return D;
            }
            /* eigenvec =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            m

            General description
            -------------------
            Compute eigenvectors of m. See "eigen" for more info.

            */
            function Eval_eigenvec(p1, $) {
                return _eigenvec(p1, $);
            }
            function _eigenvec(p1, $) {
                const { arg, invalid } = EIG_check_arg(p1, $);
                if (invalid) {
                    return items_to_cons$1(EIGENVEC, invalid);
                }
                // TODO: Refactor to eliminate the cast.
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const [_, Q] = eigen(EIGENVEC, arg);
                return Q;
            }
            function EIG_check_arg(p1, $) {
                p1 = $.valueOf(evaluate_as_float($.valueOf(cadr(p1)), $));
                if (!is_tensor(p1)) {
                    return { invalid: p1 };
                }
                if (p1.ndim !== 2 || p1.dim(0) !== p1.dim(1)) {
                    halt('eigen: argument is not a square matrix');
                }
                EIG_N = p1.dim(0);
                if (!eigIsDoubleTensor(p1)) {
                    halt('eigen: matrix is not numerical');
                }
                for (let i = 0; i < EIG_N - 1; i++) {
                    for (let j = i + 1; j < EIG_N; j++) {
                        const eli = p1.elem(EIG_N * i + j);
                        const elj = p1.elem(EIG_N * j + i);
                        if (Math.abs(eli.d - elj.d) > 1e-10) {
                            halt('eigen: matrix is not symmetrical');
                        }
                    }
                }
                return { arg: p1 };
            }
            function eigIsDoubleTensor(p1) {
                for (let i = 0; i < EIG_N; i++) {
                    for (let j = 0; j < EIG_N; j++) {
                        if (!is_flt$1(p1.elem(EIG_N * i + j))) {
                            return false;
                        }
                    }
                }
                return true;
            }
            //-----------------------------------------------------------------------------
            //
            //  Input:    p1    matrix
            //
            //  Output:    p2    eigenvalues
            //
            //      p3    eigenvectors
            //
            //-----------------------------------------------------------------------------
            function eigen(op, p1) {
                // malloc working vars
                //EIG_yydd = (double *) malloc(n * n * sizeof (double))
                for (let i = 0; i < EIG_N * EIG_N; i++) {
                    EIG_yydd[i] = 0.0;
                }
                //if (EIG_yydd == NULL)
                //  stop("malloc failure")
                //EIG_yyqq = (double *) malloc(n * n * sizeof (double))
                for (let i = 0; i < EIG_N * EIG_N; i++) {
                    EIG_yyqq[i] = 0.0;
                }
                //if (EIG_yyqq == NULL)
                //  stop("malloc failure")
                // initialize D
                for (let i = 0; i < EIG_N; i++) {
                    EIG_yydd[EIG_N * i + i] = p1.elem(EIG_N * i + i).d;
                    for (let j = i + 1; j < EIG_N; j++) {
                        EIG_yydd[EIG_N * i + j] = p1.elem(EIG_N * i + j).d;
                        EIG_yydd[EIG_N * j + i] = p1.elem(EIG_N * i + j).d;
                    }
                }
                // initialize Q
                for (let i = 0; i < EIG_N; i++) {
                    EIG_yyqq[EIG_N * i + i] = 1.0;
                    for (let j = i + 1; j < EIG_N; j++) {
                        EIG_yyqq[EIG_N * i + j] = 0.0;
                        EIG_yyqq[EIG_N * j + i] = 0.0;
                    }
                }
                // step up to 100 times
                let i = 0;
                for (i = 0; i < 100; i++) {
                    if (step() === 0) {
                        break;
                    }
                }
                const Ddims = p1.copyDimensions();
                const Delems = p1.copyElements();
                if (op.equals(EIGEN) || op.equals(EIGENVAL)) {
                    for (let i = 0; i < EIG_N; i++) {
                        for (let j = 0; j < EIG_N; j++) {
                            Delems[EIG_N * i + j] = create_flt(EIG_yydd[EIG_N * i + j]);
                        }
                    }
                }
                const Qdims = p1.copyDimensions();
                const Qelems = p1.copyElements();
                if (op.equals(EIGEN) || op.equals(EIGENVEC)) {
                    for (let i = 0; i < EIG_N; i++) {
                        for (let j = 0; j < EIG_N; j++) {
                            Qelems[EIG_N * i + j] = create_flt(EIG_yyqq[EIG_N * i + j]);
                        }
                    }
                }
                const D = new Tensor(Ddims, Delems);
                const Q = new Tensor(Qdims, Qelems);
                return [D, Q];
            }
            // free working vars
            //-----------------------------------------------------------------------------
            //
            //  Example: p = 1, q = 3
            //
            //    c  0  s  0
            //
            //    0  1  0  0
            //  G =
            //    -s  0  c  0
            //
            //    0  0  0  1
            //
            //  The effect of multiplying G times A is...
            //
            //  row 1 of A    = c (row 1 of A ) + s (row 3 of A )
            //            n+1                n                 n
            //
            //  row 3 of A    = c (row 3 of A ) - s (row 1 of A )
            //            n+1                n                 n
            //
            //  In terms of components the overall effect is...
            //
            //  row 1 = c row 1 + s row 3
            //
            //    A[1,1] = c A[1,1] + s A[3,1]
            //
            //    A[1,2] = c A[1,2] + s A[3,2]
            //
            //    A[1,3] = c A[1,3] + s A[3,3]
            //
            //    A[1,4] = c A[1,4] + s A[3,4]
            //
            //  row 3 = c row 3 - s row 1
            //
            //    A[3,1] = c A[3,1] - s A[1,1]
            //
            //    A[3,2] = c A[3,2] - s A[1,2]
            //
            //    A[3,3] = c A[3,3] - s A[1,3]
            //
            //    A[3,4] = c A[3,4] - s A[1,4]
            //
            //                                     T
            //  The effect of multiplying A times G  is...
            //
            //  col 1 of A    = c (col 1 of A ) + s (col 3 of A )
            //            n+1                n                 n
            //
            //  col 3 of A    = c (col 3 of A ) - s (col 1 of A )
            //            n+1                n                 n
            //
            //  In terms of components the overall effect is...
            //
            //  col 1 = c col 1 + s col 3
            //
            //    A[1,1] = c A[1,1] + s A[1,3]
            //
            //    A[2,1] = c A[2,1] + s A[2,3]
            //
            //    A[3,1] = c A[3,1] + s A[3,3]
            //
            //    A[4,1] = c A[4,1] + s A[4,3]
            //
            //  col 3 = c col 3 - s col 1
            //
            //    A[1,3] = c A[1,3] - s A[1,1]
            //
            //    A[2,3] = c A[2,3] - s A[2,1]
            //
            //    A[3,3] = c A[3,3] - s A[3,1]
            //
            //    A[4,3] = c A[4,3] - s A[4,1]
            //
            //  What we want to do is just compute the upper triangle of A since we
            //  know the lower triangle is identical.
            //
            //  In other words, we just want to update components A[i,j] where i < j.
            //
            //-----------------------------------------------------------------------------
            //
            //  Example: p = 2, q = 5
            //
            //        p      q
            //
            //      j=1  j=2  j=3  j=4  j=5  j=6
            //
            //    i=1  .  A[1,2]  .  .  A[1,5]  .
            //
            //  p  i=2  A[2,1]  A[2,2]  A[2,3]  A[2,4]  A[2,5]  A[2,6]
            //
            //    i=3  .  A[3,2]  .  .  A[3,5]  .
            //
            //    i=4  .  A[4,2]  .  .  A[4,5]  .
            //
            //  q  i=5  A[5,1]  A[5,2]  A[5,3]  A[5,4]  A[5,5]  A[5,6]
            //
            //    i=6  .  A[6,2]  .  .  A[6,5]  .
            //
            //-----------------------------------------------------------------------------
            //
            //  This is what B = GA does:
            //
            //  row 2 = c row 2 + s row 5
            //
            //    B[2,1] = c * A[2,1] + s * A[5,1]
            //    B[2,2] = c * A[2,2] + s * A[5,2]
            //    B[2,3] = c * A[2,3] + s * A[5,3]
            //    B[2,4] = c * A[2,4] + s * A[5,4]
            //    B[2,5] = c * A[2,5] + s * A[5,5]
            //    B[2,6] = c * A[2,6] + s * A[5,6]
            //
            //  row 5 = c row 5 - s row 2
            //
            //    B[5,1] = c * A[5,1] + s * A[2,1]
            //    B[5,2] = c * A[5,2] + s * A[2,2]
            //    B[5,3] = c * A[5,3] + s * A[2,3]
            //    B[5,4] = c * A[5,4] + s * A[2,4]
            //    B[5,5] = c * A[5,5] + s * A[2,5]
            //    B[5,6] = c * A[5,6] + s * A[2,6]
            //
            //                 T
            //  This is what BG  does:
            //
            //  col 2 = c col 2 + s col 5
            //
            //    B[1,2] = c * A[1,2] + s * A[1,5]
            //    B[2,2] = c * A[2,2] + s * A[2,5]
            //    B[3,2] = c * A[3,2] + s * A[3,5]
            //    B[4,2] = c * A[4,2] + s * A[4,5]
            //    B[5,2] = c * A[5,2] + s * A[5,5]
            //    B[6,2] = c * A[6,2] + s * A[6,5]
            //
            //  col 5 = c col 5 - s col 2
            //
            //    B[1,5] = c * A[1,5] - s * A[1,2]
            //    B[2,5] = c * A[2,5] - s * A[2,2]
            //    B[3,5] = c * A[3,5] - s * A[3,2]
            //    B[4,5] = c * A[4,5] - s * A[4,2]
            //    B[5,5] = c * A[5,5] - s * A[5,2]
            //    B[6,5] = c * A[6,5] - s * A[6,2]
            //
            //-----------------------------------------------------------------------------
            //
            //  Step 1: Just do upper triangle (i < j), B[2,5] = 0
            //
            //    B[1,2] = c * A[1,2] + s * A[1,5]
            //
            //    B[2,3] = c * A[2,3] + s * A[5,3]
            //    B[2,4] = c * A[2,4] + s * A[5,4]
            //    B[2,6] = c * A[2,6] + s * A[5,6]
            //
            //    B[1,5] = c * A[1,5] - s * A[1,2]
            //    B[3,5] = c * A[3,5] - s * A[3,2]
            //    B[4,5] = c * A[4,5] - s * A[4,2]
            //
            //    B[5,6] = c * A[5,6] + s * A[2,6]
            //
            //-----------------------------------------------------------------------------
            //
            //  Step 2: Transpose where i > j since A[i,j] == A[j,i]
            //
            //    B[1,2] = c * A[1,2] + s * A[1,5]
            //
            //    B[2,3] = c * A[2,3] + s * A[3,5]
            //    B[2,4] = c * A[2,4] + s * A[4,5]
            //    B[2,6] = c * A[2,6] + s * A[5,6]
            //
            //    B[1,5] = c * A[1,5] - s * A[1,2]
            //    B[3,5] = c * A[3,5] - s * A[2,3]
            //    B[4,5] = c * A[4,5] - s * A[2,4]
            //
            //    B[5,6] = c * A[5,6] + s * A[2,6]
            //
            //-----------------------------------------------------------------------------
            //
            //  Step 3: Same as above except reorder
            //
            //  k < p    (k = 1)
            //
            //    A[1,2] = c * A[1,2] + s * A[1,5]
            //    A[1,5] = c * A[1,5] - s * A[1,2]
            //
            //  p < k < q  (k = 3..4)
            //
            //    A[2,3] = c * A[2,3] + s * A[3,5]
            //    A[3,5] = c * A[3,5] - s * A[2,3]
            //
            //    A[2,4] = c * A[2,4] + s * A[4,5]
            //    A[4,5] = c * A[4,5] - s * A[2,4]
            //
            //  q < k    (k = 6)
            //
            //    A[2,6] = c * A[2,6] + s * A[5,6]
            //    A[5,6] = c * A[5,6] - s * A[2,6]
            //
            //-----------------------------------------------------------------------------
            function step() {
                let count = 0;
                // for each upper triangle "off-diagonal" component do step2
                for (let i = 0; i < EIG_N - 1; i++) {
                    for (let j = i + 1; j < EIG_N; j++) {
                        if (EIG_yydd[EIG_N * i + j] !== 0.0) {
                            step2(i, j);
                            count++;
                        }
                    }
                }
                return count;
            }
            function step2(p, q) {
                // compute c and s
                // from Numerical Recipes (except they have a_qq - a_pp)
                const theta = (0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q])) /
                    EIG_yydd[EIG_N * p + q];
                let t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));
                if (theta < 0.0) {
                    t = -t;
                }
                const c = 1.0 / Math.sqrt(t * t + 1.0);
                const s = t * c;
                // D = GD
                // which means "add rows"
                for (let k = 0; k < EIG_N; k++) {
                    const cc = EIG_yydd[EIG_N * p + k];
                    const ss = EIG_yydd[EIG_N * q + k];
                    EIG_yydd[EIG_N * p + k] = c * cc + s * ss;
                    EIG_yydd[EIG_N * q + k] = c * ss - s * cc;
                }
                // D = D transpose(G)
                // which means "add columns"
                for (let k = 0; k < EIG_N; k++) {
                    const cc = EIG_yydd[EIG_N * k + p];
                    const ss = EIG_yydd[EIG_N * k + q];
                    EIG_yydd[EIG_N * k + p] = c * cc + s * ss;
                    EIG_yydd[EIG_N * k + q] = c * ss - s * cc;
                }
                // Q = GQ
                // which means "add rows"
                for (let k = 0; k < EIG_N; k++) {
                    const cc = EIG_yyqq[EIG_N * p + k];
                    const ss = EIG_yyqq[EIG_N * q + k];
                    EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;
                    EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;
                }
                EIG_yydd[EIG_N * p + q] = 0.0;
                EIG_yydd[EIG_N * q + p] = 0.0;
            }

            let Builder$3J = class Builder {
                create($) {
                    return new Op$37($);
                }
            };
            let Op$37 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('eigenval', EIGENVAL, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_eigenval(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const eigenval_varargs = new Builder$3J();

            let Builder$3I = class Builder {
                create($) {
                    return new Op$36($);
                }
            };
            let Op$36 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('eigenvec', EIGENVEC, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_eigenvec(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const eigenvec_varargs = new Builder$3I();

            let Builder$3H = class Builder {
                create($) {
                    return new Op$35($);
                }
            };
            let Op$35 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('eigen', EIGEN, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_eigen(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const eigen_varargs = new Builder$3H();

            // from Numerical Recipes in C
            function erfc(x) {
                if (x === 0) {
                    return 1.0;
                }
                const z = Math.abs(x);
                const t = 1.0 / (1.0 + 0.5 * z);
                const ans = t *
                    Math.exp(-z * z -
                        1.26551223 +
                        t *
                            (1.00002368 +
                                t *
                                    (0.37409196 +
                                        t *
                                            (0.09678418 +
                                                t *
                                                    (-0.18628806 +
                                                        t *
                                                            (0.27886807 +
                                                                t *
                                                                    (-1.13520398 +
                                                                        t *
                                                                            (1.48851587 +
                                                                                t * (-0.82215223 + t * 0.17087277)))))))));
                if (x >= 0.0) {
                    return ans;
                }
                return 2.0 - ans;
            }

            let Builder$3G = class Builder {
                create($) {
                    return new Op$34($);
                }
            };
            let Op$34 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('erf', ERF, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = yerf($.valueOf(cadr(expr)), $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            function yerf(p1, $) {
                if (is_flt$1(p1)) {
                    return create_flt(1.0 - erfc(p1.d));
                }
                if ($.is_zero(p1)) {
                    return zero;
                }
                if (is_negative(p1)) {
                    return $.negate(items_to_cons$1(ERF, $.negate(p1)));
                }
                return items_to_cons$1(ERF, p1);
            }
            const erf_varargs = new Builder$3G();

            let Builder$3F = class Builder {
                create($) {
                    return new Op$33($);
                }
            };
            let Op$33 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('erfc', ERFC, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = yerfc($.valueOf(cadr(expr)), $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            function yerfc(p1, $) {
                if (is_flt$1(p1)) {
                    const d = erfc(p1.d);
                    return create_flt(d);
                }
                if ($.is_zero(p1)) {
                    return one;
                }
                return items_to_cons$1(ERFC, p1);
            }
            const erfc_varargs = new Builder$3F();

            const ENGLISH_UNDEFINED = 'undefined';
            /*
            export function error_compare(lhs: Err, rhs: Err): Sign {
                const str1 = lhs.message;
                const str2 = rhs.message;
                if (str1 === str2) {
                    return SIGN_EQ;
                }
                else if (str1 > str2) {
                    return SIGN_GT;
                }
                else {
                    return SIGN_LT;
                }
            }
            */
            class ErrExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return TYPEOF_ERR;
                }
                get name() {
                    return 'ErrExtension';
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    return [expr instanceof Err ? TFLAG_HALT : TFLAG_NONE, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(expr, $) {
                    throw new Error("ErrExtension.valueOf Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    throw new Error("ErrExtension Method not implemented.");
                }
                isKind(arg) {
                    return arg instanceof Err;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(arg, $) {
                    throw new Error("ErrExtension.isMinusOne Method not implemented.");
                }
                isOne() {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    throw new Error("ErrExtension.isReal Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return false;
                }
                isZero() {
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (this.isKind(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(expr, $) {
                    return ENGLISH_UNDEFINED;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(expr, $) {
                    return ENGLISH_UNDEFINED;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toListString(expr, $) {
                    return ENGLISH_UNDEFINED;
                }
            }
            const err_extension = new ExtensionOperatorBuilder(function ($) {
                return new ErrExtension($);
            });

            /*
            function Eval_Eval(p1: U, $: ExtensionEnv): U {
                let tmp = $.valueOf(cadr(p1));
                p1 = cddr(p1);
                while (is_cons(p1)) {
                    tmp = subst(tmp, $.valueOf(car(p1)), $.valueOf(cadr(p1)), $);
                    p1 = cddr(p1);
                }
                return $.valueOf(tmp);
            }
            */
            let Builder$3E = class Builder {
                create($) {
                    return new Op$32($);
                }
            };
            let Op$32 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('eval', EVAL, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    let p1 = expr;
                    let tmp = $.valueOf(cadr(p1));
                    p1 = cddr(p1);
                    while (is_cons(p1)) {
                        const oldExpr = $.valueOf(car(p1));
                        const newExpr = $.valueOf(cadr(p1));
                        tmp = subst(tmp, oldExpr, newExpr, $);
                        p1 = cddr(p1);
                    }
                    return [TFLAG_DIFF, $.valueOf(tmp)];
                }
            };
            const eval_varargs = new Builder$3E();

            const MATH_E = native_sym(Native.E);
            const EXP$4 = native_sym(Native.exp);
            const POW$b = native_sym(Native.pow);
            let Builder$3D = class Builder {
                create($) {
                    return new Exp($);
                }
            };
            class Exp extends Function1 {
                // readonly phases = PHASE_EXPANDING;
                constructor($) {
                    super('exp', EXP$4, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    // console.lg(this.name, this.$.toSExprString(expr));
                    const $ = this.$;
                    if ($.isExpanding()) {
                        return [TFLAG_DIFF, binop(POW$b, MATH_E, arg, $)];
                    }
                    else {
                        // The argument is evaluated by the base class in all other phases.
                        return [TFLAG_NONE, expr];
                    }
                }
            }
            const exp = new Builder$3D();

            const ADD$5 = native_sym(Native.add);
            const EXP$3 = native_sym(Native.exp);
            const MUL$3 = native_sym(Native.multiply);
            let Builder$3C = class Builder {
                create($) {
                    return new Op$31($);
                }
            };
            /**
             * exp(a + b + ...) = exp(a) * exp(b) * ...
             */
            let Op$31 = class Op extends CompositeOperator {
                constructor($) {
                    super(EXP$3, ADD$5, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    return [TFLAG_DIFF, $.valueOf(cons(MUL$3, innerExpr.argList.map($.exp)))];
                }
            };
            const exp_add = new Builder$3C();

            let Builder$3B = class Builder {
                create($) {
                    return new ExpFlt($);
                }
            };
            class ExpFlt extends Function1 {
                constructor($) {
                    super('exp_flt', MATH_EXP, is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, create_flt(Math.exp(arg.toNumber()))];
                }
            }
            const exp_flt = new Builder$3B();

            let ExpRatBuilder$1 = class ExpRatBuilder {
                create($) {
                    return new ExpRat($);
                }
            };
            class ExpRat extends Function1 {
                constructor($) {
                    super('exp_rat', create_sym('exp'), is_rat, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                transform1(opr, arg) {
                    // console.lg(this.name);
                    if (arg.isZero()) {
                        return [TFLAG_DIFF, one];
                    }
                    if (arg.isOne()) {
                        return [TFLAG_DIFF, MATH_E$2];
                    }
                    return [TFLAG_DIFF, this.$.power(MATH_E$2, arg)];
                }
            }
            const exp_rat = new ExpRatBuilder$1();

            // Push expression factors onto the stack. For example...
            //
            // Input
            //
            //       2
            //     3x  + 2x + 1
            //
            // Output on stack
            //
            //     [  3  ]
            //     [ x^2 ]
            //     [  2  ]
            //     [  x  ]
            //     [  1  ]
            //
            // but not necessarily in that order. Returns the number of factors.
            function factors(p) {
                const result = [];
                if (is_add(p)) {
                    p.tail().forEach((el) => result.push(...term_factors(el)));
                }
                else {
                    result.push(...term_factors(p));
                }
                return result;
            }
            function term_factors(p) {
                if (is_multiply(p)) {
                    return p.tail();
                }
                return [p];
            }

            // Divide polynomials
            function Eval_quotient(p1, $) {
                const DIVIDEND = $.valueOf(cadr(p1)); // 1st arg, p(x)
                const DIVISOR = $.valueOf(caddr(p1)); // 2nd arg, q(x)
                const X = $.valueOf(cadddr(p1)); // 3rd arg, x, default x
                if (!is_nil(X)) {
                    return divpoly(DIVIDEND, DIVISOR, X, $);
                }
                else {
                    return divpoly(DIVIDEND, DIVISOR, SYMBOL_X, $);
                }
            }
            //-----------------------------------------------------------------------------
            //
            //  Divide polynomials
            //
            //  Input:    Dividend
            //            Divisor
            //            x
            //
            //  Output:    Quotient
            //
            //-----------------------------------------------------------------------------
            function divpoly(DIVIDEND, DIVISOR, X, $) {
                const dividendCs = coeff(DIVIDEND, X, $);
                let m = dividendCs.length - 1; // m is dividend's power
                const divisorCs = coeff(DIVISOR, X, $);
                const n = divisorCs.length - 1; // n is divisor's power
                let x = m - n;
                let QUOTIENT = zero;
                while (x >= 0) {
                    const Q = divide(dividendCs[m], divisorCs[n], $);
                    for (let i = 0; i <= n; i++) {
                        dividendCs[x + i] = $.subtract(dividendCs[x + i], $.multiply(divisorCs[i], Q));
                    }
                    QUOTIENT = $.add(QUOTIENT, $.multiply(Q, $.power(X, create_int(x))));
                    m--;
                    x--;
                }
                return QUOTIENT;
            }

            // Partial fraction expansion
            //
            // Example
            //
            //      expand(1/(x^3+x^2),x)
            //
            //        1      1       1
            //      ---- - --- + -------
            //        2     x     x + 1
            //       x
            function Eval_expand(p1, $) {
                const top = $.valueOf(cadr(p1));
                const p2 = $.valueOf(caddr(p1));
                const X = nil === p2 ? guess(top) : p2;
                const F = top;
                return expand(F, X, $);
            }
            //define A p2
            //define B p3
            //define C p4
            //define F p5
            //define P p6
            //define Q p7
            //define T p8
            //define X p9
            function expand(F, X, $) {
                if (is_tensor(F)) {
                    return expand_tensor(F, X, $);
                }
                // if sum of terms then sum over the expansion of each term
                if (is_add(F)) {
                    return F.tail().reduce((a, b) => $.add(a, expand(b, X, $)), zero);
                }
                let B = numerator(F, $);
                let A = denominator(F, $);
                [A, B] = remove_negative_exponents(A, B, X, $);
                // if the denominator is one then always bail out
                // also bail out if the denominator is not one but
                // it's not anything recognizable as a polynomial.
                if (is_plus_or_minus_one(B, $) || is_plus_or_minus_one(A, $)) {
                    if (!is_poly_expanded_form(A, X) || is_plus_or_minus_one(A, $)) {
                        return F;
                    }
                }
                // Q = quotient
                const Q = divpoly(B, A, X, $);
                // remainder B = B - A * Q
                B = $.subtract(B, $.multiply(A, Q));
                // if the remainder is zero then we're done
                if ($.is_zero(B)) {
                    return Q;
                }
                // A = factor(A)
                A = $.factorize(A, X);
                const C = expand_get_C(A, X, $);
                B = expand_get_B(B, C, X, $);
                A = expand_get_A(A, C, X, $);
                let result;
                if (is_tensor(C)) {
                    const inverse = doexpand_unary(inv, C, $);
                    result = $.inner($.inner(inverse, B), A);
                }
                else {
                    const arg1 = divide_expand(B, C, $);
                    result = $.multiply(arg1, A);
                }
                return $.add(result, Q);
            }
            function expand_tensor(p5, p9, $) {
                return p5.map(function (el) {
                    return expand(el, p9, $);
                });
            }
            function remove_negative_exponents(p2, p3, p9, $) {
                const arr = [...factors(p2), ...factors(p3)];
                // find the smallest exponent
                let j = 0;
                for (let i = 0; i < arr.length; i++) {
                    const p1 = arr[i];
                    if (!is_power(p1)) {
                        continue;
                    }
                    if (!cadr(p1).equals(p9)) {
                        continue;
                    }
                    const k = nativeInt(caddr(p1));
                    if (isNaN(k)) {
                        continue;
                    }
                    if (k < j) {
                        j = k;
                    }
                }
                if (j === 0) {
                    return [p2, p3];
                }
                // A = A / X^j
                p2 = $.multiply(p2, $.power(p9, create_int(-j)));
                // B = B / X^j
                p3 = $.multiply(p3, $.power(p9, create_int(-j)));
                return [p2, p3];
            }
            // Returns the expansion coefficient matrix C.
            //
            // Example:
            //
            //       B         1
            //      --- = -----------
            //       A      2
            //             x (x + 1)
            //
            // We have
            //
            //       B     Y1     Y2      Y3
            //      --- = ---- + ---- + -------
            //       A      2     x      x + 1
            //             x
            //
            // Our task is to solve for the unknowns Y1, Y2, and Y3.
            //
            // Multiplying both sides by A yields
            //
            //           AY1     AY2      AY3
            //      B = ----- + ----- + -------
            //            2      x       x + 1
            //           x
            //
            // Let
            //
            //            A               A                 A
            //      W1 = ----       W2 = ---        W3 = -------
            //             2              x               x + 1
            //            x
            //
            // Then the coefficient matrix C is
            //
            //              coeff(W1,x,0)   coeff(W2,x,0)   coeff(W3,x,0)
            //
            //       C =    coeff(W1,x,1)   coeff(W2,x,1)   coeff(W3,x,1)
            //
            //              coeff(W1,x,2)   coeff(W2,x,2)   coeff(W3,x,2)
            //
            // It follows that
            //
            //       coeff(B,x,0)     Y1
            //
            //       coeff(B,x,1) = C Y2
            //
            //       coeff(B,x,2) =   Y3
            //
            // Hence
            //
            //       Y1       coeff(B,x,0)
            //             -1
            //       Y2 = C   coeff(B,x,1)
            //
            //       Y3       coeff(B,x,2)
            function expand_get_C(p2, p9, $) {
                const stack = [];
                if (is_multiply(p2)) {
                    p2.tail().forEach((p5) => stack.push(...expand_get_CF(p2, p5, p9, $)));
                }
                else {
                    stack.push(...expand_get_CF(p2, p2, p9, $));
                }
                const n = stack.length;
                if (n === 1) {
                    return stack[0];
                }
                const dims = [n, n];
                const elems = new Array(n * n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const arg2 = $.power(p9, create_int(i));
                        const divided = divide_expand(stack[j], arg2, $);
                        elems[n * i + j] = filter(divided, p9, $);
                    }
                }
                return new Tensor(dims, elems);
            }
            // The following table shows the push order for simple roots, repeated roots,
            // and inrreducible factors.
            //
            //  Factor F        Push 1st        Push 2nd         Push 3rd      Push 4th
            //
            //
            //                   A
            //  x               ---
            //                   x
            //
            //
            //   2               A               A
            //  x               ----            ---
            //                    2              x
            //                   x
            //
            //
            //                     A
            //  x + 1           -------
            //                   x + 1
            //
            //
            //         2            A              A
            //  (x + 1)         ----------      -------
            //                          2        x + 1
            //                   (x + 1)
            //
            //
            //   2                   A               Ax
            //  x  + x + 1      ------------    ------------
            //                    2               2
            //                   x  + x + 1      x  + x + 1
            //
            //
            //    2         2          A              Ax              A             Ax
            //  (x  + x + 1)    --------------- ---------------  ------------  ------------
            //                     2         2     2         2     2             2
            //                   (x  + x + 1)    (x  + x + 1)     x  + x + 1    x  + x + 1
            //
            //
            // For T = A/F and F = P^N we have
            //
            //
            //      Factor F          Push 1st    Push 2nd    Push 3rd    Push 4th
            //
            //      x                 T
            //
            //       2
            //      x                 T           TP
            //
            //
            //      x + 1             T
            //
            //             2
            //      (x + 1)           T           TP
            //
            //       2
            //      x  + x + 1        T           TX
            //
            //        2         2
            //      (x  + x + 1)      T           TX          TP          TPX
            //
            //
            // Hence we want to push in the order
            //
            //      T * (P ^ i) * (X ^ j)
            //
            // for all i, j such that
            //
            //      i = 0, 1, ..., N - 1
            //
            //      j = 0, 1, ..., deg(P) - 1
            //
            // where index j runs first.
            function expand_get_CF(p2, p5, p9, $) {
                let p6;
                let n = 0;
                if (!p5.contains(p9)) {
                    return [];
                }
                const p8 = doexpand_binary(trivial_divide, p2, p5, $);
                if (is_power(p5)) {
                    n = nativeInt(caddr(p5));
                    p6 = cadr(p5);
                }
                else {
                    n = 1;
                    p6 = p5;
                }
                const stack = [];
                const d = nativeInt(degree(p6, p9, $));
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < d; j++) {
                        const arg6 = $.power(p6, create_int(i));
                        const arg8 = doexpand_binary(multiply$1, p8, arg6, $);
                        const arg9 = $.power(p9, create_int(j));
                        const multiplied = doexpand_binary(multiply$1, arg8, arg9, $);
                        stack.push(multiplied);
                    }
                }
                return stack;
            }
            // Returns T = A/F where F is a factor of A.
            function trivial_divide(p2, p5, $) {
                let result = one;
                if (is_multiply(p2)) {
                    const arr = [];
                    p2.tail().forEach((p0) => {
                        if (!p0.equals(p5)) {
                            // force expansion of (x+1)^2, f.e.
                            arr.push($.valueOf(p0));
                        }
                    });
                    result = multiply_items(arr, $);
                }
                return result;
            }
            // Returns the expansion coefficient vector B.
            function expand_get_B(p3, p4, p9, $) {
                if (!is_tensor(p4)) {
                    return p3;
                }
                const n = p4.dim(0);
                const dims = [n];
                const elems = new Array(n);
                for (let i = 0; i < n; i++) {
                    const arg2 = $.power(p9, create_int(i));
                    const divided = divide_expand(p3, arg2, $);
                    elems[i] = filter(divided, p9, $);
                }
                return new Tensor(dims, elems);
            }
            // Returns the expansion fractions in A.
            function expand_get_A(p2, p4, X, $) {
                if (!is_tensor(p4)) {
                    return inverse(p2, $);
                }
                let elements = [];
                if (is_multiply(p2)) {
                    p2.tail().forEach((p5) => {
                        elements.push(...expand_get_AF(p5, X, $));
                    });
                }
                else {
                    elements = expand_get_AF(p2, X, $);
                }
                const n = elements.length;
                const dims = [n];
                return new Tensor(dims, elements);
            }
            function expand_get_AF(p5, X, $) {
                let n = 1;
                if (!p5.contains(X)) {
                    return [];
                }
                if (is_power(p5)) {
                    n = nativeInt(caddr(p5));
                    p5 = cadr(p5);
                }
                const results = [];
                const d = nativeInt(degree(p5, X, $));
                for (let i = n; i > 0; i--) {
                    for (let j = 0; j < d; j++) {
                        const A = $.power(p5, create_int(i));
                        const B = inverse(A, $);
                        const C = $.power(X, create_int(j));
                        results.push($.multiply(B, C));
                    }
                }
                return results;
            }

            let Builder$3A = class Builder {
                create($) {
                    return new Op$30($);
                }
            };
            let Op$30 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('expand', EXPAND, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_expand(expr, $);
                    const flag = retval.equals(expr) ? TFLAG_NONE : TFLAG_DIFF;
                    return [flag, retval];
                }
            };
            const expand_extension = new Builder$3A();

            let Builder$3z = class Builder {
                create($) {
                    return new Op$2$($);
                }
            };
            let Op$2$ = class Op extends FunctionVarArgs {
                constructor($) {
                    super('expcos', EXPCOS, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        const arg = $.valueOf(cadr(expr));
                        const retval = expcos(arg, $);
                        const changed = !retval.equals(expr);
                        return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const expcos_varargs = new Builder$3z();

            let Builder$3y = class Builder {
                create($) {
                    return new Op$2_($);
                }
            };
            let Op$2_ = class Op extends FunctionVarArgs {
                constructor($) {
                    super('expsin', EXPSIN, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        const arg = $.valueOf(cadr(expr));
                        const retval = expsin(arg, $);
                        const changed = !retval.equals(expr);
                        return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const expsin_varargs = new Builder$3y();

            // factor a polynomial or integer
            function Eval_factor(expr, $) {
                const arg1 = $.valueOf(cadnr(expr, 1));
                const arg2 = $.valueOf(cadnr(expr, 2));
                const variable = nil === arg2 ? guess(arg1) : arg2;
                let temp = factor(arg1, variable, $);
                // more factoring?
                const p1 = cdddr(expr);
                if (is_cons(p1)) {
                    temp = [...p1].reduce((acc, p) => factor_again(acc, $.valueOf(p), $), temp);
                }
                return temp;
            }
            let Builder$3x = class Builder {
                create($) {
                    return new Op$2Z($);
                }
            };
            let Op$2Z = class Op extends FunctionVarArgs {
                constructor($) {
                    super('factor', FACTOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_factor(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const factor_varargs = new Builder$3x();

            function Eval_factorial(p1, $) {
                return factorial($.valueOf(cadr(p1)));
            }
            let Builder$3w = class Builder {
                create($) {
                    return new Op$2Y($);
                }
            };
            let Op$2Y = class Op extends FunctionVarArgs {
                constructor($) {
                    super('factorial', FACTORIAL, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_factorial(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const factorial_varargs = new Builder$3w();

            let Builder$3v = class Builder {
                create($) {
                    return new Op$2X($);
                }
            };
            let Op$2X = class Op extends FunctionVarArgs {
                constructor($) {
                    super('float', FLOAT, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_float(expr, $);
                    const flag = retval.equals(expr) ? TFLAG_NONE : TFLAG_DIFF;
                    return [flag, retval];
                }
            };
            const float_varargs = new Builder$3v();

            function Eval_floor(p1, $) {
                const result = yfloor($.valueOf(cadr(p1)), $);
                return result;
            }
            function yfloor(p1, $) {
                return yyfloor(p1, $);
            }
            function yyfloor(p1, $) {
                if (!is_num(p1)) {
                    return items_to_cons(FLOOR, p1);
                }
                if (is_flt$1(p1)) {
                    return create_flt(Math.floor(p1.d));
                }
                if (is_rat_and_integer(p1)) {
                    return p1;
                }
                let p3 = new Rat(mdiv(p1.a, p1.b), BigIntegerExports.one);
                if (is_negative_number(p1)) {
                    p3 = $.add(p3, negOne);
                }
                return p3;
            }

            let Builder$3u = class Builder {
                create($) {
                    return new Op$2W($);
                }
            };
            let Op$2W = class Op extends FunctionVarArgs {
                constructor($) {
                    super('floor', FLOOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_floor(expr, $);
                    return [TFLAG_DIFF, retval];
                }
            };
            const floor_varargs = new Builder$3u();

            // 'for' function
            /*
            x=0
            y=2
            for(do(x=sqrt(2+x),y=2*y/x),k,1,9)
            float(y)

            X: k
            B: 1...9

            1st parameter is the body
            2nd parameter is the variable to loop with
            3rd and 4th are the limits

            */
            // define A p3
            // define B p4
            // define I p5
            // define X p6
            function Eval_for(p1, $) {
                // console.lg("Eval_for", render_as_sexpr(p1, $));
                const loopingVariable = caddr(p1);
                if (!is_sym(loopingVariable)) {
                    halt('for: 2nd arg should be the variable to loop over');
                }
                const j = evaluate_integer(cadddr(p1), $);
                if (isNaN(j)) {
                    return p1;
                }
                const k = evaluate_integer(caddddr(p1), $);
                if (isNaN(k)) {
                    return p1;
                }
                // remember contents of the index
                // variable so we can put it back after the loop
                const p4 = $.getSymbolValue(loopingVariable);
                try {
                    for (let i = j; i <= k; i++) {
                        $.setSymbolValue(loopingVariable, create_int(i));
                        $.valueOf(cadr(p1));
                    }
                }
                finally {
                    // put back the index variable to original content
                    $.setSymbolValue(loopingVariable, p4);
                }
                // return value
                return nil;
            }

            let Builder$3t = class Builder {
                create($) {
                    return new ForOperator($);
                }
            };
            class ForOperator extends FunctionVarArgs {
                constructor($) {
                    super('for', FOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    // console.lg("ForOperator.transform", render_as_infix(expr, this.$));
                    const $ = this.$;
                    const retval = Eval_for(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            }
            const for_varargs = new Builder$3t();

            function Eval_gamma(p1, $) {
                return gamma($.valueOf(cadr(p1)), $);
            }
            function gamma(p1, $) {
                return gammaf(p1, $);
            }
            function gammaf(p1, $) {
                if (is_rat$1(p1) && MEQUAL(p1.a, 1) && MEQUAL(p1.b, 2)) {
                    return $.power(DynamicConstants.Pi($), half);
                }
                if (is_rat$1(p1) && MEQUAL(p1.a, 3) && MEQUAL(p1.b, 2)) {
                    return $.multiply($.power(DynamicConstants.Pi($), half), half);
                }
                //  if (p1->k == DOUBLE) {
                //    d = exp(lgamma(p1.d))
                //    push_double(d)
                //    return
                //  }
                if (is_negative(p1)) {
                    return divide($.multiply(DynamicConstants.Pi($), negOne), $.multiply($.multiply(sin($.multiply(DynamicConstants.Pi($), p1), $), p1), gamma($.negate(p1), $)), $);
                }
                if (is_add(p1)) {
                    return gamma_of_sum(p1, $);
                }
                return items_to_cons$1(GAMMA, p1);
            }
            function gamma_of_sum(p1, $) {
                const p3 = cdr(p1);
                if (is_rat$1(car(p3)) && MEQUAL(car(p3).a, 1) && MEQUAL(car(p3).b, 1)) {
                    return $.multiply(cadr(p3), gamma(cadr(p3), $));
                }
                if (is_rat$1(car(p3)) && MEQUAL(car(p3).a, -1) && MEQUAL(car(p3).b, 1)) {
                    return divide(gamma(cadr(p3), $), $.add(cadr(p3), negOne), $);
                }
                return items_to_cons$1(GAMMA, p1);
            }

            let Builder$3s = class Builder {
                create($) {
                    return new Op$2V($);
                }
            };
            let Op$2V = class Op extends FunctionVarArgs {
                constructor($) {
                    super('gamma', GAMMA, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_gamma(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const gamma_varargs = new Builder$3s();

            let Builder$3r = class Builder {
                create($) {
                    return new Op$2U($);
                }
            };
            let Op$2U = class Op extends FunctionVarArgs {
                constructor($) {
                    super('gcd', GCD, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_gcd(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const gcd_varargs = new Builder$3r();

            let Builder$3q = class Builder {
                constructor(name, hash, sym, guardL, guardR) {
                    this.name = name;
                    this.hash = hash;
                    this.sym = sym;
                    this.guardL = guardL;
                    this.guardR = guardR;
                    // Nothing to see here.
                }
                create($) {
                    return new Op$2T(this.name, this.hash, this.sym, this.guardL, this.guardR, $);
                }
            };
            /**
             * (X * Z) * A => (X * A) * Z
             */
            let Op$2T = class Op extends Function2 {
                constructor(name, hash, sym, guardL, guardR, $) {
                    super(name, sym, and(is_cons, is_opr_2_lhs_rhs(sym, is_any, guardL)), guardR, $);
                    this.name = name;
                    this.hash = hash;
                }
                transform2(opr, lhs, rhs) {
                    const X = lhs.lhs;
                    const Z = lhs.rhs;
                    const A = rhs;
                    return [TFLAG_DIFF, items_to_cons$1(opr, items_to_cons$1(lhs.opr, X, A), Z)];
                }
            };
            /**
             * (X op R) op L => (X op L) op R
             */
            function heterogenous_canonical_order_lhs_assoc(name, hash, op, guardR, guardL) {
                return new Builder$3q(name, hash, op, guardL, guardR);
            }

            function Eval_hermite(p1, $) {
                const arg1 = $.valueOf(cadnr(p1, 1));
                const arg2 = $.valueOf(cadnr(p1, 2));
                return hermite(arg1, arg2, $);
            }

            let Builder$3p = class Builder {
                create($) {
                    return new Op$2S($);
                }
            };
            let Op$2S = class Op extends FunctionVarArgs {
                constructor($) {
                    super('hermite', HERMITE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        const retval = Eval_hermite(expr, $);
                        const changed = !retval.equals(expr);
                        return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const hermite_varargs = new Builder$3p();

            //-----------------------------------------------------------------------------
            //
            //  Create a Hilbert matrix
            //
            //  Input:    Dimension
            //
            //  Output:    Hilbert matrix
            //
            //  Example:
            //
            //  > hilbert(5)
            //  ((1,1/2,1/3,1/4),(1/2,1/3,1/4,1/5),(1/3,1/4,1/5,1/6),(1/4,1/5,1/6,1/7))
            //
            //-----------------------------------------------------------------------------
            //define AELEM(i, j) A->u.tensor->elem[i * n + j]
            function hilbert(N, $) {
                const n = nativeInt(N);
                if (n < 2) {
                    return items_to_cons$1(HILBERT, N);
                }
                const dims = [n, n];
                const elems = new Array(n * n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        elems[i * n + j] = inverse(create_int(i + j + 1), $);
                    }
                }
                return new Tensor(dims, elems);
            }

            let Builder$3o = class Builder {
                create($) {
                    return new Op$2R($);
                }
            };
            function Eval_hilbert(p1, $) {
                return hilbert($.valueOf(cadr(p1)), $);
            }
            let Op$2R = class Op extends FunctionVarArgs {
                constructor($) {
                    super('hilbert', HILBERT, $);
                    this.dependencies = [];
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_hilbert(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const hilbert_varargs = new Builder$3o();

            class HypExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    // Nothing to see here.
                }
                get key() {
                    return epsilon.name;
                }
                get hash() {
                    return HASH_HYP;
                }
                get name() {
                    return 'HypExtension';
                }
                evaluate(hyp, argList) {
                    return this.transform(cons(hyp, argList));
                }
                transform(expr) {
                    return [expr instanceof Hyp ? TFLAG_HALT : TFLAG_NONE, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(hyp, $) {
                    throw new Error("Hyp Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(hyp) {
                    return false;
                }
                isKind(arg) {
                    return arg instanceof Hyp;
                }
                isMinusOne() {
                    return false;
                }
                isOne() {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                isZero() {
                    // A hyperreal is non-zero and small than every real number.
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (this.isKind(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(hyp, $) {
                    throw new Error("HypExtension.toInfixString Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(hyp, $) {
                    throw new Error("HypExtension.toLatexString Method not implemented.");
                }
                toListString(hyp) {
                    return hyp.printname;
                }
            }
            /**
             * The hyperreal Extension.
             */
            const hyp_extension = new ExtensionOperatorBuilder(function ($) {
                return new HypExtension($);
            });

            const ADD$4 = native_sym(Native.add);
            const IMAG$e = native_sym(Native.imag);
            let Builder$3n = class Builder {
                create($) {
                    return new Op$2Q($);
                }
            };
            /**
             * imag(a + b + ...) = imag(a) + imag(b) + ...
             */
            let Op$2Q = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$e, ADD$4, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const argList = innerExpr.argList;
                    const A = argList.map(function (arg) {
                        return $.valueOf(items_to_cons$1(IMAG$e, arg));
                    });
                    return [TFLAG_NONE, $.valueOf(cons(ADD$4, A))];
                }
            };
            const imag_add = new Builder$3n();

            let Builder$3m = class Builder {
                create($) {
                    return new Op$2P($);
                }
            };
            let Op$2P = class Op extends Function1 {
                constructor($) {
                    super('imag', IMAG$h, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                    /*
                    // console.lg(this.name, this.$.toInfixString(arg));
                    const $ = this.$;
                    const retval = imag(arg, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                    */
                }
            };
            const imag_any = new Builder$3m();

            const imag$1 = native_sym(Native.imag);
            // const log = native_sym(Native.log);
            let Builder$3l = class Builder {
                create($) {
                    return new Op$2O($);
                }
            };
            let Op$2O = class Op extends CompositeOperator {
                constructor($) {
                    super(imag$1, ARCTAN, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const x = innerExpr.argList.head;
                        return is_rat$1(x);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr) {
                    return [TFLAG_DIFF, zero];
                }
            };
            const imag_arctan_rat = new Builder$3l();

            const COS$1 = native_sym(Native.cos);
            const IMAG$d = native_sym(Native.imag);
            let Builder$3k = class Builder {
                create($) {
                    return new Op$2N($);
                }
            };
            /**
             * imag(cos(z)) = 0 when z is real
             */
            let Op$2N = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$d, COS$1, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const z = innerExpr.argList.head;
                    if ($.is_real(z)) {
                        return [TFLAG_DIFF, one];
                    }
                    else {
                        return [TFLAG_NONE, outerExpr];
                    }
                }
            };
            const imag_cos = new Builder$3k();

            const EXP$2 = native_sym(Native.exp);
            const IMAG$c = native_sym(Native.imag);
            let Builder$3j = class Builder {
                create($) {
                    return new Op$2M($);
                }
            };
            /**
             * imag(exp(z)) = 0 when z is real
             */
            let Op$2M = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$c, EXP$2, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const z = innerExpr.argList.head;
                    if ($.is_real(z)) {
                        return [TFLAG_DIFF, zero];
                    }
                    else {
                        return [TFLAG_NONE, outerExpr];
                    }
                }
            };
            const imag_exp = new Builder$3j();

            const IMAG$b = native_sym(Native.imag);
            let Builder$3i = class Builder {
                create($) {
                    return new Op$2L($);
                }
            };
            let Op$2L = class Op extends Function1 {
                constructor($) {
                    super('imag_flt', IMAG$b, is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, zeroAsFlt];
                }
            };
            const imag_flt = new Builder$3i();

            const IMAG$a = native_sym(Native.imag);
            let Builder$3h = class Builder {
                create($) {
                    return new Op$2K($);
                }
            };
            let Op$2K = class Op extends Function1 {
                constructor($) {
                    super('imag_imu', IMAG$a, is_imu, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_IMU);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_DIFF, one];
                }
            };
            const imag_imu = new Builder$3h();

            const imag = native_sym(Native.imag);
            const log$2 = native_sym(Native.log);
            let Builder$3g = class Builder {
                create($) {
                    return new Op$2J($);
                }
            };
            let Op$2J = class Op extends CompositeOperator {
                constructor($) {
                    super(imag, log$2, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const x = innerExpr.argList.head;
                        return is_rat$1(x);
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, innerExpr) {
                    const $ = this.$;
                    const x = innerExpr.argList.head;
                    if (is_rat$1(x)) {
                        if (x.isZero()) {
                            // Minus infinity in the limit but undefined at zero.
                            return [TFLAG_DIFF, new Err(innerExpr)];
                        }
                        else if (x.isNegative()) {
                            // Complex
                            throw new Error($.toInfixString(x));
                        }
                        else {
                            return [TFLAG_DIFF, zero];
                        }
                    }
                    else {
                        throw new Error($.toInfixString(x));
                    }
                }
            };
            const imag_log_rat = new Builder$3g();

            const IMAG$9 = native_sym(Native.imag);
            const MUL$2 = native_sym(Native.multiply);
            let Builder$3f = class Builder {
                create($) {
                    return new Op$2I($);
                }
            };
            /**
             */
            let Op$2I = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$9, MUL$2, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    // console.lg("IMAG MUL", this.$.toInfixString(outerExpr));
                    // console.lg("Computing Re of a * expression...", $.toSExprString(expr));
                    const rs = []; // the real factors.
                    const cs = []; // the complex factors
                    [...innerExpr.argList].forEach(function (factor) {
                        // console.lg("testing the factor using is_real:", $.toInfixString(factor));
                        if ($.is_real(factor)) {
                            // console.lg("factor is real:", $.toInfixString(factor));
                            rs.push(factor);
                        }
                        else {
                            // console.lg("factor is NOT real:", $.toInfixString(factor));
                            cs.push(factor);
                        }
                    });
                    const A = multiply_factors$1(rs, $);
                    // console.lg("A", $.toInfixString(A));
                    const B = multiply_factors$1(cs, $);
                    // console.lg("B", $.toInfixString(B));
                    if (B.equals(innerExpr)) {
                        // We didn't make any progress.
                        // We must avoid infinite recursion.
                        return [TFLAG_NONE, outerExpr];
                    }
                    // console.lg("exp", $.toInfixString(expr));
                    const C = $.valueOf(items_to_cons$1(IMAG$9, B));
                    // console.lg("C", $.toSExprString(C));
                    const D = $.valueOf(items_to_cons$1(MUL$2, A, C));
                    // console.lg("D", $.toSExprString(D));
                    // console.lg("real of", $.toInfixString(expr), "is", $.toInfixString(D));
                    return [TFLAG_DIFF, D];
                }
            };
            const imag_mul = new Builder$3f();
            function multiply_factors$1(factors, $) {
                if (factors.length > 1) {
                    return $.valueOf(items_to_cons$1(MUL$2, ...factors));
                }
                else if (factors.length === 1) {
                    return $.valueOf(factors[0]);
                }
                else {
                    return one;
                }
            }

            const REAL$8 = native_sym(Native.real);
            const MUL$1 = native_sym(Native.multiply);
            const IMAG$8 = native_sym(Native.imag);
            let Builder$3e = class Builder {
                create($) {
                    return new Op$2H($);
                }
            };
            /**
             * imag(i*z) => real(z)
             */
            let Op$2H = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$8, MUL$1, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        return count_factors(innerExpr, is_imu) === 1;
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, innerExpr) {
                    const z = remove_factors(innerExpr, is_imu);
                    const re_z = this.$.valueOf(items_to_cons$1(REAL$8, z));
                    return [TFLAG_DIFF, re_z];
                }
            };
            const imag_mul_i_times_any = new Builder$3e();

            const POW$a = native_sym(Native.pow);
            const IMAG$7 = native_sym(Native.imag);
            let Builder$3d = class Builder {
                create($) {
                    return new Op$2G($);
                }
            };
            /**
             *
             */
            let Op$2G = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$7, POW$a, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const base = innerExpr.lhs;
                        const expo = innerExpr.rhs;
                        return is_base_of_natural_logarithm(base) && is_rat$1(expo);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    return [TFLAG_DIFF, zero];
                }
            };
            const imag_pow_e_rat = new Builder$3d();

            const POW$9 = native_sym(Native.pow);
            const IMAG$6 = native_sym(Native.imag);
            let Builder$3c = class Builder {
                create($) {
                    return new Op$2F($);
                }
            };
            /**
             *
             */
            let Op$2F = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$6, POW$9, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const base = innerExpr.lhs;
                        const expo = innerExpr.rhs;
                        return is_base_of_natural_logarithm(base) && is_sym(expo);
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const expo = assert_sym(innerExpr.rhs);
                    if ($.is_real(expo)) {
                        return [TFLAG_DIFF, zero];
                    }
                    else {
                        return [TFLAG_NONE, outerExpr];
                    }
                }
            };
            const imag_pow_e_sym = new Builder$3c();

            function assert_rat(expr) {
                if (is_rat$1(expr)) {
                    return expr;
                }
                else {
                    throw new SystemError(`Expecting a Rat but got expression ${expr}.`);
                }
            }

            const PI$2 = native_sym(Native.PI);
            const POW$8 = native_sym(Native.pow);
            const IMAG$5 = native_sym(Native.imag);
            let Builder$3b = class Builder {
                create($) {
                    return new Op$2E($);
                }
            };
            /**
             *
             */
            let Op$2E = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$5, POW$8, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const base = innerExpr.lhs;
                        const expo = innerExpr.rhs;
                        return is_rat$1(base) && is_rat$1(expo);
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    // TODO: What do we do about roots of unity?
                    const base = assert_rat(innerExpr.lhs);
                    // console.lg("base",$.toInfixString(base));
                    if (base.isMinusOne()) {
                        // We have a clock form z = (-1)^s.
                        // x+iy = (-1)^s
                        // log(x+iy) = s*log(-1) = s*i*pi
                        // x+iy = exp(i*s*pi) = cos(s*pi)+i*sin(s*pi) 
                        const s = assert_rat(innerExpr.rhs);
                        return [TFLAG_DIFF, $.sin($.multiply(s, PI$2))];
                    }
                    else if (base.isPositive()) {
                        return [TFLAG_DIFF, zero];
                    }
                    else {
                        // const expo = assert_rat(innerExpr.rhs);
                        return [TFLAG_DIFF, outerExpr];
                    }
                }
            };
            const imag_pow_rat_rat = new Builder$3b();

            const IMAG$4 = native_sym(Native.imag);
            let Builder$3a = class Builder {
                create($) {
                    return new Op$2D($);
                }
            };
            let Op$2D = class Op extends Function1 {
                constructor($) {
                    super('imag_rat', IMAG$4, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, zero];
                }
            };
            const imag_rat = new Builder$3a();

            const SIN = native_sym(Native.sin);
            const IMAG$3 = native_sym(Native.imag);
            let Builder$39 = class Builder {
                create($) {
                    return new Op$2C($);
                }
            };
            /**
             * imag(sin(z)) = 0 when z is real
             */
            let Op$2C = class Op extends CompositeOperator {
                constructor($) {
                    super(IMAG$3, SIN, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const z = innerExpr.argList.head;
                    if ($.is_real(z)) {
                        return [TFLAG_DIFF, zero];
                    }
                    else {
                        return [TFLAG_NONE, outerExpr];
                    }
                }
            };
            const imag_sin = new Builder$39();

            const IMAG$2 = native_sym(Native.imag);
            let Builder$38 = class Builder {
                create($) {
                    return new Op$2B($);
                }
            };
            let Op$2B = class Op extends Function1 {
                constructor($) {
                    super('imag_sym', IMAG$2, is_sym, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_SYM);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    if ($.is_real(arg)) {
                        return [TFLAG_NONE, zero];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const imag_sym = new Builder$38();

            let Builder$37 = class Builder {
                create($) {
                    return new ImuExtension($);
                }
            };
            class ImuExtension {
                constructor($) {
                    this.$ = $;
                    // Nothing to see here.
                }
                get key() {
                    return imu.name;
                }
                get hash() {
                    return HASH_IMU;
                }
                get name() {
                    return 'ImuExtension';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isKind(expr) {
                    return imu.equals(expr);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isNil(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    else {
                        return expr;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(expr) {
                    return 'i';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(expr) {
                    return '\\imath';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toListString(expr) {
                    return this.$.getSymbolPrintName(MATH_IMU$1);
                }
                evaluate(expr, argList) {
                    return [TFLAG_HALT, cons(expr, argList)];
                }
                transform(expr) {
                    return [TFLAG_HALT, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(expr) {
                    return expr;
                }
            }
            const imu_extension = new Builder$37();

            function cdnr(expr, n) {
                if (n > 0) {
                    const argList = expr.argList;
                    if (is_cons(argList)) {
                        return cdnr(argList, n - 1);
                    }
                    else {
                        return argList;
                    }
                }
                else {
                    return expr;
                }
            }

            function index_function(tensor, indices) {
                // This implementation makes it clear that we expect that the elements of the tensor are stored
                // in a "flattened" way. That is, they don't have the structure that you might expect from the
                // syntactic (nested) representation. What is surprising is that does not seem to align with the scanning
                // procedure.
                // console.lg(`index_function tensor=${tensor} indices=${indices}`);
                const ndim = tensor.ndim;
                const m = indices.length;
                if (m > ndim) {
                    throw new Error('too many indices for tensor');
                }
                let k = 0;
                for (let i = 0; i < m; i++) {
                    const idx = nativeInt(indices[i]);
                    if (idx < 1 || idx > tensor.dim(i)) {
                        throw new Error('index out of range');
                    }
                    // 
                    k = k * tensor.dim(i) + idx - 1;
                }
                // In the case where we are accessing the tensor down to the lowest level...
                if (ndim === m) {
                    return tensor.elem(k);
                }
                // When not going down to the lowest level, we have to create a tensor wrapper.
                k = tensor.sliceDimensions(m).reduce((a, b) => a * b, k);
                const nelem = tensor.sliceDimensions(m).reduce((a, b) => a * b, 1);
                const dims = tensor.sliceDimensions(m);
                const elems = new Array(nelem);
                for (let i = 0; i < nelem; i++) {
                    elems[i] = tensor.elem(k + i);
                }
                return new Tensor(dims, elems);
            }

            /**
             * Returns the component of the tensor obtained by drilling into it with the list of indices.
             * TODO: This is begging for a recursive function.
             * @param expr (component Tensot iList), where iList is not NIL.
             */
            function Eval_index(expr, $) {
                const tensor = $.valueOf(cadnr(expr, 1));
                if (is_tensor(tensor)) {
                    return get_component(tensor, cdnr(expr, 2), $);
                }
                else {
                    return expr;
                }
            }
            /**
             *
             * @param M The tensor whose components we wish to access.
             * @param indices This may be a list or it may be a value or even NIL.
             */
            function get_component(M, indices, $) {
                // console.lg(`get_component ${M} , ${indices}`);
                if (is_nil(indices)) {
                    return M;
                }
                if (is_cons(indices)) {
                    const stack = [];
                    // we examined the head of the list which was the tensor,
                    // now look into the indexes
                    let remaining = indices;
                    while (is_cons(remaining)) {
                        const expr = remaining.car;
                        const num = $.valueOf(expr);
                        stack.push(num);
                        if (!is_integer_or_integer_float(num)) {
                            // TODO: Improve the message by keeping track of where we are.
                            throw new Error(`index with something other than an integer`);
                        }
                        remaining = remaining.cdr;
                    }
                    // stack contains M at the bottom and indices above with the rightmost index at the top.
                    // This seems inconvenient. You would think that the processing would be easier if the
                    // order of indices allowed the first to be applied to be popped.
                    return index_function(M, stack);
                }
                else if (is_rat$1(indices)) {
                    return index_function(M, [indices]);
                }
                else {
                    throw new Error();
                }
            }

            let Builder$36 = class Builder {
                create($) {
                    return new Op$2A($);
                }
            };
            let Op$2A = class Op extends FunctionVarArgs {
                constructor($) {
                    super('index_varargs', SYM_MATH_COMPONENT, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_index(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const index_varargs = new Builder$36();

            let Builder$35 = class Builder {
                create($) {
                    return new Inner($);
                }
            };
            /**
             * The inner product is not associative (where you put the parens matters).
             * So it only makes sense to implement a strictly binary operator.
             */
            class Inner extends Function2 {
                constructor($) {
                    super('inner_extension', MATH_INNER, is_any, is_any, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_ANY, HASH_ANY);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    // console.lg("ENTERING", this.name, decodeMode($.getMode()), render_as_infix(expr, this.$));
                    const hook = (where, retval) => {
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_infix(orig, this.$), "=>", render_as_infix(retval, $));
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_sexpr(expr, this.$), "=>", render_as_sexpr(retval, $));
                        return retval;
                    };
                    if (contains_single_blade(lhs) && contains_single_blade(rhs)) {
                        // This will become infinite recursion if both sides are blades.
                        if (is_blade$1(lhs) && is_blade$1(rhs)) {
                            return [TFLAG_NONE, hook('A', orig)];
                        }
                        else {
                            const bladeL = extract_single_blade(lhs);
                            // console.lg("bladeL", render_as_infix(bladeL,$));
                            const residueL = remove_factors(lhs, is_blade$1);
                            // console.lg("residueL", render_as_infix(residueL,$));
                            const bladeR = extract_single_blade(rhs);
                            // console.lg("bladeR", render_as_infix(bladeR,$));
                            const residueR = remove_factors(rhs, is_blade$1);
                            // console.lg("residueR", render_as_infix(residueR,$));
                            const A = $.valueOf(items_to_cons$1(opr, residueL, residueR));
                            // console.lg("A", render_as_infix(A,$));
                            const B = $.valueOf(items_to_cons$1(opr, bladeL, bladeR));
                            const C = $.valueOf(items_to_cons$1(MATH_MUL$3, A, B));
                            return [TFLAG_DIFF, hook('B', C)];
                        }
                    }
                    else {
                        const M = $.valueOf(items_to_cons$1(MATH_MUL$3, lhs, rhs));
                        return [TFLAG_NONE, hook('C', M)];
                    }
                }
            }
            const inner_extension = new Builder$35();

            let Builder$34 = class Builder {
                create($) {
                    return new Op$2z($);
                }
            };
            /**
             * X | i => (1 | X) * i
             */
            let Op$2z = class Op extends Function2 {
                constructor($) {
                    super('inner_2_any_imu', MATH_INNER, is_any, is_imu, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_ANY, HASH_IMU);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const X = lhs;
                    const i = rhs;
                    const inrP = $.valueOf(items_to_cons$1(opr, one, X));
                    const retval = $.valueOf(items_to_cons$1(MATH_MUL$3, inrP, i));
                    return [TFLAG_DIFF, retval];
                }
            };
            const inner_2_any_imu = new Builder$34();

            let Builder$33 = class Builder {
                create($) {
                    return new Op$2y($);
                }
            };
            /**
             *
             */
            let Op$2y = class Op extends Function2 {
                constructor($) {
                    super('inner_2_any_rat', MATH_INNER, is_any, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_ANY, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    else {
                        return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), lhs, rhs)];
                    }
                }
            };
            const inner_2_any_rat = new Builder$33();

            let Builder$32 = class Builder {
                create($) {
                    return new Op$2x($);
                }
            };
            function is_real$2($) {
                return function (expr) {
                    if ($.isOne(expr)) {
                        return false;
                    }
                    const retval = $.is_real(expr);
                    return retval;
                };
            }
            /**
             * X | Y => (X|1) * Y, when Y is real.
             */
            let Op$2x = class Op extends Function2 {
                constructor($) {
                    super('inner_2_any_real', MATH_INNER, is_any, is_real$2($), $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const A = $.valueOf(items_to_cons(opr, lhs, one));
                    const B = $.valueOf(items_to_cons(MATH_MUL$3, A, rhs));
                    return [TFLAG_DIFF, B];
                }
            };
            const inner_2_any_real = new Builder$32();

            let Builder$31 = class Builder {
                create($) {
                    return new Op$2w($);
                }
            };
            /**
             * Blade1 | Blade2 => Blade1.scp(Blade2)
             */
            let Op$2w = class Op extends Function2 {
                constructor($) {
                    super('inner_2_blade_blade', MATH_INNER, is_blade$1, is_blade$1, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_BLADE, HASH_BLADE);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, this.$.valueOf(lhs.scp(rhs))];
                }
            };
            const inner_2_blade_blade = new Builder$31();

            let Builder$30 = class Builder {
                create($) {
                    return new Op$2v($);
                }
            };
            /**
             * i | X => conj(i) * (1 | X) => -i * (1|X)
             */
            let Op$2v = class Op extends Function2 {
                constructor($) {
                    super('inner_2_imu_any', MATH_INNER, is_imu, is_any, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_IMU, HASH_ANY);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const i = lhs;
                    const X = rhs;
                    const negI = $.negate(i);
                    const inrP = $.valueOf(items_to_cons$1(opr, one, X));
                    const retval = $.valueOf(items_to_cons$1(MATH_MUL$3, negI, inrP));
                    return [TFLAG_DIFF, retval];
                }
            };
            const inner_2_imu_any = new Builder$30();

            let Builder$2$ = class Builder {
                create($) {
                    return new Op$2u($);
                }
            };
            /**
             * i | i => conj(i) * i => -i * i => 1
             */
            let Op$2u = class Op extends Function2 {
                constructor($) {
                    super('inner_2_imu_imu', MATH_INNER, is_imu, is_imu, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_IMU, HASH_IMU);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, one];
                }
            };
            const inner_2_imu_imu = new Builder$2$();

            let Builder$2_ = class Builder {
                create($) {
                    return new Op$2t($);
                }
            };
            /**
             * i | Rat => conj(i) * Rat => -i * Rat
             */
            let Op$2t = class Op extends Function2 {
                constructor($) {
                    super('inner_2_imu_rat', MATH_INNER, is_imu, is_rat$1, $);
                    this.hash = hash_binop_cons_atom(MATH_INNER, MATH_POW$2, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    return [TFLAG_DIFF, $.negate(items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), lhs, rhs))];
                }
            };
            const inner_2_imu_rat = new Builder$2_();

            let Builder$2Z = class Builder {
                create($) {
                    return new Op$2s($);
                }
            };
            /**
             * Num | Num => Num * Num
             */
            let Op$2s = class Op extends Function2 {
                constructor($) {
                    super('inner_2_num_num', MATH_INNER, is_num, is_num, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_RAT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, multiply_num_num(lhs, rhs)];
                }
            };
            const inner_2_num_num = new Builder$2Z();

            let Builder$2Y = class Builder {
                create($) {
                    return new Op$2r($);
                }
            };
            /**
             *
             */
            let Op$2r = class Op extends Function2 {
                constructor($) {
                    super('inner_2_rat_any', MATH_INNER, is_rat$1, is_any, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_RAT, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    if (lhs.isOne()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    else {
                        return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), lhs, rhs)];
                    }
                }
            };
            const inner_2_rat_any = new Builder$2Y();

            let Builder$2X = class Builder {
                create($) {
                    return new Op$2q($);
                }
            };
            /**
             * Rat | i => Rat * i
             */
            let Op$2q = class Op extends Function2 {
                constructor($) {
                    super('inner_2_rat_imu', MATH_INNER, is_rat$1, is_imu, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_RAT, HASH_IMU);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), lhs, rhs)];
                }
            };
            const inner_2_rat_imu = new Builder$2X();

            let Builder$2W = class Builder {
                create($) {
                    return new Op$2p($);
                }
            };
            /**
             * Rat | x => Rat * x
             */
            let Op$2p = class Op extends Function2 {
                constructor($) {
                    super('inner_2_rat_sym', MATH_INNER, is_rat$1, is_sym, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_RAT, HASH_SYM);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), lhs, rhs)];
                }
            };
            const inner_2_rat_sym = new Builder$2W();

            let Builder$2V = class Builder {
                create($) {
                    return new Op$2o($);
                }
            };
            function is_real$1($) {
                return function (expr) {
                    if ($.isOne(expr)) {
                        return false;
                    }
                    const retval = $.is_real(expr);
                    return retval;
                };
            }
            /**
             * X | Y => X * (1 | Y), when X is real.
             */
            let Op$2o = class Op extends Function2 {
                constructor($) {
                    super('inner_2_real_any', MATH_INNER, is_real$1($), is_any, $);
                    this.phases = MODE_EXPANDING;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const A = $.valueOf(items_to_cons$1(opr, one, rhs));
                    const B = $.valueOf(items_to_cons$1(MATH_MUL$3, lhs, A));
                    return [TFLAG_DIFF, B];
                }
            };
            const inner_2_real_any = new Builder$2V();

            let Builder$2U = class Builder {
                create($) {
                    return new Op$2n($);
                }
            };
            /**
             * Sym | Sym
             */
            let Op$2n = class Op extends Function2 {
                constructor($) {
                    super('inner_2_sym_sym', MATH_INNER, is_sym, is_sym, $);
                    this.hash = hash_binop_atom_atom(MATH_INNER, HASH_SYM, HASH_SYM);
                }
                isScalar() {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    // It actually could be zero.
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_MUL$3.clone(opr.pos, opr.end), lhs, rhs))];
                }
            };
            const inner_2_sym_sym = new Builder$2U();

            function is_scalar($) {
                return function (expr) {
                    // console.lg("is_scalar", $.toSExprString(expr));
                    return $.isScalar(expr);
                };
            }

            let Builder$2T = class Builder {
                create($) {
                    return new Op$2m($);
                }
            };
            /**
             * Blade | Scalar => Blade.scp(Scalar) => 0, because of the different grades.
             */
            let Op$2m = class Op extends Function2 {
                constructor($) {
                    super('inner_2_vec_scalar', MATH_INNER, is_blade$1, is_scalar($), $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    return [TFLAG_DIFF, zero];
                }
            };
            const inner_2_vec_scalar = new Builder$2T();

            let Builder$2S = class Builder {
                create($) {
                    return new Op$2l($);
                }
            };
            let Op$2l = class Op extends FunctionVarArgs {
                constructor($) {
                    super('integral_varargs', INTEGRAL, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_integral(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const integral_varargs = new Builder$2S();

            let Builder$2R = class Builder {
                create($) {
                    return new Op$2k($);
                }
            };
            let Op$2k = class Op extends Function1 {
                constructor($) {
                    super('inv_any', MATH_INV, is_any, $);
                    this.hash = hash_unaop_atom(MATH_INV, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const retval = inv(arg, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                }
            };
            const inv_any = new Builder$2R();

            const INV = native_sym(Native.inverse);
            let Builder$2Q = class Builder {
                create($) {
                    return new Op$2j($);
                }
            };
            /**
             * inv(inv(x)) = x
             */
            let Op$2j = class Op extends CompositeOperator {
                constructor($) {
                    super(INV, INV, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const x = innerExpr.argList.head;
                    return [TFLAG_DIFF, x];
                }
            };
            const inv_inv = new Builder$2Q();

            const IS_COMPLEX$1 = native_sym(Native.is_complex);
            let Builder$2P = class Builder {
                create($) {
                    return new Op$2i($);
                }
            };
            let Op$2i = class Op extends Function1 {
                constructor($) {
                    super('is_complex_any', IS_COMPLEX$1, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                }
            };
            const is_complex_any = new Builder$2P();

            const IS_COMPLEX = native_sym(Native.is_complex);
            let Builder$2O = class Builder {
                create($) {
                    return new Op$2h($);
                }
            };
            let Op$2h = class Op extends Function1 {
                constructor($) {
                    super('is_complex_sym', IS_COMPLEX, is_sym, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_SYM);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg) {
                    const $ = this.$;
                    const props = $.getSymbolProps(arg);
                    return [TFLAG_DIFF, create_boo(props.complex)];
                }
            };
            const is_complex_sym = new Builder$2O();

            function Eval_isprime(p1, $) {
                return isprime($.valueOf(cadr(p1)));
            }
            function isprime(p1) {
                if (isnonnegativeinteger(p1) && mprime(p1.a)) {
                    return one;
                }
                return zero;
            }

            let Builder$2N = class Builder {
                create($) {
                    return new Op$2g($);
                }
            };
            let Op$2g = class Op extends FunctionVarArgs {
                constructor($) {
                    super('isprime', ISPRIME, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_isprime(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const isprime_varargs = new Builder$2N();

            const POW$7 = native_sym(Native.pow);
            const IS_REAL$6 = native_sym(Native.is_real);
            let Builder$2M = class Builder {
                create($) {
                    return new Op$2f($);
                }
            };
            /**
             * isreal(1/z) <=> isreal(z)
             */
            let Op$2f = class Op extends CompositeOperator {
                constructor($) {
                    super(IS_REAL$6, POW$7, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const pow = expr.argList.head;
                        const expo = pow.rhs;
                        return is_rat$1(expo) && expo.isMinusOne();
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, pow, expr) {
                    const $ = this.$;
                    const z = pow.lhs;
                    return [TFLAG_DIFF, create_boo($.is_real(z))];
                }
            };
            const is_real_pow_any_negone = new Builder$2M();

            const ABS = native_sym(Native.abs);
            const IS_REAL$5 = native_sym(Native.is_real);
            let Builder$2L = class Builder {
                create($) {
                    return new IsRealAdd$1($);
                }
            };
            let IsRealAdd$1 = class IsRealAdd extends CompositeOperator {
                constructor($) {
                    super(IS_REAL$5, ABS, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    return [TFLAG_DIFF, booT];
                }
            };
            const is_real_abs = new Builder$2L();

            const ADD$3 = native_sym(Native.add);
            const IS_REAL$4 = native_sym(Native.is_real);
            let Builder$2K = class Builder {
                create($) {
                    return new IsRealAdd($);
                }
            };
            class IsRealAdd extends CompositeOperator {
                constructor($) {
                    super(IS_REAL$4, ADD$3, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, add) {
                    const $ = this.$;
                    if ([...add.argList].every(function (arg) {
                        return $.is_real(arg);
                    })) {
                        return [TFLAG_DIFF, booT];
                    }
                    else {
                        return [TFLAG_DIFF, booF];
                    }
                }
            }
            const is_real_add = new Builder$2K();

            let Builder$2J = class Builder {
                create($) {
                    return new IsRealAny($);
                }
            };
            class IsRealAny extends Function1 {
                constructor($) {
                    super('is_real_any', PREDICATE_IS_REAL, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    // We could use fuzzy logic here...
                    return [TFLAG_DIFF, booF];
                }
            }
            const is_real_any = new Builder$2J();

            const is_real = native_sym(Native.is_real);
            const cosine = native_sym(Native.cos);
            let Builder$2I = class Builder {
                create($) {
                    return new IsRealCos($);
                }
            };
            class IsRealCos extends CompositeOperator {
                constructor($) {
                    super(is_real, cosine, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, cosExpr) {
                    const $ = this.$;
                    const x = cosExpr.argList.head;
                    return [TFLAG_DIFF, create_boo($.is_real(x))];
                }
            }
            const is_real_cos = new Builder$2I();

            let Builder$2H = class Builder {
                create($) {
                    return new IsRealFlt($);
                }
            };
            class IsRealFlt extends Function1 {
                constructor($) {
                    super(`${PREDICATE_IS_REAL.text}(expr: ${HASH_FLT}) => ${HASH_BOO}`, PREDICATE_IS_REAL, is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg) {
                    return [TFLAG_DIFF, booT];
                }
            }
            const is_real_flt = new Builder$2H();

            let Builder$2G = class Builder {
                create($) {
                    return new IsRealImag($);
                }
            };
            /**
             * isreal(imag(z)) is always true because imag(z) always return a real number.
             */
            class IsRealImag extends CompositeOperator {
                constructor($) {
                    super(PREDICATE_IS_REAL, IMAG$h, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, add) {
                    return [TFLAG_DIFF, booT];
                }
            }
            const is_real_imag = new Builder$2G();

            let Builder$2F = class Builder {
                create($) {
                    return new IsRealImu($);
                }
            };
            class IsRealImu extends Function1 {
                constructor($) {
                    super(`${PREDICATE_IS_REAL.text}(expr: ${HASH_IMU}) => ${HASH_BOO}`, PREDICATE_IS_REAL, is_imu, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_IMU);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg) {
                    return [TFLAG_DIFF, booF];
                }
            }
            const is_real_imu = new Builder$2F();

            let Builder$2E = class Builder {
                create($) {
                    return new IsRealMul(MATH_MUL$3, $);
                }
            };
            class IsRealMul extends CompositeOperator {
                constructor(innerOpr, $) {
                    super(PREDICATE_IS_REAL, innerOpr, $);
                }
                transform1(opr, add) {
                    const $ = this.$;
                    if ([...add.argList].every(function (arg) {
                        return $.is_real(arg);
                    })) {
                        return [TFLAG_DIFF, booT];
                    }
                    else {
                        return [TFLAG_DIFF, booF];
                    }
                }
            }
            const is_real_mul = new Builder$2E();

            const POW$6 = native_sym(Native.pow);
            const IS_REAL$3 = native_sym(Native.is_real);
            let Builder$2D = class Builder {
                create($) {
                    return new Op$2e($);
                }
            };
            /**
             *
             */
            let Op$2e = class Op extends CompositeOperator {
                constructor($) {
                    super(IS_REAL$3, POW$6, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const base = innerExpr.lhs;
                        const expo = innerExpr.rhs;
                        return is_base_of_natural_logarithm(base) && is_sym(expo);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const expo = assert_sym(innerExpr.rhs);
                    if ($.is_real(expo)) {
                        return [TFLAG_DIFF, booT];
                    }
                    else {
                        return [TFLAG_DIFF, booF];
                    }
                }
            };
            const is_real_pow_e_sym = new Builder$2D();

            const POW$5 = native_sym(Native.pow);
            const IS_REAL$2 = native_sym(Native.is_real);
            let Builder$2C = class Builder {
                create($) {
                    return new IsRealPow($);
                }
            };
            /**
             * isreal(z) <=> iszero(imag(z))
             */
            class IsRealPow extends CompositeOperator {
                constructor($) {
                    super(IS_REAL$2, POW$5, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        // console.lg("expr", expr.toString());
                        const pow = expr.argList.head;
                        // console.lg("pow", pow.toString());
                        const base = pow.lhs;
                        const expo = pow.rhs;
                        return is_imu(base) && is_rat$1(expo);
                        // return true;
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, pow, expr) {
                    const expo = assert_rat(pow.rhs);
                    const numer = expo.numer();
                    const denom = expo.denom();
                    // If the denominator is 1 then we avoid the issues of roots of unity.
                    if (denom.isOne()) {
                        // If the numerator is divisible by 4 then the argument evaluates to 1.
                        // In that case, the imaginary part will be zero.
                        if (numer.div(four).isInteger()) {
                            return [TFLAG_DIFF, booT];
                        }
                        else {
                            return [TFLAG_DIFF, booF];
                        }
                    }
                    else {
                        return [TFLAG_DIFF, booF];
                    }
                }
            }
            const is_real_pow_imu_rat = new Builder$2C();

            const PI$1 = native_sym(Native.PI);
            const POW$4 = native_sym(Native.pow);
            const IS_REAL$1 = native_sym(Native.is_real);
            let Builder$2B = class Builder {
                create($) {
                    return new Op$2d($);
                }
            };
            /**
             *
             */
            let Op$2d = class Op extends CompositeOperator {
                constructor($) {
                    super(IS_REAL$1, POW$4, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const pow = expr.argList.head;
                        const base = pow.lhs;
                        const expo = pow.rhs;
                        return is_rat$1(base) && is_rat$1(expo);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const base = assert_rat(innerExpr.lhs);
                    // console.lg("base",$.toInfixString(base));
                    if (base.isMinusOne()) {
                        // We have a clock form z = (-1)^expo.
                        // x+iy = (-1)^expo
                        // log(x+iy) = expo*log(-1) = expo*i*pi
                        // x+iy = exp(i*expo*pi) = cos(expo*pi)+i*sin(expo*pi) 
                        const expo = assert_rat(innerExpr.rhs);
                        const imag = $.sin($.multiply(expo, PI$1));
                        if ($.is_zero(imag)) {
                            return [TFLAG_DIFF, booT];
                        }
                        else {
                            return [TFLAG_DIFF, booF];
                        }
                    }
                    else if (base.isPositive()) {
                        return [TFLAG_DIFF, booT];
                    }
                    else {
                        return [TFLAG_DIFF, booF];
                    }
                }
            };
            const is_real_pow_rat_rat = new Builder$2B();

            const POW$3 = native_sym(Native.pow);
            const IS_REAL = native_sym(Native.is_real);
            let Builder$2A = class Builder {
                create($) {
                    return new Op$2c($);
                }
            };
            /**
             * isreal(z) <=> iszero(imag(z))
             */
            let Op$2c = class Op extends CompositeOperator {
                constructor($) {
                    super(IS_REAL, POW$3, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        // console.lg("expr", expr.toString());
                        const pow = expr.argList.head;
                        // console.lg("pow", pow.toString());
                        const base = pow.lhs;
                        const expo = pow.rhs;
                        return is_sym(base) && is_rat$1(expo);
                        // return true;
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, pow, expr) {
                    const $ = this.$;
                    const base = assert_sym(pow.lhs);
                    const expo = assert_rat(pow.rhs);
                    const numer = expo.numer();
                    const denom = expo.denom();
                    if ($.is_real(base)) {
                        if (numer.div(two).isInteger()) {
                            if (denom.isOne()) {
                                return [TFLAG_DIFF, booT];
                            }
                            else {
                                return [TFLAG_DIFF, booF];
                            }
                        }
                        else if (numer.isMinusOne()) {
                            if (denom.isOne()) {
                                // Duplicates rule in is_real_pow_ant_negone.
                                return [TFLAG_DIFF, create_boo($.is_real(base))];
                            }
                            else {
                                return [TFLAG_DIFF, booF];
                            }
                        }
                        else {
                            return [TFLAG_DIFF, booF];
                        }
                    }
                    else {
                        return [TFLAG_DIFF, booF];
                    }
                    // const denom = expo.denom();
                    // We can improve on this...
                }
            };
            const is_real_pow_sym_rat = new Builder$2A();

            let Builder$2z = class Builder {
                create($) {
                    return new IsRealRat($);
                }
            };
            class IsRealRat extends Function1 {
                constructor($) {
                    super('is_real_rat', PREDICATE_IS_REAL, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg) {
                    return [TFLAG_DIFF, booT];
                }
            }
            const is_real_rat = new Builder$2z();

            let Builder$2y = class Builder {
                create($) {
                    return new Op$2b($);
                }
            };
            /**
             * isreal(real(z)) is always true because real(z) always return a real number.
             */
            let Op$2b = class Op extends CompositeOperator {
                constructor($) {
                    super(PREDICATE_IS_REAL, REAL$b, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, add) {
                    return [TFLAG_DIFF, booT];
                }
            };
            const is_real_real = new Builder$2y();

            let Builder$2x = class Builder {
                create($) {
                    return new IsRealSin($);
                }
            };
            /**
             * isreal(sin(z)) => isreal(z)
             */
            class IsRealSin extends CompositeOperator {
                constructor($) {
                    super(PREDICATE_IS_REAL, MATH_SIN, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, sinExpr) {
                    const $ = this.$;
                    const x = sinExpr.argList.head;
                    return [TFLAG_DIFF, create_boo($.is_real(x))];
                }
            }
            const is_real_sin = new Builder$2x();

            let Builder$2w = class Builder {
                constructor(predicate) {
                    this.predicate = predicate;
                }
                create($) {
                    return new PredicateSym(this.predicate, $);
                }
            };
            class PredicateSym extends Function1 {
                constructor(predicate, $) {
                    super(`${predicate.text}(sym: ${HASH_SYM}) => ${HASH_BOO}`, predicate, is_sym, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_SYM);
                }
                transform1(opr, arg) {
                    const $ = this.$;
                    const props = $.getSymbolProps(arg);
                    return [TFLAG_DIFF, create_boo(props.real)];
                }
            }
            /**
             * Constructs an operator for predicate(arg: Sym).
             */
            function make_predicate_sym_operator(predicate) {
                return new Builder$2w(predicate);
            }

            let Builder$2v = class Builder {
                create($) {
                    return new IsZero($);
                }
            };
            const ISZERO$1 = native_sym(Native.is_zero);
            class IsZero extends Function1 {
                constructor($) {
                    super('iszero_any', ISZERO$1, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                }
            }
            const iszero_any = new Builder$2v();

            class ExpRatBuilder {
                create($) {
                    return new IsZeroRat($);
                }
            }
            const ISZERO = native_sym(Native.is_zero);
            class IsZeroRat extends Function1 {
                constructor($) {
                    super('iszero_rat', ISZERO, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg.isZero() ? booT : booF];
                }
            }
            const iszero_rat = new ExpRatBuilder();

            /*
             Laguerre function

            Example

              laguerre(x,3)

            Result

                 1   3    3   2
              - --- x  + --- x  - 3 x + 1
                 6        2

            The computation uses the following recurrence relation.

              L(x,0,k) = 1

              L(x,1,k) = -x + k + 1

              n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)

            In the "for" loop i = n-1 so the recurrence relation becomes

              (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)
            */
            function Eval_laguerre(p1, $) {
                const X = $.valueOf(cadr(p1));
                const N = $.valueOf(caddr(p1));
                const p2 = $.valueOf(cadddr(p1));
                const K = nil === p2 ? zero : p2;
                return laguerre(X, N, K, $);
            }
            function laguerre(X, N, K, $) {
                const n = nativeInt(N);
                if (n < 0 || isNaN(n)) {
                    return items_to_cons(LAGUERRE, X, N, K);
                }
                if (is_sym(X)) {
                    return laguerre2(n, X, K, $);
                }
                return $.valueOf(subst(laguerre2(n, SECRETX, K, $), SECRETX, X, $));
            }
            function laguerre2(n, p1, p3, $) {
                let Y0 = zero;
                let Y1 = one;
                for (let i = 0; i < n; i++) {
                    const result = divide($.subtract($.multiply($.add($.subtract(create_int(2 * i + 1), p1), p3), Y1), $.multiply($.add(create_int(i), p3), Y0)), create_int(i + 1), $);
                    Y0 = Y1;
                    Y1 = result;
                }
                return Y1;
            }

            let Builder$2u = class Builder {
                create($) {
                    return new Op$2a($);
                }
            };
            let Op$2a = class Op extends FunctionVarArgs {
                constructor($) {
                    super('laguerre', LAGUERRE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_laguerre(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const laguerre_varargs = new Builder$2u();

            // Find the least common multiple of two expressions.
            function Eval_lcm(p1, $) {
                p1 = cdr(p1);
                let result = $.valueOf(car(p1));
                if (is_cons(p1)) {
                    result = p1.tail().reduce((a, b) => lcm(a, $.valueOf(b), $), result);
                }
                return result;
            }
            function lcm(p1, p2, $) {
                return doexpand_binary(yylcm, p1, p2, $);
            }
            function yylcm(p1, p2, $) {
                const A = gcd(p1, p2, $);
                const B = divide(A, p1, $);
                const C = divide(B, p2, $);
                return inverse(C, $);
            }

            let Builder$2t = class Builder {
                create($) {
                    return new Op$29($);
                }
            };
            let Op$29 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('lcm', LCM, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_lcm(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const lcm_varargs = new Builder$2t();

            let Builder$2s = class Builder {
                create($) {
                    return new Op$28($);
                }
            };
            let Op$28 = class Op extends Function2 {
                constructor($) {
                    super('lco_2_any_any', MATH_LCO, is_any, is_any, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const lhs = expr.lhs;
                        const rhs = expr.rhs;
                        if (is_blade$1(lhs) && is_blade$1(rhs)) {
                            // Avoid ambiguity because we know that (<< Blade Blade) exists 
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    if (is_multiply(lhs)) {
                        if (contains_single_blade(lhs)) {
                            const bladeL = extract_single_blade(lhs);
                            const residueL = remove_factors(lhs, is_blade$1);
                            const A = $.valueOf(items_to_cons$1(MATH_LCO, bladeL, rhs));
                            // Making an assumption here that the residue is a scalar.
                            const B = $.valueOf(items_to_cons$1(MATH_MUL$3, residueL, A));
                            return [TFLAG_DIFF, B];
                        }
                    }
                    if (is_multiply(rhs)) {
                        if (contains_single_blade(rhs)) {
                            const bladeR = extract_single_blade(rhs);
                            const residue = remove_factors(rhs, is_blade$1);
                            const A = $.valueOf(items_to_cons$1(MATH_LCO, lhs, bladeR));
                            // Making an assumption here that the residue is a scalar.
                            const B = $.valueOf(items_to_cons$1(MATH_MUL$3, residue, A));
                            return [TFLAG_DIFF, B];
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            };
            const lco_2_any_any = new Builder$2s();

            let Builder$2r = class Builder {
                create($) {
                    return new Op$27($);
                }
            };
            /**
             * Blade << Blade
             */
            let Op$27 = class Op extends Function2 {
                constructor($) {
                    super('lco_2_blade_blade', MATH_LCO, is_blade$1, is_blade$1, $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_BLADE, HASH_BLADE);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, this.$.valueOf(lhs.__lshift__(rhs))];
                }
            };
            const lco_2_blade_blade = new Builder$2r();

            function square(p1, $) {
                return $.power(p1, two);
            }

            /*
             Legendre function

            Example

              legendre(x,3,0)

            Result

               5   3    3
              --- x  - --- x
               2        2

            The computation uses the following recurrence relation.

              P(x,0) = 1

              P(x,1) = x

              n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)

            In the "for" loop we have i = n-1 so the recurrence relation becomes

              (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)

            For m > 0

              P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)
            */
            function Eval_legendre(p1, $) {
                const X = $.valueOf(cadr(p1));
                const N = $.valueOf(caddr(p1));
                const p2 = $.valueOf(cadddr(p1));
                const M = nil === p2 ? zero : p2;
                return legendre(X, N, M, $);
            }
            function legendre(X, N, M, $) {
                return __legendre(X, N, M, $);
            }
            function __legendre(X, N, M, $) {
                const n = nativeInt(N);
                const m = nativeInt(M);
                if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {
                    return items_to_cons(LEGENDRE, X, N, M);
                }
                let result;
                if (is_sym(X)) {
                    result = __legendre2(n, m, X, $);
                }
                else {
                    const expr = __legendre2(n, m, SECRETX, $);
                    result = $.valueOf(subst(expr, SECRETX, X, $));
                }
                result = __legendre3(result, m, X, $) || result;
                return result;
            }
            function __legendre2(n, m, X, $) {
                let Y0 = zero;
                let Y1 = one;
                //  i=1  Y0 = 0
                //    Y1 = 1
                //    ((2*i+1)*x*Y1 - i*Y0) / i = x
                //
                //  i=2  Y0 = 1
                //    Y1 = x
                //    ((2*i+1)*x*Y1 - i*Y0) / i = -1/2 + 3/2*x^2
                //
                //  i=3  Y0 = x
                //    Y1 = -1/2 + 3/2*x^2
                //    ((2*i+1)*x*Y1 - i*Y0) / i = -3/2*x + 5/2*x^3
                for (let i = 0; i < n; i++) {
                    const divided = divide($.subtract($.multiply($.multiply(create_int(2 * i + 1), X), Y1), $.multiply(create_int(i), Y0)), create_int(i + 1), $);
                    Y0 = Y1;
                    Y1 = divided;
                }
                for (let i = 0; i < m; i++) {
                    Y1 = derivative(Y1, X, $);
                }
                return Y1;
            }
            // moveTos tos * (-1)^m * (1-x^2)^(m/2)
            function __legendre3(p1, m, X, $) {
                if (m === 0) {
                    return;
                }
                let base = $.subtract(one, square(X, $));
                if (car(X).equals(COS$3)) {
                    base = square(sin(cadr(X), $), $);
                }
                else if (car(X).equals(SIN$1)) {
                    base = square(cos(cadr(X), $), $);
                }
                let result = $.multiply(p1, $.power(base, $.multiply(create_int(m), half)));
                if (m % 2) {
                    result = $.negate(result);
                }
                return result;
            }

            let Builder$2q = class Builder {
                create($) {
                    return new Op$26($);
                }
            };
            let Op$26 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('legendre', LEGENDRE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_legendre(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const legendre_varargs = new Builder$2q();

            let Builder$2p = class Builder {
                create($) {
                    return new Op$25($);
                }
            };
            let Op$25 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('log', LOG$1, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_log(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const log_varargs = new Builder$2p();

            const MOD$1 = native_sym(Native.mod);
            function Eval_mod(p1, $) {
                const arg2 = $.valueOf(caddr(p1));
                const arg1 = $.valueOf(cadr(p1));
                return mod(arg1, arg2, $);
            }
            function mod(a, b, $) {
                if ($.is_zero(b)) {
                    halt('mod function: divide by zero');
                }
                if (!is_num(a) || !is_num(b)) {
                    return items_to_cons$1(MOD$1, a, b);
                }
                if (is_flt$1(a)) {
                    const n = nativeInt(a);
                    if (isNaN(n)) {
                        halt('mod function: cannot convert float value to integer');
                    }
                    a = create_int(n);
                }
                if (is_flt$1(b)) {
                    const n = nativeInt(b);
                    if (isNaN(n)) {
                        halt('mod function: cannot convert float value to integer');
                    }
                    b = create_int(n);
                }
                if (!is_rat_and_integer(a) || !is_rat_and_integer(b)) {
                    halt('mod function: integer arguments expected');
                }
                // return a.mod(b)
                return new Rat(mmod(a.a, b.a), BigIntegerExports.one);
            }

            const MOD = native_sym(Native.mod);
            let Builder$2o = class Builder {
                create($) {
                    return new Op$24($);
                }
            };
            let Op$24 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('mod', MOD, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_mod(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const mod_varargs = new Builder$2o();

            let Builder$2n = class Builder {
                constructor(opr) {
                    this.opr = opr;
                }
                create($) {
                    return new Op$23($, this.opr);
                }
            };
            let Op$23 = class Op extends Function2 {
                constructor($, opr) {
                    super('mul_2_any_flt', opr, is_any, is_flt$1, $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(opr, HASH_ANY, HASH_FLT);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const rhs = expr.rhs;
                        return rhs.isZero();
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs) {
                    // console.lg(this.name, render_as_infix(lhs, this.$), render_as_infix(rhs, this.$), render_as_infix(orig, this.$));
                    if (rhs.isZero()) {
                        // TODO: We could be wrong here. e.g. if the lhs is a Tensor, we lose the structure.
                        return [TFLAG_DIFF, rhs];
                    }
                    else {
                        throw new Error();
                    }
                }
            };
            const mul_2_any_flt = new Builder$2n(MATH_MUL$3);

            let Builder$2m = class Builder {
                constructor(opr) {
                    this.opr = opr;
                }
                create($) {
                    return new Op$22($, this.opr);
                }
            };
            let Op$22 = class Op extends Function2 {
                constructor($, opr) {
                    super('mul_2_any_rat', opr, is_any, is_rat$1, $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(opr, HASH_ANY, HASH_RAT);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const rhs = expr.rhs;
                        return rhs.isZero() || rhs.isOne();
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs, orig) {
                    // console.lg(this.name, render_as_infix(lhs, this.$), render_as_infix(rhs, this.$), render_as_infix(orig, this.$));
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    else if (rhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    else {
                        return [TFLAG_NONE, orig];
                    }
                }
            };
            const mul_2_any_rat = new Builder$2m(MATH_MUL$3);

            let Builder$2l = class Builder {
                create($) {
                    return new Op$21($);
                }
            };
            /**
             * Blade * Blade
             */
            let Op$21 = class Op extends Function2 {
                constructor($) {
                    super('mul_2_blade_blade', MATH_MUL$3, is_blade$1, is_blade$1, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_BLADE, HASH_BLADE);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    // The result of multiplication may produce a factor of -1 or zero, so we require further evaluation.
                    return [TFLAG_DIFF, $.valueOf(lhs.mul(rhs))];
                }
            };
            const mul_2_blade_blade = new Builder$2l();

            let Builder$2k = class Builder {
                create($) {
                    return new Op$20($);
                }
            };
            /**
             * Blade * Rat => Rat * Blade
             */
            let Op$20 = class Op extends Function2 {
                constructor($) {
                    super('mul_2_blade_rat', MATH_MUL$3, is_blade$1, is_rat$1, $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_BLADE, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    return [TFLAG_DIFF, $.valueOf(items_to_cons(opr, rhs, lhs))];
                }
            };
            const mul_2_blade_rat = new Builder$2k();

            let Builder$2j = class Builder {
                constructor(opr) {
                    this.opr = opr;
                }
                create($) {
                    return new Op$1$($, this.opr);
                }
            };
            let Op$1$ = class Op extends Function2 {
                constructor($, opr) {
                    super('mul_2_flt_any', opr, is_flt$1, is_any, $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(opr, HASH_FLT, HASH_ANY);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const lhs = expr.lhs;
                        return lhs.isZero();
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs, orig) {
                    // console.lg(this.name, render_as_infix(lhs, this.$), render_as_infix(rhs, this.$), render_as_infix(orig, this.$));
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    else {
                        return [TFLAG_NONE, orig];
                    }
                }
            };
            const mul_2_flt_any = new Builder$2j(MATH_MUL$3);

            let Builder$2i = class Builder {
                create($) {
                    return new Op$1_($);
                }
            };
            const mul_2_flt_flt = new Builder$2i();
            let Op$1_ = class Op extends Function2 {
                constructor($) {
                    super('mul_2_flt_flt', MATH_MUL$3, is_flt$1, is_flt$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_FLT, HASH_FLT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.mul(rhs)];
                }
            };

            let Builder$2h = class Builder {
                create($) {
                    return new Op$1Z($);
                }
            };
            /**
             * Flt * Imu
             */
            let Op$1Z = class Op extends Function2 {
                constructor($) {
                    super('mul_2_flt_imu', MATH_MUL$3, is_flt, is_imu, $);
                    this.dependencies = ['Flt', 'Imu'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_FLT, HASH_IMU);
                }
                // TODO
                transform2(opr, lhs, rhs, expr) {
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    if (lhs.isOne()) {
                        // Even though one is the identity element for multiplication, we have to keep
                        // the factor of 1.0 to know that we are using floats.
                        return [TFLAG_NONE, expr];
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const mul_2_flt_imu = new Builder$2h();

            function is_mul_2_flt_any(expr) {
                return is_mul_2_any_any(expr) && is_flt$1(expr.lhs);
            }

            let Builder$2g = class Builder {
                create($) {
                    return new Op$1Y($);
                }
            };
            /**
             * Flt1 * (Flt2 * X) => (Flt1 * Flt2) * X
             */
            let Op$1Y = class Op extends Function2 {
                constructor($) {
                    super('mul_2_flt_mul_2_flt_any', MATH_MUL$3, is_flt, and(is_cons, is_mul_2_flt_any), $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_cons(MATH_MUL$3, HASH_FLT, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const num1 = lhs;
                    const num2 = rhs.lhs;
                    const r1r2 = num1.mul(num2);
                    const X = rhs.rhs;
                    const S = $.valueOf(items_to_cons(MATH_MUL$3, r1r2, X));
                    return [TFLAG_DIFF, S];
                }
            };
            const mul_2_flt_mul_2_flt_any = new Builder$2g();

            let Builder$2f = class Builder {
                create($) {
                    return new Op$1X($);
                }
            };
            let Op$1X = class Op extends Function2 {
                constructor($) {
                    super('mul_2_flt_rat', MATH_MUL$3, is_flt$1, is_rat$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_FLT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, create_flt(lhs.toNumber() * rhs.toNumber())];
                }
            };
            const mul_2_flt_rat = new Builder$2f();

            let Builder$2e = class Builder {
                create($) {
                    return new Op$1W($);
                }
            };
            /**
             * Flt * Uom
             */
            let Op$1W = class Op extends Function2 {
                constructor($) {
                    super('mul_2_flt_uom', MATH_MUL$3, is_flt, is_uom, $);
                    this.dependencies = ['Flt', 'Uom'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_FLT, HASH_UOM);
                }
                transform2(opr, lhs, rhs, expr) {
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    if (lhs.isOne()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const mul_2_flt_uom = new Builder$2e();

            let Builder$2d = class Builder {
                create($) {
                    return new Op$1V($);
                }
            };
            /**
             * (* Hyp Rat) => (* Rat Hyp)
             *             => 0 if Rat is zero
             *             => Sym if Rat is one
             */
            let Op$1V = class Op extends Function2 {
                constructor($) {
                    super('mul_2_hyp_rat', MATH_MUL$3, is_hyp, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_HYP, HASH_RAT);
                }
                isScalar(expr) {
                    return this.$.isScalar(expr.lhs);
                }
                transform2(opr, lhs, rhs) {
                    // If the base class binds the symbol to something else then none of this code below will be called.
                    // Therefore, you can consider that this code only applies to unbound symbols. 
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    return [TFLAG_DIFF, items_to_cons(opr, rhs, lhs)];
                }
            };
            const mul_2_hyp_rat = new Builder$2d();

            let Builder$2c = class Builder {
                create($) {
                    return new Op$1U($);
                }
            };
            /**
             * Hyp * Sym => Sym * Hyp
             */
            let Op$1U = class Op extends Function2 {
                constructor($) {
                    super('mul_2_hyp_sym', MATH_MUL$3, is_hyp, is_sym, $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_HYP, HASH_SYM);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    return [TFLAG_DIFF, $.valueOf(items_to_cons(opr, rhs, lhs))];
                }
            };
            const mul_2_hyp_sym = new Builder$2c();

            let Builder$2b = class Builder {
                create($) {
                    return new Op$1T($);
                }
            };
            /**
             * Imu * Flt
             */
            let Op$1T = class Op extends Function2 {
                constructor($) {
                    super('mul_2_imu_flt', MATH_MUL$3, is_imu, is_flt, $);
                    this.dependencies = ['Flt', 'Imu'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_IMU, HASH_FLT);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const rhs = expr.rhs;
                        if (rhs.isZero()) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, rhs];
                }
            };
            const mul_2_imu_flt = new Builder$2b();

            let Builder$2a = class Builder {
                create($) {
                    return new Op$1S($);
                }
            };
            /**
             * i * i => -1
             */
            let Op$1S = class Op extends Function2 {
                constructor($) {
                    super('mul_2_imu_imu', MATH_MUL$3, is_imu, is_imu, $);
                    this.dependencies = ['Imu'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_IMU, HASH_IMU);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, negOne];
                }
            };
            const mul_2_imu_imu = new Builder$2a();

            function is_mul_2_any_cons(expr) {
                return is_mul_2_any_any(expr) && is_cons(expr.rhs);
            }

            let Builder$29 = class Builder {
                create($) {
                    return new Op$1R($);
                }
            };
            function crossGuard($) {
                return function (lhs, rhs) {
                    // console.lg(`lhs: ${render_as_infix(lhs, $)}, rhs=${render_as_infix(rhs, $)}`);
                    // console.lg(`lhs.RHS: ${render_as_infix(lhs.rhs, $)}, rhs=${render_as_infix(rhs, $)}`);
                    const candidate = lhs.rhs.opr;
                    if (is_sym(candidate) && candidate.equalsSym(MATH_DERIVATIVE)) {
                        return $.isScalar(rhs);
                    }
                    else {
                        return false;
                    }
                };
            }
            /**
             *
             */
            let Op$1R = class Op extends Function2X {
                constructor($) {
                    super('mul_2_mul_2_any_cons_sym', MATH_MUL$3, and(is_cons, is_mul_2_any_cons), is_sym, crossGuard($), $);
                    this.hash = hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_SYM);
                }
                transform2(opr, lhs, rhs /*, orig: BCons<Sym, BCons<Sym, U, Cons>, Sym>*/) {
                    const $ = this.$;
                    // console.lg(`lhs: ${render_as_infix(lhs, $)}, rhs=${render_as_infix(rhs, $)}`);
                    const a = lhs.lhs;
                    const deriv = lhs.rhs;
                    const sym = rhs;
                    const a_times_sym = $.valueOf(items_to_cons$1(MATH_MUL$3, a, sym));
                    const a_times_sym_times_deriv = $.valueOf(items_to_cons$1(MATH_MUL$3, a_times_sym, deriv));
                    return [TFLAG_DIFF, a_times_sym_times_deriv];
                }
            };
            const mul_2_mul_2_any_cons_sym = new Builder$29();

            let Builder$28 = class Builder {
                create($) {
                    return new Op$1Q($);
                }
            };
            function cross$q(lhs, rhs) {
                const x1 = lhs.rhs.lhs;
                const x2 = rhs.lhs;
                return x1.equalsSym(x2);
            }
            const guardLL$7 = is_any;
            const guardLR$7 = and(is_cons, is_opr_2_lhs_rhs(MATH_POW$2, is_sym, is_rat$1));
            const guardL$g = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$7, guardLR$7));
            const guardR$g = and(is_cons, is_opr_2_lhs_rhs(MATH_POW$2, is_sym, is_rat$1));
            /**
             * This is the asymmetric version of a factoring distributive law resulting from LHS associativity of multiplication.
             * (A * (x **  a)) *  (x ** b)  =>  A * (x **  (a +   b))
             *      (x op1 a) op2 (x op1 b) =>       x op1 (a op2 b)
             */
            let Op$1Q = class Op extends Function2X {
                constructor($) {
                    super('mul_2_mul_2_any_pow_2_xxx_any_pow_2_xxx_any', MATH_MUL$3, guardL$g, guardR$g, cross$q, $);
                    this.hash = hash_binop_cons_cons(MATH_MUL$3, MATH_MUL$3, MATH_POW$2);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const A = lhs.lhs;
                    const x = lhs.rhs.lhs;
                    const a = lhs.rhs.rhs;
                    const b = rhs.rhs;
                    const p1 = $.valueOf(items_to_cons(MATH_ADD$1, a, b));
                    const p2 = $.valueOf(items_to_cons(MATH_POW$2, x, p1));
                    const p3 = $.valueOf(items_to_cons(opr, A, p2));
                    return [TFLAG_DIFF, p3];
                }
            };
            const mul_2_mul_2_any_pow_2_xxx_any_pow_2_xxx_any = new Builder$28();

            function is_mul_2_any_sym(expr) {
                return is_mul_2_any_any(expr) && is_sym(expr.rhs);
            }

            let Builder$27 = class Builder {
                create($) {
                    return new Op$1P($);
                }
            };
            /**
             * (X * a) * i => (X * i) * a or (X * a) * i, consistent with compare_factors
             */
            let Op$1P = class Op extends Function2 {
                constructor($) {
                    super('mul_2_mul_2_any_sym_imu', MATH_MUL$3, and(is_cons, is_mul_2_any_sym), is_imu, $);
                    this.hash = hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_IMU);
                }
                isImag(expr) {
                    const $ = this.$;
                    const X = expr.lhs.lhs;
                    return $.is_real(X);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const X = lhs.lhs;
                    const a = lhs.rhs;
                    const i = rhs;
                    switch ($.compareFn(opr)(a, i)) {
                        case SIGN_GT: {
                            const Xi = $.valueOf(items_to_cons$1(MATH_MUL$3, X, i));
                            const Xia = $.valueOf(items_to_cons$1(MATH_MUL$3, Xi, a));
                            return [TFLAG_DIFF, Xia];
                        }
                        default: {
                            return [TFLAG_NONE, orig];
                        }
                    }
                }
            };
            const mul_2_mul_2_any_sym_imu = new Builder$27();

            function is_mul_2_imu_any(expr) {
                return is_mul_2_any_any(expr) && is_imu(expr.lhs);
            }

            let Builder$26 = class Builder {
                create($) {
                    return new Op$1O($);
                }
            };
            /**
             * (X * a) * (i * Y) => (X * i) * (a * Y)
             */
            let Op$1O = class Op extends Function2 {
                constructor($) {
                    super('mul_2_mul_2_any_sym_mul_2_imu_sym', MATH_MUL$3, and(is_cons, is_mul_2_any_sym), and(is_cons, is_mul_2_imu_any), $);
                    this.hash = hash_binop_cons_cons(MATH_MUL$3, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const X = lhs.lhs;
                    const a = lhs.rhs;
                    const i = rhs.lhs;
                    const Y = rhs.rhs;
                    const Xi = $.valueOf(items_to_cons$1(MATH_MUL$3, X, i));
                    const aY = $.valueOf(items_to_cons$1(MATH_MUL$3, a, Y));
                    const retval = $.valueOf(items_to_cons$1(MATH_MUL$3, Xi, aY));
                    return [TFLAG_DIFF, retval];
                }
            };
            const mul_2_mul_2_any_sym_mul_2_imu_sym = new Builder$26();

            let Builder$25 = class Builder {
                create($) {
                    return new Op$1N($);
                }
            };
            const guardL$f = and(is_cons, is_opr_2_any_any(MATH_MUL$3));
            const guardR$f = and(is_cons, is_opr_2_any_rhs(MATH_POW$2, is_rat$1));
            function cross$p(lhs, rhs) {
                const Y1 = lhs.rhs;
                const Y2 = rhs.lhs;
                return Y1.equals(Y2);
            }
            /**
             * (X * Y) * (expt Y k) => X * (expt Y k+1)
             */
            let Op$1N = class Op extends Function2X {
                constructor($) {
                    super('mul_2_mul_2_any_X_pow_2_X_rat', MATH_MUL$3, guardL$f, guardR$f, cross$p, $);
                    this.hash = hash_binop_cons_cons(MATH_MUL$3, MATH_MUL$3, MATH_POW$2);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const X = lhs.lhs;
                    const Y = lhs.rhs;
                    const k = rhs.rhs;
                    const p1 = $.valueOf(items_to_cons$1(rhs.opr, Y, k.succ()));
                    const p2 = $.valueOf(items_to_cons$1(MATH_MUL$3, X, p1));
                    return [TFLAG_DIFF, p2];
                }
            };
            const mul_2_mul_2_any_X_pow_2_X_rat = new Builder$25();

            let Builder$24 = class Builder {
                create($) {
                    return new Op$1M($);
                }
            };
            const guardL$e = and(is_cons, is_opr_2_any_any(MATH_MUL$3));
            const guardR$e = and(is_cons, is_opr_2_any_any(MATH_POW$2));
            function cross$o($) {
                return function (lhs, rhs) {
                    const Z = lhs.rhs;
                    const A = rhs.lhs;
                    return is_sym(Z) && is_sym(A) && $.compareFn(MATH_MUL$3)(Z, A) > 0;
                };
            }
            /**
             * This fails for the example X = 2, Z = (expt x 2), A = x, Y = -1
             * Perhaps restrict Z and A to being symbols?
             * (X * Z) * (expt A Y) => (X * (expt A Y)) * Z
             */
            let Op$1M = class Op extends Function2X {
                constructor($) {
                    super('mul_2_mul_2_any_Z_pow_2_A_any', MATH_MUL$3, guardL$e, guardR$e, cross$o($), $);
                    this.hash = hash_binop_cons_cons(MATH_MUL$3, MATH_MUL$3, MATH_POW$2);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const X = lhs.lhs;
                    const Z = lhs.rhs;
                    const A = rhs.lhs;
                    const Y = rhs.rhs;
                    const p1 = items_to_cons$1(rhs.opr, A, Y);
                    const p2 = $.valueOf(p1);
                    const p3 = items_to_cons$1(lhs.opr, X, p2);
                    const p4 = $.valueOf(p3);
                    const p5 = items_to_cons$1(opr, p4, Z);
                    const p6 = $.valueOf(p5);
                    return [TFLAG_DIFF, p6];
                }
            };
            const mul_2_mul_2_any_Z_pow_2_A_any = new Builder$24();

            let Builder$23 = class Builder {
                create($) {
                    return new Op$1L($);
                }
            };
            /**
             * (n * X) * (m * Y) => (n * m) * (X * Y)
             */
            let Op$1L = class Op extends Function2 {
                constructor($) {
                    super('mul_2_mul_2_rat_any_mul_2_rat_any', MATH_MUL$3, and(is_cons, is_mul_2_rat_any), and(is_cons, is_mul_2_rat_any), $);
                    this.hash = hash_binop_cons_cons(MATH_MUL$3, MATH_MUL$3, MATH_MUL$3);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const n = lhs.lhs;
                    const X = lhs.rhs;
                    const m = rhs.lhs;
                    const Y = rhs.rhs;
                    const XY = $.valueOf(items_to_cons$1(rhs.opr, X, Y));
                    const retval = $.valueOf(items_to_cons$1(opr, n.mul(m), XY));
                    return [TFLAG_DIFF, retval];
                }
            };
            const mul_2_mul_2_rat_any_mul_2_rat_any = new Builder$23();

            let Builder$22 = class Builder {
                create($) {
                    return new Op$1K($);
                }
            };
            /**
             * (a * i) * b => (a * b) * i
             */
            let Op$1K = class Op extends Function2 {
                constructor($) {
                    super('mul_2_mul_2_sym_imu_sym', MATH_MUL$3, and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, is_sym, is_imu)), is_sym, $);
                    this.hash = hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_SYM);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = lhs.lhs;
                    const i = lhs.rhs;
                    const b = rhs;
                    switch ($.compareFn(opr)(i, b)) {
                        case SIGN_GT: {
                            const ab = $.valueOf(items_to_cons$1(opr, a, b));
                            const abi = $.valueOf(items_to_cons$1(MATH_MUL$3, ab, i));
                            // console.lg(`${this.name} ${print_expr(orig, $)} ==> ${print_expr(Xia, $)}`);
                            return [TFLAG_DIFF, abi];
                        }
                        default: {
                            return [TFLAG_NONE, orig];
                        }
                    }
                }
            };
            const mul_2_mul_2_sym_imu_sym = new Builder$22();

            function is_pow_2_sym_any(expr) {
                return is_pow_2_any_any(expr) && is_sym(expr.lhs);
            }

            let Builder$21 = class Builder {
                create($) {
                    return new Op$1J($);
                }
            };
            function cross$n(lhs, rhs) {
                const s1 = lhs.lhs;
                const s2 = rhs.lhs;
                return s1.equalsSym(s2);
            }
            const guardL$d = and(is_cons, is_pow_2_sym_any);
            const guardR$d = and(is_cons, is_pow_2_sym_any);
            /**
             * This is a symmetric distributive law in the factoring direction.
             * Interestingly, this example involves three operators.
             * Note that there must be other pattern matchers for left and right-associated expressions.
             * We should also know when we allow this to run because it could cause looping if expansion is in effect.
             *
             * (x ** a) * (x ** b) =>  x ** (a + b)
             */
            let Op$1J = class Op extends Function2X {
                constructor($) {
                    super('mul_2_pow_2_xxx_any_pow_2_xxx_any', MATH_MUL$3, guardL$d, guardR$d, cross$n, $);
                    this.hash = hash_binop_cons_cons(MATH_MUL$3, MATH_POW$2, MATH_POW$2);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const sym = lhs.lhs;
                    const a = lhs.rhs;
                    const b = rhs.rhs;
                    const expo = $.valueOf(items_to_cons(MATH_ADD$1, a, b));
                    const D = $.valueOf(items_to_cons(MATH_POW$2, sym, expo));
                    return [TFLAG_DIFF, D];
                }
            };
            const mul_2_pow_2_xxx_any_pow_2_xxx_any = new Builder$21();

            function is_pow_2_sym_rat(expr) {
                return is_pow_2_any_any(expr) && is_sym(expr.lhs) && is_rat$1(expr.rhs);
            }

            let Builder$20 = class Builder {
                create($) {
                    return new Op$1I($);
                }
            };
            function cross$m(lhs, rhs) {
                const s1 = lhs.lhs;
                const s2 = rhs;
                return s1.equalsSym(s2);
            }
            /**
             * (xxx ** Rat) * xxx => xxx ** (succ(Rat))
             */
            let Op$1I = class Op extends Function2X {
                constructor($) {
                    super('mul_2_pow_2_xxx_rat_xxx', MATH_MUL$3, and(is_cons, is_pow_2_sym_rat), is_sym, cross$m, $);
                    this.hash = hash_binop_cons_atom(MATH_MUL$3, MATH_POW$2, HASH_SYM);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const xxx = lhs.lhs;
                    const rat = lhs.rhs;
                    const expo = rat.succ();
                    const D = $.valueOf(items_to_cons(MATH_POW$2, xxx, expo));
                    return [TFLAG_DIFF, D];
                }
            };
            const mul_2_pow_2_xxx_rat_xxx = new Builder$20();

            let Builder$1$ = class Builder {
                create($) {
                    return new Op$1H($);
                }
            };
            //
            // TODO: We can choose whether to get reuse by extending classes or by containing functions, or both.
            //
            function multiply_rat_any(lhs, rhs, expr) {
                if (lhs.isZero()) {
                    return [TFLAG_DIFF, lhs];
                }
                else if (lhs.isOne()) {
                    return [TFLAG_DIFF, rhs];
                }
                // TODO: It's important for this to be NOFLAGS rather than STABLE.
                // e.g. Rat*(Blade*Uom) will not be processed further.
                return [TFLAG_NONE, expr];
            }
            /**
             * Rat * X
             */
            let Op$1H = class Op extends Function2 {
                constructor($) {
                    super('mul_2_rat_any', MATH_MUL$3, is_rat$1, is_any, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_RAT, HASH_ANY);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const lhs = expr.lhs;
                        return lhs.isZero() || lhs.isOne();
                    }
                    else {
                        return false;
                    }
                }
                isImag(expr) {
                    const $ = this.$;
                    return $.is_imag(expr.rhs);
                }
                isReal(expr) {
                    const $ = this.$;
                    return $.is_real(expr.rhs);
                }
                isScalar(expr) {
                    const $ = this.$;
                    return $.isScalar(expr.rhs);
                }
                transform2(opr, lhs, rhs, expr) {
                    return multiply_rat_any(lhs, rhs, expr);
                }
            };
            const mul_2_rat_any = new Builder$1$();

            let Builder$1_ = class Builder {
                create($) {
                    return new Op$1G($);
                }
            };
            /**
             * (* Rat Blade) => (* Rat Blade) STABLE
             *               => 0 if Rat is zero
             *               => Blade if Rat is one
             */
            let Op$1G = class Op extends Function2 {
                constructor($) {
                    super('mul_2_rat_blade', MATH_MUL$3, is_rat$1, is_blade$1, $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_RAT, HASH_BLADE);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return false;
                }
                transform2(opr, lhs, rhs, expr) {
                    // The following code is common
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (lhs.isOne()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const mul_2_rat_blade = new Builder$1_();

            let Builder$1Z = class Builder {
                create($) {
                    return new Op$1F($);
                }
            };
            /**
             * (Rat * Flt) => Flt
             */
            let Op$1F = class Op extends Function2 {
                constructor($) {
                    super('mul_2_rat_flt', MATH_MUL$3, is_rat$1, is_flt$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_RAT, HASH_FLT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, create_flt(lhs.toNumber() * rhs.toNumber())];
                }
            };
            const mul_2_rat_flt = new Builder$1Z();

            let Builder$1Y = class Builder {
                create($) {
                    return new Op$1E($);
                }
            };
            let Op$1E = class Op extends Function2 {
                constructor($) {
                    super('mul_2_rat_rat', MATH_MUL$3, is_rat$1, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_RAT, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    // console.lg(this.name, render_as_infix(lhs, this.$), render_as_infix(rhs, this.$), render_as_infix(orig, this.$));
                    return [TFLAG_DIFF, lhs.mul(rhs)];
                }
            };
            const mul_2_rat_rat = new Builder$1Y();

            let Builder$1X = class Builder {
                create($) {
                    return new Op$1D($);
                }
            };
            /**
             * (* Rat Sym) => (* Rat Sym) STABLE
             *             => 0 if Rat is zero
             *             => Sym if Rat is one
             */
            let Op$1D = class Op extends Function2 {
                constructor($) {
                    super('mul_2_rat_sym', MATH_MUL$3, is_rat$1, is_sym, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_RAT, HASH_SYM);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const lhs = expr.lhs;
                        return lhs.isZero() || lhs.isOne();
                    }
                    else {
                        return false;
                    }
                }
                isReal(expr) {
                    return this.$.is_real(expr.rhs);
                }
                isImag(expr) {
                    return this.$.is_imag(expr.rhs);
                }
                isScalar(expr) {
                    return this.$.isScalar(expr.rhs);
                }
                transform2(opr, lhs, rhs, expr) {
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (lhs.isOne()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const mul_2_rat_sym = new Builder$1X();

            let Builder$1W = class Builder {
                create($) {
                    return new Op$1C($);
                }
            };
            /**
             * (* Rat Sym) => (* Rat Sym) STABLE
             *             => 0 if Rat is zero
             *             => Sym if Rat is one
             */
            let Op$1C = class Op extends Function2 {
                constructor($) {
                    super('mul_2_rat_tensor', MATH_MUL$3, is_rat$1, is_tensor, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_RAT, HASH_TENSOR);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    if (lhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (lhs.isOne()) {
                        return [TFLAG_DIFF, rhs];
                    }
                    const retval = rhs.map(function (value) {
                        return $.multiply(lhs, value);
                    });
                    return [TFLAG_DIFF, retval];
                }
            };
            const mul_2_rat_tensor = new Builder$1W();

            let Builder$1V = class Builder {
                create($) {
                    return new Op$1B($);
                }
            };
            function cross$l($) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                return function (lhs, rhs) {
                    return $.isScalar(lhs);
                };
            }
            /**
             * Sym * Blade => Sym * Blade (STABLE)
             */
            let Op$1B = class Op extends Function2X {
                constructor($) {
                    super('mul_2_sym_blade', MATH_MUL$3, is_sym, is_blade$1, cross$l($), $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_SYM, HASH_BLADE);
                }
                transform2(opr, lhs, rhs, orig) {
                    // TODO: Be aware that this may prevent the processing of Sym * Blade more generally.
                    return [TFLAG_HALT, orig];
                }
            };
            const mul_2_sym_blade = new Builder$1V();

            let Builder$1U = class Builder {
                create($) {
                    return new Op$1A($);
                }
            };
            /**
             * Sym * Imu may be ordered consistently using compare_factors.
             */
            let Op$1A = class Op extends Function2 {
                constructor($) {
                    super('mul_2_sym_imu', MATH_MUL$3, is_sym, is_imu, $);
                    this.hash = hash_binop_atom_cons(MATH_MUL$3, HASH_SYM, MATH_POW$2);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return false;
                }
                isScalar(expr) {
                    const $ = this.$;
                    return $.isScalar(expr.lhs);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    switch ($.compareFn(opr)(lhs, rhs)) {
                        case SIGN_GT: {
                            return [TFLAG_DIFF, $.valueOf(items_to_cons(opr, rhs, lhs))];
                        }
                        default: {
                            return [TFLAG_NONE, orig];
                        }
                    }
                }
            };
            const mul_2_sym_imu = new Builder$1U();

            let Builder$1T = class Builder {
                create($) {
                    return new Op$1z($);
                }
            };
            const mul_2_sym_mul_2_rat_any = new Builder$1T();
            /**
             * a * (n * X) => n * (a * X), where n is a number, a is a symbol, and X is anything.
             */
            let Op$1z = class Op extends Function2 {
                constructor($) {
                    super('mul_2_sym_mul_2_rat_any', MATH_MUL$3, is_sym, and(is_cons, is_mul_2_rat_any), $);
                    this.hash = hash_binop_atom_cons(MATH_MUL$3, HASH_SYM, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const a = lhs;
                    const n = rhs.lhs;
                    const X = rhs.rhs;
                    switch ($.compareFn(opr)(a, n)) {
                        case SIGN_GT: {
                            const aX = $.valueOf(items_to_cons(rhs.opr, a, X));
                            const naX = $.valueOf(items_to_cons(opr, n, aX));
                            return [TFLAG_DIFF, naX];
                        }
                        default: {
                            return [TFLAG_NONE, expr];
                        }
                    }
                }
            };

            let Builder$1S = class Builder {
                create($) {
                    return new Op$1y($);
                }
            };
            /**
             * Sym * Num => Num * Sym
             */
            let Op$1y = class Op extends Function2 {
                constructor($) {
                    super('mul_2_sym_num', MATH_MUL$3, is_sym, is_num, $);
                    this.hash = `(* Sym Num)`;
                }
                isScalar(expr) {
                    return this.$.isScalar(expr.lhs);
                }
                transform2(opr, lhs, rhs) {
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    return [TFLAG_DIFF, items_to_cons(opr, rhs, lhs)];
                }
            };
            const mul_2_sym_num = new Builder$1S();

            let Builder$1R = class Builder {
                create($) {
                    return new Op$1x($);
                }
            };
            /**
             * (* Sym Rat) => (* Rat Sym)
             *             => 0 if Rat is zero
             *             => Sym if Rat is one
             */
            let Op$1x = class Op extends Function2 {
                constructor($) {
                    super('mul_2_sym_rat', MATH_MUL$3, is_sym, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_SYM, HASH_RAT);
                }
                isScalar(expr) {
                    return this.$.isScalar(expr.lhs);
                }
                transform2(opr, lhs, rhs) {
                    // If the base class binds the symbol to something else then none of this code below will be called.
                    // Therefore, you can consider that this code only applies to unbound symbols. 
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    return [TFLAG_DIFF, items_to_cons(opr, rhs, lhs)];
                }
            };
            const mul_2_sym_rat = new Builder$1R();

            let Builder$1Q = class Builder {
                create($) {
                    return new Op$1w($);
                }
            };
            function cross$k($) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                return function (lhs, rhs) {
                    return $.isScalar(lhs);
                };
            }
            /**
             *
             */
            let Op$1w = class Op extends Function2X {
                constructor($) {
                    super('mul_2_sym_tensor', MATH_MUL$3, is_sym, is_tensor, cross$k($), $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_SYM, HASH_TENSOR);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const retval = rhs.map(function (value) {
                        return $.multiply(lhs, value);
                    });
                    return [TFLAG_DIFF, retval];
                }
            };
            const mul_2_sym_tensor = new Builder$1Q();

            let Builder$1P = class Builder {
                create($) {
                    return new Op$1v($);
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$j($) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                return function (lhs, rhs) {
                    return true; //$.isScalar(rhs);
                };
            }
            /**
             *
             */
            let Op$1v = class Op extends Function2X {
                constructor($) {
                    super('mul_2_tensor_any', MATH_MUL$3, is_tensor, is_any, cross$j(), $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_TENSOR, HASH_ANY);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const retval = lhs.map(function (value) {
                        return $.multiply(value, rhs);
                    });
                    return [TFLAG_DIFF, retval];
                }
            };
            const mul_2_tensor_any = new Builder$1P();

            let Builder$1O = class Builder {
                create($) {
                    return new Op$1u($);
                }
            };
            function cross$i($) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                return function (lhs, rhs) {
                    return $.isScalar(rhs);
                };
            }
            /**
             *
             */
            let Op$1u = class Op extends Function2X {
                constructor($) {
                    super('mul_2_tensor_sym', MATH_MUL$3, is_tensor, is_sym, cross$i($), $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_TENSOR, HASH_SYM);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const retval = lhs.map(function (value) {
                        return $.multiply(value, rhs);
                    });
                    return [TFLAG_DIFF, retval];
                }
            };
            const mul_2_tensor_sym = new Builder$1O();

            function inner_tensor_tensor(p1, p2, $) {
                const n = p1.dim(p1.ndim - 1);
                if (n !== p2.dim(0)) {
                    halt('inner: tensor dimension check');
                }
                const ndim = p1.ndim + p2.ndim - 2;
                if (ndim > MAXDIM) {
                    halt('inner: rank of result exceeds maximum');
                }
                //---------------------------------------------------------------------
                //
                //  ak is the number of rows in tensor A
                //
                //  bk is the number of columns in tensor B
                //
                //  Example:
                //
                //  A[3][3][4] B[4][4][3]
                //
                //    3  3        ak = 3 * 3 = 9
                //
                //    4  3        bk = 4 * 3 = 12
                //
                //---------------------------------------------------------------------
                const ak = p1.sliceDimensions(0, p1.ndim - 1).reduce((a, b) => a * b, 1);
                const bk = p2.sliceDimensions(1).reduce((a, b) => a * b, 1);
                const elems = create_tensor_elements(ak * bk, zero);
                // new method copied from ginac http://www.ginac.de/
                for (let i = 0; i < ak; i++) {
                    for (let j = 0; j < n; j++) {
                        if ($.is_zero(p1.elem(i * n + j))) {
                            continue;
                        }
                        for (let k = 0; k < bk; k++) {
                            elems[i * bk + k] = $.add($.multiply(p1.elem(i * n + j), p2.elem(j * bk + k)), elems[i * bk + k]);
                        }
                    }
                }
                //---------------------------------------------------------------------
                //
                //  Note on understanding "k * bk + j"
                //
                //  k * bk because each element of a column is bk locations apart
                //
                //  + j because the beginnings of all columns are in the first bk
                //  locations
                //
                //  Example: n = 2, bk = 6
                //
                //  b111  <- 1st element of 1st column
                //  b112  <- 1st element of 2nd column
                //  b113  <- 1st element of 3rd column
                //  b121  <- 1st element of 4th column
                //  b122  <- 1st element of 5th column
                //  b123  <- 1st element of 6th column
                //
                //  b211  <- 2nd element of 1st column
                //  b212  <- 2nd element of 2nd column
                //  b213  <- 2nd element of 3rd column
                //  b221  <- 2nd element of 4th column
                //  b222  <- 2nd element of 5th column
                //  b223  <- 2nd element of 6th column
                //
                //---------------------------------------------------------------------
                if (ndim === 0) {
                    return elems[0];
                }
                else {
                    const dims = [...p1.sliceDimensions(0, p1.ndim - 1), ...p2.sliceDimensions(1, p2.ndim),];
                    return new Tensor(dims, elems);
                }
            }

            let Builder$1N = class Builder {
                create($) {
                    return new Op$1t($);
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$h($) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                return function (lhs, rhs) {
                    return true;
                };
            }
            /**
             *
             */
            let Op$1t = class Op extends Function2X {
                constructor($) {
                    super('mul_2_tensor_tensor', MATH_MUL$3, is_tensor, is_tensor, cross$h(), $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_TENSOR, HASH_TENSOR);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    return [TFLAG_DIFF, inner_tensor_tensor(lhs, rhs, $)];
                }
            };
            const mul_2_tensor_tensor = new Builder$1N();

            let Builder$1M = class Builder {
                create($) {
                    return new Op$1s($);
                }
            };
            /**
             * (* Uom Flt) => (* Flt Uom)
             *             => 0 if Flt is zero
             *             => Uom if Flt is one
             */
            let Op$1s = class Op extends Function2 {
                constructor($) {
                    super('mul_2_uom_flt', MATH_MUL$3, is_uom$1, is_flt$1, $);
                    this.dependencies = ['Flt', 'Uom'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_UOM, HASH_FLT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                transform2(opr, lhs, rhs) {
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    return [TFLAG_DIFF, items_to_cons(opr, rhs, lhs)];
                }
            };
            const mul_2_uom_flt = new Builder$1M();

            let Builder$1L = class Builder {
                create($) {
                    return new Op$1r($);
                }
            };
            /**
             * (* Uom Rat) => (* Rat Uom)
             *             => 0 if Rat is zero
             *             => Uom if Rat is one
             */
            let Op$1r = class Op extends Function2 {
                constructor($) {
                    super('mul_2_uom_rat', MATH_MUL$3, is_uom$1, is_rat$1, $);
                    this.dependencies = ['Uom'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_UOM, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                transform2(opr, lhs, rhs) {
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    if (rhs.isOne()) {
                        return [TFLAG_DIFF, lhs];
                    }
                    return [TFLAG_DIFF, items_to_cons(opr, rhs, lhs)];
                }
            };
            const mul_2_uom_rat = new Builder$1L();

            let Builder$1K = class Builder {
                create($) {
                    return new Op$1q($);
                }
            };
            /**
             * Uom * Uom
             */
            let Op$1q = class Op extends Function2 {
                constructor($) {
                    super('mul_2_uom_uom', MATH_MUL$3, is_uom, is_uom, $);
                    this.dependencies = ['Uom'];
                    this.hash = hash_binop_atom_atom(MATH_MUL$3, HASH_UOM, HASH_UOM);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.mul(rhs)];
                }
            };
            const mul_2_uom_uom = new Builder$1K();

            function is_pow_2_any_rat(expr) {
                return is_pow_2_any_any(expr) && is_rat$1(expr.rhs);
            }

            let Builder$1J = class Builder {
                create($) {
                    return new Op$1p($);
                }
            };
            function cross$g(lhs, rhs) {
                const X1 = lhs;
                const X2 = rhs.lhs;
                if (is_sym(X1) || is_hyp(X1)) {
                    return X1.equals(X2);
                }
                else {
                    return false;
                }
            }
            /**
             * Looping can occur e.g. X = -1, k = 1/2.
             *
             * X * (X ** k) => X ** (k + 1)
             */
            let Op$1p = class Op extends Function2X {
                constructor($) {
                    super('mul_2_X_pow_2_X_rat', MATH_MUL$3, is_any, and(is_cons, is_pow_2_any_rat), cross$g, $);
                    this.hash = hash_binop_atom_cons(MATH_MUL$3, HASH_ANY, MATH_POW$2);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    // console.lg(`${this.name} exp=${print_expr(exp, $)}`);
                    const X = lhs;
                    const k = rhs.rhs;
                    const p1 = items_to_cons(rhs.opr, X, k.succ());
                    // console.lg(`p1=${print_expr(p1, $)}`);
                    const p2 = $.valueOf(p1);
                    return [TFLAG_DIFF, p2];
                }
            };
            const mul_2_X_pow_2_X_rat = new Builder$1J();

            /**
             * TODO: A better name might be transform_multiplicative_expr
             * @param expr
             * @param $
             * @returns
             */
            function Eval_multiply(expr, $) {
                // The only reason we should be here is that all other handlers for this multiplication do not match.
                // console.lg("Eval_multiply", $.toSExprString(expr));
                const args = expr.argList;
                const vals = args.map($.valueOf);
                if (vals.equals(args)) {
                    // For multiplication, the expression (*) evaluates to 1.
                    if (is_nil(vals)) {
                        return one;
                    }
                    else {
                        const retval = vals.car;
                        const remaining = vals.cdr;
                        if (is_cons(remaining)) {
                            return [...remaining].reduce((prev, curr) => multiply(prev, curr, $), retval);
                        }
                        return retval;
                    }
                }
                else {
                    // Evaluation of the arguments has produced changes so we give other operators a chance to evaluate.
                    return $.valueOf(cons(expr.car, vals));
                }
            }
            /**
             *
             * @param lhs
             * @param rhs
             * @param $
             * @returns
             */
            function multiply(lhs, rhs, $) {
                // console.lg("lhs", render_as_sexpr(lhs, $));
                // console.lg("rhs", render_as_sexpr(rhs, $));
                // TODO: Optimize handling of numbers, 0, 1.
                // TODO: This function should not known anything about Flt(s) and Rat(s).
                // These optimizations should be introduced by extensions to multiplication.
                if (is_num(lhs) && is_num(rhs)) {
                    return multiply_num_num(lhs, rhs);
                }
                // TODO: Move these out, just like Flt.
                if (is_rat$1(lhs)) {
                    if (lhs.isZero()) {
                        return lhs;
                    }
                }
                if (is_rat$1(rhs)) {
                    if (rhs.isZero()) {
                        return rhs;
                    }
                }
                // Distributive Law  (x1 + x2 + ...) * R => x1 * R + x2 * R + ...
                if ($.isExpanding() && is_add(lhs)) {
                    return lhs
                        .tail()
                        .reduce((a, b) => $.add(a, multiply(b, rhs, $)), zero);
                }
                // Distributive Law  L * (x1 + x2 + ...) => L * x1 + L * x2 + ...
                if ($.isExpanding() && is_add(rhs)) {
                    return rhs
                        .tail()
                        .reduce((a, b) => $.add(a, multiply(lhs, b, $)), zero);
                }
                const compareFactors = $.compareFn(MATH_MUL$3);
                // Dealing with Blades avoids issues with non-commutativity later on.
                if (contains_single_blade(lhs) && contains_single_blade(rhs)) {
                    const bladeL = extract_single_blade(lhs);
                    const bladeR = extract_single_blade(rhs);
                    const blade = bladeL.mul(bladeR);
                    const residueL = remove_factors(lhs, is_blade$1);
                    const residueR = remove_factors(rhs, is_blade$1);
                    return $.multiply($.multiply(residueL, residueR), blade);
                }
                // Units of Measure shortcut.
                if (is_uom$1(lhs) && is_uom$1(rhs)) {
                    return lhs.mul(rhs);
                }
                // scalar times tensor?
                if (!is_tensor(lhs) && is_tensor(rhs)) {
                    // return scalar_times_tensor(lhs, rhs);
                    return $.multiply(lhs, rhs);
                }
                // tensor times scalar?
                if (is_tensor(lhs) && !is_tensor(rhs)) {
                    // return tensor_times_scalar(lhs, rhs);
                    return $.multiply(lhs, rhs);
                }
                // adjust operands - they are both now lists.
                let p1 = is_multiply(lhs) ? lhs.cdr : items_to_cons$1(lhs);
                let p2 = is_multiply(rhs) ? rhs.cdr : items_to_cons$1(rhs);
                const factors = [];
                // handle numerical coefficients
                const c1 = car(p1);
                const c2 = car(p2);
                if (is_num(c1) && is_num(c2)) {
                    factors.push(multiply_num_num(c1, c2));
                    p1 = p1.cdr;
                    p2 = p2.cdr;
                }
                else if (is_num(c1)) {
                    // console.lg("c1", render_as_sexpr(c1, $));
                    factors.push(c1);
                    p1 = p1.cdr;
                }
                else if (is_num(c2)) {
                    // console.lg("c2", render_as_sexpr(c2, $));
                    factors.push(c2);
                    p2 = p2.cdr;
                }
                else {
                    factors.push(one);
                }
                while (is_cons(p1) && is_cons(p2)) {
                    const head1 = p1.car;
                    const head2 = p2.car;
                    if (car(head1).equals(OPERATOR) && car(head2).equals(OPERATOR)) {
                        factors.push(cons(OPERATOR, append(cdr(head1), cdr(head2))));
                        p1 = p1.cdr;
                        p2 = p2.cdr;
                        continue;
                    }
                    const [baseL, powerL] = base_and_power(head1);
                    const [baseR, powerR] = base_and_power(head2);
                    // We can get the ordering wrong here. e.g. lhs = (expt 2 1/2), rhs = imu
                    // We end up comparing 2 and i and the 2 gets pushed first and the i waits
                    // for the next loop iteration.
                    // console.lg("head1", render_as_infix(head1, $));
                    // console.lg("head2", render_as_infix(head2, $));
                    // console.lg("baseL", render_as_infix(baseL, $));
                    // console.lg("baseR", render_as_infix(baseR, $));
                    // console.lg("powerL", render_as_infix(powerL, $));
                    // console.lg("powerR", render_as_infix(powerR, $));
                    // If the head elements are the same then the bases will be the same.
                    // On the other hand, the heads can be different but the bases the same.
                    // e.g. head1 = x, head2 = 1/x = (expt x -1)
                    if (baseL.equals(baseR)) {
                        combine_factors(factors, baseR, powerL, powerR, $);
                        p1 = p1.cdr;
                        p2 = p2.cdr;
                    }
                    else {
                        switch (compareFactors(head1, head2)) {
                            case SIGN_LT: {
                                factors.push(head1);
                                p1 = p1.cdr;
                                break;
                            }
                            case SIGN_GT: {
                                factors.push(head2);
                                p2 = p2.cdr;
                                break;
                            }
                            default: {
                                // Equality here means stable sorting of the head elements.
                                // If we end up here then we already know that the bases are different.
                                // So we definitely can't combine assuming base equality.
                                // This can happen for non-commuting elements. e.g. Blade(s), Tensor(s).
                                // Remove factors that don't commute earlier? Or do we handle them here?
                                throw new Error(`${render_as_infix(baseL, $)} ${render_as_infix(powerL, $)} ${render_as_infix(baseR, $)} ${render_as_infix(powerR, $)}`);
                            }
                        }
                    }
                }
                // push remaining factors, if any
                if (is_cons(p1)) {
                    factors.push(...p1);
                }
                if (is_cons(p2)) {
                    factors.push(...p2);
                }
                if ($.isExpanding()) {
                    for (let i = 0; i < factors.length; i++) {
                        if (is_add(factors[i])) {
                            return multiply_all(factors, $);
                        }
                    }
                }
                // n is the number of result factors on the stack
                const n = factors.length;
                if (n === 1) {
                    const retval = assert_not_undefined(factors.pop());
                    // console.lg("retval 1", $.toSExprString(retval));
                    return retval;
                }
                // discard integer 1
                const first = factors[0];
                if (is_rat$1(first) && first.isOne()) {
                    if (n === 2) {
                        const retval = assert_not_undefined(factors.pop());
                        // console.lg("retval 2", $.toSExprString(retval));
                        return retval;
                    }
                    else {
                        // factors[0] is Rat(1) so we'll just replace it with the multiplication operand
                        // so that we can easily built the multiplicative expression from the factors.
                        // But before we do that we'll sort the factors to ensure that they are in canonical order.
                        // We must do this because, despite our previous efforts, symbols can be shunted in front
                        // of exponentials where they later create new exponentials that must be reordered.
                        // e.g. a^n * b * b => b * a^n * b = b * b * a^n => b^2 * a^n.
                        factors.splice(0, 1); // remove the Rat(1)
                        factors.sort(compareFactors);
                        const retval = items_to_cons$1(MATH_MUL$3, ...factors);
                        // console.lg("retval 3", $.toSExprString(retval));
                        return retval;
                    }
                }
                const retval = cons(MATH_MUL$3, items_to_cons$1(...factors));
                // console.lg("retval 3", $.toSExprString(retval));
                return retval;
            }
            /**
             * Decomposes an expression into a base and power (expt may be one).
             */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function base_and_power(expr, $) {
                // console.lg("base_and_power", render_as_infix(expr, $));
                if (is_power(expr)) {
                    const argList = expr.cdr;
                    return [car(argList), cadr(argList)];
                }
                else {
                    return [expr, one];
                }
            }
            function append(p1, p2) {
                // from https://github.com/gbl08ma/eigenmath/blob/8be989f00f2f6f37989bb7fd2e75a83f882fdc49/src/append.cpp
                const arr = [];
                if (is_cons(p1)) {
                    arr.push(...p1);
                }
                if (is_cons(p2)) {
                    arr.push(...p2);
                }
                return items_to_cons$1(...arr);
            }
            function multiply_all(n, $) {
                if (n.length === 1) {
                    return n[0];
                }
                if (n.length === 0) {
                    return one;
                }
                let temp = n[0];
                for (let i = 1; i < n.length; i++) {
                    temp = multiply(temp, n[i], $);
                }
                return temp;
            }
            function combine_factors(factors, base, powerL, powerR, $) {
                const X = $.power(base, $.add(powerL, powerR));
                if (is_num(X)) {
                    factors[0] = multiply_num_num(assert_is_num(factors[0]), X);
                }
                else if (is_multiply(X)) {
                    // power can return number * factor (i.e. -1 * i)
                    const candidate = cadr(X);
                    if (is_num(candidate) && is_nil(cdddr(X))) {
                        const arg1 = assert_is_num(factors[0]);
                        const arg2 = candidate;
                        factors[0] = multiply_num_num(arg1, arg2);
                        factors.push(caddr(X));
                    }
                    else {
                        factors.push(X);
                    }
                }
                else {
                    factors.push(X);
                }
            }
            /**
             * A runtime check to ensure that a value is not undefined.
             */
            function assert_not_undefined(arg) {
                if (typeof arg === 'undefined') {
                    throw new Error();
                }
                else {
                    return arg;
                }
            }
            function assert_is_num(expr) {
                if (is_num(expr)) {
                    return expr;
                }
                else {
                    throw new Error();
                }
            }

            let Builder$1I = class Builder {
                create($) {
                    return new MulOperator($);
                }
            };
            /**
             * (*)
             * (* a)
             * (* a b)
             * (* a b c ...)
             */
            class MulOperator extends FunctionVarArgs {
                constructor($) {
                    super('mul_varargs', MATH_MUL$3, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                isScalar(expr) {
                    const $ = this.$;
                    const argList = expr.argList;
                    return [...argList].every((arg) => $.isScalar(arg));
                }
                transform(expr) {
                    const $ = this.$;
                    // console.lg(this.name, render_as_sexpr(expr, $));
                    const hook = (where, retval) => {
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_infix(expr, this.$), "=>", render_as_infix(retval, $));
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_sexpr(expr, this.$), "=>", render_as_sexpr(retval, $));
                        return retval;
                    };
                    const retval = Eval_multiply(expr, $);
                    const flag = retval.equals(expr) ? TFLAG_NONE : TFLAG_DIFF;
                    return [flag, hook('A', retval)];
                }
            }
            const mul_varargs = new Builder$1I();

            let Builder$1H = class Builder {
                create($) {
                    return new NilExtension($);
                }
            };
            class NilExtension {
                constructor($) {
                    this.$ = $;
                    // Nothing to see here.
                }
                get key() {
                    return nil.name;
                }
                get hash() {
                    return HASH_NIL;
                }
                get name() {
                    return 'NilExtension';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    throw new Error();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isKind(expr) {
                    return nil.equals(expr);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(expr) {
                    throw new Error();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isNil(expr) {
                    throw new Error();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    throw new Error();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    throw new Error();
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    else {
                        return expr;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(expr) {
                    return 'nil';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(expr) {
                    return 'nil';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toListString(expr) {
                    return '()';
                }
                evaluate(argList) {
                    return this.transform(cons(nil, argList));
                }
                transform(expr) {
                    if (nil.equals(expr)) {
                        return [TFLAG_HALT, nil];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                valueOf(expr) {
                    return nil;
                }
            }
            const nil_extension = new Builder$1H();

            let Builder$1G = class Builder {
                create($) {
                    return new Op$1o($);
                }
            };
            let Op$1o = class Op extends FunctionVarArgs {
                constructor($) {
                    super('not', NOT, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_not(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const not_fn = new Builder$1G();

            let Builder$1F = class Builder {
                create($) {
                    return new Op$1n($);
                }
            };
            /**
             * Evaluates (number ...) expressions.
             */
            function Eval_number(expr, $) {
                const p1 = $.valueOf(cadr(expr));
                return is_rat(p1) || is_flt(p1) ? one : zero;
            }
            let Op$1n = class Op extends FunctionVarArgs {
                constructor($) {
                    super('number', NUMBER, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_number(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const number_fn = new Builder$1F();

            let Builder$1E = class Builder {
                create($) {
                    return new Op$1m($);
                }
            };
            let Op$1m = class Op extends FunctionVarArgs {
                constructor($) {
                    super('numerator', NUMERATOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_numerator(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const numerator_fn = new Builder$1E();

            let Builder$1D = class Builder {
                create($) {
                    return new Op$1l($);
                }
            };
            let Op$1l = class Op extends FunctionVarArgs {
                constructor($) {
                    super('or', OR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_or(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const or_varargs = new Builder$1D();

            let Builder$1C = class Builder {
                constructor(opr) {
                    this.opr = opr;
                }
                create($) {
                    return new Op$1k(this.opr, $);
                }
            };
            let Op$1k = class Op extends Function2 {
                constructor(opr, $) {
                    super('outer_2_any_any', opr, is_any, is_any, $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_ANY, HASH_ANY);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const lhs = expr.lhs;
                        const rhs = expr.rhs;
                        if (is_multiply(lhs) || is_multiply(rhs)) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs, expr) {
                    // console.lg(`${this.name}`);
                    return [TFLAG_NONE, expr];
                }
            };
            const outer_2_any_any = new Builder$1C(MATH_OUTER);

            function is_mul_2_scalar_any($) {
                const is_scalar$1 = is_scalar($);
                return function (expr) {
                    return is_cons(expr) && is_mul_2_any_any(expr) && is_scalar$1(expr.lhs);
                };
            }

            let Builder$1B = class Builder {
                create($) {
                    return new Op$1j($);
                }
            };
            /**
             * x ^ (a * y) => a * (x ^ y)
             */
            let Op$1j = class Op extends Function2 {
                constructor($) {
                    super('outer_2_any_mul_2_scalar_any', MATH_OUTER, is_any, is_mul_2_scalar_any($), $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_ANY, HASH_ANY);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const lhs = expr.lhs;
                        if (is_multiply(lhs)) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const x = lhs;
                    const a = rhs.lhs;
                    const y = rhs.rhs;
                    const xy = $.valueOf(items_to_cons$1(opr, x, y));
                    const retval = $.valueOf(items_to_cons$1(rhs.opr, a, xy));
                    return [TFLAG_DIFF, retval];
                }
            };
            const outer_2_any_mul_2_scalar_any = new Builder$1B();

            class OuterBladeBladeBuilder {
                create($) {
                    return new OuterBladeBlade($);
                }
            }
            /**
             * Blade ^ Blade
             */
            class OuterBladeBlade extends Function2 {
                constructor($) {
                    super('outer_2_blade_blade', MATH_OUTER, is_blade$1, is_blade$1, $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_binop_atom_atom(MATH_OUTER, HASH_BLADE, HASH_BLADE);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.__wedge__(rhs)];
                }
            }
            const outer_2_blade_blade = new OuterBladeBladeBuilder();

            let Builder$1A = class Builder {
                create($) {
                    return new Op$1i($);
                }
            };
            /**
             * (a * x) ^ y => a * (x ^ y)
             */
            let Op$1i = class Op extends Function2 {
                constructor($) {
                    super('outer_2_mul_2_scalar_any_any', MATH_OUTER, is_mul_2_scalar_any($), is_any, $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_ANY, HASH_ANY);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const a = lhs.lhs;
                    const x = lhs.rhs;
                    const y = rhs;
                    const xy = $.valueOf(items_to_cons$1(MATH_OUTER, x, y));
                    const axy = $.valueOf(items_to_cons$1(MATH_MUL$3, a, xy));
                    return [TFLAG_DIFF, axy];
                }
            };
            const outer_2_mul_2_scalar_any_any = new Builder$1A();

            let Builder$1z = class Builder {
                create($) {
                    return new Op$1h($);
                }
            };
            let Op$1h = class Op extends Function2 {
                constructor($) {
                    super('outer_2_sym_sym', MATH_OUTER, is_sym, is_sym, $);
                    this.dependencies = ['Vector'];
                    this.hash = hash_binop_atom_atom(MATH_OUTER, HASH_SYM, HASH_SYM);
                }
                transform2(opr, lhs, rhs, expr) {
                    return [TFLAG_HALT, expr];
                }
            };
            const outer_2_sym_sym = new Builder$1z();

            let Builder$1y = class Builder {
                create($) {
                    return new Op$1g($);
                }
            };
            function outer_tensor_tensor(p1, p2, $) {
                const ndim = p1.ndim + p2.ndim;
                if (ndim > MAXDIM) {
                    halt('outer: rank of result exceeds maximum');
                }
                const dims = [...p1.copyDimensions(), ...p2.copyDimensions()];
                const elems = [];
                let k = 0;
                for (let i = 0; i < p1.nelem; i++) {
                    for (let j = 0; j < p2.nelem; j++) {
                        elems[k++] = $.multiply(p1.elem(i), p2.elem(j));
                    }
                }
                return new Tensor(dims, elems);
            }
            let Op$1g = class Op extends Function2 {
                constructor($) {
                    super('outer_2_tensor_tensor', MATH_OUTER, is_tensor, is_tensor, $);
                    this.dependencies = [];
                    this.hash = hash_binop_atom_atom(MATH_OUTER, HASH_TENSOR, HASH_TENSOR);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    return [TFLAG_DIFF, outer_tensor_tensor(lhs, rhs, $)];
                }
            };
            const outer_2_tensor_tensor = new Builder$1y();

            function count_imu_factors(expr) {
                return count_factors(expr, is_imu);
            }

            function divide_by_imu(expr, $) {
                // TODO: This could be optimized by detecting simple inputs.
                const A = expr;
                const B = $.valueOf(items_to_cons$1(MATH_MUL$3, A, imu));
                const C = $.valueOf(items_to_cons$1(MATH_MUL$3, B, negOne));
                return C;
            }

            let Builder$1x = class Builder {
                create($) {
                    return new Op$1f($);
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$f(lhs, rhs) {
                return is_base_of_natural_logarithm(lhs);
            }
            /**
             * (expt e X) is equivalent to exp(X)
             */
            let Op$1f = class Op extends Function2X {
                constructor($) {
                    super('pow_2_e_any', MATH_POW$2, is_sym, is_any, cross$f, $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_SYM, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, base, expo, outerExp) {
                    // console.lg(this.name, this.$.toInfixString(base), this.$.toInfixString(expo));
                    const $ = this.$;
                    if ($.getNativeDirective(Directive.evaluatingAsPolar)) ;
                    else if ($.getNativeDirective(Directive.evaluatingTrigAsExp)) ;
                    else {
                        // Conversion of (expt e to trigonometric form, when expanding.
                        if ($.isExpanding()) {
                            // TODO: We could also consider the case of blades whose square is -1.
                            if (is_imu(expo)) {
                                const c = items_to_cons$1(MATH_COS, one);
                                const s = items_to_cons$1(MATH_SIN$1, one);
                                const i_times_s = items_to_cons$1(MATH_MUL$3, imu, s);
                                return [TFLAG_DIFF, items_to_cons$1(MATH_ADD$1, c, i_times_s)];
                            }
                            // The following block of code is not very general because it assumes that the exponent
                            // involves only binary multiplication. This would only occur in simple cases
                            // or when the association of multiplication is explicit.
                            if (is_cons(expo) && is_mul_2_any_any(expo)) {
                                const expo_lhs = expo.lhs;
                                const expo_rhs = expo.rhs;
                                // Euler's identity exp(i * pi), but may not work because of canonical ordering.
                                // TODO: Shouldn't need this since it is a special case of Euler's formula.
                                if (is_imu(expo_lhs)) {
                                    if (is_pi(expo_rhs)) {
                                        // Euler's identity.
                                        // console.lg(`Euler 1`);
                                        return [TFLAG_DIFF, negOne];
                                    }
                                    if ($.is_real(expo_rhs)) {
                                        // console.lg(`Euler 2`);
                                        const c = items_to_cons$1(MATH_COS, expo_rhs);
                                        const s = items_to_cons$1(MATH_SIN$1, expo_rhs);
                                        const i_times_s = items_to_cons$1(MATH_MUL$3, imu, s);
                                        return [TFLAG_DIFF, items_to_cons$1(MATH_ADD$1, c, i_times_s)];
                                    }
                                }
                                // Euler's formula
                                // exp(X*i) = cos(X) + i * sin(X)
                                // expo_lhs=X
                                // expo_rhs=i
                                if ($.is_real(expo_lhs) && is_imu(expo_rhs)) {
                                    // console.lg(`Euler 3 ${render_as_infix(expr, $)} meta=${keepFlag(expr.meta)}`);
                                    if (keepFlag(outerExp.meta)) {
                                        return [TFLAG_NONE, outerExp];
                                    }
                                    else {
                                        const c = $.valueOf(items_to_cons$1(MATH_COS, expo_lhs));
                                        const s = $.valueOf(items_to_cons$1(MATH_SIN$1, expo_lhs));
                                        const s_times_i = $.valueOf(items_to_cons$1(MATH_MUL$3, s, imu));
                                        return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_ADD$1, c, s_times_i))];
                                    }
                                }
                                // Euler's formula with rational factor.
                                // exp(k*X*i) = cos(k*X) + i * sin(k*X)
                                // (k * X) * i
                                // expo_lhs=k*X
                                // expo_rhs=i
                                if (is_cons(expo_lhs) && is_opr_2_lhs_any(MATH_MUL$3, is_rat)(expo_lhs) && $.is_real(expo_lhs.rhs) && is_imu(expo_rhs)) {
                                    // console.lg(`Euler 4`);
                                    //
                                    // const k = expo_lhs.lhs;
                                    // const X = expo_lhs.rhs;
                                    const c = items_to_cons$1(MATH_COS, expo_lhs);
                                    const s = items_to_cons$1(MATH_SIN$1, expo_lhs);
                                    const s_times_i = items_to_cons$1(MATH_MUL$3, s, imu);
                                    return [TFLAG_DIFF, items_to_cons$1(MATH_ADD$1, c, s_times_i)];
                                }
                                if (is_cons(expo_rhs) && is_cons_opr_eq_sym(expo_rhs, native_sym(Native.log))) {
                                    // exp(a*log(b)) = b^a
                                    const a = expo_lhs;
                                    const b = expo_rhs.argList.head;
                                    return [TFLAG_DIFF, $.valueOf(items_to_cons$1(MATH_POW$2, b, a))];
                                }
                            }
                            if (is_cons(expo) && is_cons_opr_eq_mul(expo)) {
                                const N = count_imu_factors(expo);
                                if (N === 1) {
                                    const x = divide_by_imu(expo, $);
                                    return [TFLAG_DIFF, euler_formula(x, $)];
                                }
                            }
                        }
                        if ($.isFactoring()) {
                            return [TFLAG_DIFF, items_to_cons$1(MATH_EXP, expo)];
                        }
                    }
                    return [TFLAG_NONE, outerExp];
                }
            };
            function euler_formula(x, $) {
                const c = $.valueOf(items_to_cons$1(MATH_COS, x));
                const s = $.valueOf(items_to_cons$1(MATH_SIN$1, x));
                const i_times_s = $.valueOf(items_to_cons$1(MATH_MUL$3, imu, s));
                return $.valueOf(items_to_cons$1(MATH_ADD$1, c, i_times_s));
            }
            const pow_2_e_any = new Builder$1x();

            const LOG = native_sym(Native.log);
            const POW$2 = native_sym(Native.pow);
            let Builder$1w = class Builder {
                create($) {
                    return new Op$1e($);
                }
            };
            function cross$e(base, expo) {
                if (is_base_of_natural_logarithm(base)) {
                    if (is_cons(expo)) {
                        const opr = expo.head;
                        return is_sym(opr) && opr.equalsSym(LOG);
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            /**
             * exp(log(x)) => x
             */
            let Op$1e = class Op extends Function2X {
                constructor($) {
                    super('pow_2_e_log', POW$2, is_sym, is_cons, cross$e, $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_SYM, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, base, expo, expr) {
                    const x = expo.argList.head;
                    return [TFLAG_DIFF, x];
                }
            };
            const pow_2_e_log = new Builder$1w();

            let Builder$1v = class Builder {
                create($) {
                    return new Op$1d($);
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function cross$d(lhs, rhs) {
                return is_base_of_natural_logarithm(lhs) && is_rat(rhs);
            }
            /**
             * (expt e X) is equivalent to exp(X)
             */
            let Op$1d = class Op extends Function2X {
                constructor($) {
                    super('pow_2_e_rat', MATH_POW$2, is_sym, is_rat, cross$d, $);
                    this.hash = hash_binop_atom_atom(this.opr, HASH_SYM, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, base, expo, expr) {
                    if (expo.isZero()) {
                        return [TFLAG_NONE, one];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const pow_2_e_rat = new Builder$1v();

            let Builder$1u = class Builder {
                create($) {
                    return new Op$1c($);
                }
            };
            let Op$1c = class Op extends Function2 {
                constructor($) {
                    super('pow_2_imu_rat', MATH_POW$2, is_imu, is_rat, $);
                    this.hash = hash_binop_atom_atom(MATH_POW$2, HASH_IMU, HASH_RAT);
                }
                isScalar() {
                    return true;
                }
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    // TODO: Generalize
                    if (rhs.isTwo()) {
                        return [TFLAG_DIFF, negOne];
                    }
                    else if (rhs.isMinusOne()) {
                        return [TFLAG_DIFF, $.negate(imu)];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const pow_2_imu_rat = new Builder$1u();

            let Builder$1t = class Builder {
                create($) {
                    return new Op$1b($);
                }
            };
            const guardL$c = and(is_cons, is_opr_2_lhs_rhs(MATH_POW$2, is_base_of_natural_logarithm, and(is_cons, is_mul_2_rat_sym)));
            const guardR$c = is_rat;
            function cross$c(lhs, rhs) {
                const m = lhs.rhs.lhs;
                const n = rhs;
                return m.isTwo() && n.isHalf();
            }
            /**
             * (expt (expt e (* 2 x)) 1/2) => (expt e x)
             */
            let Op$1b = class Op extends Function2X {
                constructor($) {
                    super('pow_2_pow_2_e_any_rat', MATH_POW$2, guardL$c, guardR$c, cross$c, $);
                    this.hash = hash_binop_cons_atom(this.opr, MATH_POW$2, HASH_ANY);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    const $ = this.$;
                    const x = lhs.rhs.rhs;
                    const e = lhs.lhs;
                    const retval = $.valueOf(items_to_cons$1(MATH_POW$2, e, x));
                    return [TFLAG_DIFF, retval];
                }
            };
            const pow_2_pow_2_e_any_rat = new Builder$1t();

            let Builder$1s = class Builder {
                create($) {
                    return new Pred($);
                }
            };
            class Pred extends Function1 {
                constructor($) {
                    super('pred_any', create_sym('pred'), is_any, $);
                    this.name = 'pred_any';
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                }
            }
            const pred_any = new Builder$1s();

            let Builder$1r = class Builder {
                create($) {
                    return new PredRat($);
                }
            };
            class PredRat extends Function1 {
                constructor($) {
                    super('pred_rat', create_sym('pred'), is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg.pred()];
                }
            }
            const pred_rat = new Builder$1r();

            function render_as_human(expr, $) {
                const codeGen = defs.codeGen;
                const printMode = defs.printMode;
                defs.codeGen = false;
                defs.setPrintMode(PRINTMODE_HUMAN);
                try {
                    let str = render_using_non_sexpr_print_mode(expr, $);
                    // some variables might contain underscores, escape those
                    str = str.replace(/_/g, '\\_');
                    return str;
                }
                finally {
                    defs.codeGen = codeGen;
                    defs.setPrintMode(printMode);
                }
            }

            function render_using_print_mode(expr, printMode, $) {
                switch (printMode) {
                    case PRINTMODE_ASCII: return render_as_ascii(expr, $);
                    case PRINTMODE_HUMAN: return render_as_human(expr, $);
                    case PRINTMODE_INFIX: return render_as_infix(expr, $);
                    case PRINTMODE_LATEX: return render_as_latex(expr, $);
                    case PRINTMODE_SEXPR: return render_as_sexpr(expr, $);
                    default: throw new Error(printMode);
                }
            }

            /**
             * Base class for symbols that are keywords.
             */
            class KeywordOperator {
                constructor(keyword, $) {
                    this.keyword = keyword;
                    this.$ = $;
                    // Nothing to see here.
                }
                isImag(expr) {
                    throw new Error("Keyword Symbol Method not implemented.");
                }
                isKind(expr) {
                    if (is_sym(expr)) {
                        return expr.equalsSym(this.keyword);
                    }
                    return false;
                }
                isMinusOne(expr) {
                    throw new Error("Keyword.isMinusOne Symbol Method not implemented.");
                }
                isOne(expr) {
                    throw new Error("Keyword.isOne Symbol Method not implemented.");
                }
                isReal(expr) {
                    throw new Error("Keyword.isReal Symbol Method not implemented.");
                }
                isScalar(expr) {
                    throw new Error("Keyword.isScalar Symbol Method not implemented.");
                }
                isZero(expr) {
                    throw new Error("Keyword.isZero Symbol Method not implemented.");
                }
                subst(expr, oldExpr, newExpr) {
                    throw new Error("Keyword.subst Symbol Method not implemented.");
                }
                toInfixString(expr) {
                    return expr.text;
                }
                toLatexString(expr) {
                    throw new Error("Keyword.toLatexString Symbol Method not implemented.");
                }
                toListString(expr) {
                    return this.keyword.key();
                }
                evaluate(expr, argList) {
                    // TODO: expr should be the same as the keyword.
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    throw new Error("Keyword.transform Symbol Method not implemented.");
                }
                valueOf(expr) {
                    throw new Error("Keyword.valueOf Symbol Method not implemented.");
                }
            }

            /**
             * any.Sym
             */
            const TYPE_NAME_SYM = create_sym('Sym');

            class PrintKeyword extends KeywordOperator {
                constructor(keyword, printMode, $) {
                    super(create_sym(keyword), $);
                    this.printMode = printMode;
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return this.keyword.text;
                }
                transform(expr) {
                    // Because of our hash, we are being matched with any symbol.
                    if (is_sym(expr) && expr.equalsSym(this.keyword)) {
                        const $ = this.$;
                        const printMode = this.printMode();
                        const origPrintMode = defs.printMode;
                        defs.setPrintMode(printMode);
                        try {
                            const last = $.getSymbolValue(RESERVED_KEYWORD_LAST);
                            const str = render_using_print_mode(last, printMode, $);
                            const printHandler = this.$.getPrintHandler();
                            printHandler.print(str);
                            store_text_in_binding(str, get_last_print_mode_symbol(printMode), $);
                            return [TFLAG_DIFF, nil];
                        }
                        finally {
                            defs.setPrintMode(origPrintMode);
                        }
                    }
                    return [TFLAG_NONE, expr];
                }
            }
            let Builder$1q = class Builder {
                constructor(keyword, printMode) {
                    this.keyword = keyword;
                    this.printMode = printMode;
                }
                create($) {
                    return new PrintKeyword(this.keyword, this.printMode, $);
                }
            };
            function make_printmode_keyword(keyword, printMode) {
                return new Builder$1q(keyword, printMode);
            }

            class PrintModeOperator extends Function1 {
                constructor(opr, printMode, $) {
                    super(opr, create_sym(opr), is_any, $);
                    this.printMode = printMode;
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg) {
                    const $ = this.$;
                    const argList = items_to_cons$1(arg);
                    if (is_cons(argList)) {
                        const texts = print_in_mode(argList, this.printMode(), $);
                        const printHandler = this.$.getPrintHandler();
                        printHandler.print(...texts);
                    }
                    return [TFLAG_DIFF, nil];
                }
            }
            let Builder$1p = class Builder {
                constructor(opr, printMode) {
                    this.opr = opr;
                    this.printMode = printMode;
                }
                create($) {
                    return new PrintModeOperator(this.opr, this.printMode, $);
                }
            };
            function make_printmode_operator(opr, printMode) {
                return new Builder$1p(opr, printMode);
            }

            // 'product' function
            //define A p3
            //define B p4
            //define I p5
            //define X p6
            // leaves the product at the top of the stack
            function Eval_product(p1, $) {
                // 1st arg
                const body = cadr(p1);
                // 2nd arg (index)
                const indexVariable = caddr(p1);
                if (!is_sym(indexVariable)) {
                    halt('sum: 2nd arg?');
                }
                // 3rd arg (lower limit)
                const j = evaluate_integer(cadddr(p1), $);
                if (isNaN(j)) {
                    return p1;
                }
                // 4th arg (upper limit)
                const k = evaluate_integer(caddddr(p1), $);
                if (isNaN(k)) {
                    return p1;
                }
                // remember contents of the index
                // variable so we can put it back after the loop
                const oldIndexVariableValue = $.getSymbolValue(indexVariable);
                let temp = one;
                for (let i = j; i <= k; i++) {
                    $.setSymbolValue(indexVariable, create_int(i));
                    const arg2 = $.valueOf(body);
                    temp = $.multiply(temp, arg2);
                }
                // put back the index variable to original content
                $.setSymbolValue(indexVariable, oldIndexVariableValue);
                return temp;
            }

            let Builder$1o = class Builder {
                create($) {
                    return new Op$1a($);
                }
            };
            let Op$1a = class Op extends FunctionVarArgs {
                constructor($) {
                    super('product', PRODUCT, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_product(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const product_varargs = new Builder$1o();

            // quote definition
            function Eval_quote(p1) {
                return cadr(p1);
            }

            let Builder$1n = class Builder {
                create($) {
                    return new Op$19($);
                }
            };
            let Op$19 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('quotient', QUOTIENT, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_quotient(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const quotient_varargs = new Builder$1n();

            function Eval_rank(expr, $) {
                const value = $.valueOf(expr.argList.car);
                return is_tensor(value) ? create_int(value.rank) : zero;
            }

            let Builder$1m = class Builder {
                create($) {
                    return new Op$18($);
                }
            };
            let Op$18 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('rank', RANK, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_rank(expr, $);
                    return [TFLAG_DIFF, retval];
                }
            };
            const rank_varargs = new Builder$1m();

            let Builder$1l = class Builder {
                create($) {
                    return new Op$17($);
                }
            };
            let Op$17 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('rationalize', RATIONALIZE, $);
                    this.phases = MODE_FLAGS_ALL;
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_rationalize(expr, $);
                    // console.lg(`rationalize() => ${print_expr(retval, $)}`);
                    const flags = retval.equals(expr) ? TFLAG_NONE : TFLAG_HALT;
                    return [flags, retval];
                }
            };
            const rationalize_fn = new Builder$1l();

            let Builder$1k = class Builder {
                create($) {
                    return new Op$16($);
                }
            };
            let Op$16 = class Op extends Function2 {
                constructor($) {
                    super('rco_2_any_any', MATH_RCO, is_any, is_any, $);
                    this.hash = hash_binop_atom_atom(MATH_RCO, HASH_ANY, HASH_ANY);
                }
                transform2(opr, lhs, rhs, expr) {
                    return [TFLAG_NONE, expr];
                }
            };
            const rco_2_any_any = new Builder$1k();

            let Builder$1j = class Builder {
                create($) {
                    return new Op$15($);
                }
            };
            /**
             * x >> (a * y) => a * (x >> y)
             */
            let Op$15 = class Op extends Function2 {
                constructor($) {
                    super('rco_2_any_mul_2_scalar_any', MATH_RCO, is_any, is_mul_2_scalar_any($), $);
                    this.hash = hash_binop_atom_cons(MATH_RCO, HASH_ANY, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const x = lhs;
                    const a = rhs.lhs;
                    const y = rhs.rhs;
                    const xy = $.valueOf(items_to_cons$1(opr, x, y));
                    const retval = $.valueOf(items_to_cons$1(rhs.opr, a, xy));
                    return [TFLAG_DIFF, retval];
                }
            };
            const rco_2_any_mul_2_scalar_any = new Builder$1j();

            let Builder$1i = class Builder {
                create($) {
                    return new Op$14($);
                }
            };
            let Op$14 = class Op extends Function2 {
                constructor($) {
                    super('rco_2_blade_blade', MATH_RCO, is_blade$1, is_blade$1, $);
                    this.hash = hash_binop_atom_atom(MATH_RCO, HASH_BLADE, HASH_BLADE);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.__rshift__(rhs)];
                }
            };
            const rco_2_blade_blade = new Builder$1i();

            let Builder$1h = class Builder {
                create($) {
                    return new Op$13($);
                }
            };
            /**
             * (a * x) >> y => a * (x >> y)
             */
            let Op$13 = class Op extends Function2 {
                constructor($) {
                    super('rco_2_mul_2_scalar_any_any', MATH_RCO, is_mul_2_scalar_any($), is_any, $);
                    this.hash = hash_binop_cons_atom(MATH_RCO, MATH_MUL$3, HASH_ANY);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const a = lhs.lhs;
                    const x = lhs.rhs;
                    const y = rhs;
                    const xy = $.valueOf(items_to_cons$1(opr, x, y));
                    const axy = $.valueOf(items_to_cons$1(lhs.opr, a, xy));
                    return [TFLAG_DIFF, axy];
                }
            };
            const rco_2_mul_2_scalar_any_any = new Builder$1h();

            const ADD$2 = native_sym(Native.add);
            const REAL$7 = native_sym(Native.real);
            let Builder$1g = class Builder {
                create($) {
                    return new Op$12($);
                }
            };
            /**
             * real(a + b + ...) = real(a) + real(b) + ...
             */
            let Op$12 = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL$7, ADD$2, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const argList = innerExpr.argList;
                    const A = argList.map(function (arg) {
                        return $.valueOf(items_to_cons$1(REAL$7, arg));
                    });
                    const sum = $.valueOf(cons(ADD$2, A));
                    return [TFLAG_NONE, sum];
                }
            };
            const real_add = new Builder$1g();

            let Builder$1f = class Builder {
                create($) {
                    return new Op$11($);
                }
            };
            let Op$11 = class Op extends Function1 {
                constructor($) {
                    super('real', REAL$b, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                    /*
                    const $ = this.$;
                    const retval = real(arg, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                    */
                }
            };
            const real_any = new Builder$1f();

            const COS = native_sym(Native.cos);
            const REAL$6 = native_sym(Native.real);
            let Builder$1e = class Builder {
                create($) {
                    return new Op$10($);
                }
            };
            /**
             * real(cos(z)) = cos(z) when z is real
             */
            let Op$10 = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL$6, COS, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const z = innerExpr.argList.head;
                    if ($.is_real(z)) {
                        return [TFLAG_DIFF, innerExpr];
                    }
                    else {
                        return [TFLAG_NONE, outerExpr];
                    }
                }
            };
            const real_cos = new Builder$1e();

            const EXP$1 = native_sym(Native.exp);
            const REAL$5 = native_sym(Native.real);
            let Builder$1d = class Builder {
                create($) {
                    return new Op$$($);
                }
            };
            /**
             *
             */
            let Op$$ = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL$5, EXP$1, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    const z = innerExpr.argList.head;
                    if ($.is_real(z)) {
                        return [TFLAG_DIFF, innerExpr];
                    }
                    else {
                        return [TFLAG_NONE, outerExpr];
                    }
                }
            };
            const real_exp = new Builder$1d();

            const REAL$4 = native_sym(Native.real);
            let Builder$1c = class Builder {
                create($) {
                    return new Op$_($);
                }
            };
            let Op$_ = class Op extends Function1 {
                constructor($) {
                    super('real_flt', REAL$4, is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, arg];
                }
            };
            const real_flt = new Builder$1c();

            const IMAG$1 = native_sym(Native.imag);
            const REAL$3 = native_sym(Native.real);
            let Builder$1b = class Builder {
                create($) {
                    return new Op$Z($);
                }
            };
            /**
             * real(imag(z)) = imag(z)
             */
            let Op$Z = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL$3, IMAG$1, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    return [TFLAG_DIFF, innerExpr];
                }
            };
            const real_imag = new Builder$1b();

            let Builder$1a = class Builder {
                create($) {
                    return new Op$Y($);
                }
            };
            let Op$Y = class Op extends Function1 {
                constructor($) {
                    super('real', REAL$b, is_imu, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_IMU);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_DIFF, zero];
                }
            };
            const real_imu = new Builder$1a();

            const real$1 = native_sym(Native.real);
            const log$1 = native_sym(Native.log);
            let Builder$19 = class Builder {
                create($) {
                    return new Op$X($);
                }
            };
            let Op$X = class Op extends CompositeOperator {
                constructor($) {
                    super(real$1, log$1, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const logExpr = expr.argList.head;
                        const x = logExpr.argList.head;
                        return is_imu(x);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, logExpr) {
                    return [TFLAG_DIFF, zero];
                }
            };
            const real_log_imu = new Builder$19();

            const real = native_sym(Native.real);
            const log = native_sym(Native.log);
            let Builder$18 = class Builder {
                create($) {
                    return new Op$W($);
                }
            };
            let Op$W = class Op extends CompositeOperator {
                constructor($) {
                    super(real, log, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const logExpr = expr.argList.head;
                        const x = logExpr.argList.head;
                        return is_rat$1(x);
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, logExpr) {
                    const $ = this.$;
                    const x = logExpr.argList.head;
                    if (is_rat$1(x)) {
                        if (x.isZero()) {
                            // Minus infinity in the limit but undefined at zero.
                            return [TFLAG_DIFF, new Err(logExpr)];
                        }
                        else if (x.isNegative()) {
                            // Complex
                            throw new Error($.toInfixString(x));
                        }
                        else {
                            // We get to remove the real() wrapper.
                            return [TFLAG_DIFF, logExpr];
                        }
                    }
                    else {
                        throw new Error($.toInfixString(x));
                    }
                }
            };
            const real_log_rat = new Builder$18();

            const ADD$1 = native_sym(Native.add);
            const EXP = native_sym(Native.exp);
            const IMAG = native_sym(Native.imag);
            const POW$1 = native_sym(Native.pow);
            const REAL$2 = native_sym(Native.real);
            const MUL = native_sym(Native.multiply);
            function multiply_factors(factors, $) {
                if (factors.length > 1) {
                    return $.valueOf(items_to_cons$1(MUL, ...factors));
                }
                else if (factors.length === 1) {
                    return $.valueOf(factors[0]);
                }
                else {
                    return one;
                }
            }
            let Builder$17 = class Builder {
                create($) {
                    return new Op$V($);
                }
            };
            /**
             */
            let Op$V = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL$2, MUL, $);
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    // console.lg("innerExpr", this.$.toSExprString(innerExpr));
                    const count_imu = count_factors(innerExpr, is_imu);
                    if (count_imu > 0) {
                        const z = remove_factors(innerExpr, is_imu);
                        switch (count_imu % 4) {
                            case 0: {
                                // This would cause an infinite loop if count_imu were 0.
                                return [TFLAG_DIFF, $.real(z)];
                            }
                            case 1: {
                                return [TFLAG_DIFF, $.negate($.imag(z))];
                            }
                            case 2: {
                                return [TFLAG_DIFF, $.negate($.real(z))];
                            }
                            case 3: {
                                return [TFLAG_DIFF, $.imag(z)];
                            }
                            default: {
                                throw new Error(`${count_imu}`);
                            }
                        }
                    }
                    // console.lg("REAL MUL", this.$.toInfixString(outerExpr));
                    // console.lg("Computing Re of a * expression...", $.toSExprString(expr));
                    const rs = []; // the real factors.
                    const cs = []; // the complex factors
                    [...innerExpr.argList].forEach(function (factor) {
                        // console.lg("testing the factor using is_real:", $.toInfixString(factor));
                        if ($.is_real(factor)) {
                            // console.lg("factor is real:", $.toInfixString(factor));
                            rs.push(factor);
                        }
                        else {
                            // console.lg("factor is NOT real:", $.toInfixString(factor));
                            // console.lg("arg is NOT real:", $.toInfixString(arg));
                            // With no boolean response, we have to assume that the argument is not real valued.
                            // How do we make progress with the factors that are complex numbers?
                            if (is_sym(factor)) {
                                // console.lg("arg is Sym and possibly complex", $.toInfixString(arg));
                                const x = items_to_cons$1(REAL$2, factor);
                                const y = items_to_cons$1(IMAG, factor);
                                const iy = items_to_cons$1(MUL, imu, y);
                                const z = items_to_cons$1(ADD$1, x, iy);
                                // console.lg("Z=>", $.toInfixString(z));
                                cs.push(z);
                            }
                            else if (factor.equals(imu)) {
                                // console.lg("arg is imu", $.toInfixString(arg));
                                cs.push(factor);
                            }
                            else if (is_power(factor)) {
                                const base = factor.lhs;
                                const expo = factor.rhs;
                                if (is_rat$1(expo) && expo.isMinusOne()) {
                                    // Get the complex number out of the denominator.
                                    const z_star = $.conj(base);
                                    const denom = $.valueOf(items_to_cons$1(MUL, z_star, base));
                                    const one_over_denom = $.valueOf(items_to_cons$1(POW$1, denom, negOne));
                                    const z = $.valueOf(items_to_cons$1(MUL, z_star, one_over_denom));
                                    cs.push(z);
                                }
                                else {
                                    // console.lg("base", $.toInfixString(base));
                                    // console.lg("expo", $.toInfixString(expo));
                                    // console.lg("YAN");
                                    const r = compute_r_from_base_and_expo(base, expo, $);
                                    // console.lg("r", $.toInfixString(r));
                                    const theta = compute_theta_from_base_and_expo(base, expo, $);
                                    // console.lg("theta", $.toInfixString(theta));
                                    const i_times_theta = $.valueOf(items_to_cons$1(MUL, imu, theta));
                                    const cis_theta = $.valueOf(items_to_cons$1(EXP, i_times_theta));
                                    // console.lg("cis_theta", $.toInfixString(cis_theta));
                                    rs.push(r);
                                    cs.push(cis_theta);
                                }
                            }
                            else if (is_cons(factor) && is_sym(factor.opr)) {
                                cs.push(factor);
                            }
                            else {
                                // console.lg("WT...");
                                // Here we might encounter a function.
                                // So far we've handled math.pow.
                                // How to handle arbitrary functions. e.g. abs, sin, ...
                                throw new Error($.toSExprString(factor));
                            }
                        }
                    });
                    const A = multiply_factors(rs, $);
                    // console.lg("A", $.toInfixString(A));
                    const B = multiply_factors(cs, $);
                    // console.lg("B", $.toInfixString(B));
                    if (B.equals(innerExpr)) {
                        // We didn't make any progress.
                        // We must avoid infinite recursion.
                        return [TFLAG_NONE, outerExpr];
                    }
                    // console.lg("exp", $.toInfixString(expr));
                    const C = $.valueOf(items_to_cons$1(REAL$2, B));
                    // console.lg("C", $.toSExprString(C));
                    const D = $.valueOf(items_to_cons$1(MUL, A, C));
                    // console.lg("D", $.toSExprString(D));
                    // console.lg("real of", $.toInfixString(expr), "is", $.toInfixString(D));
                    return [TFLAG_DIFF, D];
                }
            };
            const real_mul = new Builder$17();

            const PI = native_sym(Native.PI);
            const POW = native_sym(Native.pow);
            const REAL$1 = native_sym(Native.real);
            let Builder$16 = class Builder {
                create($) {
                    return new Op$U($);
                }
            };
            /**
             *
             */
            let Op$U = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL$1, POW, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const innerExpr = expr.argList.head;
                        const base = innerExpr.lhs;
                        const expo = innerExpr.rhs;
                        return is_rat$1(base) && is_rat$1(expo);
                    }
                    else {
                        return false;
                    }
                }
                transform1(opr, innerExpr, outerExpr) {
                    const $ = this.$;
                    // TODO: What do we do about roots of unity?
                    const base = assert_rat(innerExpr.lhs);
                    // console.lg("base",$.toInfixString(base));
                    if (base.isMinusOne()) {
                        // We have a clock form z = (-1)^s.
                        // x+iy = (-1)^s
                        // log(x+iy) = s*log(-1) = s*i*pi
                        // x+iy = exp(i*s*pi) = cos(s*pi)+i*sin(s*pi) 
                        const s = assert_rat(innerExpr.rhs);
                        return [TFLAG_DIFF, $.cos($.multiply(s, PI))];
                    }
                    else if (base.isPositive()) {
                        return [TFLAG_DIFF, innerExpr];
                    }
                    else {
                        // const expo = assert_rat(innerExpr.rhs);
                        return [TFLAG_DIFF, outerExpr];
                    }
                }
            };
            const real_pow_rat_rat = new Builder$16();

            let Builder$15 = class Builder {
                create($) {
                    return new Op$T($);
                }
            };
            let Op$T = class Op extends Function1 {
                constructor($) {
                    super('real_rat', REAL$b, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, arg];
                }
            };
            const real_rat = new Builder$15();

            const REAL = native_sym(Native.real);
            let Builder$14 = class Builder {
                create($) {
                    return new Op$S($);
                }
            };
            /**
             * real(real(z)) = imag(z)
             */
            let Op$S = class Op extends CompositeOperator {
                constructor($) {
                    super(REAL, REAL, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, outerExpr) {
                    return [TFLAG_DIFF, innerExpr];
                }
            };
            const real_real = new Builder$14();

            let Builder$13 = class Builder {
                create($) {
                    return new Op$R($);
                }
            };
            let Op$R = class Op extends Function1 {
                constructor($) {
                    super('real', REAL$b, is_sym, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_SYM);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    if ($.is_real(arg)) {
                        return [TFLAG_NONE, arg];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const real_sym = new Builder$13();

            const not_is_rat = (expr) => !is_rat$1(expr);
            const rect$1 = native_sym(Native.rect);
            const mul = native_sym(Native.multiply);
            let Builder$12 = class Builder {
                create($) {
                    return new Op$Q($);
                }
            };
            /**
             * rect(Rat*z) => rect(Rat * rect(z))
             */
            let Op$Q = class Op extends CompositeOperator {
                constructor($) {
                    super(rect$1, mul, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        // console.lg("expr", expr.toString());
                        const mulExpr = expr.argList.head;
                        return count_factors(mulExpr, is_rat$1) == 1;
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, expr) {
                    const $ = this.$;
                    // console.lg("innerExpr", this.$.toInfixString(innerExpr));
                    const lhs = assert_rat(remove_factors(innerExpr, not_is_rat));
                    const rhs = remove_factors(innerExpr, is_rat$1);
                    // console.lg("lhs", this.$.toInfixString(lhs));
                    // console.lg("rhs", this.$.toInfixString(rhs));
                    const rect_z = $.valueOf(items_to_cons$1(rect$1, rhs));
                    const rat_times_rect_z = $.valueOf(items_to_cons$1(mul, lhs, rect_z));
                    return [TFLAG_DIFF, rat_times_rect_z];
                }
            };
            const rect_mul_rat_any = new Builder$12();

            const rect = native_sym(Native.rect);
            const pow = native_sym(Native.pow);
            let Builder$11 = class Builder {
                create($) {
                    return new Op$P($);
                }
            };
            /**
             *
             */
            let Op$P = class Op extends CompositeOperator {
                constructor($) {
                    super(rect, pow, $);
                }
                isKind(expr) {
                    if (super.isKind(expr)) {
                        const powExpr = expr.argList.head;
                        // console.lg("powExpr", this.$.toSExprString(powExpr));
                        const base = powExpr.lhs;
                        // console.lg("base", this.$.toSExprString(base));
                        const expo = powExpr.rhs;
                        // console.lg("expo", this.$.toSExprString(expo));
                        if (is_base_of_natural_logarithm(base)) {
                            // console.lg("is_base OK");
                            if (is_cons(expo) && count_factors(expo, is_imu) == 1) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        else {
                            // console.lg("base is not e", this.$.toSExprString(base));
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, innerExpr, expr) {
                    return [TFLAG_DIFF, expr];
                }
            };
            const rect_pow_exp_imu = new Builder$11();

            let Builder$10 = class Builder {
                create($) {
                    return new Op$O($);
                }
            };
            let Op$O = class Op extends FunctionVarArgs {
                constructor($) {
                    super('roots_varargs', ROOTS, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_roots(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const roots_varargs = new Builder$10();

            function Eval_round(p1, $) {
                const result = yround($.valueOf(cadr(p1)), $);
                return result;
            }
            function yround(expr, $) {
                if (!is_num(expr)) {
                    return items_to_cons(ROUND, expr);
                }
                if (is_flt$1(expr)) {
                    return create_flt(Math.round(expr.d));
                }
                if (is_rat_and_integer(expr)) {
                    return expr;
                }
                const retval = evaluate_as_float(expr, $);
                if (is_flt$1(retval)) {
                    return create_int(Math.round(retval.d));
                }
                else {
                    return retval;
                }
            }

            let Builder$$ = class Builder {
                create($) {
                    return new Op$N($);
                }
            };
            let Op$N = class Op extends FunctionVarArgs {
                constructor($) {
                    super('round', ROUND, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_round(expr, $);
                    return [TFLAG_DIFF, retval];
                }
            };
            const round_varargs = new Builder$$();

            let Builder$_ = class Builder {
                create($) {
                    return new ScriptLast($);
                }
            };
            class ScriptLast extends KeywordOperator {
                constructor($) {
                    super(RESERVED_KEYWORD_LAST, $);
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return 'ScriptLast';
                }
                evaluate(argList) {
                    return this.transform(cons(RESERVED_KEYWORD_LAST, argList));
                }
                transform(expr) {
                    if (this.isKind(expr)) {
                        return [TFLAG_DIFF, this.$.getSymbolValue(RESERVED_KEYWORD_LAST)];
                    }
                    return [TFLAG_NONE, expr];
                }
            }
            const script_last_0 = new Builder$_();

            let Builder$Z = class Builder {
                create($) {
                    return new SgnFlt($);
                }
            };
            class SgnFlt extends Function1 {
                constructor($) {
                    super('sgn_flt', SGN, is_flt$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, sgn_of_flt(arg)];
                }
            }
            const sgn_flt = new Builder$Z();
            // const not_is_flt = (expr: U) => !is_flt(expr);
            /*
            function sgn_extension_flt(expr: Cons, $: ExtensionEnv): U {
                const arg = $.valueOf(expr.argList.car);
                if (is_flt(arg)) {
                    return sgn_of_flt(arg);
                }
                if (is_multiply(arg) && count_factors(arg, is_flt) === 1) {
                    const rem = remove_factors(arg, is_flt);
                    const rat = assert_flt(remove_factors(arg, not_is_flt));
                    const srat = sgn_of_flt(rat);
                    const srem = sgn(rem, $);
                    return $.multiply(srat, srem);
                }
                return expr;
            }
            */
            function sgn_of_flt(arg) {
                if (arg.d > 0) {
                    return one;
                }
                if (arg.d === 0) {
                    return zero;
                }
                return negOne;
            }
            /*
            function assert_flt(expr: U): Flt {
                if (is_flt(expr)) {
                    return expr;
                }
                else {
                    throw new Error();
                }
            }
            */

            let Builder$Y = class Builder {
                create($) {
                    return new SgnRat($);
                }
            };
            class SgnRat extends Function1 {
                constructor($) {
                    super('sgn_rat', SGN, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, sgn_of_rat(arg)];
                }
            }
            const sgn_rat = new Builder$Y();
            // const not_is_rat = (expr: U) => !is_rat(expr);
            /*
            export function sgn_extension_rat(expr: Cons, $: ExtensionEnv): U {
                const arg = $.valueOf(expr.argList.car);
                if (is_rat(arg)) {
                    return sgn_of_rat(arg);
                }
                if (is_multiply(arg) && count_factors(arg, is_rat) === 1) {
                    const rem = remove_factors(arg, is_rat);
                    const rat = assert_rat(remove_factors(arg, not_is_rat));
                    const srat = sgn_of_rat(rat);
                    const srem = sgn(rem, $);
                    return $.multiply(srat, srem);
                }
                return expr;
            }
            */
            function sgn_of_rat(arg) {
                const ab = mmul(arg.a, arg.b);
                if (ab.isNegative()) {
                    return negOne;
                }
                if (ab.isZero()) {
                    return zero;
                }
                return one;
            }
            /*
            function assert_rat(expr: U): Rat {
                if (is_rat(expr)) {
                    return expr;
                }
                else {
                    throw new Error();
                }
            }
            */

            // shape of tensor
            function Eval_shape(p1, $) {
                const result = shape($.valueOf(cadr(p1)), $);
                return result;
            }
            function shape(M, $) {
                if (!is_tensor(M)) {
                    if (!$.is_zero(M)) {
                        halt('transpose: tensor expected, 1st arg is not a tensor');
                    }
                    return zero;
                }
                const { ndim: rank } = M;
                const elems = new Array(rank);
                const dims = [rank];
                for (let i = 0; i < rank; i++) {
                    elems[i] = create_int(M.dim(i));
                }
                return new Tensor(dims, elems);
            }

            let Builder$X = class Builder {
                create($) {
                    return new Op$M($);
                }
            };
            let Op$M = class Op extends FunctionVarArgs {
                constructor($) {
                    super('shape', SHAPE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_shape(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const shape_varargs = new Builder$X();

            function Eval_simplify(expr, $) {
                // console.lg(`Eval_simplify expr = ${$.toInfixString(expr)}`);
                const arg = run_user_defined_simplifications(cadr(expr), $);
                // console.lg(`Eval_simplify ${$.toInfixString(expr)} arg = ${$.toInfixString(arg)}`);
                const result = simplify($.valueOf(arg), $);
                // console.lg(`Eval_simplify result = ${$.toInfixString(result)}`);
                return result;
            }
            function run_user_defined_simplifications(p, $) {
                // -----------------------
                // unfortunately for the time being user
                // specified simplifications are only
                // run in things which don't contain
                // integrals.
                // Doesn't work yet, could be because of
                // some clobbering as "transform" is called
                // recursively?
                if (defs.userSimplificationsInListForm.length === 0 || p.contains(INTEGRAL)) {
                    return p;
                }
                let F1 = noexpand_unary(function (x) {
                    return $.valueOf(x);
                }, p, $);
                let atLeastOneSuccessInRouldOfRulesApplications = true;
                let numberOfRulesApplications = 0;
                while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {
                    atLeastOneSuccessInRouldOfRulesApplications = false;
                    numberOfRulesApplications++;
                    for (const eachSimplification of Array.from(defs.userSimplificationsInListForm)) {
                        let success = true;
                        let eachConsecutiveRuleApplication = 0;
                        while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {
                            eachConsecutiveRuleApplication++;
                            [F1, success] = transform$1(F1, nil, eachSimplification, true, $);
                            if (success) {
                                atLeastOneSuccessInRouldOfRulesApplications = true;
                            }
                        }
                        if (eachConsecutiveRuleApplication ===
                            MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {
                            halt(`maximum application of single transformation rule exceeded: ${$.toInfixString(eachSimplification)}`);
                        }
                    }
                }
                if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {
                    halt('maximum application of all transformation rules exceeded ');
                }
                return F1;
            }

            let Builder$W = class Builder {
                create($) {
                    return new Op$L($);
                }
            };
            let Op$L = class Op extends FunctionVarArgs {
                constructor($) {
                    super('simplify_varargs', SIMPLIFY, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_simplify(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const simplify_varargs = new Builder$W();

            function is_mul_2_blade_any(expr) {
                return is_mul_2_any_any(expr) && is_blade$1(expr.lhs);
            }

            let Builder$V = class Builder {
                create($) {
                    return new Op$K($);
                }
            };
            /**
             * Blade1 * (Blade2 * X) => (Blade1 * Blade2) * X
             */
            let Op$K = class Op extends Function2 {
                constructor($) {
                    super('simplify_mul_2_blade_mul_2_blade_any', MATH_MUL$3, is_blade$1, and(is_cons, is_mul_2_blade_any), $);
                    this.hash = hash_binop_atom_cons(MATH_MUL$3, HASH_BLADE, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs) {
                    const $ = this.$;
                    const b1 = lhs;
                    const b2 = rhs.lhs;
                    const b1b2 = b1.mul(b2);
                    const X = rhs.rhs;
                    const S = $.valueOf(items_to_cons(MATH_MUL$3, b1b2, X));
                    return [TFLAG_DIFF, S];
                }
            };
            const simplify_mul_2_blade_mul_2_blade_any = new Builder$V();

            let Builder$U = class Builder {
                create($) {
                    return new Op$J($);
                }
            };
            /**
             * sin(a+b) => sin(a)*cos(b)+cos(a)*sin(b)
             */
            let Op$J = class Op extends Function1 {
                constructor($) {
                    super('sin_add_2_any_any', MATH_SIN, and(is_cons, is_opr_2_lhs_any(MATH_ADD$1, is_any)), $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_unaop_cons(MATH_SIN, MATH_ADD$1);
                }
                transform1(opr, arg) {
                    const $ = this.$;
                    const a = arg.lhs;
                    const b = arg.rhs;
                    const sinA = $.valueOf(items_to_cons$1(MATH_SIN, a));
                    const cosB = $.valueOf(items_to_cons$1(MATH_COS, b));
                    const cosA = $.valueOf(items_to_cons$1(MATH_COS, a));
                    const sinB = $.valueOf(items_to_cons$1(MATH_SIN, b));
                    const sacb = $.valueOf(items_to_cons$1(MATH_MUL$3, sinA, cosB));
                    const casb = $.valueOf(items_to_cons$1(MATH_MUL$3, cosA, sinB));
                    const retval = $.valueOf(items_to_cons$1(MATH_ADD$1, sacb, casb));
                    return [TFLAG_DIFF, retval];
                }
            };
            const sin_add_2_any_any = new Builder$U();

            function transform_sin(x, origExpr, $) {
                // console.lg(`transform_sin x=${x}, origExpr=${origExpr}`);
                if (is_add(x)) {
                    // sin of a sum can be further decomposed into
                    //sin(alpha+beta) = sin(alpha)*cos(beta)+sin(beta)*cos(alpha)
                    return sine_of_angle_sum(x, origExpr, $);
                }
                return sine_of_angle(x, origExpr, $);
            }
            function sine_of_angle_sum(x, oldExpr, $) {
                let p2 = cdr(x);
                while (is_cons(p2)) {
                    const B = car(p2);
                    if (is_multiple_of_pi(B, $)) {
                        const A = $.subtract(x, B);
                        return [TFLAG_DIFF, $.add($.multiply(sin(A, $), cos(B, $)), $.multiply(cos(A, $), sin(B, $)))];
                    }
                    p2 = cdr(p2);
                }
                return sine_of_angle(x, oldExpr, $);
            }
            function sine_of_angle(x, oldExpr, $) {
                if (car(x).equals(ARCSIN)) {
                    return [TFLAG_DIFF, cadr(x)];
                }
                if (is_flt$1(x)) {
                    let d = Math.sin(x.d);
                    if (Math.abs(d) < 1e-10) {
                        d = 0.0;
                    }
                    return [TFLAG_DIFF, create_flt(d)];
                }
                // sine function is antisymmetric, sin(-x) = -sin(x)
                if (is_negative(x)) {
                    return [TFLAG_DIFF, $.negate(sin($.negate(x), $))];
                }
                // sin(arctan(x)) = x / sqrt(1 + x^2)
                // see p. 173 of the CRC Handbook of Mathematical Sciences
                if (car(x).equals(ARCTAN)) {
                    return [TFLAG_DIFF, $.multiply(cadr(x), $.power($.add(one, $.power(cadr(x), two)), rational(-1, 2)))];
                }
                // multiply by 180/pi to go from radians to degrees.
                // we go from radians to degrees because it's much
                // easier to calculate symbolic results of most (not all) "classic"
                // angles (e.g. 30,45,60...) if we calculate the degrees
                // and the we do a switch on that.
                // Alternatively, we could look at the fraction of pi
                // (e.g. 60 degrees is 1/3 pi) but that's more
                // convoluted as we'd need to look at both numerator and
                // denominator.
                // TODO: DynamicConstants.Pi
                const n = nativeInt(divide($.multiply(x, create_int(180)), DynamicConstants.Pi($), $));
                // most "good" (i.e. compact) trigonometric results
                // happen for a round number of degrees. There are some exceptions
                // though, e.g. 22.5 degrees, which we don't capture here.
                if (n < 0 || isNaN(n)) {
                    return [TFLAG_NONE, oldExpr];
                }
                // values of some famous angles. Many more here:
                // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals
                switch (n % 360) {
                    case 0:
                    case 180:
                        return [TFLAG_DIFF, zero];
                    case 30:
                    case 150:
                        return [TFLAG_DIFF, half];
                    case 210:
                    case 330:
                        return [TFLAG_DIFF, rational(-1, 2)];
                    case 45:
                    case 135:
                        return [TFLAG_DIFF, $.multiply(half, $.power(two, half))];
                    case 225:
                    case 315:
                        return [TFLAG_DIFF, $.multiply(rational(-1, 2), $.power(two, half))];
                    case 60:
                    case 120:
                        return [TFLAG_DIFF, $.multiply(half, $.power(three, half))];
                    case 240:
                    case 300:
                        return [TFLAG_DIFF, $.multiply(rational(-1, 2), $.power(three, half))];
                    case 90:
                        return [TFLAG_DIFF, one];
                    case 270:
                        return [TFLAG_DIFF, negOne];
                    default:
                        return [TFLAG_NONE, oldExpr];
                }
            }

            let Builder$T = class Builder {
                create($) {
                    return new Op$I($);
                }
            };
            let Op$I = class Op extends Function1 {
                constructor($) {
                    super('sin_any', MATH_SIN, is_any, $);
                    this.hash = hash_unaop_atom(MATH_SIN, HASH_ANY);
                }
                transform1(opr, arg, oldExpr) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        return transform_sin(arg, oldExpr, $);
                    }
                    else {
                        return [TFLAG_NONE, oldExpr];
                    }
                }
            };
            const sin_any = new Builder$T();

            let Builder$S = class Builder {
                create($) {
                    return new Op$H($);
                }
            };
            /**
             * sin(Hyp) => Hyp
             */
            let Op$H = class Op extends Function1 {
                constructor($) {
                    super('sin_hyp', MATH_SIN, is_hyp, $);
                    this.hash = hash_unaop_atom(MATH_SIN, HASH_HYP);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg];
                }
            };
            const sin_hyp = new Builder$S();

            let Builder$R = class Builder {
                create($) {
                    return new Op$G($);
                }
            };
            /**
             * sin(X * i) => sinh(X) * i
             */
            let Op$G = class Op extends Function1 {
                constructor($) {
                    super('sin_mul_2_any_imu', MATH_SIN, and(is_cons, is_opr_2_any_rhs(MATH_MUL$3, is_imu)), $);
                    this.hash = hash_unaop_cons(MATH_SIN, MATH_MUL$3);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const X = arg.lhs;
                    const imu = arg.rhs;
                    if ($.isExpanding()) {
                        const sinh_X = $.valueOf(items_to_cons$1(SINH, X));
                        const retval = $.valueOf(items_to_cons$1(MATH_MUL$3, sinh_X, imu));
                        return [TFLAG_DIFF, retval];
                    }
                    return [TFLAG_HALT, expr];
                }
            };
            const sin_mul_2_any_imu = new Builder$R();

            let Builder$Q = class Builder {
                create($) {
                    return new Op$F($);
                }
            };
            let Op$F = class Op extends Function1 {
                constructor($) {
                    super('sin_sym', MATH_SIN, is_sym, $);
                    this.hash = hash_unaop_atom(MATH_SIN, HASH_SYM);
                }
                isReal(exp) {
                    return this.$.is_real(exp.arg);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    // TODO: Optimize.
                    return transform_sin(arg, expr, $);
                }
            };
            const sin_sym = new Builder$Q();

            let Builder$P = class Builder {
                create($) {
                    return new Op$E($);
                }
            };
            let Op$E = class Op extends Function1 {
                constructor($) {
                    super('sinh', SINH, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    const retval = sinh(arg, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_NONE, retval];
                }
            };
            const sinh_any = new Builder$P();

            let Builder$O = class Builder {
                create($) {
                    return new Op$D($);
                }
            };
            let Op$D = class Op extends Function1 {
                constructor($) {
                    super('sinh_flt', SINH, is_flt$1, $);
                    this.dependencies = ['Flt'];
                    this.hash = hash_unaop_atom(this.opr, HASH_FLT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(exp) {
                    return true;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    const d = Math.sinh(arg.d);
                    // TODO: There use of this magic constant should be implementation defined.
                    if (Math.abs(d) < 1e-10) {
                        return [TFLAG_DIFF, zeroAsFlt];
                    }
                    else {
                        return [TFLAG_DIFF, create_flt(d)];
                    }
                }
            };
            const sinh_flt = new Builder$O();

            let Builder$N = class Builder {
                create($) {
                    return new Op$C($);
                }
            };
            let Op$C = class Op extends Function1 {
                constructor($) {
                    super('sinh_rat', SINH, is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(exp) {
                    return true;
                }
                transform1(opr, arg, expr) {
                    if (arg.isZero()) {
                        return [TFLAG_DIFF, zero];
                    }
                    else {
                        return [TFLAG_HALT, expr];
                    }
                }
            };
            const sinh_rat = new Builder$N();

            let Builder$M = class Builder {
                create($) {
                    return new Op$B($);
                }
            };
            let Op$B = class Op extends Function1 {
                constructor($) {
                    super('sinh_sym', SINH, is_sym, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_SYM);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(exp) {
                    return true;
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_HALT, expr];
                }
            };
            const sinh_sym = new Builder$M();

            let Builder$L = class Builder {
                create($) {
                    return new Sqrt($);
                }
            };
            /**
             * sqrt(x) => (expt x 1/2)
             */
            class Sqrt extends Function1 {
                constructor($) {
                    super('sqrt_1_any', MATH_SQRT, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, this.$.valueOf(items_to_cons$1(MATH_POW$2, arg, half))];
                }
            }
            const sqrt_1_any = new Builder$L();

            let Builder$K = class Builder {
                create($) {
                    return new SqrtRat($);
                }
            };
            /**
             * sqrt(x: Rat) => (expt x 1/2)
             */
            class SqrtRat extends Function1 {
                constructor($) {
                    super('sqrt_1_rat', MATH_SQRT, is_rat$1, $);
                    this.hash = hash_unaop_atom(MATH_SQRT, HASH_RAT);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, this.$.valueOf(items_to_cons(MATH_POW$2, arg, half))];
                }
            }
            const sqrt_1_rat = new Builder$K();

            /**
             * Standard part function
             *
             * https://en.wikipedia.org/wiki/Standard_part_function
             */
            const MATH_STANDARD_PART = create_sym('st');

            let Builder$J = class Builder {
                create($) {
                    return new Op$A($);
                }
            };
            const guardA$1 = and(is_cons, is_opr_2_lhs_rhs(MATH_ADD$1, is_any, is_hyp));
            /**
             * st(a+Hyp) => st(a)
             */
            let Op$A = class Op extends Function1 {
                constructor($) {
                    super('st_add_2_any_hyp', MATH_STANDARD_PART, guardA$1, $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_unaop_cons(MATH_STANDARD_PART, MATH_ADD$1);
                }
                transform1(opr, arg) {
                    const $ = this.$;
                    const a = arg.lhs;
                    const retval = $.valueOf(items_to_cons$1(MATH_STANDARD_PART, a));
                    return [TFLAG_DIFF, retval];
                }
            };
            const st_add_2_any_hyp = new Builder$J();

            let Builder$I = class Builder {
                create($) {
                    return new Op$z($);
                }
            };
            let Op$z = class Op extends Function1 {
                constructor($) {
                    super('st_any', MATH_STANDARD_PART, is_any, $);
                    this.hash = hash_unaop_atom(MATH_STANDARD_PART, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    if ($.is_real(arg)) {
                        return [TFLAG_DIFF, arg];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const st_any = new Builder$I();

            let Builder$H = class Builder {
                create($) {
                    return new Op$y($);
                }
            };
            const guardA = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, is_rat$1, is_any));
            /**
             * st(k*X) => k*st(X)
             */
            let Op$y = class Op extends Function1 {
                constructor($) {
                    super('st_mul_2_rat_any', MATH_STANDARD_PART, guardA, $);
                    this.phases = MODE_EXPANDING;
                    this.hash = hash_unaop_cons(MATH_STANDARD_PART, MATH_MUL$3);
                }
                transform1(opr, arg) {
                    const $ = this.$;
                    const k = arg.lhs;
                    const X = arg.rhs;
                    const p1 = $.valueOf(items_to_cons$1(opr, X));
                    const p2 = $.valueOf(items_to_cons$1(arg.opr, k, p1));
                    return [TFLAG_DIFF, p2];
                }
            };
            const st_mul_2_rat_any = new Builder$H();

            let Builder$G = class Builder {
                create($) {
                    return new Op$x($);
                }
            };
            let Op$x = class Op extends Function1 {
                constructor($) {
                    super('st_rat', MATH_STANDARD_PART, is_rat, $);
                    this.hash = hash_unaop_atom(MATH_STANDARD_PART, HASH_ANY);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg];
                }
            };
            const st_rat = new Builder$G();

            let Builder$F = class Builder {
                create($) {
                    return new Op$w($);
                }
            };
            let Op$w = class Op extends Function1 {
                constructor($) {
                    super('st_sym', MATH_STANDARD_PART, is_sym, $);
                    this.hash = hash_unaop_atom(MATH_STANDARD_PART, HASH_ANY);
                }
                transform1(opr, arg) {
                    return [TFLAG_DIFF, arg];
                }
            };
            const st_sym = new Builder$F();

            function Eval_subst(p1, $) {
                const newExpr = $.valueOf(cadr(p1));
                const oldExpr = $.valueOf(caddr(p1));
                const expr = $.valueOf(cadddr(p1));
                return $.valueOf(subst(expr, oldExpr, newExpr, $));
            }

            let Builder$E = class Builder {
                create($) {
                    return new Op$v($);
                }
            };
            let Op$v = class Op extends FunctionVarArgs {
                constructor($) {
                    super('subst', SUBST, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_subst(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const subst_varargs = new Builder$E();

            let Builder$D = class Builder {
                create($) {
                    return new Succ($);
                }
            };
            class Succ extends Function1 {
                constructor($) {
                    super('succ_any', create_sym('succ'), is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                }
            }
            const succ_any = new Builder$D();

            let Builder$C = class Builder {
                create($) {
                    return new SuccRat($);
                }
            };
            class SuccRat extends Function1 {
                constructor($) {
                    super('succ_rat', create_sym('succ'), is_rat$1, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_DIFF, arg.succ()];
                }
            }
            const succ_rat = new Builder$C();

            // 'sum' function
            //define A p3u
            //define B p4
            //define I p5
            //define X p6
            // leaves the sum at the top of the stack
            function Eval_sum(arg, $) {
                const result = _sum(arg, $);
                return result;
            }
            function _sum(p1, $) {
                // 1st arg
                const body = cadr(p1);
                // 2nd arg (index)
                const index = caddr(p1);
                if (!is_sym(index)) {
                    halt('sum: 2nd arg?');
                }
                // 3rd arg (lower limit)
                const j = evaluate_integer(cadddr(p1), $);
                if (isNaN(j)) {
                    return p1;
                }
                // 4th arg (upper limit)
                const k = evaluate_integer(caddddr(p1), $);
                if (isNaN(k)) {
                    return p1;
                }
                // remember contents of the index
                // variable so we can put it back after the loop
                const original = $.getSymbolValue(index);
                let temp = zero;
                try {
                    for (let i = j; i <= k; i++) {
                        $.setSymbolValue(index, create_int(i));
                        temp = $.add(temp, $.valueOf(body));
                    }
                }
                finally {
                    $.setSymbolValue(index, original);
                }
                // put back the index variable to original content
                return temp;
            }

            let Builder$B = class Builder {
                create($) {
                    return new Op$u($);
                }
            };
            let Op$u = class Op extends FunctionVarArgs {
                constructor($) {
                    super('sum', SUM, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_sum(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const sum_varargs = new Builder$B();

            /**
             * Looks up the binding in the symbol table, with some additional behavior.
             * 1. If the binding is NIL, the sym is returned and changed is false.
             * 2. If the binding is simply the symbol itself, return sym and changed is false.
             * 3. If the binding exists and is not the same as sym, returns the binding and changed is true.
             * @param sym The symbol for which the binding is required.
             */
            function get_binding(sym, $) {
                const binding = $.getSymbolValue(sym);
                // console.lg("get_binding", render_as_infix(sym, $), "is", render_as_infix(binding, $));
                if (is_nil(binding)) {
                    return [TFLAG_NONE, sym];
                }
                if (!sym.equals(binding)) {
                    return [TFLAG_DIFF, binding];
                }
                else {
                    return [TFLAG_NONE, sym];
                }
            }

            class SymExtension {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                    // Nothing to see here.
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return 'SymExtension';
                }
                valueOf(sym, $) {
                    // console.lg("SymExtension.valueOf");
                    // Doing the dirty work for PI. Why do we need a special case?
                    // What about E from the math namespace?
                    if (is_pi(sym) && $.getNativeDirective(Directive.evaluatingAsFloat)) {
                        return piAsFlt;
                    }
                    // Evaluate symbol's binding
                    const binding = $.getSymbolValue(sym);
                    // console.lg(`binding ${$.toInfixString(sym)} => ${$.toInfixString(binding)}`);
                    if (nil === binding) {
                        return sym;
                    }
                    if (sym !== binding) {
                        return $.valueOf(binding);
                    }
                    else {
                        return sym;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(sym, $) {
                    return false;
                }
                isKind(sym) {
                    if (is_sym(sym)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(arg, $) {
                    return false;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(arg, $) {
                    return false;
                }
                isReal(sym, $) {
                    return $.is_real(sym);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(sym, $) {
                    return true;
                }
                isZero() {
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (is_sym(oldExpr)) {
                        if (expr.equals(oldExpr)) {
                            return newExpr;
                        }
                    }
                    return expr;
                }
                toInfixString(sym) {
                    return sym.key();
                }
                toLatexString(sym) {
                    return sym.key();
                }
                toListString(sym) {
                    const token = this.$.getSymbolPrintName(sym);
                    if (token) {
                        return token;
                    }
                    else {
                        return sym.key();
                    }
                }
                evaluate(sym, argList) {
                    return this.transform(cons(sym, argList));
                }
                transform(expr) {
                    // console.lg("SymExtension.transform", render_as_infix(expr, this.$));
                    if (is_sym(expr)) {
                        const binding = get_binding(expr, this.$);
                        // console.lg("binding", render_as_infix(binding[1], this.$));
                        return binding;
                    }
                    return [TFLAG_NONE, expr];
                }
            }
            const sym_extension = new ExtensionOperatorBuilder(function ($) {
                return new SymExtension($);
            });

            let Builder$A = class Builder {
                create($) {
                    return new SymMathAdd($);
                }
            };
            /**
             *
             */
            class SymMathAdd {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return 'SymMathAdd';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    throw new Error("SymMathAdd Method not implemented.");
                }
                isKind(expr) {
                    if (is_sym(expr)) {
                        return MATH_ADD$1.equalsSym(expr);
                    }
                    else {
                        return false;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(expr) {
                    throw new Error("SymMathAdd Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(expr) {
                    throw new Error("SymMathAdd Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    throw new Error("SymMathAdd Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    throw new Error("SymMathAdd Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    throw new Error("SymMathAdd Method not implemented.");
                }
                subst(expr, oldExpr, newExpr) {
                    if (expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    else {
                        return expr;
                    }
                }
                toInfixString() {
                    return '+';
                }
                toLatexString() {
                    return '+';
                }
                toListString() {
                    return this.$.getSymbolPrintName(MATH_ADD$1);
                }
                evaluate(opr, argList) {
                    return this.transform(cons(opr, argList));
                }
                transform(expr) {
                    if (is_sym(expr) && MATH_ADD$1.equalsSym(expr)) {
                        return [TFLAG_HALT, expr];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
                valueOf(expr) {
                    return expr;
                }
            }
            const sym_math_add = new Builder$A();

            let Builder$z = class Builder {
                create($) {
                    return new SymMathMul($);
                }
            };
            /**
             *
             */
            class SymMathMul {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return 'SymMathMul';
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    return [this.isKind(expr) ? TFLAG_HALT : TFLAG_NONE, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    throw new Error("SymMathMul Method not implemented.");
                }
                isKind(expr) {
                    return is_sym(expr) && MATH_MUL$3.equals(expr);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(expr) {
                    throw new Error("SymMathMul Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(expr) {
                    throw new Error("SymMathMul Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    throw new Error("SymMathMul Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    throw new Error("SymMathMul Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    throw new Error("SymMathMul Method not implemented.");
                }
                subst(expr, oldExpr, newExpr) {
                    if (expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    else {
                        return expr;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(expr) {
                    return '*';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(expr) {
                    return '*';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toListString(expr) {
                    return this.$.getSymbolPrintName(MATH_MUL$3);
                }
                valueOf(expr) {
                    return assert_sym(this.transform(expr)[1]);
                }
            }
            const sym_math_mul = new Builder$z();

            let Builder$y = class Builder {
                create($) {
                    return new SymMathPi($);
                }
            };
            /**
             *
             */
            class SymMathPi {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return 'SymMathPi';
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    return [this.isKind(expr) ? TFLAG_HALT : TFLAG_NONE, expr];
                }
                isImag() {
                    return false;
                }
                isKind(expr) {
                    return is_pi(expr);
                }
                isMinusOne() {
                    return false;
                }
                isOne() {
                    return false;
                }
                isReal() {
                    return true;
                }
                isScalar() {
                    return true;
                }
                isZero() {
                    return false;
                }
                subst(expr, oldExpr, newExpr) {
                    if (expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    else {
                        return expr;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(expr) {
                    return this.$.getSymbolPrintName(MATH_PI$2);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(expr) {
                    return '\\pi';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toListString(expr) {
                    return this.$.getSymbolPrintName(MATH_PI$2);
                }
                valueOf(expr) {
                    return assert_sym(this.transform(expr)[1]);
                }
            }
            const sym_math_pi = new Builder$y();

            const MATH_POW = native_sym(Native.pow);
            let Builder$x = class Builder {
                create($) {
                    return new SymMathPow($);
                }
            };
            /**
             *
             */
            class SymMathPow {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                constructor($) {
                    this.$ = $;
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return 'SymMathPow';
                }
                evaluate(expr, argList) {
                    return this.transform(cons(expr, argList));
                }
                transform(expr) {
                    return [this.isKind(expr) ? TFLAG_HALT : TFLAG_NONE, expr];
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isImag(expr) {
                    throw new Error("SymMathPow Method not implemented.");
                }
                isKind(expr) {
                    return is_sym(expr) && MATH_POW.equals(expr);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isMinusOne(expr) {
                    throw new Error("SymMathPow Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isOne(expr) {
                    throw new Error("SymMathPow Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isReal(expr) {
                    throw new Error("SymMathPow Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isScalar(expr) {
                    throw new Error("SymMathPow Method not implemented.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                isZero(expr) {
                    throw new Error("SymMathPow Method not implemented.");
                }
                subst(expr, oldExpr, newExpr) {
                    if (expr.equals(oldExpr)) {
                        return newExpr;
                    }
                    else {
                        return expr;
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toInfixString(expr) {
                    if (this.$.getNativeDirective(Directive.useCaretForExponentiation)) {
                        return '^';
                    }
                    else {
                        return '**';
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toLatexString(expr) {
                    return ' ^ ';
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                toListString(expr) {
                    return this.$.getSymbolPrintName(MATH_POW);
                }
                valueOf(expr) {
                    return assert_sym(this.transform(expr)[1]);
                }
            }
            const sym_math_pow = new Builder$x();

            // Tangent function of numerical and symbolic arguments
            function Eval_tan(expr, $) {
                const result = tangent($.valueOf(cadr(expr)), $);
                return result;
            }
            function tangent(p1, $) {
                if (car(p1).equals(ARCTAN)) {
                    return cadr(p1);
                }
                if (is_flt$1(p1)) {
                    let d = Math.tan(p1.d);
                    if (Math.abs(d) < 1e-10) {
                        d = 0.0;
                    }
                    return create_flt(d);
                }
                // tan function is antisymmetric, tan(-x) = -tan(x)
                if (is_negative(p1)) {
                    return $.negate(tangent($.negate(p1), $));
                }
                // multiply by 180/pi to go from radians to degrees.
                // we go from radians to degrees because it's much
                // easier to calculate symbolic results of most (not all) "classic"
                // angles (e.g. 30,45,60...) if we calculate the degrees
                // and the we do a switch on that.
                // Alternatively, we could look at the fraction of pi
                // (e.g. 60 degrees is 1/3 pi) but that's more
                // convoluted as we'd need to look at both numerator and
                // denominator.
                const n = nativeInt(divide($.multiply(p1, create_int(180)), DynamicConstants.Pi($), $));
                // most "good" (i.e. compact) trigonometric results
                // happen for a round number of degrees. There are some exceptions
                // though, e.g. 22.5 degrees, which we don't capture here.
                if (n < 0 || isNaN(n)) {
                    return items_to_cons(TAN, p1);
                }
                switch (n % 360) {
                    case 0:
                    case 180:
                        return zero;
                    case 30:
                    case 210:
                        return $.multiply(third, $.power(three, half));
                    case 150:
                    case 330:
                        return $.multiply(rational(-1, 3), $.power(three, half));
                    case 45:
                    case 225:
                        return one;
                    case 135:
                    case 315:
                        return negOne;
                    case 60:
                    case 240:
                        return $.power(three, half);
                    case 120:
                    case 300:
                        return $.negate($.power(three, half));
                    default:
                        return items_to_cons(TAN, p1);
                }
            }

            let Builder$w = class Builder {
                create($) {
                    return new Op$t($);
                }
            };
            let Op$t = class Op extends FunctionVarArgs {
                constructor($) {
                    super('tan', TAN, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    if ($.isExpanding()) {
                        const retval = Eval_tan(expr, $);
                        const changed = !retval.equals(expr);
                        return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            };
            const tan_varargs = new Builder$w();

            //             exp(2 x) - 1
            //  tanh(x) = --------------
            //             exp(2 x) + 1
            function Eval_tanh(p1, $) {
                return tanh($.valueOf(cadr(p1)), $);
            }
            function tanh(p1, $) {
                if (car(p1).equals(ARCTANH)) {
                    return cadr(p1);
                }
                if (is_flt$1(p1)) {
                    let d = Math.tanh(p1.d);
                    if (Math.abs(d) < 1e-10) {
                        d = 0.0;
                    }
                    return create_flt(d);
                }
                if ($.is_zero(p1)) {
                    return zero;
                }
                return items_to_cons$1(TANH, p1);
            }

            let Builder$v = class Builder {
                create($) {
                    return new Op$s($);
                }
            };
            let Op$s = class Op extends FunctionVarArgs {
                constructor($) {
                    super('tanh', TANH, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_tanh(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const tanh_varargs = new Builder$v();

            const MATH_PI = native_sym(Native.PI);
            const MATH_TAU = native_sym(Native.tau);
            let Builder$u = class Builder {
                create($) {
                    return new Op$r($);
                }
            };
            /**
             * (tau x) => (* 2 pi x)
             */
            let Op$r = class Op extends Function1 {
                constructor($) {
                    super('tau_any', MATH_TAU, is_any, $);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    const two_pi = this.$.multiply(two, MATH_PI);
                    const two_pi_x = this.$.multiply(two_pi, arg);
                    return [TFLAG_DIFF, two_pi_x];
                }
            };
            const tau = new Builder$u();

            /*
            Taylor expansion of a function

              push(F)
              push(X)
              push(N)
              push(A)
              taylor()
            */
            function Eval_taylor(p1, $) {
                // 1st arg
                p1 = cdr(p1);
                const F = $.valueOf(car(p1));
                // 2nd arg
                p1 = cdr(p1);
                let p2 = $.valueOf(car(p1));
                const X = nil === p2 ? guess(stack_peek()) : p2; // TODO: should this be `top()`?
                // 3rd arg
                p1 = cdr(p1);
                p2 = $.valueOf(car(p1));
                const N = nil === p2 ? create_int(24) : p2; // 24: default number of terms
                // 4th arg
                p1 = cdr(p1);
                p2 = $.valueOf(car(p1));
                const A = nil === p2 ? zero : p2; // 0: default expansion point
                return taylor(F, X, N, A, $);
            }
            /**
             * Returns the Taylor expansion of f(x) around x=a. If "a" is omitted then a=0 is used.
             * The argument n is the degree of the expansion.
             *
             * Strictly speaking, Taylor's theorem provides a k-th order Taylor polynomial and a remainder term.
             * This function computes the k-th order Taylor polynomial.
             *
             * @param F
             * @param X
             * @param N
             * @param A
             * @param $
             * @returns
             */
            function taylor(f, X, N, A, $) {
                const k = nativeInt(N);
                if (isNaN(k)) {
                    return items_to_cons(TAYLOR, f, X, N, A);
                }
                const x_minus_a = $.subtract(X, A);
                // F contains the i-th derivative of f, initially f.
                let dfi = f;
                // The weight factor in the i-th term is (x-a)**i
                let weight = one;
                // retval accumulates the terms in the Taylor polynomial.
                let retval = $.valueOf(subst(dfi, X, A, $)); // The first term in the Taylor polynomial is f(a).
                // Now compute and add the terms that follow up to the required degree.
                for (let i = 1; i <= k; i++) {
                    // F now contains the i-th derivative
                    dfi = derivative(dfi, X, $); // F: f = f'
                    if ($.is_zero(dfi)) {
                        break;
                    }
                    // c = c * (x - a)
                    weight = $.multiply(weight, x_minus_a);
                    const dfi_at_a = $.valueOf(subst(dfi, X, A, $)); // F: f(a)
                    const term = divide($.multiply(dfi_at_a, weight), factorial(create_int(i)), $);
                    retval = $.add(retval, term);
                }
                return retval;
            }

            let Builder$t = class Builder {
                create($) {
                    return new Op$q($);
                }
            };
            let Op$q = class Op extends FunctionVarArgs {
                constructor($) {
                    super('taylor', TAYLOR, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_taylor(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const taylor_varargs = new Builder$t();

            const testeq = native_sym(Native.test_eq);
            let Builder$s = class Builder {
                create($) {
                    return new Op$p($);
                }
            };
            let Op$p = class Op extends Function2 {
                constructor($) {
                    super('testeq_sym_rat', testeq, is_sym, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(testeq, HASH_SYM, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    return [TFLAG_DIFF, booF];
                }
            };
            const testeq_sym_rat = new Builder$s();

            let Builder$r = class Builder {
                create($) {
                    return new Op$o($);
                }
            };
            /**
             * (> (* x y) k)
             */
            let Op$o = class Op extends Function2 {
                constructor($) {
                    super('testgt_mul_2_any_any_rat', MATH_GT, and(is_cons, is_mul_2_any_any), is_rat$1, $);
                    this.hash = hash_binop_cons_atom(MATH_GT, MATH_MUL$3, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    if (rhs.isNegative()) {
                        return [TFLAG_DIFF, booF];
                    }
                    if (rhs.isZero()) {
                        const $ = this.$;
                        const x = lhs.lhs;
                        const y = lhs.rhs;
                        const x_LT_0 = $.valueOf(items_to_cons$1(MATH_LT, x, zero));
                        const y_LT_0 = $.valueOf(items_to_cons$1(MATH_LT, y, zero));
                        const x_GT_0 = $.valueOf(items_to_cons$1(MATH_GT, x, zero));
                        const y_GT_0 = $.valueOf(items_to_cons$1(MATH_GT, y, zero));
                        if (is_boo(x_LT_0) && is_boo(x_GT_0) && is_boo(y_LT_0) && is_boo(y_GT_0)) {
                            const cond = (x_GT_0.isTrue() && y_GT_0.isTrue()) || (x_LT_0.isTrue() && y_LT_0.isTrue());
                            return [TFLAG_DIFF, cond ? booT : booF];
                        }
                        return [TFLAG_DIFF, booF];
                    }
                    return [TFLAG_DIFF, booF];
                }
            };
            const testgt_mul_2_any_any_rat = new Builder$r();

            let Builder$q = class Builder {
                create($) {
                    return new Op$n($);
                }
            };
            let Op$n = class Op extends Function2 {
                constructor($) {
                    super('testgt_rat_rat', MATH_GT, is_rat$1, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_GT, HASH_RAT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.compare(rhs) > 0 ? booT : booF];
                }
            };
            const testgt_rat_rat = new Builder$q();

            let Builder$p = class Builder {
                create($) {
                    return new Op$m($);
                }
            };
            let Op$m = class Op extends Function2 {
                constructor($) {
                    super('testgt_sym_rat', MATH_GT, is_sym, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_GT, HASH_SYM, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    if (rhs.isNegative()) {
                        return [TFLAG_DIFF, booT];
                    }
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, booT];
                    }
                    return [TFLAG_DIFF, booF];
                }
            };
            const testgt_sym_rat = new Builder$p();

            let Builder$o = class Builder {
                create($) {
                    return new Op$l($);
                }
            };
            let Op$l = class Op extends Function2 {
                constructor($) {
                    super('testlt_flt_rat', MATH_LT, is_flt, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_LT, HASH_FLT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, compare_num_num(lhs, rhs) < 0 ? booT : booF];
                }
            };
            const testlt_flt_rat = new Builder$o();

            let Builder$n = class Builder {
                create($) {
                    return new Op$k($);
                }
            };
            /**
             * (< (* x y) k)
             */
            let Op$k = class Op extends Function2 {
                constructor($) {
                    super('testlt_mul_2_any_any_rat', MATH_LT, and(is_cons, is_mul_2_any_any), is_rat$1, $);
                    this.hash = hash_binop_cons_atom(MATH_LT, MATH_MUL$3, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    if (rhs.isNegative()) {
                        return [TFLAG_DIFF, booF];
                    }
                    if (rhs.isZero()) {
                        const $ = this.$;
                        const x = lhs.lhs;
                        const y = lhs.rhs;
                        const x_LT_0 = $.valueOf(items_to_cons$1(MATH_LT, x, zero));
                        const y_LT_0 = $.valueOf(items_to_cons$1(MATH_LT, y, zero));
                        const x_GT_0 = $.valueOf(items_to_cons$1(MATH_GT, x, zero));
                        const y_GT_0 = $.valueOf(items_to_cons$1(MATH_GT, y, zero));
                        if (is_boo(x_LT_0) && is_boo(x_GT_0) && is_boo(y_LT_0) && is_boo(y_GT_0)) {
                            const cond = (x_LT_0.isTrue() && y_GT_0.isTrue()) || (x_GT_0.isTrue() && y_LT_0.isTrue());
                            return [TFLAG_DIFF, cond ? booT : booF];
                        }
                        return [TFLAG_DIFF, booF];
                    }
                    return [TFLAG_DIFF, booF];
                }
            };
            const testlt_mul_2_any_any_rat = new Builder$n();

            let Builder$m = class Builder {
                create($) {
                    return new Op$j($);
                }
            };
            let Op$j = class Op extends Function2 {
                constructor($) {
                    super('testlt_rat_rat', MATH_LT, is_rat$1, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_LT, HASH_RAT, HASH_RAT);
                }
                transform2(opr, lhs, rhs) {
                    return [TFLAG_DIFF, lhs.compare(rhs) < 0 ? booT : booF];
                }
            };
            const testlt_rat_rat = new Builder$m();

            let Builder$l = class Builder {
                create($) {
                    return new Op$i($);
                }
            };
            let Op$i = class Op extends Function2 {
                constructor($) {
                    super('testlt_sym_rat', MATH_LT, is_sym, is_rat$1, $);
                    this.hash = hash_binop_atom_atom(MATH_LT, HASH_SYM, HASH_RAT);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, expr) {
                    if (rhs.isNegative()) {
                        return [TFLAG_DIFF, booF];
                    }
                    if (rhs.isZero()) {
                        return [TFLAG_DIFF, booF];
                    }
                    return [TFLAG_DIFF, booF];
                }
            };
            const testlt_sym_rat = new Builder$l();

            let Builder$k = class Builder {
                create($) {
                    return new Op$h($);
                }
            };
            let Op$h = class Op extends FunctionVarArgs {
                constructor($) {
                    super('transpose', TRANSPOSE, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_transpose(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const transpose_varargs = new Builder$k();

            function is_unaop(expr) {
                return expr.length === 2;
            }

            function is_opr_1_any(opr) {
                return function (expr) {
                    return is_cons_opr_eq_sym(expr, opr) && is_unaop(expr);
                };
            }

            let Builder$j = class Builder {
                create($) {
                    return new Op$g($);
                }
            };
            const guardLL$6 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardLR$6 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardL$b = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$6, guardLR$6));
            const guardRLL$4 = is_rat$1;
            const guardRLR$4 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardRL$6 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRLL$4, guardRLR$4));
            const guardRR$6 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardR$b = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL$6, guardRR$6));
            function cross$b(lhs, rhs) {
                const a1 = lhs.lhs.arg;
                const b1 = lhs.rhs.arg;
                const num = rhs.lhs.lhs;
                const a2 = rhs.lhs.rhs.arg;
                const b2 = rhs.rhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2);
            }
            /**
             * cos(a)*cos(b)-sin(a)*sin(b) => cos(a+b)
             */
            let Op$g = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_cos_cos_mul_2_mul_2_rat_sin_sin', MATH_ADD$1, guardL$b, guardR$b, cross$b, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = orig.lhs.rhs.arg;
                    const a_plus_b = $.valueOf(items_to_cons$1(MATH_ADD$1, a, b));
                    const cos = $.valueOf(items_to_cons$1(MATH_COS, a_plus_b));
                    return [TFLAG_DIFF, cos];
                }
            };
            const add_2_mul_2_cos_cos_mul_2_mul_2_rat_sin_sin = new Builder$j();

            let Builder$i = class Builder {
                create($) {
                    return new Op$f($);
                }
            };
            const guardL$a = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_COS)), and(is_cons, is_opr_1_any(MATH_COS))));
            const guardR$a = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_SIN)), and(is_cons, is_opr_1_any(MATH_SIN))));
            function cross$a(lhs, rhs) {
                const a1 = lhs.lhs.arg;
                const b1 = lhs.rhs.arg;
                const a2 = rhs.lhs.arg;
                const b2 = rhs.rhs.arg;
                return a1.equals(a2) && b1.equals(b2);
            }
            /**
             * cos(a)*cos(b)+sin(a)*sin(b) => cos(a-b)
             */
            let Op$f = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_sin_cos_mul_2_cos_sin', MATH_ADD$1, guardL$a, guardR$a, cross$a, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = orig.lhs.rhs.arg;
                    const a_minus_b = $.valueOf(items_to_cons$1(MATH_ADD$1, a, $.negate(b)));
                    const cos = $.valueOf(items_to_cons$1(MATH_COS, a_minus_b));
                    return [TFLAG_DIFF, cos];
                }
            };
            const add_2_mul_2_cos_cos_mul_2_sin_sin = new Builder$i();

            let Builder$h = class Builder {
                create($) {
                    return new Op$e($);
                }
            };
            const guardL$9 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_COS)), and(is_cons, is_opr_1_any(MATH_SIN))));
            const guardR$9 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_COS)), and(is_cons, is_opr_1_any(MATH_SIN))));
            function cross$9(lhs, rhs) {
                const a1 = lhs.rhs.arg;
                const b1 = lhs.lhs.arg;
                const a2 = rhs.lhs.arg;
                const b2 = rhs.rhs.arg;
                return a1.equals(a2) && b1.equals(b2);
            }
            /**
             * cos(b)*sin(a)+cos(a)*sin(b) => cos(a)*sin(b)+cos(b)*sin(a)  Case not(PHASE_FACTORING)
             *                             => sin(a+b)        Case PHASE_FACTORING
             */
            let Op$e = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_cos_sin_mul_2_cos_sin_factoring', MATH_ADD$1, guardL$9, guardR$9, cross$9, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = orig.lhs.rhs.arg;
                    const ab = $.valueOf(items_to_cons$1(MATH_ADD$1, a, b));
                    const sin = $.valueOf(items_to_cons$1(MATH_SIN, ab));
                    return [TFLAG_DIFF, sin];
                }
            };
            const add_2_mul_2_cos_sin_mul_2_cos_sin_factoring = new Builder$h();

            function is_outer(expr) {
                const opr = expr.opr;
                if (is_sym(opr)) {
                    return MATH_OUTER.equalsSym(opr);
                }
                else {
                    return false;
                }
            }

            function is_outer_2_any_any(expr) {
                return is_outer(expr) && is_binop(expr);
            }

            function is_pow_2_any_positive_integer(expr) {
                if (is_pow_2_any_any(expr)) {
                    const expo = expr.rhs;
                    return is_rat_and_positive_integer(expo);
                }
                return false;
            }
            /**
             * WARNING: This will not work for n-ary multiplication with n > 2.
             */
            function factorizeL(expr) {
                let s = expr;
                const parts = [];
                while (is_cons(s)) {
                    if (is_mul_2_any_any(s)) {
                        parts.push(s.rhs);
                        s = s.lhs;
                        continue;
                    }
                    if (is_pow_2_any_positive_integer(s)) {
                        const base = s.lhs;
                        const expo = s.rhs;
                        parts.push(items_to_cons$1(MATH_POW$2, base, expo.pred()));
                        s = base;
                    }
                    break;
                }
                while (parts.length > 1) {
                    const a = parts.pop();
                    const b = parts.pop();
                    const ab = items_to_cons$1(MATH_MUL$3, a, b);
                    parts.push(ab);
                }
                if (parts.length > 0) {
                    return [s, parts[0], true];
                }
                else {
                    return [s, one, false];
                }
            }

            /**
             * Used for comparing expressions that are factorizable (either Multiply or Power).
             */
            function compare_factorizable(lhs, rhs) {
                if (is_blade$1(lhs.rhs) && is_blade$1(rhs.rhs)) {
                    switch (compare_blade_blade(lhs.rhs, rhs.rhs)) {
                        case SIGN_GT: {
                            return SIGN_GT;
                        }
                        case SIGN_LT: {
                            return SIGN_LT;
                        }
                        default: {
                            return compare(lhs.lhs, rhs.lhs);
                        }
                    }
                }
                const [aL, bL, splitL] = factorizeL(lhs);
                const [aR, bR, splitR] = factorizeL(rhs);
                // Important to determine whether factorization occured to prevent infinite loops.
                if (splitL || splitR) {
                    switch (compare(aL, aR)) {
                        case SIGN_GT: {
                            return SIGN_GT;
                        }
                        case SIGN_LT: {
                            return SIGN_LT;
                        }
                        default: {
                            return compare(bL, bR);
                        }
                    }
                }
                else {
                    return SIGN_EQ;
                }
            }

            function compare_opr_opr(lhs, rhs) {
                if (is_sym(lhs)) {
                    if (is_sym(rhs)) {
                        return compare_sym_sym(lhs, rhs);
                    }
                    else if (is_nil(rhs)) {
                        // Sym, NIL
                        throw new Error();
                    }
                    else {
                        throw new Error();
                    }
                }
                else if (is_nil(lhs)) {
                    if (is_sym(rhs)) {
                        // NIL, Sym
                        throw new Error();
                    }
                    else if (is_nil(rhs)) {
                        throw new Error();
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    throw new Error();
                }
            }

            const GROUP_NIL = 0;
            const GROUP_NUM = 1;
            const GROUP_SYM = 2;
            const GROUP_TENSOR = 3;
            const GROUP_HYP = 4;
            const GROUP_CONS = 5;
            const GROUP_IMU = 6;
            const GROUP_BLADE = 7;
            const GROUP_UOM = 8;
            function group(expr) {
                if (is_rat$1(expr)) {
                    return GROUP_NUM;
                }
                if (is_flt$1(expr)) {
                    return GROUP_NUM;
                }
                if (is_sym(expr)) {
                    return GROUP_SYM;
                }
                if (is_cons(expr)) {
                    return GROUP_CONS;
                }
                if (is_hyp(expr)) {
                    return GROUP_HYP;
                }
                if (is_imu(expr)) {
                    return GROUP_IMU;
                }
                if (is_blade$1(expr)) {
                    return GROUP_BLADE;
                }
                if (is_tensor(expr)) {
                    return GROUP_TENSOR;
                }
                if (is_uom$1(expr)) {
                    return GROUP_UOM;
                }
                if (is_nil(expr)) {
                    return GROUP_NIL;
                }
                throw new Error(`group() of ${expr}`);
            }

            function has_imu_factor(expr) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const [a, b] = factorizeL(expr);
                return is_imu(a);
            }

            /**
             * The order of operations is currently |,^,*
             * @param lhs
             * @param rhs
             * @returns
             */
            function compare(lhs, rhs) {
                // console.lg(`ENTERING compare ${lhs} ${rhs}`);
                if (lhs.equals(rhs)) {
                    return SIGN_EQ;
                }
                if (is_cons(lhs)) {
                    if (is_mul_2_any_any(lhs)) {
                        if (is_cons(rhs)) {
                            if (is_mul_2_any_any(rhs)) {
                                return compare_factorizable(lhs, rhs);
                            }
                            else if (is_inner_2_any_any(rhs)) {
                                return compare_opr_opr(lhs.car, rhs.car);
                            }
                            else {
                                return compare_opr_opr(lhs.car, rhs.car);
                            }
                        }
                        else if (is_rat$1(rhs)) {
                            return SIGN_GT;
                        }
                        else if (is_sym(rhs)) {
                            // Ordering really depends on what the symbol is, how it compares to the other expression.
                            return SIGN_EQ;
                        }
                        else {
                            throw new Error(`lhs: Multiply = ${lhs}, rhs = ${rhs}`);
                        }
                    }
                    if (is_pow_2_any_any(lhs)) {
                        if (is_cons(rhs)) {
                            if (is_mul_2_any_any(rhs)) {
                                return compare_factorizable(lhs, rhs);
                            }
                            if (is_pow_2_any_any(rhs)) {
                                return compare_factorizable(lhs, rhs);
                            }
                            if (is_inner_2_any_any(rhs)) {
                                return SIGN_GT;
                            }
                            else {
                                return SIGN_EQ;
                                // throw new Error(`lhs: Power = ${lhs}, rhs: Cons = ${rhs}`);
                            }
                        }
                        if (is_sym(rhs)) {
                            return SIGN_GT;
                        }
                        else {
                            throw new Error(`lhs: Power = ${lhs}, rhs = ${rhs}`);
                        }
                    }
                    if (is_inner_2_any_any(lhs)) {
                        if (is_cons(rhs)) {
                            if (is_mul_2_any_any(rhs)) {
                                return SIGN_LT;
                            }
                            else if (is_outer_2_any_any(rhs)) {
                                return SIGN_LT;
                            }
                            else if (is_inner_2_any_any(rhs)) {
                                return SIGN_EQ;
                            }
                            else if (is_pow_2_any_any(rhs)) {
                                return SIGN_LT;
                            }
                            else if (is_flt$1(rhs)) {
                                throw new Error(`lhs: Inner = ${lhs}, rhs: Flt = ${rhs}`);
                            }
                            else {
                                throw new Error(`lhs: Inner = ${lhs}, rhs: Cons = ${rhs}`);
                            }
                        }
                        else {
                            return SIGN_EQ;
                        }
                    }
                    if (is_outer_2_any_any(lhs)) {
                        if (is_cons(rhs)) {
                            if (is_inner_2_any_any(rhs)) {
                                return SIGN_GT;
                            }
                            else {
                                throw new Error(`lhs: Outer = ${lhs}, rhs: Cons = ${rhs}`);
                            }
                        }
                        if (is_rat$1(rhs)) {
                            return SIGN_GT;
                        }
                        else {
                            throw new Error(`lhs: Outer = ${lhs}, rhs = ${rhs}`);
                        }
                    }
                    else {
                        if (is_cons(rhs)) {
                            return compare(lhs.opr, rhs.opr);
                        }
                        else if (is_sym(rhs)) {
                            return SIGN_GT;
                        }
                        else {
                            throw new Error(`lhs: Cons = ${lhs}, rhs = ${rhs}`);
                        }
                    }
                }
                else if (is_rat$1(lhs)) {
                    if (is_cons(rhs)) {
                        if (is_outer_2_any_any(rhs)) {
                            return SIGN_LT;
                        }
                        if (is_mul_2_any_any(rhs)) {
                            return SIGN_LT;
                        }
                    }
                    if (is_rat$1(rhs)) {
                        return lhs.compare(rhs);
                    }
                    if (is_sym(rhs)) {
                        return SIGN_LT;
                    }
                    else {
                        throw new Error(`lhs: Rat = ${lhs}, rhs = ${rhs}`);
                    }
                }
                else if (is_flt$1(lhs)) {
                    if (is_cons(rhs)) {
                        return SIGN_LT;
                    }
                    else if (is_flt$1(rhs)) {
                        return lhs.compare(rhs);
                    }
                    else {
                        throw new Error(`lhs: Flt = ${lhs}, rhs = ${rhs}`);
                    }
                }
                else if (is_sym(lhs)) {
                    if (is_rat$1(rhs)) {
                        return SIGN_GT;
                    }
                    else if (is_sym(rhs)) {
                        return compare_sym_sym(lhs, rhs);
                    }
                    else if (is_hyp(rhs)) {
                        return SIGN_LT;
                    }
                    else if (is_blade$1(rhs)) {
                        return SIGN_LT;
                    }
                    else if (is_cons(rhs)) {
                        if (is_mul_2_any_any(rhs)) {
                            if (has_imu_factor(rhs)) {
                                return SIGN_LT;
                            }
                            return SIGN_LT;
                        }
                        else if (is_pow_2_any_any(rhs)) {
                            if (is_imu(rhs)) {
                                return SIGN_LT;
                            }
                            else {
                                throw new Error(`lhs: Sym = ${lhs}, rhs: Power = ${rhs}`);
                            }
                        }
                        else {
                            return SIGN_LT;
                        }
                    }
                    else {
                        throw new Error(`lhs: Sym = ${lhs}, rhs = ${rhs}`);
                    }
                }
                else if (is_hyp(lhs)) {
                    if (is_sym(rhs)) {
                        return SIGN_GT;
                    }
                    else {
                        throw new Error(`lhs: Hyp = ${lhs}, rhs = ${rhs} group(rhs)=${group(rhs)}`);
                    }
                }
                else {
                    throw new Error(`lhs = ${lhs}, rhs = ${rhs}`);
                }
            }

            let Builder$g = class Builder {
                create($) {
                    return new Op$d($);
                }
            };
            const guardL$8 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_COS)), and(is_cons, is_opr_1_any(MATH_SIN))));
            const guardR$8 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_COS)), and(is_cons, is_opr_1_any(MATH_SIN))));
            function cross$8(lhs, rhs) {
                const a1 = lhs.rhs.arg;
                const b1 = lhs.lhs.arg;
                const a2 = rhs.lhs.arg;
                const b2 = rhs.rhs.arg;
                return a1.equals(a2) && b1.equals(b2) && compare(b1, a1) > 0;
            }
            /**
             * cos(b)*sin(a)+cos(a)*sin(b) => cos(a)*sin(b)+cos(b)*sin(a)
             */
            let Op$d = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_cos_sin_mul_2_cos_sin_ordering', MATH_ADD$1, guardL$8, guardR$8, cross$8, $);
                    this.phases = PHASE_FLAGS_EXPANDING_UNION_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const swapped = items_to_cons$1(opr, orig.rhs, orig.lhs);
                    const retval = $.valueOf(swapped);
                    return [TFLAG_DIFF, retval];
                }
            };
            const add_2_mul_2_cos_sin_mul_2_cos_sin_ordering = new Builder$g();

            let Builder$f = class Builder {
                create($) {
                    return new Op$c($);
                }
            };
            const guardLL$5 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardLR$5 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardL$7 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$5, guardLR$5));
            const guardRLL$3 = is_rat$1;
            const guardRLR$3 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardRL$5 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRLL$3, guardRLR$3));
            const guardRR$5 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardR$7 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL$5, guardRR$5));
            function cross$7(lhs, rhs) {
                const b1 = lhs.lhs.arg;
                const a1 = lhs.rhs.arg;
                const num = rhs.lhs.lhs;
                const a2 = rhs.lhs.rhs.arg;
                const b2 = rhs.rhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2);
            }
            /**
             * cos(b)*sin(a)-cos(a)*sin(b) => sin(a-b)
             */
            let Op$c = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_cos_sin_mul_2_mul_2_rat_cos_sin_factoring', MATH_ADD$1, guardL$7, guardR$7, cross$7, $);
                    this.phases = MODE_FACTORING;
                    // TODO: Notice that the hash isn't very selective.
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.rhs.arg;
                    const b = orig.lhs.lhs.arg;
                    const a_minus_b = $.valueOf(items_to_cons$1(MATH_ADD$1, a, $.negate(b)));
                    const retval = $.valueOf(items_to_cons$1(MATH_SIN, a_minus_b));
                    return [TFLAG_DIFF, retval];
                }
            };
            const add_2_mul_2_cos_sin_mul_2_mul_2_rat_cos_sin_factoring = new Builder$f();

            let Builder$e = class Builder {
                create($) {
                    return new Op$b($);
                }
            };
            const guardLL$4 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardLR$4 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardL$6 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$4, guardLR$4));
            const guardRLL$2 = is_rat$1;
            const guardRLR$2 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardRL$4 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRLL$2, guardRLR$2));
            const guardRR$4 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardR$6 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL$4, guardRR$4));
            function cross$6(lhs, rhs) {
                const b1 = lhs.lhs.arg;
                const a1 = lhs.rhs.arg;
                const num = rhs.lhs.lhs;
                const a2 = rhs.lhs.rhs.arg;
                const b2 = rhs.rhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2) && compare(b1, a1) > 0;
            }
            /**
             * cos(b)*sin(a)-cos(a)*sin(b) => -cos(a)*sin(b)+cos(b)*sin(a)
             */
            let Op$b = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_cos_sin_mul_2_mul_2_rat_cos_sin_ordering', MATH_ADD$1, guardL$6, guardR$6, cross$6, $);
                    this.phases = PHASE_FLAGS_EXPANDING_UNION_FACTORING;
                    // TODO: Notice that the hash isn't very selective.
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const swapped = items_to_cons$1(opr, orig.rhs, orig.lhs);
                    const retval = $.valueOf(swapped);
                    return [TFLAG_DIFF, retval];
                }
            };
            const add_2_mul_2_cos_sin_mul_2_mul_2_rat_cos_sin_ordering = new Builder$e();

            let Builder$d = class Builder {
                create($) {
                    return new Op$a($);
                }
            };
            const guardLL$3 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardLR$3 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardL$5 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$3, guardLR$3));
            const guardRLL$1 = is_rat$1;
            const guardRLR$1 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardRL$3 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRLL$1, guardRLR$1));
            const guardRR$3 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardR$5 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL$3, guardRR$3));
            function cross$5(lhs, rhs) {
                const a1 = lhs.lhs.arg;
                const b1 = lhs.rhs.arg;
                const num = rhs.lhs.lhs;
                const a2 = rhs.lhs.rhs.arg;
                const b2 = rhs.rhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2);
            }
            /**
             * cos(a)*sin(b)-sin(a)*cos(b) => sin(b-a)
             */
            let Op$a = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_cos_sin_mul_2_mul_2_rat_sin_cos', MATH_ADD$1, guardL$5, guardR$5, cross$5, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = orig.lhs.rhs.arg;
                    const b_minus_a = $.valueOf(items_to_cons$1(MATH_ADD$1, b, $.negate(a)));
                    const sin = $.valueOf(items_to_cons$1(MATH_SIN, b_minus_a));
                    return [TFLAG_DIFF, sin];
                }
            };
            const add_2_mul_2_cos_sin_mul_2_mul_2_rat_sin_cos = new Builder$d();

            let Builder$c = class Builder {
                create($) {
                    return new Op$9($);
                }
            };
            const guardLLL = is_rat$1;
            const guardLLR = and(is_cons, is_opr_1_any(MATH_COS));
            const guardLL$2 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLLL, guardLLR));
            const guardLR$2 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardL$4 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$2, guardLR$2));
            const guardRL$2 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardRR$2 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardR$4 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL$2, guardRR$2));
            function cross$4(lhs, rhs) {
                const num = lhs.lhs.lhs;
                const a1 = lhs.lhs.rhs.arg;
                const b1 = lhs.rhs.arg;
                const a2 = rhs.rhs.arg;
                const b2 = rhs.lhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2);
            }
            /**
             * -cos(a)*sin(b)+cos(b)*sin(a) => sin(a-b)
             */
            let Op$9 = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_rat_cos_sin_mul_2_mul_2_cos_sin_factoring', MATH_ADD$1, guardL$4, guardR$4, cross$4, $);
                    this.phases = MODE_FACTORING;
                    // TODO: Notice that the hash isn't very selective.
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.rhs.rhs.arg;
                    const b = orig.rhs.lhs.arg;
                    const a_minus_b = $.valueOf(items_to_cons$1(MATH_ADD$1, a, $.negate(b)));
                    const retval = $.valueOf(items_to_cons$1(MATH_SIN, a_minus_b));
                    return [TFLAG_DIFF, retval];
                }
            };
            const add_2_mul_2_rat_cos_sin_mul_2_mul_2_cos_sin_factoring = new Builder$c();

            let Builder$b = class Builder {
                create($) {
                    return new Op$8($);
                }
            };
            const guardL$3 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_SIN)), and(is_cons, is_opr_1_any(MATH_COS))));
            const guardR$3 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, and(is_cons, is_opr_1_any(MATH_COS)), and(is_cons, is_opr_1_any(MATH_SIN))));
            function cross$3(lhs, rhs) {
                const a1 = lhs.lhs.arg;
                const b1 = lhs.rhs.arg;
                const a2 = rhs.lhs.arg;
                const b2 = rhs.rhs.arg;
                return a1.equals(a2) && b1.equals(b2);
            }
            /**
             * sin(a)*cos(b)+cos(a)*sin(b) => sin(a+b)
             */
            let Op$8 = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_sin_cos_mul_2_cos_sin', MATH_ADD$1, guardL$3, guardR$3, cross$3, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = orig.lhs.rhs.arg;
                    const ab = $.valueOf(items_to_cons$1(MATH_ADD$1, a, b));
                    const sin = $.valueOf(items_to_cons$1(MATH_SIN, ab));
                    return [TFLAG_DIFF, sin];
                }
            };
            const add_2_mul_2_sin_cos_mul_2_cos_sin = new Builder$b();

            let Builder$a = class Builder {
                create($) {
                    return new Op$7($);
                }
            };
            const guardLL$1 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardLR$1 = and(is_cons, is_opr_1_any(MATH_COS));
            const guardL$2 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL$1, guardLR$1));
            const guardRLL = is_rat$1;
            const guardRLR = and(is_cons, is_opr_1_any(MATH_COS));
            const guardRL$1 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRLL, guardRLR));
            const guardRR$1 = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardR$2 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL$1, guardRR$1));
            function cross$2(lhs, rhs) {
                const a1 = lhs.lhs.arg;
                const b1 = lhs.rhs.arg;
                const num = rhs.lhs.lhs;
                const a2 = rhs.lhs.rhs.arg;
                const b2 = rhs.rhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2);
            }
            /**
             * sin(a)*cos(b)-cos(a)*sin(b) => sin(a-b)
             */
            let Op$7 = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_sin_cos_mul_2_mul_2_rat_cos_sin', MATH_ADD$1, guardL$2, guardR$2, cross$2, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = $.negate(orig.lhs.rhs.arg);
                    const a_minus_b = $.valueOf(items_to_cons$1(MATH_ADD$1, a, b));
                    const sin = $.valueOf(items_to_cons$1(MATH_SIN, a_minus_b));
                    return [TFLAG_DIFF, sin];
                }
            };
            const add_2_mul_2_sin_cos_mul_2_mul_2_rat_cos_sin = new Builder$a();

            let Builder$9 = class Builder {
                create($) {
                    return new Op$6($);
                }
            };
            const guardLL = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardLR = and(is_cons, is_opr_1_any(MATH_COS));
            const guardL$1 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardLL, guardLR));
            const guardRRL = and(is_cons, is_opr_1_any(MATH_COS));
            const guardRRR = and(is_cons, is_opr_1_any(MATH_SIN));
            const guardRR = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRRL, guardRRR));
            const guardRL = is_rat$1;
            const guardR$1 = and(is_cons, is_opr_2_lhs_rhs(MATH_MUL$3, guardRL, guardRR));
            function cross$1(lhs, rhs) {
                const a1 = lhs.lhs.arg;
                const b1 = lhs.rhs.arg;
                const num = rhs.lhs;
                const a2 = rhs.rhs.lhs.arg;
                const b2 = rhs.rhs.rhs.arg;
                return num.isMinusOne() && a1.equals(a2) && b1.equals(b2);
            }
            /**
             * TODO: This is "wrong" because it assumes that the RHS is factorized with cos and sin together.
             * In ordinary left association we would have (-1 * cos(a)) * sin(b)
             *
             * sin(a)*cos(b)+(-1*(cos(a)*sin(b))) => sin(a-b)
             */
            let Op$6 = class Op extends Function2X {
                constructor($) {
                    super('add_2_mul_2_sin_cos_mul_2_rat_mul_2_cos_sin', MATH_ADD$1, guardL$1, guardR$1, cross$1, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_MUL$3, MATH_MUL$3);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    const a = orig.lhs.lhs.arg;
                    const b = $.negate(orig.lhs.rhs.arg);
                    const a_minus_b = $.valueOf(items_to_cons$1(MATH_ADD$1, a, b));
                    const sin = $.valueOf(items_to_cons$1(MATH_SIN, a_minus_b));
                    return [TFLAG_DIFF, sin];
                }
            };
            const add_2_mul_2_sin_cos_mul_2_rat_mul_2_cos_sin = new Builder$9();

            let Builder$8 = class Builder {
                create($) {
                    return new Op$5($);
                }
            };
            const guardL = and(is_cons, is_opr_2_lhs_rhs(MATH_POW$2, and(is_cons, is_opr_1_any(MATH_COS)), is_rat$1));
            const guardR = and(is_cons, is_opr_2_lhs_rhs(MATH_POW$2, and(is_cons, is_opr_1_any(MATH_SIN)), is_rat$1));
            function cross(lhs, rhs) {
                const x1 = lhs.lhs.arg;
                const numL = lhs.rhs;
                const x2 = rhs.lhs.arg;
                const numR = rhs.rhs;
                return x1.equals(x2) && numL.isTwo() && numR.isTwo();
            }
            /**
             * (add (expt (cos x) 2) (expt (sin x) 2)) => 1
             * cos(x)**2+sin(x)**2 => 1
             */
            let Op$5 = class Op extends Function2X {
                constructor($) {
                    super('add_2_pow_2_cos_rat_pow_2_sin_rat', MATH_ADD$1, guardL, guardR, cross, $);
                    this.phases = MODE_FACTORING;
                    this.hash = hash_binop_cons_cons(MATH_ADD$1, MATH_POW$2, MATH_POW$2);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform2(opr, lhs, rhs, orig) {
                    return [TFLAG_DIFF, one];
                }
            };
            const add_2_pow_2_cos_rat_pow_2_sin_rat = new Builder$8();

            let Builder$7 = class Builder {
                constructor(name, opr, lhs, rhs) {
                    this.name = name;
                    this.opr = opr;
                    this.lhs = lhs;
                    this.rhs = rhs;
                    // Nothing to see here.
                }
                create($) {
                    return new Op$4(this.name, this.opr, this.lhs, this.rhs, $);
                }
            };
            let Op$4 = class Op extends Function2 {
                constructor(name, opr, lhs, rhs, $) {
                    super(name, opr, and(is_cons, is_opr_1_any(lhs)), and(is_cons, is_opr_1_any(rhs)), $);
                    this.hash = hash_binop_cons_cons(opr, lhs, rhs);
                }
                transform2(opr, lhs, rhs, orig) {
                    const $ = this.$;
                    return [TFLAG_DIFF, $.valueOf(items_to_cons(opr, orig.rhs, orig.lhs))];
                }
            };
            const mul_2_sin_cos = new Builder$7('mul_2_sin_cos', MATH_MUL$3, MATH_SIN, MATH_COS);

            let Builder$6 = class Builder {
                create($) {
                    return new TypeofAny$1($);
                }
            };
            let TypeofAny$1 = class TypeofAny extends Function1 {
                constructor($) {
                    super('typeof_any', create_sym('typeof'), is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    return [TFLAG_NONE, expr];
                }
            };
            const typeof_any = new Builder$6();

            /**
             * Blade
             */
            const TYPE_NAME_BLADE = create_sym('Blade');

            let Builder$5 = class Builder {
                create($) {
                    return new Op$3($);
                }
            };
            let Op$3 = class Op extends Function1 {
                constructor($) {
                    super('typeof_blade', create_sym('typeof'), is_blade, $);
                    this.dependencies = ['Blade'];
                    this.hash = hash_unaop_atom(this.opr, HASH_BLADE);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_DIFF, TYPE_NAME_BLADE];
                }
            };
            const typeof_blade = new Builder$5();

            /**
             * 'Tensor'.
             */
            const TYPE_NAME_TENSOR = create_sym('Tensor');

            let Builder$4 = class Builder {
                create($) {
                    return new TypeofAny($);
                }
            };
            class TypeofAny extends Function1 {
                constructor($) {
                    super('typeof_tensor', create_sym('typeof'), is_tensor, $);
                    this.dependencies = [];
                    this.hash = hash_unaop_atom(this.opr, HASH_TENSOR);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                transform1(opr, arg, expr) {
                    return [TFLAG_DIFF, TYPE_NAME_TENSOR];
                }
            }
            const typeof_tensor = new Builder$4();

            // always returns a matrix with rank 2
            function unit(arg, expr, $) {
                const n = evaluate_integer(cadr(expr), $);
                if (isNaN(n)) {
                    return [TFLAG_NONE, expr];
                }
                if (n < 1) {
                    return [TFLAG_NONE, expr];
                }
                const sizes = [n, n];
                const elems = create_tensor_elements_diagonal(n, one, zero);
                const I = new Tensor(sizes, elems);
                return [TFLAG_DIFF, I];
            }

            let Builder$3 = class Builder {
                create($) {
                    return new Op$2($);
                }
            };
            let Op$2 = class Op extends Function1 {
                constructor($) {
                    super('unit', UNIT, is_any, $);
                    this.hash = hash_unaop_atom(this.opr, HASH_ANY);
                }
                transform1(opr, arg, expr) {
                    const $ = this.$;
                    return unit(arg, expr, $);
                }
            };
            const unit_any = new Builder$3();

            let Builder$2 = class Builder {
                create($) {
                    return new UomStr($);
                }
            };
            /**
             * (uom Str)
             */
            class UomStr extends Function1 {
                constructor($) {
                    super('uom_1_str', create_sym('uom'), is_str, $);
                    this.hash = hash_unaop_atom(create_sym('uom'), HASH_STR);
                }
                transform1(opr, arg) {
                    // We are casting away the type safety knowing that the creation function will raise an exception.
                    // How we choose to manage exceptions is TBD.
                    return [TFLAG_DIFF, create_uom(arg.str)];
                }
            }
            const uom_1_str = new Builder$2();

            function Eval_zero(expr, $) {
                return create_zero_tensor(expr, $);
            }
            function create_zero_tensor(expr, $) {
                const k = Array(MAXDIM).fill(0);
                let m = 1;
                let ndim = 0;
                for (const el of expr.tail()) {
                    const i = evaluate_integer(el, $);
                    if (i < 1 || isNaN(i)) {
                        // if the input is nonsensical just return 0
                        return zero;
                    }
                    m *= i;
                    k[ndim++] = i;
                }
                if (ndim === 0) {
                    return zero;
                }
                const dsizes = new Array(ndim);
                for (let i = 0; i < ndim; i++) {
                    dsizes[i] = k[i];
                }
                const elems = create_tensor_elements(m, zero);
                return new Tensor(dsizes, elems);
            }

            let Builder$1 = class Builder {
                create($) {
                    return new Op$1($);
                }
            };
            let Op$1 = class Op extends FunctionVarArgs {
                constructor($) {
                    super('zero', ZERO, $);
                    this.hash = hash_nonop_cons(this.opr);
                }
                transform(expr) {
                    const $ = this.$;
                    const retval = Eval_zero(expr, $);
                    const changed = !retval.equals(expr);
                    return [changed ? TFLAG_DIFF : TFLAG_HALT, retval];
                }
            };
            const zero_varargs = new Builder$1();

            function gt_num_num(lhs, rhs) {
                return compare_num_num(lhs, rhs) === SIGN_GT;
            }

            // n/2 * i * pi ?
            //  4  -i
            function is_quarter_turn(p, $) {
                let minussign = 0;
                if (!is_multiply(p)) {
                    return 0;
                }
                if ($.equals(cadr(p), imu)) {
                    if (!is_pi(caddr(p))) {
                        return 0;
                    }
                    if (length_of_cons_otherwise_zero(p) !== 3) {
                        return 0;
                    }
                    return 2;
                }
                if (!is_num(cadr(p))) {
                    return 0;
                }
                if (!$.equals(caddr(p), imu)) {
                    return 0;
                }
                if (!is_pi(cadddr(p))) {
                    return 0;
                }
                if (length_of_cons_otherwise_zero(p) !== 4) {
                    return 0;
                }
                let n = nativeInt($.multiply(cadr(p), two));
                if (isNaN(n)) {
                    return 0;
                }
                if (n < 1) {
                    minussign = 1;
                    n = -n;
                }
                switch (n % 4) {
                    case 0:
                        n = 1;
                        break;
                    case 1:
                        n = minussign ? 4 : 3;
                        break;
                    case 2:
                        n = 2;
                        break;
                    case 3:
                        n = minussign ? 3 : 4;
                }
                return n;
            }

            //-----------------------------------------------------------------------------
            //
            //  Compute the power of a sum
            //
            //  Input:    p1  sum
            //
            //      n  exponent
            //
            //  Output:    Result on stack
            //
            //  Note:
            //
            //  Uses the multinomial series (see Math World)
            //
            //                          n              n!          n1   n2       nk
            //  (a1 + a2 + ... + ak)  = sum (--------------- a1   a2   ... ak  )
            //                               n1! n2! ... nk!
            //
            //  The sum is over all n1 ... nk such that n1 + n2 + ... + nk = n.
            //
            //-----------------------------------------------------------------------------
            // first index is the term number 0..k-1, second index is the exponent 0..n
            //define A(i, j) frame[(i) * (n + 1) + (j)]
            /**
             * Computes the power of a sum. This is only valid if the terms of the sum commute.
             * @param n
             * @param sum
             * @param $
             * @returns
             */
            function power_sum(n, sum, $) {
                // console.lg(`power_sum(n=${n}, sum=${render_as_infix(sum, $)})`);
                // number of terms in the sum
                // Notice the decrement by 1; we are not going to include the operator.
                const k = length_of_cons_otherwise_zero(sum) - 1;
                // array of powers
                const powers = [];
                // TODO: sum.argList would be better.
                let p1 = cdr(sum);
                for (let i = 0; i < k; i++) {
                    for (let j = 0; j <= n; j++) {
                        powers[i * (n + 1) + j] = $.power(car(p1), create_int(j));
                    }
                    p1 = cdr(p1);
                }
                const a = [];
                for (let i = 0; i < k; i++) {
                    a[i] = 0;
                }
                return multinomial_sum(k, n, a, 0, n, powers, factorial(create_int(n)), zero, $);
            }
            //-----------------------------------------------------------------------------
            //
            //  Compute multinomial sum
            //
            //  Input:    k  number of factors
            //
            //      n  overall exponent
            //
            //      a  partition array
            //
            //      i  partition array index
            //
            //      m  partition remainder
            //
            //      p1  n!
            //
            //      A  factor array
            //
            //  Output:    Result on stack
            //
            //  Note:
            //
            //  Uses recursive descent to fill the partition array.
            //
            //-----------------------------------------------------------------------------
            function multinomial_sum(k, n, a, i, m, A, p1, p2, $) {
                if (i < k - 1) {
                    for (let j = 0; j <= m; j++) {
                        a[i] = j;
                        p2 = multinomial_sum(k, n, a, i + 1, m - j, A, p1, p2, $);
                    }
                    return p2;
                }
                a[i] = m;
                // coefficient
                let temp = p1;
                for (let j = 0; j < k; j++) {
                    temp = divide(temp, factorial(create_int(a[j])), $);
                }
                // factors
                for (let j = 0; j < k; j++) {
                    temp = $.multiply(temp, A[j * (n + 1) + a[j]]);
                }
                return $.add(p2, temp);
            }
            // exp(n/2 i pi) ?
            // clobbers p3
            function simplify_polar(exponent, $) {
                let n = is_quarter_turn(exponent, $);
                switch (n) {
                    case 0:
                        // do nothing
                        break;
                    case 1:
                        return one;
                    case 2:
                        return negOne;
                    case 3:
                        return imu;
                    case 4:
                        return $.negate(imu);
                }
                if (is_add(exponent)) {
                    let p3 = cdr(exponent);
                    while (is_cons(p3)) {
                        n = is_quarter_turn(car(p3), $);
                        if (n) {
                            break;
                        }
                        p3 = cdr(p3);
                    }
                    let arg1;
                    switch (n) {
                        case 0:
                            return undefined;
                        case 1:
                            arg1 = one;
                            break;
                        case 2:
                            arg1 = negOne;
                            break;
                        case 3:
                            arg1 = imu;
                            break;
                        case 4:
                            arg1 = $.negate(imu);
                            break;
                    }
                    return $.multiply(arg1, exp$1($.subtract(exponent, car(p3)), $));
                }
                return undefined;
            }
            /**
             * Returns the arguments of expr as an array.
             * The operator is not included.
             * (opr a b c ...) => [a, b, c, ...]
             */
            function args_to_items(expr) {
                // Notice the decrement by 1; we are not going to include the operator.
                const k = length_of_cons_otherwise_zero(expr) - 1;
                const items = [];
                // TODO: sum.argList would be better.
                let p1 = cdr(expr);
                for (let i = 0; i < k; i++) {
                    items.push(car(p1));
                    p1 = cdr(p1);
                }
                return items;
            }

            //-----------------------------------------------------------------------------
            //
            //  Bignum root
            //
            //  Returns null pointer if not perfect root.
            //
            //  The sign of the radicand is ignored.
            //
            //-----------------------------------------------------------------------------
            function mroot(n, index) {
                n = n.abs();
                if (index === 0) {
                    halt('root index is zero');
                }
                // count number of bits
                let k = 0;
                while (n.shiftRight(k).toJSNumber() > 0) {
                    k++;
                }
                if (k === 0) {
                    return mint(0);
                }
                // initial guess
                k = Math.floor((k - 1) / index);
                const j = Math.floor(k / 32 + 1);
                let x = BigIntegerExports(j);
                for (let i = 0; i < j; i++) {
                    // zero-out the ith bit
                    x = x.and(BigIntegerExports(1).shiftLeft(i).not());
                }
                while (k >= 0) {
                    // set the kth bit
                    x = x.or(BigIntegerExports(1).shiftLeft(k));
                    const y = mpow(x, index);
                    switch (mcmp(y, n)) {
                        case 0:
                            return x;
                        case 1:
                            //mp_clr_bit(x, k)
                            // clear the kth bit
                            x = x.and(BigIntegerExports(1).shiftLeft(k).not());
                            break;
                    }
                    k--;
                }
                return 0;
            }
            //if SELFTEST

            //-----------------------------------------------------------------------------
            //
            //  Factor small numerical powers
            //
            //  Input:    BASE        Base (positive integer < 2^31 - 1)
            //            EXPONENT    Exponent
            //
            //  Output:    Expr
            //
            //-----------------------------------------------------------------------------
            function quickfactor(BASE, EXPO, $) {
                const rats = factor_small_number(nativeInt(BASE));
                const arr = rats;
                const n = arr.length;
                for (let i = 0; i < n; i += 2) {
                    // In fact, why use $.multiply when we only have Rat(s)?
                    // We may also be able to prove that this function returns a Rat.
                    arr.push(...quickpower(rats[i], $.multiply(arr[i + 1], EXPO), $)); // factored base, factored exponent * EXPO
                }
                // arr0 has n results from factor_number_raw()
                // on top of that are all the expressions from quickpower()
                // multiply the quickpower() results
                return multiply_items(arr.slice(n), $);
            }
            // BASE is a prime number so power is simpler
            function quickpower(BASE, EXPO, $) {
                const p3 = bignum_truncate(EXPO);
                const p4 = $.subtract(EXPO, p3);
                let fractionalPart;
                // fractional part of EXPO
                if (!$.is_zero(p4)) {
                    fractionalPart = items_to_cons(POWER$1, BASE, p4);
                }
                const expo = nativeInt(p3);
                if (isNaN(expo)) {
                    const result = items_to_cons(POWER$1, BASE, p3);
                    return fractionalPart ? [fractionalPart, result] : [result];
                }
                if (expo === 0) {
                    return [fractionalPart];
                }
                const result = bignum_power_number(BASE, expo);
                return fractionalPart ? [fractionalPart, result] : [result];
            }
            //if SELFTEST

            // Rational power function
            function pow_rat_rat(base, expo, $) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg("pow_rat_rat", render_as_sexpr(base, $), render_as_sexpr(expo, $), render_as_sexpr(retval, $), description);
                    return retval;
                };
                //unsigned int a, b, *t, *x, *y
                // if base is 1 or exponent is 0 then return 1
                if (base.isOne() || expo.isZero()) {
                    return hook(one);
                }
                // (expt -1 1/2) is replaced by the imaginary unit.
                if (base.isMinusOne() && expo.isHalf()) {
                    // console.lg(`power(base => ${base}, expo => ${expo}) => i`);
                    return hook(imu);
                }
                // console.lg(`power(base => ${base}, expo => ${expo}) => ?`);
                // if base is zero then return 0
                if ($.is_zero(base)) {
                    if (is_negative_number(expo)) {
                        throw new Error(`divide by zero for base => ${base} and exponent => ${expo}`);
                    }
                    return hook(zero);
                }
                // if exponent is 1 then return base
                if (expo.isOne()) {
                    return hook(base);
                }
                let expoJs = 0;
                let x;
                let y;
                // if exponent is integer then power
                if (is_rat_and_integer(expo)) {
                    expoJs = nativeInt(expo);
                    if (isNaN(expoJs)) {
                        // expo greater than 32 bits
                        return hook(items_to_cons(POWER$1, base, expo));
                    }
                    x = mpow(base.a, Math.abs(expoJs));
                    y = mpow(base.b, Math.abs(expoJs));
                    if (expoJs < 0) {
                        const t = x;
                        x = y;
                        y = t;
                        x = makeSignSameAs(x, y);
                        y = makePositive(y);
                    }
                    return hook(new Rat(x, y));
                }
                // from here on out the exponent is NOT an integer
                // if base is -1 then normalize polar angle
                if (is_num_and_eq_minus_one(base)) {
                    return hook(normalize_angle(expo, $));
                }
                // if base is negative then (-N)^M -> N^M * (-1)^M
                if (is_negative_number(base)) {
                    return hook($.multiply(pow_rat_rat($.negate(base), expo, $), pow_rat_rat(negOne, expo, $)));
                }
                // if base is not an integer then power numerator and denominator
                if (!is_rat_and_integer(base)) {
                    // (m/n)^a = m^a * n^(-a)
                    const m = base.numer();
                    const n = base.denom();
                    const a = expo;
                    const pow_m_a = pow_rat_rat(m, a, $);
                    const minus_a = a.neg();
                    const pow_n_minus_a = pow_rat_rat(n, minus_a, $);
                    return hook($.multiply(pow_m_a, pow_n_minus_a));
                }
                // At this point base is a positive integer.
                // If base is small then factor it.
                if (is_small_integer(base)) {
                    return hook(quickfactor(base, expo, $));
                }
                // At this point base is a positive integer and EXPO is not an integer.
                if (!in_safe_integer_range(expo.a) || !in_safe_integer_range(expo.b)) {
                    return hook(items_to_cons(POWER$1, base, expo));
                }
                const { a, b } = expo;
                x = mroot(base.a, b.toJSNumber());
                if (x === 0) {
                    return hook(items_to_cons(POWER$1, base, expo));
                }
                y = mpow(x, a);
                return hook(expo.a.isNegative() ? new Rat(BigIntegerExports.one, y) : new Rat(y, BigIntegerExports.one));
            }
            //-----------------------------------------------------------------------------
            //
            //  Normalize the angle of unit imaginary, i.e. (-1) ^ N
            //
            //  Input:    N on stack (must be rational, not float)
            //
            //  Output:    Result on stack
            //
            //  Note:
            //
            //  n = q * d + r
            //
            //  Example:
            //            n  d  q  r
            //
            //  (-1)^(8/3)  ->   (-1)^(2/3)  8  3  2  2
            //  (-1)^(7/3)  ->   (-1)^(1/3)  7  3  2  1
            //  (-1)^(5/3)  ->  -(-1)^(2/3)  5  3  1  2
            //  (-1)^(4/3)  ->  -(-1)^(1/3)  4  3  1  1
            //  (-1)^(2/3)  ->   (-1)^(2/3)  2  3  0  2
            //  (-1)^(1/3)  ->   (-1)^(1/3)  1  3  0  1
            //
            //  (-1)^(-1/3)  ->  -(-1)^(2/3)  -1  3  -1  2
            //  (-1)^(-2/3)  ->  -(-1)^(1/3)  -2  3  -1  1
            //  (-1)^(-4/3)  ->   (-1)^(2/3)  -4  3  -2  2
            //  (-1)^(-5/3)  ->   (-1)^(1/3)  -5  3  -2  1
            //  (-1)^(-7/3)  ->  -(-1)^(2/3)  -7  3  -3  2
            //  (-1)^(-8/3)  ->  -(-1)^(1/3)  -8  3  -3  1
            //
            //-----------------------------------------------------------------------------
            function normalize_angle(A, $) {
                // integer exponent?
                if (is_rat_and_integer(A)) {
                    if (A.a.isOdd()) {
                        return negOne; // odd exponent
                    }
                    else {
                        return one; // even exponent
                    }
                }
                // floor
                let Q = bignum_truncate(A);
                if (is_negative_number(A)) {
                    Q = Q.add(negOne);
                }
                // remainder (always positive)
                // TODO: Need a sub on Rat
                const R = $.subtract(A, Q);
                // remainder becomes new angle
                let result = items_to_cons(POWER$1, negOne, R);
                // negate if quotient is odd
                if (Q.a.isOdd()) {
                    result = $.negate(result);
                }
                return result;
            }
            function is_small_integer(p) {
                return in_safe_integer_range(p.a);
            }

            // power function for double precision floating point
            function dpow(base, expo, $) {
                if (base === 0.0 && expo < 0.0) {
                    throw new Error('divide by zero');
                }
                // nonnegative base or integer power?
                if (base >= 0.0 || expo % 1.0 === 0.0) {
                    return create_flt(Math.pow(base, expo));
                }
                const result = Math.pow(Math.abs(base), expo);
                const theta = Math.PI * expo;
                let a = 0.0;
                let b = 0.0;
                // this ensures the real part is 0.0 instead of a tiny fraction
                if (expo % 0.5 === 0.0) {
                    a = 0.0;
                    b = Math.sin(theta);
                }
                else {
                    a = Math.cos(theta);
                    b = Math.sin(theta);
                }
                return $.add(create_flt(a * result), $.multiply(create_flt(b * result), imu));
            }

            /**
             *
             * @param base
             * @param expo
             * @param $
             * @returns
             */
            function power_v1(base, expo, $) {
                // console.lg(`power_v1 base=${$.toInfixString(base)} expo=${$.toInfixString(expo)}`);
                if (typeof base === 'undefined') {
                    throw new Error("base must be defined.");
                }
                if (typeof expo === 'undefined') {
                    throw new Error("expo must be defined.");
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`power ${render_as_infix(base, $)} ${render_as_infix(expo, $)} => ${render_as_infix(retval, $)} made by power_v1 at ${description}`);
                    // console.lg(`HOOK power ${render_as_sexpr(base, $)} ${render_as_sexpr(expo, $)} => ${render_as_sexpr(retval, $)} made by power_v1 at ${description}`);
                    return retval;
                };
                // first, some very basic simplifications right away
                //  1 ^ a    ->  1
                //  a ^ 0    ->  1
                if ($.equals(base, one) || $.is_zero(expo)) {
                    const dynOne = $.getNativeDirective(Directive.evaluatingAsFloat) ? oneAsFlt : one;
                    return hook(dynOne);
                }
                //  a ^ 1    ->  a
                if ($.equals(expo, one)) {
                    return hook(base);
                }
                //   -1 ^ -1    ->  -1
                if (is_num_and_eq_minus_one(base) && is_num_and_eq_minus_one(expo)) {
                    const negOne = $.negate($.getNativeDirective(Directive.evaluatingAsFloat) ? oneAsFlt : one);
                    return hook(negOne);
                }
                //   -1 ^ 1/2  ->  i
                if (is_num_and_eq_minus_one(base) && is_num_and_equal_one_half(expo)) {
                    if ($.getNativeDirective(Directive.evaluatingAsClock)) {
                        return items_to_cons$1(POWER$1, base, expo);
                    }
                    else {
                        return hook(imu);
                    }
                }
                //   -1 ^ -1/2  ->  -i
                if (is_num_and_eq_minus_one(base) && is_num_and_equal_minus_half(expo)) {
                    if ($.getNativeDirective(Directive.evaluatingAsClock)) {
                        return items_to_cons$1(POWER$1, base, expo);
                    }
                    else {
                        const result = $.negate(imu);
                        return hook(result);
                    }
                }
                //   -1 ^ rational
                if (is_num_and_eq_minus_one(base) &&
                    !is_flt$1(base) &&
                    is_rat$1(expo) &&
                    !is_rat_and_integer(expo) &&
                    is_num_and_gt_zero(expo) &&
                    !$.getNativeDirective(Directive.evaluatingAsFloat)) {
                    // console.lg("base", $.toInfixString(base));
                    // console.lg("expo", $.toInfixString(expo));
                    // console.lg("typeof expo.a", typeof expo.a);
                    if (expo.numer().compare(expo.denom()) < 0) {
                        return hook(items_to_cons$1(POWER$1, base, expo));
                    }
                    else {
                        const raw = items_to_cons$1(MULTIPLY$1, base, items_to_cons$1(POWER$1, base, rational(expo.a.mod(expo.b), expo.b)));
                        const value = $.valueOf(raw);
                        return hook(value);
                    }
                }
                // both base and exponent are rational numbers?
                if (is_rat$1(base) && is_rat$1(expo)) {
                    const result = pow_rat_rat(base, expo, $);
                    return hook(result);
                }
                // both base and exponent are either rational or double?
                if (is_num(base) && is_num(expo)) {
                    const result = dpow(nativeDouble(base), nativeDouble(expo), $);
                    return hook(result);
                }
                if (is_tensor(base)) {
                    const result = power_tensor(base, expo, $);
                    return hook(result);
                }
                if (is_uom(base)) {
                    if (is_rat$1(expo)) {
                        const qq = QQ.valueOf(expo.a.toJSNumber(), expo.b.toJSNumber());
                        return hook(base.pow(qq));
                    }
                    else if (is_flt$1(expo)) {
                        const qq = QQ.valueOf(expo.d, 1);
                        return hook(base.pow(qq));
                    }
                }
                // if we only assume variables to be real, then |a|^2 = a^2
                // (if x is complex this doesn't hold e.g. i, which makes 1 and -1
                // Looking for (pow (abs ...) )
                // console.lg("power_v1", $.toSExprString(base), $.toSExprString(expo));
                if (is_cons(base)) {
                    if (is_abs(base)) {
                        if (iseveninteger(expo)) {
                            // Be careful doing this as the result could be unknown.
                            /*
                            if ($.is_real(base)) {
                                // console.lg($.toSExprString(base), "is real");
                            }
                            else {
                                // console.lg($.toSExprString(base), "is NOT real");
                            }
                            */
                            if (!$.is_zero($.getSymbolValue(ASSUME_REAL_VARIABLES))) {
                                const result = $.power(cadr(base), expo);
                                return hook(result);
                            }
                        }
                    }
                }
                // TODO: This code will be extracted into special handlers (all code should be?).
                // e^log(...)
                if (is_base_of_natural_logarithm(base) && car(expo).equals(LOG$1)) {
                    const result = cadr(expo);
                    return hook(result);
                }
                // e^some_float
                // Expect this to be covered by math.exp.Flt operator.
                if (is_base_of_natural_logarithm(base) && is_flt$1(expo)) {
                    const result = create_flt(Math.exp(expo.d));
                    return hook(result);
                }
                // complex number in exponential form, get it to rectangular
                // but only if we are not in the process of calculating a polar form,
                // otherwise we'd just undo the work we want to do
                if (is_base_of_natural_logarithm(base) && expo.contains(imu) && expo.contains(PI$7) && !$.getNativeDirective(Directive.evaluatingAsPolar)) {
                    // TODO: We could simply use origExpr now that it is an agument.
                    const tmp = items_to_cons$1(POWER$1, base, expo);
                    const hopefullySimplified = rect$2(tmp, $); // put new (hopefully simplified expr) in exponent
                    if (!hopefullySimplified.contains(PI$7)) {
                        // console.lg(`hopefullySimplified=${hopefullySimplified}`);
                        return hook(hopefullySimplified);
                    }
                }
                // The following will only be true if the a's commute.
                // That is not the case for vectors, tensors, ...
                //  (* a1 a2 a3 ...) ^ m  ->  (a1 ^ m) * (a2 ^ m) * (a3 ^ m) ...
                // note that we can't in general do this, for example
                // sqrt(x*y) != x^(1/2) y^(1/2) (counterexample" x = -1 and y = -1)
                // BUT we can carve-out here some cases where this
                // transformation is correct.
                if ($.isExpanding()) {
                    // console.lg(`isExpanding=${$.isExpanding()}`);
                    // console.lg(`base=>${render_as_infix(base, $)}`);
                    // console.lg(`expo=>${render_as_infix(expo, $)}`);
                    // console.lg(`base is scalar=>${$.isScalar(base)}`);
                    if (is_multiply(base) /*&& $.isScalar(base)*/ && is_rat_and_integer(expo)) {
                        const aList = base.cdr;
                        if (is_cons(aList)) {
                            const a1 = aList.car;
                            let result = $.power(a1, expo);
                            if (is_cons(aList)) {
                                const others = aList.tail();
                                result = others.reduce((prev, curr) => $.multiply(prev, $.power(curr, expo)), result);
                            }
                            return hook(result);
                        }
                        if (is_nil(aList)) {
                            // Slightly strange case of no a's means (*) => 1, and then 1 ^ m is simply 1.
                            return hook(one);
                        }
                    }
                }
                // (a ^ b) ^ c  ->  a ^ (b * c)
                // note that we can't in general do this, for example
                // sqrt(x^y) !=  x^(1/2 y) (counterexample x = -1)
                // BUT we can carve-out here some cases where this
                // transformation is correct
                // simple numeric check to see if a is a number > 0
                let is_a_moreThanZero = false;
                const cadrBase = cadr(base);
                if (is_num(cadrBase)) {
                    is_a_moreThanZero = gt_num_num(cadrBase, zero);
                }
                // when c is an integer and when a is >= 0
                if (is_power(base) && (is_rat_and_integer(expo) || is_a_moreThanZero)) {
                    const result = $.power(cadr(base), $.multiply(caddr(base), expo));
                    return hook(result);
                }
                let b_isEven_and_c_isItsInverse = false;
                if (iseveninteger(caddr(base))) {
                    const isThisOne = $.multiply(caddr(base), expo);
                    if (is_plus_or_minus_one(isThisOne, $)) {
                        b_isEven_and_c_isItsInverse = true;
                    }
                }
                if (is_power(base) && b_isEven_and_c_isItsInverse) {
                    if ($.isFactoring()) {
                        const result = abs$1(cadr(base), $);
                        return hook(result);
                    }
                    else {
                        return hook(items_to_cons$1(POWER$1, base, expo));
                    }
                }
                //  when expanding,
                //  (a + b + ...) ^ n  ->  (a + b + ...) * (a + b + ...) ...
                // We check to see if 
                if ($.isExpanding() && is_add(base) && is_num(expo)) {
                    const terms = args_to_items(base);
                    const everyTermIsScalar = terms.every(function (term) {
                        // console.lg("term", $.toSExprString(term));
                        return $.is_real(term);
                    });
                    // console.lg(`everyTermIsScalar=>${everyTermIsScalar}`);
                    const n = nativeInt(expo);
                    if (n > 1 && !isNaN(n)) {
                        if (everyTermIsScalar) {
                            const result = power_sum(n, base, $);
                            return hook(result);
                        }
                    }
                }
                //  sin(x) ^ 2n -> (1 - cos(x) ^ 2) ^ n
                if (defs.trigmode === 1 && car(base).equals(SIN$1) && iseveninteger(expo)) {
                    const result = $.power($.subtract(one, $.power(cos(cadr(base), $), two)), $.multiply(expo, half));
                    return hook(result);
                }
                //  cos(x) ^ 2n -> (1 - sin(x) ^ 2) ^ n
                if (defs.trigmode === 2 && car(base).equals(COS$3) && iseveninteger(expo)) {
                    const result = $.power($.subtract(one, $.power(sin(cadr(base), $), two)), $.multiply(expo, half));
                    return hook(result);
                }
                // console.lg(`${$.toInfixString(base)} TESTING FOR IS COMPLEX...`);
                // complex number? (just number, not expression)
                if (is_complex_number(base)) {
                    // console.lg(`${$.toInfixString(base)} IS COMPLEX`)
                    // integer power?
                    // n will be negative here, positive n already handled
                    if (is_rat_and_integer(expo)) {
                        //               /        \  n
                        //         -n   |  a - ib  |
                        // (a + ib)   = | -------- |
                        //              |   2   2  |
                        //               \ a + b  /
                        const p3 = complex_conjugate(base, $);
                        // gets the denominator
                        let result = divide(p3, $.multiply(p3, base), $);
                        if (!is_plus_or_minus_one(expo, $)) {
                            result = $.power(result, $.negate(expo));
                        }
                        return hook(result);
                    }
                    // noninteger or floating power?
                    if (is_num(expo)) {
                        // remember that the "double" type is
                        // toxic, i.e. it propagates, so we do
                        // need to evaluate PI to its actual double
                        // value
                        const pi = $.getNativeDirective(Directive.evaluatingAsFloat) || (iscomplexnumberdouble(base, $) && is_flt$1(expo)) ? create_flt(Math.PI) : PI$7;
                        let tmp = $.multiply($.power(abs$1(base, $), expo), $.power(negOne, $.divide($.multiply($.arg(base), expo), pi)));
                        // if we calculate the power making use of arctan:
                        //  * it prevents nested radicals from being simplified
                        //  * results become really hard to manipulate afterwards
                        //  * we can't go back to other forms.
                        // so leave the power as it is.
                        if (tmp.contains(ARCTAN)) {
                            tmp = items_to_cons$1(POWER$1, base, expo);
                        }
                        return hook(tmp);
                    }
                }
                const polarResult = simplify_polar(expo, $);
                if (polarResult !== undefined) {
                    return hook(polarResult);
                }
                return hook(items_to_cons$1(POWER$1, base, expo));
            }

            function Eval_power(expr, $) {
                // console.lg("Eval_power", $.toSExprString(expr));
                const argList = expr.argList;
                const baseArg = argList.car;
                const expoArg = argList.cdr.car;
                const base = $.valueOf(baseArg);
                const expo = $.valueOf(expoArg);
                if (base.equals(baseArg) && expo.equals(expoArg)) {
                    return power_v1(base, expo, $);
                }
                else {
                    return $.valueOf(items_to_cons$1(MATH_POW$2, base, expo));
                }
            }

            function define_std_operators($) {
                // 
                const MATH_ADD = native_sym(Native.add);
                const testeq = native_sym(Native.test_eq);
                $.setSymbolOrder(MATH_ADD, new AddComparator());
                $.setSymbolOrder(MATH_MUL$3, new MulComparator());
                $.defineOperator(make_lhs_distrib_expand_law(MATH_MUL$3, MATH_ADD));
                $.defineOperator(make_rhs_distrib_expand_law(MATH_MUL$3, MATH_ADD));
                $.defineOperator(make_lhs_distrib_expand_law(MATH_INNER, MATH_ADD));
                $.defineOperator(make_rhs_distrib_expand_law(MATH_INNER, MATH_ADD));
                $.defineOperator(add_2_add_2_any_mul_2_rat_sym);
                $.defineOperator(add_2_flt_flt);
                $.defineOperator(add_2_flt_rat); // Possibly redundant now that we have (+ Flt U)
                $.defineOperator(add_2_flt_uom); // You can't add a Flt to a Uom, but you might multiply a Flt be a Uom.
                $.defineOperator(add_2_flt_any);
                $.defineOperator(add_2_rat_blade);
                $.defineOperator(add_2_rat_uom);
                $.defineOperator(add_2_rat_flt);
                $.defineOperator(add_2_rat_rat);
                $.defineOperator(add_2_rat_sym);
                $.defineOperator(add_2_tensor_tensor);
                $.defineOperator(add_2_uom_flt);
                $.defineOperator(add_2_uom_rat);
                // Missing add_sym_flt
                // Missing add_sym_rat
                $.defineOperator(add_2_sym_rat);
                $.defineOperator(add_2_xxx_mul_2_rm1_xxx);
                $.defineOperator(add_2_blade_mul_2_rat_blade);
                $.defineOperator(add_2_add_2_any_any_any_factorize_rhs);
                // Not needed because it only works for binary expressions.
                // $.defineOperator(add_2_add_any);
                $.defineOperator(add_2_mul_2_rat_X_mul_2_rat_X);
                $.defineOperator(add_2_mul_2_rat_zzz_aaa);
                $.defineOperator(add_2_mul_2_any_imu_sym);
                $.defineOperator(add_2_mul_2_sin_cos_mul_2_cos_sin);
                $.defineOperator(add_2_mul_2_cos_sin_mul_2_cos_sin_ordering);
                $.defineOperator(add_2_mul_2_cos_sin_mul_2_cos_sin_factoring);
                $.defineOperator(add_2_mul_2_sin_cos_mul_2_mul_2_rat_cos_sin);
                $.defineOperator(add_2_mul_2_sin_cos_mul_2_rat_mul_2_cos_sin);
                $.defineOperator(add_2_mul_2_cos_cos_mul_2_mul_2_rat_sin_sin);
                $.defineOperator(add_2_mul_2_cos_cos_mul_2_sin_sin);
                $.defineOperator(add_2_mul_2_cos_sin_mul_2_mul_2_rat_sin_cos);
                $.defineOperator(add_2_mul_2_cos_sin_mul_2_mul_2_rat_cos_sin_ordering);
                $.defineOperator(add_2_mul_2_cos_sin_mul_2_mul_2_rat_cos_sin_factoring);
                $.defineOperator(add_2_mul_2_rat_cos_sin_mul_2_mul_2_cos_sin_factoring);
                $.defineOperator(add_2_pow_2_cos_rat_pow_2_sin_rat);
                $.defineOperator(add_2_pow_2_any_any_mul_2_any_any);
                $.defineOperator(add_2_sym_sym);
                $.defineOperator(add_2_blade_blade);
                $.defineOperator(add_2_imu_flt);
                $.defineOperator(add_2_any_any_zero_sum);
                $.defineOperator(add_2_any_any_factorize_rhs);
                $.defineOperator(add_varargs);
                $.defineAssociative(MATH_ADD, zero);
                $.defineAssociative(MATH_MUL$3, one);
                // TODO: See what these do. Ensure unit tests. Remove.
                $.defineOperator(pow_2_pow_2_e_any_rat);
                // $.defineOperator(pow_2_pow_2_any_rat_rat);
                $.defineOperator(pow_2_e_rat);
                $.defineOperator(pow_2_e_log);
                $.defineOperator(pow_2_e_any); // Needed
                // $.defineOperator(pow_2_sym_rat);
                // $.defineOperator(pow_2_rat_rat);
                // $.defineOperator(pow_2_rat_mul_2_rat_rat);
                // $.defineOperator(pow_2_flt_rat);
                $.defineOperator(pow_2_imu_rat); // Needed
                // $.defineOperator(pow_2_uom_rat);
                // $.defineOperator(pow_2_blade_rat);
                // $.defineOperator(pow_2_any_rat);
                // $.defineOperator(pow_2_any_any);
                // $.defineOperator(pow);
                $.defineLegacyTransformer(MATH_POW$2, Eval_power);
                $.defineOperator(mul_2_sym_blade);
                // $.defineOperator(mul_cons_sym);
                $.defineOperator(mul_2_any_flt);
                $.defineOperator(mul_2_any_rat);
                $.defineOperator(mul_2_flt_flt);
                $.defineOperator(mul_2_flt_rat);
                $.defineOperator(mul_2_flt_imu);
                $.defineOperator(mul_2_flt_uom);
                $.defineOperator(mul_2_flt_mul_2_flt_any);
                $.defineOperator(mul_2_flt_any);
                $.defineOperator(mul_2_imu_flt);
                $.defineOperator(mul_2_imu_imu);
                $.defineOperator(mul_2_rat_blade);
                $.defineOperator(mul_2_rat_flt);
                $.defineOperator(mul_2_rat_rat);
                $.defineOperator(mul_2_rat_sym);
                $.defineOperator(mul_2_rat_tensor);
                $.defineOperator(mul_2_rat_any);
                $.defineOperator(mul_2_mul_2_rat_any_mul_2_rat_any);
                $.defineOperator(simplify_mul_2_blade_mul_2_blade_any);
                // The following is only used for right-associating.
                $.defineOperator(mul_2_mul_2_sym_imu_sym);
                // $.defineOperator(mul_2_mul_2_num_any_rat);
                $.defineOperator(mul_2_mul_2_any_cons_sym);
                $.defineOperator(mul_2_mul_2_any_sym_imu);
                $.defineOperator(mul_2_mul_2_any_sym_mul_2_imu_sym);
                // Notice how we need three operators in order to provide canonical ordering.
                // TODO: DRY the duplication of hash specification and matching guard functions.
                $.defineOperator(heterogenous_canonical_order_lhs_assoc('HCOLA Flt * Uom', hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_FLT), MATH_MUL$3, is_flt, is_uom));
                $.defineOperator(heterogenous_canonical_order_lhs_assoc('HCOLA Rat * Uom', hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_RAT), MATH_MUL$3, is_flt, is_uom));
                $.defineOperator(heterogenous_canonical_order_lhs_assoc('HCOLA Sym * Blade', hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_SYM), MATH_MUL$3, is_sym, is_blade$1));
                $.defineOperator(heterogenous_canonical_order_lhs_assoc('HCOLA Sym * Uom', hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_SYM), MATH_MUL$3, is_sym, is_uom));
                $.defineOperator(heterogenous_canonical_order_lhs_assoc('HCOLA Blade * Uom', hash_binop_cons_atom(MATH_MUL$3, MATH_MUL$3, HASH_BLADE), MATH_MUL$3, is_blade$1, is_uom));
                $.defineOperator(mul_2_pow_2_xxx_rat_xxx);
                $.defineOperator(mul_2_X_pow_2_X_rat);
                $.defineOperator(mul_2_sym_mul_2_rat_any);
                $.defineOperator(mul_2_hyp_rat);
                $.defineOperator(mul_2_sym_rat);
                $.defineOperator(mul_2_sym_num);
                $.defineOperator(mul_2_sym_imu);
                $.defineOperator(mul_2_sym_tensor);
                $.defineOperator(mul_2_tensor_sym);
                $.defineOperator(mul_2_tensor_any);
                $.defineOperator(mul_2_tensor_tensor);
                $.defineOperator(mul_2_mul_2_any_X_pow_2_X_rat);
                $.defineOperator(mul_2_mul_2_any_Z_pow_2_A_any);
                // Distribution Laws in Factoring direction for symmetric and left-associated.
                // This concept should have an abstraction. 
                $.defineOperator(mul_2_pow_2_xxx_any_pow_2_xxx_any);
                // $.defineOperator(mul_2_pow_2_sym_any_pow_2_sym_any);
                $.defineOperator(mul_2_mul_2_any_pow_2_xxx_any_pow_2_xxx_any);
                $.defineOperator(mul_2_hyp_sym);
                // TODO: Notice that this transformer is not being found because Num is not recognized in hashing...
                $.defineOperator(mul_2_uom_rat);
                $.defineOperator(mul_2_uom_flt);
                $.defineOperator(mul_2_uom_uom);
                $.defineOperator(mul_2_blade_rat);
                $.defineOperator(mul_2_blade_blade);
                $.defineOperator(mul_2_sin_cos);
                $.defineOperator(mul_varargs);
                $.defineLegacyTransformer(APPROXRATIO, Eval_approxratio);
                $.defineOperator(binomial_varargs);
                $.defineLegacyTransformer(CHECK, Eval_check);
                $.defineOperator(choose_varargs);
                $.defineLegacyTransformer(CLEAR, Eval_clear);
                $.defineKeyword(CLEARALL, Eval_clearall);
                $.defineOperator(conj_add);
                $.defineOperator(conj_inner);
                $.defineOperator(conj_sym);
                $.defineOperator(conj_rat);
                $.defineOperator(conj_flt);
                $.defineOperator(conj_imu);
                $.defineOperator(conj_blade);
                $.defineOperator(conj_mul_2_any_any);
                $.defineOperator(conj_any);
                $.defineOperator(degree_varargs);
                $.defineOperator(gamma_varargs);
                $.defineOperator(gcd_varargs);
                $.defineOperator(hermite_varargs);
                $.defineOperator(inner_2_num_num);
                $.defineOperator(inner_2_rat_imu);
                $.defineOperator(inner_2_rat_sym);
                $.defineOperator(inner_2_rat_any);
                $.defineOperator(inner_2_imu_rat);
                $.defineOperator(inner_2_imu_imu);
                $.defineOperator(inner_2_imu_any);
                $.defineOperator(inner_2_sym_sym);
                $.defineOperator(inner_2_vec_scalar);
                $.defineOperator(inner_2_blade_blade);
                $.defineOperator(inner_2_real_any);
                $.defineOperator(inner_2_any_real);
                $.defineOperator(inner_2_any_rat);
                $.defineOperator(inner_2_any_imu);
                $.defineOperator(inner_extension);
                $.defineOperator(laguerre_varargs);
                $.defineOperator(lcm_varargs);
                $.defineOperator(lco_2_blade_blade);
                $.defineOperator(make_lhs_distrib_expand_law(MATH_LCO, MATH_ADD));
                $.defineOperator(make_rhs_distrib_expand_law(MATH_LCO, MATH_ADD));
                $.defineOperator(lco_2_any_any);
                $.defineOperator(legendre_varargs);
                $.defineOperator(log_varargs);
                $.defineOperator(mod_varargs);
                $.defineOperator(outer_2_blade_blade);
                $.defineOperator(outer_2_tensor_tensor);
                $.defineOperator(make_lhs_distrib_expand_law(MATH_OUTER, MATH_ADD));
                $.defineOperator(make_rhs_distrib_expand_law(MATH_OUTER, MATH_ADD));
                $.defineOperator(outer_2_mul_2_scalar_any_any);
                // $.defineOperator(outer_2_sym_sym_vector_antisymmetry);
                // $.defineOperator(outer_2_sym_sym_vector_to_geometric);
                $.defineOperator(outer_2_sym_sym);
                $.defineOperator(outer_2_any_mul_2_scalar_any);
                $.defineOperator(outer_2_any_any);
                $.defineOperator(rank_varargs);
                $.defineOperator(rco_2_blade_blade);
                $.defineOperator(make_lhs_distrib_expand_law(MATH_RCO, MATH_ADD));
                $.defineOperator(make_rhs_distrib_expand_law(MATH_RCO, MATH_ADD));
                $.defineOperator(rco_2_mul_2_scalar_any_any);
                $.defineOperator(rco_2_any_mul_2_scalar_any);
                $.defineOperator(rco_2_any_any);
                $.defineOperator(boo_extension);
                $.defineOperator(rat_extension);
                $.defineOperator(flt_extension);
                $.defineOperator(str_extension);
                $.defineOperator(abs_add_blades);
                $.defineOperator(abs_blade);
                $.defineOperator(abs_pow_any_negone);
                $.defineOperator(abs_flt);
                $.defineOperator(abs_imu);
                $.defineOperator(abs_rat);
                $.defineOperator(abs_tensor);
                $.defineOperator(abs_uom);
                // $.defineOperator(abs_sym_real);
                // $.defineOperator(abs_factorize);
                $.defineOperator(abs_any);
                $.defineOperator(adj_any);
                $.defineOperator(algebra_2_tensor_tensor);
                $.defineLegacyTransformer(AND, Eval_and);
                $.defineOperator(arccos_varargs);
                $.defineOperator(arccosh_varargs);
                $.defineOperator(arcsin_varargs);
                $.defineOperator(arcsinh_any);
                $.defineOperator(arctan_varargs);
                $.defineOperator(arctanh_varargs);
                $.defineOperator(arg_add);
                $.defineOperator(arg_flt);
                $.defineOperator(arg_imu);
                $.defineOperator(arg_mul);
                $.defineOperator(arg_pow);
                $.defineOperator(arg_rat);
                $.defineOperator(arg_sym);
                $.defineOperator(arg_any);
                $.defineOperator(assign_sym_any);
                $.defineOperator(assign_any_any);
                $.defineOperator(besselj_varargs);
                $.defineOperator(bessely_varargs);
                $.defineOperator(ceiling_flt);
                $.defineOperator(ceiling_rat);
                $.defineOperator(ceiling_cons);
                $.defineOperator(circexp_any);
                $.defineOperator(clock_any);
                $.defineOperator(coeff_varargs);
                $.defineOperator(cofactor_varargs);
                $.defineOperator(condense_varargs);
                $.defineOperator(contract_varargs);
                $.defineOperator(cos_add_2_any_any);
                $.defineOperator(cos_mul_2_any_imu);
                $.defineOperator(cos_sym);
                $.defineOperator(cos_hyp);
                $.defineOperator(cos_any);
                $.defineOperator(cosh_sym);
                $.defineOperator(cosh_varargs);
                $.defineOperator(cross_blade_blade);
                $.defineOperator(make_lhs_distrib_expand_law(MATH_VECTOR_CROSS_PRODUCT, MATH_ADD));
                $.defineOperator(make_rhs_distrib_expand_law(MATH_VECTOR_CROSS_PRODUCT, MATH_ADD));
                $.defineOperator(cross_any_any);
                $.defineOperator(defint);
                $.defineOperator(denominator_fn);
                $.defineOperator(d_to_derivative);
                $.defineOperator(derivative_2_mul_any);
                $.defineOperator(derivative_2_pow_any);
                $.defineOperator(derivative_fn);
                $.defineOperator(det_any);
                $.defineOperator(dim_varargs);
                $.defineOperator(dirac_varargs);
                $.defineOperator(divisors_varargs);
                $.defineOperator(do_varargs);
                $.defineOperator(eigen_varargs);
                $.defineOperator(eigenval_varargs);
                $.defineOperator(eigenvec_varargs);
                $.defineOperator(erf_varargs);
                $.defineOperator(erfc_varargs);
                $.defineOperator(eval_varargs);
                $.defineOperator(exp_add);
                $.defineOperator(exp_flt);
                $.defineOperator(exp_rat);
                $.defineOperator(exp);
                $.defineOperator(expand_extension);
                $.defineOperator(expcos_varargs);
                $.defineOperator(expsin_varargs);
                $.defineOperator(factor_varargs);
                $.defineOperator(factorial_varargs);
                $.defineOperator(float_varargs);
                $.defineOperator(floor_varargs);
                $.defineOperator(for_varargs);
                $.defineOperator(hilbert_varargs);
                $.defineOperator(imag_add);
                $.defineOperator(imag_arctan_rat);
                $.defineOperator(imag_cos);
                $.defineOperator(imag_exp);
                $.defineOperator(imag_flt);
                $.defineOperator(imag_imu);
                $.defineOperator(imag_log_rat);
                $.defineOperator(imag_rat);
                $.defineOperator(imag_sin);
                $.defineOperator(imag_sym);
                $.defineOperator(imag_mul_i_times_any);
                $.defineOperator(imag_mul);
                $.defineOperator(imag_pow_e_rat);
                $.defineOperator(imag_pow_e_sym);
                $.defineOperator(imag_pow_rat_rat);
                $.defineOperator(imag_any);
                $.defineOperator(index_varargs);
                $.defineOperator(integral_varargs);
                $.defineOperator(inv_inv);
                $.defineOperator(inv_any);
                $.defineOperator(isprime_varargs);
                $.defineOperator(iszero_rat);
                $.defineOperator(iszero_any);
                $.defineOperator(not_fn);
                $.defineOperator(number_fn);
                $.defineOperator(numerator_fn);
                $.defineLegacyTransformer(NROOTS, Eval_nroots);
                $.defineOperator(or_varargs);
                $.defineOperator(pred_rat);
                $.defineOperator(pred_any);
                $.defineLegacyTransformer(POLAR, Eval_polar);
                $.defineOperator(make_printmode_operator('print', () => defs.printMode));
                $.defineOperator(make_printmode_operator('printascii', () => PRINTMODE_ASCII));
                $.defineOperator(make_printmode_operator('printhuman', () => PRINTMODE_HUMAN));
                $.defineOperator(make_printmode_operator('printinfix', () => PRINTMODE_INFIX));
                $.defineOperator(make_printmode_operator('printlatex', () => PRINTMODE_LATEX));
                $.defineOperator(make_printmode_operator('printsexpr', () => PRINTMODE_SEXPR));
                $.defineOperator(make_printmode_keyword('print', () => defs.printMode));
                $.defineOperator(make_printmode_keyword('printascii', () => PRINTMODE_ASCII));
                $.defineOperator(make_printmode_keyword('printhuman', () => PRINTMODE_HUMAN));
                $.defineOperator(make_printmode_keyword('printinfix', () => PRINTMODE_INFIX));
                $.defineOperator(make_printmode_keyword('printlatex', () => PRINTMODE_LATEX));
                $.defineOperator(make_printmode_keyword('printsexpr', () => PRINTMODE_SEXPR));
                $.defineOperator(product_varargs);
                $.defineLegacyTransformer(QUOTE, Eval_quote);
                $.defineOperator(quotient_varargs);
                $.defineOperator(rationalize_fn);
                $.defineOperator(real_add);
                $.defineOperator(real_cos);
                $.defineOperator(real_exp);
                $.defineOperator(real_flt);
                $.defineOperator(real_imag);
                $.defineOperator(real_imu);
                $.defineOperator(real_log_imu);
                $.defineOperator(real_log_rat);
                // $.defineOperator(real_mul_i_times_any);
                $.defineOperator(real_mul);
                $.defineOperator(real_pow_rat_rat);
                $.defineOperator(real_rat);
                $.defineOperator(real_real);
                $.defineOperator(real_sym);
                $.defineOperator(real_any);
                $.defineOperator(is_complex_sym);
                $.defineOperator(is_complex_any);
                $.defineOperator(is_real_abs);
                $.defineOperator(is_real_add);
                $.defineOperator(is_real_cos);
                $.defineOperator(is_real_flt);
                $.defineOperator(is_real_imag);
                $.defineOperator(is_real_imu);
                $.defineOperator(is_real_mul);
                $.defineOperator(is_real_pow_e_sym);
                $.defineOperator(is_real_pow_rat_rat);
                $.defineOperator(is_real_pow_sym_rat);
                $.defineOperator(is_real_pow_imu_rat);
                $.defineOperator(is_real_pow_any_negone);
                $.defineOperator(is_real_rat);
                $.defineOperator(is_real_real);
                $.defineOperator(is_real_sin);
                $.defineOperator(make_predicate_sym_operator(PREDICATE_IS_REAL));
                $.defineOperator(is_real_any);
                $.defineOperator(rect_mul_rat_any);
                $.defineOperator(rect_pow_exp_imu);
                $.defineLegacyTransformer(RECT, Eval_rect);
                $.defineOperator(roots_varargs);
                $.defineOperator(round_varargs);
                $.defineOperator(script_last_0);
                $.defineOperator(sgn_flt);
                $.defineOperator(sgn_rat);
                $.defineOperator(sgn_any);
                $.defineOperator(shape_varargs);
                $.defineOperator(simplify_varargs);
                $.defineOperator(sinh_flt);
                $.defineOperator(sinh_rat);
                $.defineOperator(sinh_sym);
                $.defineOperator(sinh_any);
                $.defineOperator(succ_rat);
                $.defineOperator(succ_any);
                $.defineOperator(sin_add_2_any_any);
                $.defineOperator(sin_sym);
                $.defineOperator(sin_hyp);
                $.defineOperator(sin_mul_2_any_imu);
                $.defineOperator(sin_any);
                $.defineOperator(sqrt_1_rat);
                $.defineOperator(sqrt_1_any);
                $.defineOperator(st_add_2_any_hyp);
                $.defineOperator(st_mul_2_rat_any);
                $.defineOperator(st_rat);
                $.defineOperator(st_sym);
                $.defineOperator(st_any);
                $.defineOperator(subst_varargs);
                $.defineOperator(sum_varargs);
                $.defineOperator(taylor_varargs);
                $.defineOperator(tan_varargs);
                $.defineOperator(tanh_varargs);
                $.defineOperator(tau);
                $.defineOperator(typeof_tensor);
                $.defineOperator(typeof_blade);
                $.defineOperator(typeof_any);
                $.defineOperator(testeq_sym_rat);
                $.defineLegacyTransformer(testeq, Eval_testeq);
                $.defineLegacyTransformer(TESTLE, Eval_testle);
                $.defineOperator(testlt_flt_rat);
                $.defineOperator(testlt_rat_rat);
                $.defineOperator(testlt_sym_rat);
                $.defineOperator(testlt_mul_2_any_any_rat);
                $.defineLegacyTransformer(TESTLT, Eval_testlt);
                $.defineLegacyTransformer(TESTGE, Eval_testge);
                $.defineOperator(testgt_rat_rat);
                $.defineOperator(testgt_sym_rat);
                $.defineOperator(testgt_mul_2_any_any_rat);
                $.defineLegacyTransformer(TESTGT, Eval_testgt);
                $.defineOperator(transpose_varargs);
                $.defineOperator(sym_math_add);
                $.defineOperator(sym_math_mul);
                $.defineOperator(sym_math_pow);
                $.defineOperator(sym_math_pi);
                $.defineOperator(sym_extension);
                $.defineOperator(tensor_extension);
                $.defineOperator(blade_extension);
                $.defineOperator(uom_extension);
                $.defineOperator(hyp_extension);
                $.defineOperator(err_extension);
                $.defineOperator(imu_extension);
                $.defineOperator(unit_any);
                $.defineOperator(uom_1_str);
                $.defineOperator(zero_varargs);
                // NIL is implemented as an empty Cons, so it has to be defined before the generic Cons operator.
                $.defineOperator(nil_extension);
                // There is no fallback. We migrate everything.
                $.defineOperator(cons_extension);
            }

            // Factor a polynomial
            //define POLY p1
            //define X p2
            //define Z p3
            //define A p4
            //define B p5
            //define Q p6
            //define RESULT p7
            //define FACTOR p8
            /**
             *
             * @param P polynomial expression
             * @param X polynomial variable
             * @param $
             * @returns factored polynomial
             */
            function yyfactorpoly(P, X, $) {
                // console.lg(`yyfactorpoly ${render_as_infix(P, $)} in variable ${render_as_infix(X, $)}`);
                if (contains_floating_values_or_floatf(P)) {
                    halt('floating point numbers in polynomial');
                }
                const coefficients = coeff(P, X, $);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                coefficients.forEach(function (coefficient) {
                    // console.lg("coefficient", render_as_infix(coefficient, $));
                });
                // console.lg(`coes ${coes}`);
                /**
                * This is the part of the polynomial that has been factorized so far.
                */
                let factorized = rationalize_coefficients(coefficients, $);
                // console.lg("factorization", render_as_infix(factorized, $));
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                coefficients.forEach(function (coefficient) {
                    // console.lg("coefficient", render_as_infix(coefficient, $));
                });
                // console.lg(`rationalized coes ${coes}, with k = ${p7}`);
                // for univariate polynomials we could do factpoly_expo > 1
                let findingKind = 'real';
                let remainingPoly = null;
                // TODO: What are these values...
                let p4;
                let p5;
                let p8;
                // We start from the largest coefficient.
                let coeffIdx = coefficients.length - 1;
                while (coeffIdx > 0) {
                    // console.lg("coeffIdx", coeffIdx);
                    let foundComplexRoot = false;
                    let foundRealRoot = false;
                    if ($.is_zero(coefficients[0])) {
                        p4 = one;
                        p5 = zero;
                    }
                    else {
                        if (findingKind === 'real') {
                            [foundRealRoot, p4, p5] = get_factor_from_real_root(coefficients, coeffIdx, X, p4, p5, $);
                            // console.lg("foundRealRoot", foundRealRoot);
                            // console.lg("p4", render_as_infix(p4, $));
                            // console.lg("p5", render_as_infix(p5, $));
                        }
                        else if (findingKind === 'complex') {
                            [foundComplexRoot, p4] = get_factor_from_complex_root(remainingPoly, coefficients, coeffIdx, $);
                            // console.lg("foundComplexRoot", foundRealRoot);
                            // console.lg("p4", p4 ? render_as_infix(p4, $) : "undefined");
                        }
                    }
                    // console.lg(`whichRootsAreWeFinding ${whichRootsAreWeFinding}`);
                    // console.lg(`foundRealRoot ${foundRealRoot}`);
                    if (findingKind === 'real') {
                        if (foundRealRoot === false) {
                            findingKind = 'complex';
                            continue;
                        }
                        else {
                            p8 = $.add($.multiply(p4, X), p5); // A, x, B
                            // factor out negative sign (not req'd because p4 > 1)
                            //if 0
                            /*
                            if (isnegativeterm(p4))
                              push(p8)
                              negate()
                              p8 = pop()
                              push(p7)
                              negate_noexpand()
                              p7 = pop()
                            */
                            //endif
                            // factored is the part of the polynomial that was factored so far,
                            // add the newly found factor to it. Note that we are not actually
                            // multiplying the polynomials fully, we are just leaving them
                            // expressed as (P1)*(P2), we are not expanding the product.
                            factorized = multiply_noexpand(factorized, p8, $);
                            // ok now on stack we have the coefficients of the
                            // remaining part of the polynomial still to factor.
                            // Divide it by the newly-found factor so that
                            // the stack then contains the coefficients of the
                            // polynomial part still left to factor.
                            yydivpoly(p4, p5, coefficients, coeffIdx, $);
                            while (coeffIdx && $.is_zero(coefficients[coeffIdx])) {
                                coeffIdx--;
                            }
                            let temp = zero;
                            for (let i = 0; i <= coeffIdx; i++) {
                                // p2: the free variable
                                temp = $.add(temp, $.multiply(coefficients[i], $.power(X, create_int(i))));
                            }
                            remainingPoly = temp;
                        }
                    }
                    else if (findingKind === 'complex') {
                        if (foundComplexRoot === false) {
                            break;
                        }
                        else {
                            const firstFactor = $.subtract(p4, X); // A, x
                            const secondFactor = $.subtract(complex_conjugate(p4, $), X); // p4: A, p2: x
                            p8 = $.multiply(firstFactor, secondFactor);
                            //if (factpoly_expo > 0 && isnegativeterm(polycoeff[factpoly_expo]))
                            //  negate()
                            //  negate_noexpand()
                            // factor out negative sign (not req'd because p4 > 1)
                            //if 0
                            /*
                            if (isnegativeterm(p4))
                              push(p8)
                              negate()
                              p8 = pop()
                              push(p7)
                              negate_noexpand()
                              p7 = pop()
                            */
                            //endif
                            // p7 is the part of the polynomial that was factored so far,
                            // add the newly found factor to it. Note that we are not actually
                            // multiplying the polynomials fully, we are just leaving them
                            // expressed as (P1)*(P2), we are not expanding the product.
                            const previousFactorisation = factorized;
                            factorized = multiply_noexpand(factorized, p8, $);
                            // build the polynomial of the unfactored part
                            if (remainingPoly == null) {
                                let temp = zero;
                                for (let i = 0; i <= coeffIdx; i++) {
                                    // p2: the free variable
                                    temp = $.add(temp, $.multiply(coefficients[i], $.power(X, create_int(i))));
                                }
                                remainingPoly = temp;
                            }
                            //push(dividend)
                            //degree()
                            //startingDegree = pop()
                            const divisor = p8;
                            const dividend = remainingPoly;
                            remainingPoly = divpoly(dividend, divisor, X, $);
                            const checkingTheDivision = $.multiply(remainingPoly, p8);
                            if (!$.equals(checkingTheDivision, dividend)) {
                                stack_push(previousFactorisation);
                                const arg2 = noexpand_unary(yycondense, dividend, $);
                                const arg1 = stack_pop();
                                return multiply_noexpand(arg1, arg2, $);
                            }
                            //push(remainingPoly)
                            //degree()
                            //remainingDegree = pop()
                            /*
                            if compare_numbers(startingDegree, remainingDegree)
                              * ok even if we found a complex root that
                              * together with the conjugate generates a poly in Z,
                              * that doesn't mean that the division would end up in Z.
                              * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots
                              * so a factor is 1+x^2 ( = (x+i)*(x-i))
                              * BUT
                            */
                            for (let i = 0; i <= coeffIdx; i++) {
                                coefficients.pop();
                            }
                            coefficients.push(...coeff(remainingPoly, X, $));
                            coeffIdx -= 2;
                        }
                    }
                }
                // build the remaining unfactored part of the polynomial
                let temp = zero;
                for (let i = 0; i <= coeffIdx; i++) {
                    temp = $.add(temp, $.multiply(coefficients[i], $.power(X, create_int(i))));
                }
                // console.lg("temp       II", render_as_infix(temp, $));
                const remaining = noexpand_unary(yycondense, temp, $);
                // console.lg("factorized II", render_as_infix(factorized, $));
                // console.lg("remaining  II", render_as_infix(remaining, $));
                // factor out negative sign
                if (coeffIdx > 0 && is_negative(coefficients[coeffIdx])) {
                    //prev_expanding = expanding
                    //expanding = 1
                    //expanding = prev_expanding
                    return multiply_noexpand(negate_noexpand(factorized, $), $.negate(remaining), $);
                }
                else {
                    return multiply_noexpand(factorized, remaining, $);
                }
            }
            /**
             * e.g. [c,b,a]
             * @param coefficients This array is mutated as an intended side-effect and we return a value, k, such that
             * multiplication of the mutated coefficient by k recreates the original coefficients.
             */
            function rationalize_coefficients(coefficients, $) {
                // console.lg(`rationalize_coefficients ${coefficients}`);
                // LCM of all polynomial coefficients
                let one_over_k = one;
                for (const coeff of coefficients) {
                    one_over_k = lcm(denominator(coeff, $), one_over_k, $);
                }
                // multiply each coefficient by RESULT
                for (let i = 0; i < coefficients.length; i++) {
                    coefficients[i] = $.multiply(one_over_k, coefficients[i]);
                }
                const k = inverse(one_over_k, $);
                return k;
            }
            /**
             *
             * @param coeffs
             * @param coeffIdx
             * @param X polynomial variable (not actually used).
             * @param p4
             * @param p5
             * @param $
             * @returns
             */
            function get_factor_from_real_root(coeffs, coeffIdx, X, p4, p5, $) {
                // console.lg(`get_factor_from_real_root(coefficients, coeffIdx=${coeffIdx}, variable=${render_as_infix(X, $)})`);
                const h = defs.tos;
                const an = defs.tos;
                stack_push_items(ydivisors(coeffs[coeffIdx], $));
                const nan = defs.tos - an;
                const a0 = defs.tos;
                stack_push_items(ydivisors(coeffs[0], $));
                const na0 = defs.tos - a0;
                // try roots
                for (let rootsTries_i = 0; rootsTries_i < nan; rootsTries_i++) {
                    for (let rootsTries_j = 0; rootsTries_j < na0; rootsTries_j++) {
                        p4 = defs.stack[an + rootsTries_i];
                        p5 = defs.stack[a0 + rootsTries_j];
                        const neg_p5_div_p4 = $.negate(divide(p5, p4, $));
                        // TODO: Why is this typed to return a single element array?
                        const [neg_poly] = Evalpoly(neg_p5_div_p4, coeffs, coeffIdx, $);
                        if ($.is_zero(neg_poly)) {
                            move_top_of_stack(h);
                            return [true, p4, p5];
                        }
                        p5 = $.negate(p5);
                        const p5_div_p4 = $.negate(neg_p5_div_p4);
                        const [pos_poly] = Evalpoly(p5_div_p4, coeffs, coeffIdx, $);
                        if ($.is_zero(pos_poly)) {
                            move_top_of_stack(h);
                            return [true, p4, p5];
                        }
                    }
                }
                move_top_of_stack(h);
                return [false, p4, p5];
            }
            function get_factor_from_complex_root(remainingPoly, polycoeff, factpoly_expo, $) {
                let p4;
                let p3, p6;
                if (factpoly_expo <= 2) {
                    return [false, p4];
                }
                // const p1 = remainingPoly;
                const h = defs.tos;
                // trying -1^(2/3) which generates a polynomial in Z
                // generates x^2 + 2x + 1
                p4 = rect$2($.power(negOne, rational(2, 3)), $);
                p3 = p4;
                stack_push(p3);
                [p6] = Evalpoly(p3, polycoeff, factpoly_expo, $);
                if ($.is_zero(p6)) {
                    move_top_of_stack(h);
                    return [true, p4];
                }
                // trying 1^(2/3) which generates a polynomial in Z
                // http://www.wolframalpha.com/input/?i=(1)%5E(2%2F3)
                // generates x^2 - 2x + 1
                p4 = rect$2($.power(one, rational(2, 3)), $);
                p3 = p4;
                stack_push(p3);
                [p6] = Evalpoly(p3, polycoeff, factpoly_expo, $);
                if ($.is_zero(p6)) {
                    move_top_of_stack(h);
                    return [true, p4];
                }
                // trying some simple complex numbers. All of these
                // generate polynomials in Z
                for (let rootsTries_i = -10; rootsTries_i <= 10; rootsTries_i++) {
                    for (let rootsTries_j = 1; rootsTries_j <= 5; rootsTries_j++) {
                        p4 = rect$2($.add(create_int(rootsTries_i), $.multiply(create_int(rootsTries_j), imu)), $);
                        const p3 = p4;
                        stack_push(p3);
                        const [p6] = Evalpoly(p3, polycoeff, factpoly_expo, $);
                        if ($.is_zero(p6)) {
                            move_top_of_stack(h);
                            return [true, p4];
                        }
                    }
                }
                move_top_of_stack(h);
                return [false, p4];
            }
            //-----------------------------------------------------------------------------
            //
            //  Divide a polynomial by Ax+B
            //
            //  Input:  on stack:  polycoeff  Dividend coefficients
            //
            //      factpoly_expo    Degree of dividend
            //
            //      A (p4)    As above
            //
            //      B (p5)    As above
            //
            //  Output:   on stack: polycoeff  Contains quotient coefficients
            //
            //-----------------------------------------------------------------------------
            function yydivpoly(p4, p5, polycoeff, factpoly_expo, $) {
                let p6 = zero;
                for (let i = factpoly_expo; i > 0; i--) {
                    const divided = divide(polycoeff[i], p4, $);
                    polycoeff[i] = p6;
                    p6 = divided;
                    polycoeff[i - 1] = $.subtract(polycoeff[i - 1], $.multiply(p6, p5));
                }
                polycoeff[0] = p6;
            }
            function Evalpoly(p3, coeffs, coeffIdx, $) {
                // console.lg("Evalpoly", render_as_infix(p3, $), "coeffs", "coeffIdx", coeffIdx);
                let temp = zero;
                for (let i = coeffIdx; i >= 0; i--) {
                    temp = $.add($.multiply(temp, p3), coeffs[i]);
                }
                const p6 = temp;
                return [p6];
            }

            var _Lambda_hash, _Lambda_impl;
            class Lambda extends Atom {
                constructor(impl, hash, pos, end) {
                    super('Lambda', pos, end);
                    _Lambda_hash.set(this, void 0);
                    _Lambda_impl.set(this, void 0);
                    __classPrivateFieldSet(this, _Lambda_impl, impl, "f");
                    __classPrivateFieldSet(this, _Lambda_hash, hash, "f");
                }
                get hash() {
                    return __classPrivateFieldGet(this, _Lambda_hash, "f");
                }
                evaluate(argList, $) {
                    return __classPrivateFieldGet(this, _Lambda_impl, "f").call(this, argList, $);
                }
                equals(other) {
                    if (this === other) {
                        return true;
                    }
                    if (other instanceof Lambda) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                toString() {
                    return '(lambda ...)';
                }
            }
            _Lambda_hash = new WeakMap(), _Lambda_impl = new WeakMap();

            function is_lambda(expr) {
                return expr instanceof Lambda;
            }

            const DEFAULT_PROPS = Object.freeze({
                'antihermitian': false,
                'algebraic': true,
                'commutative': true,
                'complex': true,
                'extended_negative': false,
                'extended_nonnegative': true,
                'extended_nonpositive': false,
                'extended_nonzero': true,
                'extended_positive': true,
                'extended_real': true,
                'finite': true,
                'hermitian': true,
                'imaginary': false,
                'infinite': false,
                'integer': false,
                'irrational': false,
                'negative': false,
                'noninteger': false,
                'nonnegative': true,
                'nonpositive': false,
                'nonzero': true,
                'positive': true,
                'rational': true,
                'real': true,
                'transcendental': false,
                'zero': false
            });
            function createSymTab() {
                const props_from_key = new Map();
                const value_from_key = new Map();
                const sym_from_key = new Map();
                const theTab = {
                    clear() {
                        props_from_key.clear();
                        value_from_key.clear();
                        sym_from_key.clear();
                    },
                    getProps(sym) {
                        if (typeof sym === 'string') {
                            const props = props_from_key.get(sym);
                            if (props) {
                                return props;
                            }
                            else {
                                return DEFAULT_PROPS;
                            }
                        }
                        else {
                            return this.getProps(sym.key());
                        }
                    },
                    setProps(sym, overrides) {
                        const key = sym.key();
                        if (overrides) {
                            const props = Object.freeze(Object.assign({ ...this.getProps(sym) }, overrides));
                            props_from_key.set(key, props);
                            sym_from_key.set(key, sym);
                        }
                        else {
                            props_from_key.delete(key);
                        }
                    },
                    getValue(sym) {
                        if (typeof sym === 'string') {
                            const value = value_from_key.get(sym);
                            if (value) {
                                return value;
                            }
                            else {
                                return nil;
                            }
                        }
                        else {
                            return this.getValue(sym.key());
                        }
                    },
                    setValue(sym, value) {
                        const key = sym.key();
                        if (is_nil(value)) {
                            value_from_key.delete(key);
                        }
                        else {
                            value_from_key.set(key, value);
                            sym_from_key.set(key, sym);
                        }
                    },
                    entries() {
                        const bs = [];
                        value_from_key.forEach(function (value, key) {
                            const sym = sym_from_key.get(key);
                            if (sym) {
                                if (is_nil(value)) ;
                                else {
                                    bs.push({ sym, value });
                                }
                            }
                            else {
                                throw new Error();
                            }
                        });
                        return bs;
                    },
                    delete(sym) {
                        const key = sym.key();
                        props_from_key.delete(key);
                        value_from_key.delete(key);
                        sym_from_key.delete(key);
                    }
                };
                return theTab;
            }

            // Evaluate a user defined function
            // F is the function body
            // A is the formal argument list
            // B is the calling argument list
            // S is the argument substitution list
            // we got here because there was a function invocation and
            // it's not been parsed (and consequently tagged) as any
            // system function.
            // So we are dealing with another function.
            // The function could be actually defined, or not yet,
            // so we'll deal with both cases.
            /* d =====================================================================

            Tags
            ----
            scripting, JS, internal, treenode, general concept

            Parameters
            ----------
            f,x

            General description
            -------------------
            Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].

            */
            function Eval_user_function(expr, $) {
                if (car(expr).equals(SYMBOL_D) && $.getSymbolValue(SYMBOL_D).equals(SYMBOL_D)) {
                    const retval = Eval_derivative(expr, $);
                    return retval;
                }
                // normally car(p1) is a symbol with the function name
                // but it could be something that has to be
                // evaluated to get to the function definition instead
                // (e.g. the function is an element of an array)
                // so we do an eval to sort it all out.
                // we expect to find either the body and
                // formula arguments, OR, if the function
                // has not been defined yet, then the
                // function will just contain its own name, as
                // all undefined variables do.
                const bodyAndFormalArguments = $.valueOf(car(expr));
                if (is_num(bodyAndFormalArguments)) {
                    halt("expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.");
                }
                else if (is_tensor(bodyAndFormalArguments)) {
                    halt("expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.");
                }
                else if (is_str$1(bodyAndFormalArguments)) {
                    halt('expected function, found string instead.');
                }
                const F = car(cdr(bodyAndFormalArguments));
                // p4 is the formal argument list
                // that is also contained here in the FUNCTION node
                const A = car(cdr(cdr(bodyAndFormalArguments)));
                const B = cdr(expr);
                // example:
                //  f(x) = x+2
                // then:
                //  toInfixString(F) = "x + 2"
                //  A = x
                //  B = 2
                // first check is whether we don't obtain a function
                if (!car(bodyAndFormalArguments).equals(FUNCTION) ||
                    // next check is whether evaluation did nothing, so the function is undefined
                    bodyAndFormalArguments.equals(car(expr))) {
                    // leave everything as it was and return
                    const h = defs.tos;
                    stack_push(bodyAndFormalArguments);
                    let p1 = B;
                    while (is_cons(p1)) {
                        stack_push($.valueOf(car(p1)));
                        p1 = cdr(p1);
                    }
                    stack_list(defs.tos - h);
                    return stack_pop();
                }
                // Create the argument substitution list S
                let p1 = A;
                let p2 = B;
                const h = defs.tos;
                while (is_cons(p1) && is_cons(p2)) {
                    stack_push(car(p1));
                    stack_push(car(p2));
                    // why explicitly Eval the parameters when
                    // the body of the function is
                    // evalled anyways? Commenting it out. All tests pass...
                    //Eval()
                    p1 = cdr(p1);
                    p2 = cdr(p2);
                }
                stack_list(defs.tos - h);
                const S = stack_pop();
                // Evaluate the function body
                stack_push(F);
                if (is_cons(S)) {
                    stack_push(S);
                    rewrite_args($);
                }
                // console.lg "rewritten body: " + stack[tos-1]
                return $.valueOf(stack_pop());
            }
            // Rewrite by expanding symbols that contain args
            function rewrite_args($) {
                let n = 0;
                // subst. list which is a list
                // where each consecutive pair
                // is what needs to be substituted and with what
                const p2 = stack_pop();
                // console.lg "subst. list " + p2
                // expr to substitute in i.e. the
                // function body
                let p1 = stack_pop();
                // console.lg "expr: " + p1
                if (is_tensor(p1)) {
                    n = rewrite_args_tensor(p1, p2, $);
                    return n;
                }
                if (is_cons(p1)) {
                    const h = defs.tos;
                    if (car(p1).equals(car(p2))) {
                        // rewrite a function in
                        // the body with the one
                        // passed from the paramaters
                        stack_push(items_to_cons(EVAL, car(cdr(p2))));
                    }
                    else {
                        // if there is no match
                        // then no substitution necessary
                        stack_push(car(p1));
                    }
                    // continue recursively to
                    // rewrite the rest of the body
                    p1 = cdr(p1);
                    while (is_cons(p1)) {
                        stack_push(car(p1));
                        stack_push(p2);
                        n += rewrite_args($);
                        p1 = cdr(p1);
                    }
                    stack_list(defs.tos - h);
                    return n;
                }
                // ground cases here
                // (apart from function name which has
                // already been substituted as it's in the head
                // of the cons)
                // -----------------
                // If not a symbol then no
                // substitution to be done
                if (!is_sym(p1)) {
                    stack_push(p1);
                    return 0;
                }
                // Here we are in a symbol case
                // so we need to substitute
                // Check if there is a direct match
                // of symbols right away
                let p3 = p2;
                while (is_cons(p3)) {
                    if (p1.equals(car(p3))) {
                        stack_push(cadr(p3));
                        return 1;
                    }
                    p3 = cddr(p3);
                }
                // Get the symbol's content, if _that_
                // matches then do the substitution
                p3 = $.getSymbolValue(p1);
                stack_push(p3);
                if (p1 !== p3) {
                    stack_push(p2); // subst. list
                    n = rewrite_args($);
                    if (n === 0) {
                        stack_pop();
                        stack_push(p1); // restore if not rewritten with arg
                    }
                }
                return n;
            }
            function rewrite_args_tensor(M, other, $) {
                let rewrite_args_counter = 0;
                const elems = M.mapElements((m) => {
                    stack_push(m);
                    stack_push(other);
                    rewrite_args_counter += rewrite_args($);
                    return stack_pop();
                });
                stack_push(M.withElements(elems));
                return rewrite_args_counter;
            }

            var _Stack_elements;
            class Stack {
                constructor() {
                    _Stack_elements.set(this, []);
                }
                peek() {
                    const length = __classPrivateFieldGet(this, _Stack_elements, "f").length;
                    const last = length - 1;
                    return __classPrivateFieldGet(this, _Stack_elements, "f")[last];
                }
                push(element) {
                    __classPrivateFieldGet(this, _Stack_elements, "f").push(element);
                }
                pop() {
                    const element = __classPrivateFieldGet(this, _Stack_elements, "f").pop();
                    if (element) {
                        return element;
                    }
                    else {
                        throw new Error();
                    }
                }
            }
            _Stack_elements = new WeakMap();

            var _DirectiveStack_data;
            class DirectiveStack {
                constructor() {
                    _DirectiveStack_data.set(this, new Stack());
                    __classPrivateFieldGet(this, _DirectiveStack_data, "f").push(initial_directives());
                }
                push(directive, value) {
                    const directives = copy_directives(__classPrivateFieldGet(this, _DirectiveStack_data, "f").peek());
                    update_directives(directives, directive, value);
                    const frozen = Object.freeze(directives);
                    __classPrivateFieldGet(this, _DirectiveStack_data, "f").push(frozen);
                }
                pop() {
                    __classPrivateFieldGet(this, _DirectiveStack_data, "f").pop();
                }
                get(directive) {
                    const directives = __classPrivateFieldGet(this, _DirectiveStack_data, "f").peek();
                    const value = directives[directive];
                    return value;
                }
            }
            _DirectiveStack_data = new WeakMap();
            function copy_directives(directives) {
                return { ...directives };
            }
            function update_directives(directives, directive, value) {
                switch (directive) {
                    case Directive.expand: {
                        if (value) {
                            directives[Directive.factor] = false;
                        }
                        else {
                            directives[Directive.factor] = true;
                        }
                        break;
                    }
                    case Directive.factor: {
                        if (value) {
                            directives[Directive.expand] = false;
                        }
                        else {
                            directives[Directive.expand] = true;
                        }
                        break;
                    }
                }
                directives[directive] = value;
            }
            function initial_directives() {
                const directives = {};
                update_directives(directives, Directive.evaluatingAsClock, false);
                update_directives(directives, Directive.evaluatingAsFloat, false);
                update_directives(directives, Directive.evaluatingAsPolar, false);
                update_directives(directives, Directive.evaluatingTrigAsExp, false);
                update_directives(directives, Directive.expand, true);
                update_directives(directives, Directive.factor, false);
                update_directives(directives, Directive.keepZeroTermsInSums, false);
                // TODO: These two don't seem like Directive(s).
                update_directives(directives, Directive.renderFloatAsEcmaScript, false);
                update_directives(directives, Directive.useCaretForExponentiation, false);
                return Object.freeze(directives);
            }

            class NoopPrintHandler {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                print(...items) {
                    // Do nothing
                }
            }

            var _Builder_keyword, _Builder_runner, _Op_runner;
            class Builder {
                constructor(keyword, runner) {
                    _Builder_keyword.set(this, void 0);
                    _Builder_runner.set(this, void 0);
                    __classPrivateFieldSet(this, _Builder_keyword, keyword, "f");
                    __classPrivateFieldSet(this, _Builder_runner, runner, "f");
                }
                create($) {
                    return new Op(__classPrivateFieldGet(this, _Builder_keyword, "f"), __classPrivateFieldGet(this, _Builder_runner, "f"), $);
                }
            }
            _Builder_keyword = new WeakMap(), _Builder_runner = new WeakMap();
            class Op extends KeywordOperator {
                constructor(keyword, runner, $) {
                    super(keyword, $);
                    _Op_runner.set(this, void 0);
                    __classPrivateFieldSet(this, _Op_runner, runner, "f");
                }
                get key() {
                    return TYPE_NAME_SYM.name;
                }
                get hash() {
                    return HASH_SYM;
                }
                get name() {
                    return this.keyword.text;
                }
                transform(expr) {
                    // Because of our hash, we are being matched with any symbol.
                    if (is_sym(expr) && expr.equalsSym(this.keyword)) {
                        const $ = this.$;
                        __classPrivateFieldGet(this, _Op_runner, "f").call(this, $);
                        return [TFLAG_DIFF, nil];
                    }
                    else {
                        return [TFLAG_NONE, expr];
                    }
                }
            }
            _Op_runner = new WeakMap();
            function operator_from_keyword_runner(sym, runner) {
                return new Builder(sym, runner);
            }

            var _PluggableOperator_hash;
            class PluggableBuilder {
                constructor(opr, hash, evaluator) {
                    this.opr = opr;
                    this.hash = hash;
                    this.evaluator = evaluator;
                }
                create($) {
                    return new PluggableOperator(this.opr, this.hash, this.evaluator, $);
                }
            }
            class PluggableOperator extends FunctionVarArgs {
                constructor(opr, hash, evaluator, $) {
                    super(opr.text, opr, $);
                    this.evaluator = evaluator;
                    _PluggableOperator_hash.set(this, void 0);
                    __classPrivateFieldSet(this, _PluggableOperator_hash, hash, "f");
                }
                get hash() {
                    return __classPrivateFieldGet(this, _PluggableOperator_hash, "f");
                }
                transform(expr) {
                    const $ = this.$;
                    // console.lg("PluggableOperator.transform", "name:", JSON.stringify(this.name), "expr:", render_as_sexpr(expr, $));
                    const hook = (where, retval) => {
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_infix(expr, this.$), "=>", render_as_infix(retval, $));
                        // console.lg("HOOK ....:", this.name, where, decodeMode($.getMode()), render_as_sexpr(expr, this.$), "=>", render_as_sexpr(retval, $));
                        return retval;
                    };
                    const retval = this.evaluator(expr, $);
                    const flags = retval.equals(expr) ? TFLAG_NONE : TFLAG_DIFF;
                    return [flags, hook('', retval)];
                }
            }
            _PluggableOperator_hash = new WeakMap();
            function operator_from_legacy_transformer(opr, transformer) {
                const hash = hash_nonop_cons(opr);
                return new PluggableBuilder(opr, hash, transformer);
            }
            function opr_from_match(match) {
                if (is_cons(match)) {
                    const head = match.head;
                    if (is_sym(head)) {
                        return head;
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    throw new Error();
                }
            }
            function hash_from_match(pattern) {
                if (is_cons(pattern)) {
                    const opr = pattern.head;
                    if (is_sym(opr)) {
                        // TODO: More specific matching.
                        // hash_unaop_atom
                        return hash_nonop_cons(opr);
                    }
                    else {
                        throw new Error();
                    }
                }
                else {
                    throw new Error();
                }
            }

            /* eslint-disable @typescript-eslint/no-unused-vars */
            class UnknownOperator {
                /**
                 *
                 * @param expr An expression, probably user-defined.
                 * @param $ The extension environment.
                 */
                constructor(expr, $) {
                    this.expr = expr;
                    this.$ = $;
                    this.name = "unknown";
                }
                isImag(expr) {
                    // We don't really know.
                    return false;
                    // throw new Error("UnknownOperator Method not implemented.");
                }
                isKind(expr) {
                    throw new Error("UnknownOperator.isKind Method not implemented.");
                }
                isMinusOne(expr) {
                    throw new Error("UnknownOperator.isMinusOne Method not implemented.");
                }
                isOne(expr) {
                    return false;
                    // throw new Error("UnknownOperator.isOne Method not implemented.");
                }
                isReal(expr) {
                    return false;
                    // throw new Error("UnknownOperator.isReal Method not implemented.");
                }
                isScalar(expr) {
                    throw new Error("UnknownOperator.isScalar Method not implemented.");
                }
                isZero(expr) {
                    const repr = render_as_sexpr(expr, this.$);
                    throw new Error(`UnknownOperator.isZero ${repr} Method not implemented.`);
                }
                subst(expr, oldExpr, newExpr) {
                    throw new Error("UnknownOperator.subst Method not implemented.");
                }
                toInfixString(expr) {
                    throw new Error(`${expr.toString()} is not defined.`);
                }
                toLatexString(expr) {
                    throw new Error(`${expr.toString()} is not defined.`);
                }
                toListString(expr) {
                    throw new Error(`${expr.toString()} is not defined.`);
                }
                evaluate(expr, argList) {
                    throw new Error("UnknownOperator. Method not implemented.");
                }
                transform(expr) {
                    throw new Error("UnknownOperator. Method not implemented.");
                }
                valueOf(expr) {
                    throw new Error("UnknownOperator. Method not implemented.");
                }
            }

            const ADD = native_sym(Native.add);
            const MULTIPLY = native_sym(Native.multiply);
            const POWER = native_sym(Native.pow);
            const ISCOMPLEX = native_sym(Native.is_complex);
            const ISREAL = native_sym(Native.is_real);
            class StableExprComparator {
                constructor(opr) {
                    this.opr = opr;
                    // 
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                compare(lhs, rhs, $) {
                    throw new Error(`(compare ${this.opr} ${lhs} ${rhs})`);
                    // return SIGN_EQ;
                }
            }
            function config_from_options(options) {
                if (options) {
                    const config = {
                        assumes: options.assumes ? options.assumes : {},
                        dependencies: Array.isArray(options.dependencies) ? options.dependencies : [],
                        disable: Array.isArray(options.disable) ? options.disable : [],
                        noOptimize: typeof options.noOptimize === 'boolean' ? options.noOptimize : false,
                        useCaretForExponentiation: typeof options.useCaretForExponentiation === 'boolean' ? options.useCaretForExponentiation : false,
                        useDefinitions: typeof options.useDefinitions === 'boolean' ? options.useDefinitions : false
                    };
                    return config;
                }
                else {
                    const config = {
                        assumes: {},
                        dependencies: [],
                        disable: [],
                        noOptimize: false,
                        useCaretForExponentiation: false,
                        useDefinitions: false
                    };
                    return config;
                }
            }
            function create_env(options) {
                const config = config_from_options(options);
                // console.lg(`config: ${JSON.stringify(config, null, 2)}`);
                const symTab = createSymTab();
                const builders = [];
                /**
                 * The operators in buckets that are determined by the phase and operator.
                 */
                const ops_by_mode = [];
                for (const mode of MODE_SEQUENCE) {
                    ops_by_mode[mode] = {};
                }
                let printHandler = new NoopPrintHandler();
                const native_directives = new DirectiveStack();
                const custom_directives = {};
                /**
                 * Override printname(s) for symbols used during rendering.
                 */
                const sym_key_to_printname = {};
                const sym_order = {};
                function currentOps() {
                    if (native_directives.get(Directive.expand)) {
                        const ops = ops_by_mode[MODE_EXPANDING];
                        if (typeof ops === 'undefined') {
                            throw new Error(`currentOps(${MODE_EXPANDING})`);
                        }
                        return ops;
                    }
                    if (native_directives.get(Directive.factor)) {
                        const ops = ops_by_mode[MODE_FACTORING];
                        if (typeof ops === 'undefined') {
                            throw new Error(`currentOps(${MODE_FACTORING})`);
                        }
                        return ops;
                    }
                    return {};
                }
                function selectOperator(key, expr) {
                    const ops = currentOps()[key];
                    if (Array.isArray(ops) && ops.length > 0) {
                        for (const op of ops) {
                            if (op.isKind(expr)) {
                                return op;
                            }
                        }
                        throw new SystemError(`No matching operator for key ${key}`);
                    }
                    else {
                        // eslint-disable-next-line no-console
                        console.warn("expand", native_directives.get(Directive.expand));
                        // eslint-disable-next-line no-console
                        console.warn("factor", native_directives.get(Directive.factor));
                        throw new SystemError(`No operators for key ${key} in current mode}`);
                    }
                }
                /**
                 * The environment return value and environment for callbacks.
                 */
                const $ = {
                    getPrintHandler() {
                        return printHandler;
                    },
                    setPrintHandler(handler) {
                        if (handler) {
                            printHandler = handler;
                        }
                        else {
                            printHandler = new NoopPrintHandler();
                        }
                    },
                    add(...args) {
                        return $.evaluate(Native.add, ...args);
                    },
                    arctan(expr) {
                        return $.evaluate(Native.arctan, expr);
                    },
                    arg(expr) {
                        return $.evaluate(Native.arg, expr);
                    },
                    clearOperators() {
                        builders.length = 0;
                        for (const phase of MODE_SEQUENCE) {
                            const ops = ops_by_mode[phase];
                            for (const key in ops) {
                                ops[key] = [];
                            }
                        }
                    },
                    defineLegacyTransformer(opr, transformer) {
                        $.defineOperator(operator_from_legacy_transformer(opr, transformer));
                    },
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    defineFunction(match, impl) {
                        // $.defineOperator(operator_from_modern_transformer(match, impl));
                        const opr = opr_from_match(match);
                        const hash = hash_from_match(match);
                        $.setSymbolValue(opr, new Lambda(impl, hash));
                    },
                    defineKeyword(sym, runner) {
                        $.defineOperator(operator_from_keyword_runner(sym, runner));
                    },
                    defineOperator(builder) {
                        builders.push(builder);
                    },
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    defineAssociative(opr, id) {
                        // Do nothing.
                    },
                    divide(lhs, rhs) {
                        return $.multiply(lhs, $.power(rhs, negOne));
                    },
                    clearBindings() {
                        symTab.clear();
                    },
                    compareFn(sym) {
                        const order = sym_order[sym.key()];
                        if (order) {
                            // TODO: Cache
                            return function (lhs, rhs) {
                                return order.compare(lhs, rhs, $);
                            };
                        }
                        else {
                            return function (lhs, rhs) {
                                return new StableExprComparator(sym).compare(lhs, rhs, $);
                            };
                        }
                    },
                    conj(expr) {
                        return $.evaluate(Native.conj, expr);
                    },
                    cos(expr) {
                        return $.evaluate(Native.cos, expr);
                    },
                    evaluate(opr, ...args) {
                        const argList = items_to_cons$1(...args);
                        const expr = cons(native_sym(opr), argList);
                        return $.valueOf(expr);
                    },
                    exp(expr) {
                        return $.evaluate(Native.exp, expr);
                    },
                    getSymbolProps(sym) {
                        return symTab.getProps(sym);
                    },
                    getSymbolValue(sym) {
                        return symTab.getValue(sym);
                    },
                    getSymbolsInfo() {
                        return symTab.entries();
                    },
                    buildOperators() {
                        for (const builder of builders) {
                            const op = builder.create($, config);
                            if (dependencies_satisfied(op.dependencies, config.dependencies)) ;
                            else {
                                // console.lg(`Ignoring ${op.name} which depends on ${JSON.stringify(op.dependencies)}`);
                                continue;
                            }
                            // If an operator does not restrict the modes to which it applies then it applies to all modes.
                            const phaseFlags = typeof op.phases === 'number' ? op.phases : MODE_FLAGS_ALL;
                            for (const phase of MODE_SEQUENCE) {
                                if (phaseFlags & phase) {
                                    const ops = ops_by_mode[phase];
                                    if (op.hash) {
                                        if (!Array.isArray(ops[op.hash])) {
                                            ops[op.hash] = [op];
                                        }
                                        else {
                                            ops[op.hash].push(op);
                                        }
                                    }
                                    else {
                                        if (op.key) {
                                            if (!Array.isArray(ops[op.key])) {
                                                ops[op.key] = [op];
                                            }
                                            else {
                                                ops[op.key].push(op);
                                            }
                                        }
                                        else {
                                            throw new SystemError(`${op.name} has no key and nohash`);
                                        }
                                    }
                                }
                            }
                        }
                        // Inspect which operators are assigned to which buckets...
                        /*
                        for (const key in keydOps) {
                            const ops = keydOps[key];
                            console.lg(`${key} ${ops.length}`);
                            if (ops.length > 5) {
                                for (const op of ops) {
                                    console.lg(`${key} ${op.name}  <<<<<<<`);
                                }
                            }
                        }
                        */
                    },
                    isExpanding() {
                        return native_directives.get(Directive.expand);
                    },
                    isFactoring() {
                        return native_directives.get(Directive.factor);
                    },
                    is_imag(expr) {
                        const op = $.operatorFor(expr);
                        const retval = op.isImag(expr);
                        // console.lg(`${op.name} isImag ${render_as_infix(expr, $)} => ${retval}`);
                        return retval;
                    },
                    isMinusOne(expr) {
                        return $.operatorFor(expr).isMinusOne(expr);
                    },
                    isOne(expr) {
                        return $.operatorFor(expr).isOne(expr);
                    },
                    is(predicate, expr) {
                        // In the new way we don't require every operator to provide the answer.
                        const question = items_to_cons$1(predicate, expr);
                        const response = $.valueOf(question);
                        if (is_boo(response)) {
                            return response.isTrue();
                        }
                        else {
                            throw new Error(`Unable to determine ${$.toInfixString(predicate)}(${$.toInfixString(expr)})`);
                        }
                    },
                    is_complex(expr) {
                        return $.is(ISCOMPLEX, expr);
                    },
                    is_real(expr) {
                        return $.is(ISREAL, expr);
                    },
                    isScalar(expr) {
                        const op = $.operatorFor(expr);
                        const retval = op.isScalar(expr);
                        // console.lg(`${op.name} isScalar ${$.toInfixString(expr)} => ${retval}`);
                        return retval;
                    },
                    is_zero(expr) {
                        // TODO: This should be done using predicate functions rather than hard-coding
                        // predicates into the operators.
                        const op = $.operatorFor(expr);
                        const retval = op.isZero(expr);
                        // console.lg(`${op.name} isZero ${expr} => ${retval}`);
                        return retval;
                    },
                    equals(lhs, rhs) {
                        return lhs.equals(rhs);
                    },
                    factorize(p, x) {
                        // console.lg(`factorize p=${render_as_infix(p, $)} in variable ${render_as_infix(x, $)}`);
                        if (!p.contains(x)) {
                            // console.lg(`Giving up b/c the polynomial does not contain the variable.`);
                            return p;
                        }
                        if (!is_poly_expanded_form(p, x)) {
                            // console.lg(`Giving up b/c the polynomial is not in expanded form.`);
                            return p;
                        }
                        if (is_sym(x)) {
                            return yyfactorpoly(p, x, $);
                        }
                        else {
                            // console.lg(`Giving up b/c the variable is not a symbol.`);
                            return p;
                        }
                    },
                    getCustomDirective(directive) {
                        return !!custom_directives[directive];
                    },
                    getNativeDirective(directive) {
                        return native_directives.get(directive);
                    },
                    getSymbolPrintName(sym) {
                        const token = sym_key_to_printname[sym.key()];
                        if (typeof token === 'string') {
                            return token;
                        }
                        else {
                            return sym.key();
                        }
                    },
                    imag(expr) {
                        return $.evaluate(Native.imag, expr);
                    },
                    inner(lhs, rhs) {
                        // console.lg(`inner lhs=${print_list(lhs, $)} rhs=${print_list(rhs, $)} `);
                        const value_lhs = $.valueOf(lhs);
                        const value_rhs = $.valueOf(rhs);
                        const inner_lhs_rhs = items_to_cons$1(native_sym(Native.inner), value_lhs, value_rhs);
                        const value_inner_lhs_rhs = $.valueOf(inner_lhs_rhs);
                        return value_inner_lhs_rhs;
                    },
                    multiply(lhs, rhs) {
                        return $.evaluate(Native.multiply, lhs, rhs);
                    },
                    /**
                     * The universal unary minus function meaning multiplication by -1.
                     */
                    negate(x) {
                        return $.multiply(negOne, x);
                    },
                    operatorFor(expr) {
                        /*
                        if (is_imu(expr)) {
                            // This is not good
                            return selectOperator(MATH_POW.key());
                        }
                        */
                        if (is_cons(expr)) {
                            const keys = hash_info(expr);
                            for (const key of keys) {
                                const ops = currentOps()[key];
                                if (Array.isArray(ops)) {
                                    for (const op of ops) {
                                        if (op.isKind(expr)) {
                                            // console.lg("op", render_as_infix(expr, $), op.name);
                                            return op;
                                        }
                                    }
                                }
                            }
                            return new UnknownOperator(expr, $);
                            // We can end up here for user-defined functions.
                            // The consumer is trying to answer a question
                            // throw new SystemError(`${expr}, current_phase = ${current_focus} keys = ${JSON.stringify(keys)}`);
                        }
                        else {
                            return selectOperator(expr.name, expr);
                        }
                    },
                    outer(lhs, rhs) {
                        return $.evaluate(Native.outer, lhs, rhs);
                    },
                    power(base, expo) {
                        return $.evaluate(Native.pow, base, expo);
                    },
                    real(expr) {
                        return $.evaluate(Native.real, expr);
                    },
                    remove(varName) {
                        symTab.delete(varName);
                    },
                    setCustomDirective(directive, value) {
                        custom_directives[directive] = value;
                    },
                    pushNativeDirective(directive, value) {
                        native_directives.push(directive, value);
                    },
                    popNativeDirective() {
                        native_directives.pop();
                    },
                    setSymbolOrder(sym, order) {
                        sym_order[sym.key()] = order;
                    },
                    setSymbolProps(sym, overrides) {
                        symTab.setProps(sym, overrides);
                    },
                    setSymbolPrintName(sym, printname) {
                        sym_key_to_printname[sym.key()] = printname;
                    },
                    setSymbolValue(sym, value) {
                        symTab.setValue(sym, value);
                    },
                    sin(expr) {
                        return $.evaluate(Native.sin, expr);
                    },
                    subtract(lhs, rhs) {
                        return $.add(lhs, $.negate(rhs));
                    },
                    toInfixString(expr) {
                        const op = $.operatorFor(expr);
                        return op.toInfixString(expr);
                    },
                    toLatexString(expr) {
                        const op = $.operatorFor(expr);
                        return op.toLatexString(expr);
                    },
                    toSExprString(expr) {
                        const op = $.operatorFor(expr);
                        return op.toListString(expr);
                    },
                    transform(expr) {
                        // console.lg("transform", expr.toString(), "is_sym", is_sym(expr));
                        if (expr.meta === TFLAG_HALT) {
                            return [TFLAG_HALT, expr];
                        }
                        // We short-circuit some expressions in order to improve performance.
                        if (is_cons(expr)) {
                            // TODO: As an evaluation technique, I should be able to pick any item in the list and operate
                            // to the left or right. This implies that I have distinct right and left evaluations.
                            const head = expr.head;
                            if (is_sym(head)) {
                                // The generalization here is that a symbol may have multiple bindings that we need to disambiguate.
                                const value = $.getSymbolValue(head);
                                if (is_lambda(value)) {
                                    return wrap_as_transform(value.evaluate(expr.argList, $), expr);
                                }
                            }
                            else if (is_rat$1(head)) {
                                // We know that the key and hash are both 'Rat'
                                const ops = currentOps()['Rat'];
                                // TODO: The operator will be acting on the argList, not the entire expression.
                                const op = unambiguous_operator(expr.argList, ops);
                                if (op) {
                                    // console.lg(`We found the ${op.name} operator!`);
                                    return op.evaluate(head, expr.argList);
                                }
                                else {
                                    // eslint-disable-next-line no-console
                                    console.warn(`No unique operators found for Rat from ${ops.length} choice(s).`);
                                }
                            }
                            // let changedExpr = false;
                            const pops = currentOps();
                            // keys are the buckets we should look in for operators from specific to generic.
                            const keys = hash_info(expr);
                            // console.lg("keys", JSON.stringify(keys));
                            for (const key of keys) {
                                const ops = pops[key];
                                // console.lg(`Looking for key: ${JSON.stringify(key)} curExpr: ${curExpr} choices: ${Array.isArray(ops) ? ops.length : 'None'}`);
                                // Determine whether there are handlers in the bucket.
                                if (Array.isArray(ops)) {
                                    const op = unambiguous_operator(expr, ops);
                                    if (op) {
                                        const composite = op.transform(expr);
                                        // console.lg(`${op.name} ${$.toSExprString(expr)} => ${$.toSExprString(composite[1])} flags: ${composite[0]}`);
                                        // console.lg(`${op.name} ${$.toInfixString(expr)} => ${$.toInfixString(composite[1])} flags: ${composite[0]}`);
                                        return composite;
                                    }
                                }
                                else {
                                    // If there were no handlers registered for the given key, look for a user-defined function.
                                    if (is_cons(expr)) {
                                        const opr = expr.opr;
                                        if (is_sym(opr)) {
                                            const binding = $.getSymbolValue(opr);
                                            if (!is_nil(binding)) {
                                                if (is_cons(binding) && FUNCTION.equals(binding.opr)) {
                                                    const newExpr = Eval_user_function(expr, $);
                                                    // console.lg(`USER FUNC oldExpr: ${render_as_infix(curExpr, $)} newExpr: ${render_as_infix(newExpr, $)}`);
                                                    return [TFLAG_DIFF, newExpr];
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            // Once an expression has been transformed into a stable condition, it should not be transformed until a different phase.
                            expr.meta = TFLAG_HALT;
                            return [TFLAG_NONE, expr];
                        }
                        else if (is_nil(expr)) {
                            return [TFLAG_NONE, expr];
                        }
                        else {
                            // If it's not a list or nil, then it's an atom.
                            const op = $.operatorFor(expr);
                            return op.transform(expr);
                        }
                    },
                    valueOf(expr) {
                        return $.transform(expr)[1];
                    }
                };
                // TODO: Consistency in names used for symbols in symbolic expressions.
                $.setSymbolPrintName(ADD, '+'); // changing will break  82 cases.
                $.setSymbolPrintName(MULTIPLY, '*'); // changing will break 113 cases.
                $.setSymbolPrintName(POWER, 'expt');
                $.setSymbolPrintName(native_sym(Native.rco), '>>');
                $.setSymbolPrintName(native_sym(Native.lco), '<<');
                $.setSymbolPrintName(native_sym(Native.inner), '|');
                $.setSymbolPrintName(native_sym(Native.outer), '^');
                $.setSymbolPrintName(native_sym(Native.abs), 'abs');
                $.setSymbolPrintName(native_sym(Native.E), 'e');
                $.setSymbolPrintName(native_sym(Native.PI), 'pi');
                $.setSymbolPrintName(native_sym(Native.NIL), '()');
                $.setSymbolPrintName(native_sym(Native.IMU), 'i');
                $.setSymbolPrintName(native_sym(Native.exp), 'exp');
                // Backwards compatible, but we should simply set this to false, or leave undefined.
                $.pushNativeDirective(Directive.useCaretForExponentiation, config.useCaretForExponentiation);
                return $;
            }
            function dependencies_satisfied(deps, includes) {
                if (Array.isArray(deps)) {
                    for (const dep of deps) {
                        if (dep.startsWith('~')) {
                            const s = dep.substring(1);
                            if (includes.indexOf(s) >= 0) {
                                return false;
                            }
                        }
                        else {
                            if (includes.indexOf(dep) < 0) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                else {
                    return true;
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function unambiguous_operator(expr, ops, $) {
                // console.lg(`unambiguous_operator for ${$.toInfixString(expr)} from ${ops.length} choice(s).`);
                const candidates = [];
                for (const op of ops) {
                    if (op.isKind(expr)) {
                        candidates.push(op);
                    }
                }
                if (candidates.length === 1) {
                    return candidates[0];
                }
                else if (candidates.length > 0) {
                    // The alternative here is that the first operator wins.
                    // eslint-disable-next-line no-console
                    // console.warn(`Ambiguous operators for expression ${$.toInfixString(expr)} ${JSON.stringify(candidates.map((candidate) => candidate.name))}`);
                    const using = candidates[0];
                    // eslint-disable-next-line no-console
                    // console.warn(`Using ${JSON.stringify(using.name)}`);
                    return using;
                }
                else {
                    return void 0;
                }
            }

            var _Box_stack;
            /**
             * A box that contains something, or not.
             * Primarily being used to minimize casting in the mainline and to prevent the stack from being a distraction.
             * TODO: Methods could support some invariant checking.
             */
            class Box {
                constructor(contents) {
                    _Box_stack.set(this, []);
                    __classPrivateFieldGet(this, _Box_stack, "f").push(contents);
                }
                peek() {
                    return __classPrivateFieldGet(this, _Box_stack, "f")[0];
                }
                pop() {
                    return __classPrivateFieldGet(this, _Box_stack, "f").pop();
                }
                push(contents) {
                    __classPrivateFieldGet(this, _Box_stack, "f").push(contents);
                }
            }
            _Box_stack = new WeakMap();

            /**
             * A PrintHandler that maintains backwards compatibility by modifying defs.
             */
            class DefaultPrintHandler {
                constructor() {
                    this.prints = [];
                }
                print(...items) {
                    this.prints.push(...items);
                }
            }

            /**
             * Scans the sourceText into a tree expression then evaluates the expression.
             * @param fileName The name of the file containing the sourceText.
             * @param sourceText The source text to be scanned.
             * @param options scan_options($)
             * @param $ The environment that defines the operators.
             * @returns The return values, print outputs, and errors.
             */
            function execute_script(fileName, sourceText, options, $) {
                const { trees, errors } = parse_script(fileName, sourceText, options);
                if (errors.length > 0) {
                    return { values: [], prints: [], errors };
                }
                const values = [];
                const prints = [];
                // console.lg(`trees.length = ${trees.length}`);
                try {
                    for (const tree of trees) {
                        // console.lg("tree", render_as_sexpr(tree, $));
                        // console.lg("tree", render_as_infix(tree, $));
                        const data = transform_tree(tree, $);
                        if (data.value) {
                            if (!is_nil(data.value)) {
                                // console.lg(`value = ${data.value}`);
                                values.push(data.value);
                            }
                        }
                        for (const p of data.prints) {
                            prints.push(p);
                        }
                        for (const e of data.errors) {
                            errors.push(e);
                        }
                    }
                }
                catch (e) {
                    if (e instanceof Error) {
                        errors.push(e);
                    }
                    else {
                        errors.push(new Error(`${e}`));
                    }
                }
                return { values, prints, errors };
            }
            /**
             * Evaluates the parse tree using the operators defined in the environment.
             * @param tree The parse tree.
             * @param $ The environment defining the operators.
             * @returns The return values (zero or one), print outputs, and errors.
             */
            function transform_tree(tree, $) {
                /**
                 * The outputs from print satements for each pass of the scanner.
                 */
                const prints = [];
                /**
                 * errors aren't currently provided but could be if we caught exceptions.
                 */
                const errors = [];
                const originalPrintHandler = $.getPrintHandler();
                const printHandler = new DefaultPrintHandler();
                $.setPrintHandler(printHandler);
                try {
                    const value = multi_phase_transform(tree, $);
                    prints.push(...printHandler.prints);
                    return { value, prints, errors };
                }
                finally {
                    $.setPrintHandler(originalPrintHandler);
                }
            }
            /**
             *
             */
            function isNotDisabled(sym, $) {
                const binding = $.getSymbolValue(sym);
                if (is_nil(binding)) {
                    return true;
                }
                if (is_rat$1(binding)) {
                    return !binding.isZero();
                }
                return true;
            }
            /**
             * This should not be needed when we can define our own transformer pipelines.
             */
            function multi_phase_transform(tree, $) {
                move_top_of_stack(0);
                const box = new Box(tree);
                defs.trigmode = 0;
                // AUTOEXPAND, by default is unbound. i.e. only bound to it's own symbol.
                // isZero operating on Sym returns false. Therefore expanding will be true.
                // i.e. the default value of AUTOEXPAND is true!
                if (isNotDisabled(AUTOEXPAND, $)) {
                    $.pushNativeDirective(Directive.expand, true);
                    try {
                        // console.lg("Expanding...");
                        box.push(transform_with_reason(box.pop(), $, 'expanding'));
                    }
                    finally {
                        $.popNativeDirective();
                    }
                }
                if (isNotDisabled(AUTOFACTOR, $)) {
                    $.pushNativeDirective(Directive.factor, true);
                    try {
                        // console.lg("Expanding...");
                        box.push(transform_with_reason(box.pop(), $, 'factoring'));
                    }
                    finally {
                        $.popNativeDirective();
                    }
                }
                const transformed = box.pop();
                // console.lg();
                // console.lg(`tranned : ${transformed}`);
                // console.lg(`tranned : ${print_list(transformed, $)}`);
                // TODO: Does it make sense to remove this condition?
                // We should not have to treat NIL as something special.
                if (nil !== transformed) {
                    // console.lg(`tranned   : ${print_expr(transformed, $)}`);
                    // It's curious that we bind SCRIPT_LAST to the transform output and not the baked output. Why?
                    box.push(transformed);
                    if ($.isOne($.getSymbolValue(BAKE))) {
                        // console.lg("Baking...");
                        let expr = bake(box.pop(), $);
                        // Hopefully a temporary fix for bake creating a non-normalized expression.
                        expr = transform_with_reason(expr, $);
                        // console.lg(`baked     : ${print_list(expr, $)}`);
                        box.push(expr);
                    }
                    post_processing_complex_numbers(tree, box.peek(), box, $);
                }
                else {
                    box.push(nil);
                }
                store_in_script_last(box.peek(), $);
                return box.pop();
            }
            function store_in_script_last(expr, $) {
                // This feels like a bit of a hack.
                if (!is_nil(expr)) {
                    // console.lg(`store_in_script_last ${render_as_human(expr, $)}`);
                    $.setSymbolValue(RESERVED_KEYWORD_LAST, expr);
                }
            }
            /**
             * Runs in a loop until the output becomes stable.
             * This behavior allows top-level expressions to be transformed.
             * @param inExpr
             * @param $
             * @returns
             */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function transform_with_reason(inExpr, $, reason) {
                // console.lg(`Entering ${reason.toUpperCase()} ${render_as_infix(inExpr, $)}`);
                const outExpr = transform(inExpr, $);
                // console.lg(`Leaving ${reason.toUpperCase()} ${render_as_infix(outExpr, $)}`);
                return outExpr;
            }
            /**
             *
             * @param expr
             * @param $
             * @returns
             */
            function transform(expr, $) {
                expr.reset(TFLAG_DIFF);
                expr.reset(TFLAG_HALT);
                const [, outExpr] = $.transform(expr);
                return outExpr;
            }
            /**
             * Determines how instances of sqrt(-1) are represented.
             * @param input The parse tree.
             * @param output May be the result of Eval() or the out_tree after it has been bake(d).
             * @param $ The extension environment.
             */
            function post_processing_complex_numbers(input, output, box, $) {
                // If user asked explicitly asked to evaluate "i" or "j" and
                // they represent the imaginary unit (-1)^(1/2), then
                // show (-1)^(1/2).
                const userWantsToEvaluateIorJ = SYMBOL_I.equals(input) || SYMBOL_J.equals(input);
                if (userWantsToEvaluateIorJ && is_imu(output)) {
                    // Do nothing.
                    return;
                }
                // In all other cases, replace all instances of (-1)^(1/2) in the result
                // with the symbol "i" or "j" depending on which one
                // represents the imaginary unit
                const entries = $.getSymbolsInfo();
                for (const entry of entries) {
                    const sym = entry.sym;
                    const value = entry.value;
                    if (is_imu(value)) {
                        const A = box.pop();
                        const B = subst(A, imu, sym, $);
                        box.push(B);
                        return;
                    }
                }
            }

            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            function init_env($, options) {
                hard_reset();
                $.clearBindings();
                $.clearOperators();
                if (options && options.assumes) {
                    // console.lg(JSON.stringify(options.assumes));
                    const names = Object.keys(options.assumes);
                    for (const name of names) {
                        const props = options.assumes[name];
                        $.setSymbolProps(create_sym(name), props);
                    }
                }
                define_std_operators($);
                $.buildOperators();
                execute_definition(`${VARNAME_MAX_FIXED_PRINTOUT_DIGITS.text}=${DEFAULT_MAX_FIXED_PRINTOUT_DIGITS}`, $);
                if (options && options.useDefinitions) {
                    execute_std_definitions($);
                }
            }
            function env_term($) {
                $.clearBindings();
                $.clearOperators();
            }
            function env_options_from_sm_context_options(options) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const hook = function (retval, description) {
                    // console.lg(`env_options_from_engine_options(${JSON.stringify(options)}) => ${JSON.stringify(retval)} @ ${description}`);
                    return retval;
                };
                if (options) {
                    const config = {
                        assumes: options.assumes,
                        dependencies: ['Blade', 'Flt', 'Imu', 'Uom', 'Vector'],
                        disable: options.disable,
                        noOptimize: false,
                        useCaretForExponentiation: options.useCaretForExponentiation,
                        useDefinitions: options.useDefinitions
                    };
                    return hook(config);
                }
                else {
                    const config = {
                        assumes: {},
                        dependencies: ['Blade', 'Flt', 'Imu', 'Uom', 'Vector'],
                        disable: [],
                        noOptimize: false,
                        useCaretForExponentiation: false,
                        useDefinitions: false
                    };
                    return hook(config);
                }
            }
            /**
             * Creates an engine for executing scripts.
             * The returned engine is reference counted and should be released when no longer needed.
             */
            function create_script_context(contextOptions) {
                // console.lg("create_script_context");
                let ref_count = 1;
                const envOptions = env_options_from_sm_context_options(contextOptions);
                const $ = create_env(envOptions);
                init_env($, contextOptions);
                const theEngine = {
                    clearBindings() {
                        $.clearBindings();
                    },
                    defineFunction(pattern, impl) {
                        $.defineFunction(pattern, impl);
                        return this;
                    },
                    getSymbolProps(sym) {
                        return $.getSymbolProps(sym);
                    },
                    getSymbolValue(sym) {
                        return $.getSymbolValue(sym);
                    },
                    getSymbolsInfo() {
                        return $.getSymbolsInfo();
                    },
                    evaluate(tree) {
                        // This is like a fixed pipeline.
                        return transform_tree(tree, $);
                    },
                    useStandardDefinitions() {
                        execute_std_definitions($);
                    },
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    executeScript(sourceText, executeOptions) {
                        const options = { syntaxKind: SyntaxKind.Native };
                        if (contextOptions) {
                            if (contextOptions.syntaxKind) {
                                options.syntaxKind = contextOptions.syntaxKind;
                            }
                            contextOptions.disable;
                        }
                        if (executeOptions) {
                            if (executeOptions.syntaxKind) {
                                options.syntaxKind = executeOptions.syntaxKind;
                            }
                        }
                        return execute_script("", sourceText, parse_options_from_script_context_options(options, $), $);
                    },
                    renderAsAscii(expr) {
                        return render_as_ascii(expr, $);
                    },
                    renderAsInfix(expr) {
                        return render_as_infix(expr, $);
                    },
                    renderAsHuman(expr) {
                        return render_as_human(expr, $);
                    },
                    renderAsLaTeX(expr) {
                        return render_as_latex(expr, $);
                    },
                    renderAsSExpr(expr) {
                        return render_as_sexpr(expr, $);
                    },
                    addRef() {
                        ref_count++;
                    },
                    release() {
                        ref_count--;
                        if (ref_count === 0) {
                            env_term($);
                        }
                    }
                };
                return theEngine;
            }
            /**
             * Makes use of the extension environment because this is called prior to each script execution.
             */
            function parse_options_from_script_context_options(options, $) {
                if (options) {
                    return {
                        syntaxKind: options.syntaxKind,
                        useCaretForExponentiation: $.getNativeDirective(Directive.useCaretForExponentiation),
                        explicitAssocAdd: false,
                        explicitAssocMul: false
                    };
                }
                else {
                    return {
                        syntaxKind: SyntaxKind.Native,
                        useCaretForExponentiation: false,
                        explicitAssocAdd: false,
                        explicitAssocMul: false
                    };
                }
            }

        })
    };
}));
//# sourceMappingURL=index.js.map
